var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { r as requireReact, b as requireReactDom, c as reactExports, R as React, L as Link, u as useNavigate, d as reactDomExports, e as useParams, f as useSearchParams, B as BrowserRouter, h as useLocation, i as Routes, j as Route } from "./vendor-CP16y5pE.js";
import { _ as __vitePreload, W as WalletPluginAnchor, a as WalletPluginCloudWallet, b as WalletPluginWombat } from "./wallets-BY4zLC3k.js";
import { t as APIClient, F as FetchProvider, u as UInt128, v as BN, b as Struct, s as Asset, w as Int64, x as __decorate, U as UInt64, T as TimePointSec, y as AbstractTransactPlugin, z as TransactHookTypes, D as Action, E as prependAction, N as Name, r as UInt32, G as WebRenderer, H as SessionKit } from "./wharfkit-CgoYgCEG.js";
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config.key && (key = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config)
        "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    config = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== config ? config : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var client = { exports: {} };
var reactDomClient_production = {};
var scheduler = { exports: {} };
var scheduler_production = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production;
function requireScheduler_production() {
  if (hasRequiredScheduler_production) return scheduler_production;
  hasRequiredScheduler_production = 1;
  (function(exports) {
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: for (; 0 < index; ) {
        var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
        if (0 < compare(parent, node))
          heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
          var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
          else if (rightIndex < length && 0 > compare(right, last))
            heap[index] = right, heap[rightIndex] = last, index = rightIndex;
          else break a;
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    function shouldYieldToHost() {
      return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
    }
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  })(scheduler_production);
  return scheduler_production;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production();
  }
  return scheduler.exports;
}
var hasRequiredReactDomClient_production;
function requireReactDomClient_production() {
  if (hasRequiredReactDomClient_production) return reactDomClient_production;
  hasRequiredReactDomClient_production = 1;
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Scheduler = requireScheduler(), React2 = requireReact(), ReactDOM = requireReactDom();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i = 2; i < arguments.length; i++)
        url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function isValidContainer(node) {
    return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
  }
  function getNearestMountedFiber(fiber) {
    var node = fiber, nearestMounted = fiber;
    if (fiber.alternate) for (; node.return; ) node = node.return;
    else {
      fiber = node;
      do
        node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
      while (fiber);
    }
    return 3 === node.tag ? nearestMounted : null;
  }
  function getSuspenseInstanceFromFiber(fiber) {
    if (13 === fiber.tag) {
      var suspenseState = fiber.memoizedState;
      null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
      if (null !== suspenseState) return suspenseState.dehydrated;
    }
    return null;
  }
  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber)
      throw Error(formatProdErrorMessage(188));
  }
  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) {
      alternate = getNearestMountedFiber(fiber);
      if (null === alternate) throw Error(formatProdErrorMessage(188));
      return alternate !== fiber ? null : fiber;
    }
    for (var a = fiber, b = alternate; ; ) {
      var parentA = a.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;
      if (null === parentB) {
        b = parentA.return;
        if (null !== b) {
          a = b;
          continue;
        }
        break;
      }
      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB; ) {
          if (parentB === a) return assertIsMounted(parentA), fiber;
          if (parentB === b) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }
        throw Error(formatProdErrorMessage(188));
      }
      if (a.return !== b.return) a = parentA, b = parentB;
      else {
        for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
          if (child$0 === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }
          if (child$0 === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild) {
          for (child$0 = parentB.child; child$0; ) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }
            if (child$0 === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) throw Error(formatProdErrorMessage(189));
        }
      }
      if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
    }
    if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
    return a.stateNode.current === a ? fiber : alternate;
  }
  function findCurrentHostFiberImpl(node) {
    var tag = node.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
    for (node = node.child; null !== node; ) {
      tag = findCurrentHostFiberImpl(node);
      if (null !== tag) return tag;
      node = node.sibling;
    }
    return null;
  }
  var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
  var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
  var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
  var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type)
      return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
      case REACT_ACTIVITY_TYPE:
        return "Activity";
    }
    if ("object" === typeof type)
      switch (type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return (type.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {
          }
      }
    return null;
  }
  var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
    pending: false,
    data: null,
    method: null,
    action: null
  }, valueStack = [], index = -1;
  function createCursor(defaultValue) {
    return { current: defaultValue };
  }
  function pop(cursor) {
    0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
  }
  function push(cursor, value) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }
  var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance);
    push(contextFiberStackCursor, fiber);
    push(contextStackCursor, null);
    switch (nextRootInstance.nodeType) {
      case 9:
      case 11:
        fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
        break;
      default:
        if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
          nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
        else
          switch (fiber) {
            case "svg":
              fiber = 1;
              break;
            case "math":
              fiber = 2;
              break;
            default:
              fiber = 0;
          }
    }
    pop(contextStackCursor);
    push(contextStackCursor, fiber);
  }
  function popHostContainer() {
    pop(contextStackCursor);
    pop(contextFiberStackCursor);
    pop(rootInstanceStackCursor);
  }
  function pushHostContext(fiber) {
    null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
    var context = contextStackCursor.current;
    var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
    context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
  }
  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
    hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
  function setIsStrictModeForDevtools(newIsStrictMode) {
    "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
    if (injectedHook && "function" === typeof injectedHook.setStrictMode)
      try {
        injectedHook.setStrictMode(rendererID, newIsStrictMode);
      } catch (err) {
      }
  }
  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log2 = Math.log, LN2 = Math.LN2;
  function clz32Fallback(x) {
    x >>>= 0;
    return 0 === x ? 32 : 31 - (log2(x) / LN2 | 0) | 0;
  }
  var nextTransitionLane = 256, nextRetryLane = 4194304;
  function getHighestPriorityLanes(lanes) {
    var pendingSyncLanes = lanes & 42;
    if (0 !== pendingSyncLanes) return pendingSyncLanes;
    switch (lanes & -lanes) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return lanes & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return lanes & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return lanes;
    }
  }
  function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
    var pendingLanes = root2.pendingLanes;
    if (0 === pendingLanes) return 0;
    var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
    root2 = root2.warmLanes;
    var nonIdlePendingLanes = pendingLanes & 134217727;
    0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
    return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
  }
  function checkIfRootIsPrerendering(root2, renderLanes2) {
    return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
  }
  function computeExpirationTime(lane, currentTime) {
    switch (lane) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return currentTime + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return currentTime + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function claimNextTransitionLane() {
    var lane = nextTransitionLane;
    nextTransitionLane <<= 1;
    0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
    return lane;
  }
  function claimNextRetryLane() {
    var lane = nextRetryLane;
    nextRetryLane <<= 1;
    0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
    return lane;
  }
  function createLaneMap(initial) {
    for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
    return laneMap;
  }
  function markRootUpdated$1(root2, updateLane) {
    root2.pendingLanes |= updateLane;
    268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
  }
  function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
    var previouslyPendingLanes = root2.pendingLanes;
    root2.pendingLanes = remainingLanes;
    root2.suspendedLanes = 0;
    root2.pingedLanes = 0;
    root2.warmLanes = 0;
    root2.expiredLanes &= remainingLanes;
    root2.entangledLanes &= remainingLanes;
    root2.errorRecoveryDisabledLanes &= remainingLanes;
    root2.shellSuspendCounter = 0;
    var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
    for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
      var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
      entanglements[index$5] = 0;
      expirationTimes[index$5] = -1;
      var hiddenUpdatesForLane = hiddenUpdates[index$5];
      if (null !== hiddenUpdatesForLane)
        for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
          var update = hiddenUpdatesForLane[index$5];
          null !== update && (update.lane &= -536870913);
        }
      remainingLanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
    0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
  }
  function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
    root2.pendingLanes |= spawnedLane;
    root2.suspendedLanes &= ~spawnedLane;
    var spawnedLaneIndex = 31 - clz32(spawnedLane);
    root2.entangledLanes |= spawnedLane;
    root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
  }
  function markRootEntangled(root2, entangledLanes) {
    var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
    for (root2 = root2.entanglements; rootEntangledLanes; ) {
      var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
      lane & entangledLanes | root2[index$6] & entangledLanes && (root2[index$6] |= entangledLanes);
      rootEntangledLanes &= ~lane;
    }
  }
  function getBumpedLaneForHydrationByLane(lane) {
    switch (lane) {
      case 2:
        lane = 1;
        break;
      case 8:
        lane = 4;
        break;
      case 32:
        lane = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        lane = 128;
        break;
      case 268435456:
        lane = 134217728;
        break;
      default:
        lane = 0;
    }
    return lane;
  }
  function lanesToEventPriority(lanes) {
    lanes &= -lanes;
    return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
  }
  function resolveUpdatePriority() {
    var updatePriority = ReactDOMSharedInternals.p;
    if (0 !== updatePriority) return updatePriority;
    updatePriority = window.event;
    return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
  }
  function runWithPriority(priority, fn) {
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      return ReactDOMSharedInternals.p = priority, fn();
    } finally {
      ReactDOMSharedInternals.p = previousPriority;
    }
  }
  var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
  function detachDeletedInstance(node) {
    delete node[internalInstanceKey];
    delete node[internalPropsKey];
    delete node[internalEventHandlersKey];
    delete node[internalEventHandlerListenersKey];
    delete node[internalEventHandlesSetKey];
  }
  function getClosestInstanceFromNode(targetNode) {
    var targetInst = targetNode[internalInstanceKey];
    if (targetInst) return targetInst;
    for (var parentNode = targetNode.parentNode; parentNode; ) {
      if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
        parentNode = targetInst.alternate;
        if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
          for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
            if (parentNode = targetNode[internalInstanceKey]) return parentNode;
            targetNode = getParentSuspenseInstance(targetNode);
          }
        return targetInst;
      }
      targetNode = parentNode;
      parentNode = targetNode.parentNode;
    }
    return null;
  }
  function getInstanceFromNode(node) {
    if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
      var tag = node.tag;
      if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
        return node;
    }
    return null;
  }
  function getNodeFromInstance(inst) {
    var tag = inst.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
    throw Error(formatProdErrorMessage(33));
  }
  function getResourcesFromRoot(root2) {
    var resources = root2[internalRootNodeResourcesKey];
    resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
    return resources;
  }
  function markNodeAsHoistable(node) {
    node[internalHoistableMarker] = true;
  }
  var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
  function registerTwoPhaseEvent(registrationName, dependencies) {
    registerDirectEvent(registrationName, dependencies);
    registerDirectEvent(registrationName + "Capture", dependencies);
  }
  function registerDirectEvent(registrationName, dependencies) {
    registrationNameDependencies[registrationName] = dependencies;
    for (registrationName = 0; registrationName < dependencies.length; registrationName++)
      allNativeEvents.add(dependencies[registrationName]);
  }
  var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
  function isAttributeNameSafe(attributeName) {
    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
      return true;
    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
      return validatedAttributeNameCache[attributeName] = true;
    illegalAttributeNameCache[attributeName] = true;
    return false;
  }
  function setValueForAttribute(node, name, value) {
    if (isAttributeNameSafe(name))
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            node.removeAttribute(name);
            return;
          case "boolean":
            var prefix$8 = name.toLowerCase().slice(0, 5);
            if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
              node.removeAttribute(name);
              return;
            }
        }
        node.setAttribute(name, "" + value);
      }
  }
  function setValueForKnownAttribute(node, name, value) {
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      node.setAttribute(name, "" + value);
    }
  }
  function setValueForNamespacedAttribute(node, namespace, name, value) {
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      node.setAttributeNS(namespace, name, "" + value);
    }
  }
  var prefix, suffix;
  function describeBuiltInComponentFrame(name) {
    if (void 0 === prefix)
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return "\n" + prefix + name + suffix;
  }
  var reentry = false;
  function describeNativeComponentFrame(fn, construct) {
    if (!fn || reentry) return "";
    reentry = true;
    var previousPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: function() {
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  var control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$9) {
                  control = x$9;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$10) {
                control = x$10;
              }
              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
              });
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack)
              return [sample.stack, control.stack];
          }
          return [null, null];
        }
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name"
      );
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
        for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
          RunInRootFrame++;
        for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        ); )
          namePropDescriptor++;
        if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
          for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
            namePropDescriptor--;
        for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
          if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
            if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
              do
                if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                  var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                  fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                  return frame;
                }
              while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
            }
            break;
          }
      }
    } finally {
      reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
    }
    return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
  }
  function describeFiber(fiber) {
    switch (fiber.tag) {
      case 26:
      case 27:
      case 5:
        return describeBuiltInComponentFrame(fiber.type);
      case 16:
        return describeBuiltInComponentFrame("Lazy");
      case 13:
        return describeBuiltInComponentFrame("Suspense");
      case 19:
        return describeBuiltInComponentFrame("SuspenseList");
      case 0:
      case 15:
        return describeNativeComponentFrame(fiber.type, false);
      case 11:
        return describeNativeComponentFrame(fiber.type.render, false);
      case 1:
        return describeNativeComponentFrame(fiber.type, true);
      case 31:
        return describeBuiltInComponentFrame("Activity");
      default:
        return "";
    }
  }
  function getStackByFiberInDevAndProd(workInProgress2) {
    try {
      var info = "";
      do
        info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
      while (workInProgress2);
      return info;
    } catch (x) {
      return "\nError generating stack: " + x.message + "\n" + x.stack;
    }
  }
  function getToStringValue(value) {
    switch (typeof value) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return value;
      case "object":
        return value;
      default:
        return "";
    }
  }
  function isCheckable(elem) {
    var type = elem.type;
    return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
  }
  function trackValueOnNode(node) {
    var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
      node.constructor.prototype,
      valueField
    ), currentValue = "" + node[valueField];
    if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
      var get = descriptor.get, set = descriptor.set;
      Object.defineProperty(node, valueField, {
        configurable: true,
        get: function() {
          return get.call(this);
        },
        set: function(value) {
          currentValue = "" + value;
          set.call(this, value);
        }
      });
      Object.defineProperty(node, valueField, {
        enumerable: descriptor.enumerable
      });
      return {
        getValue: function() {
          return currentValue;
        },
        setValue: function(value) {
          currentValue = "" + value;
        },
        stopTracking: function() {
          node._valueTracker = null;
          delete node[valueField];
        }
      };
    }
  }
  function track(node) {
    node._valueTracker || (node._valueTracker = trackValueOnNode(node));
  }
  function updateValueIfChanged(node) {
    if (!node) return false;
    var tracker = node._valueTracker;
    if (!tracker) return true;
    var lastValue = tracker.getValue();
    var value = "";
    node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
    node = value;
    return node !== lastValue ? (tracker.setValue(node), true) : false;
  }
  function getActiveElement(doc) {
    doc = doc || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof doc) return null;
    try {
      return doc.activeElement || doc.body;
    } catch (e) {
      return doc.body;
    }
  }
  var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
  function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
    return value.replace(
      escapeSelectorAttributeValueInsideDoubleQuotesRegex,
      function(ch) {
        return "\\" + ch.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
    element.name = "";
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
    if (null != value)
      if ("number" === type) {
        if (0 === value && "" === element.value || element.value != value)
          element.value = "" + getToStringValue(value);
      } else
        element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
    else
      "submit" !== type && "reset" !== type || element.removeAttribute("value");
    null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
    null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
    null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
  }
  function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
    if (null != value || null != defaultValue) {
      if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
        return;
      defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      value = null != value ? "" + getToStringValue(value) : defaultValue;
      isHydrating2 || value === element.value || (element.value = value);
      element.defaultValue = value;
    }
    checked = null != checked ? checked : defaultChecked;
    checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
    element.checked = isHydrating2 ? element.checked : !!checked;
    element.defaultChecked = !!checked;
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
  }
  function setDefaultValue(node, type, value) {
    "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
  }
  function updateOptions(node, multiple, propValue, setDefaultSelected) {
    node = node.options;
    if (multiple) {
      multiple = {};
      for (var i = 0; i < propValue.length; i++)
        multiple["$" + propValue[i]] = true;
      for (propValue = 0; propValue < node.length; propValue++)
        i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
    } else {
      propValue = "" + getToStringValue(propValue);
      multiple = null;
      for (i = 0; i < node.length; i++) {
        if (node[i].value === propValue) {
          node[i].selected = true;
          setDefaultSelected && (node[i].defaultSelected = true);
          return;
        }
        null !== multiple || node[i].disabled || (multiple = node[i]);
      }
      null !== multiple && (multiple.selected = true);
    }
  }
  function updateTextarea(element, value, defaultValue) {
    if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
      element.defaultValue !== value && (element.defaultValue = value);
      return;
    }
    element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
  }
  function initTextarea(element, value, defaultValue, children) {
    if (null == value) {
      if (null != children) {
        if (null != defaultValue) throw Error(formatProdErrorMessage(92));
        if (isArrayImpl(children)) {
          if (1 < children.length) throw Error(formatProdErrorMessage(93));
          children = children[0];
        }
        defaultValue = children;
      }
      null == defaultValue && (defaultValue = "");
      value = defaultValue;
    }
    defaultValue = getToStringValue(value);
    element.defaultValue = defaultValue;
    children = element.textContent;
    children === defaultValue && "" !== children && null !== children && (element.value = children);
  }
  function setTextContent(node, text) {
    if (text) {
      var firstChild = node.firstChild;
      if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  }
  var unitlessNumbers = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function setValueForStyle(style2, styleName, value) {
    var isCustomProperty = 0 === styleName.indexOf("--");
    null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
  }
  function setValueForStyles(node, styles, prevStyles) {
    if (null != styles && "object" !== typeof styles)
      throw Error(formatProdErrorMessage(62));
    node = node.style;
    if (null != prevStyles) {
      for (var styleName in prevStyles)
        !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
      for (var styleName$16 in styles)
        styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
    } else
      for (var styleName$17 in styles)
        styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
  }
  function isCustomElement(tagName) {
    if (-1 === tagName.indexOf("-")) return false;
    switch (tagName) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var aliases = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function sanitizeURL(url) {
    return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
  }
  var currentReplayingEvent = null;
  function getEventTarget(nativeEvent) {
    nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
    nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
    return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
  }
  var restoreTarget = null, restoreQueue = null;
  function restoreStateOfTarget(target) {
    var internalInstance = getInstanceFromNode(target);
    if (internalInstance && (target = internalInstance.stateNode)) {
      var props = target[internalPropsKey] || null;
      a: switch (target = internalInstance.stateNode, internalInstance.type) {
        case "input":
          updateInput(
            target,
            props.value,
            props.defaultValue,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name
          );
          internalInstance = props.name;
          if ("radio" === props.type && null != internalInstance) {
            for (props = target; props.parentNode; ) props = props.parentNode;
            props = props.querySelectorAll(
              'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                "" + internalInstance
              ) + '"][type="radio"]'
            );
            for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
              var otherNode = props[internalInstance];
              if (otherNode !== target && otherNode.form === target.form) {
                var otherProps = otherNode[internalPropsKey] || null;
                if (!otherProps) throw Error(formatProdErrorMessage(90));
                updateInput(
                  otherNode,
                  otherProps.value,
                  otherProps.defaultValue,
                  otherProps.defaultValue,
                  otherProps.checked,
                  otherProps.defaultChecked,
                  otherProps.type,
                  otherProps.name
                );
              }
            }
            for (internalInstance = 0; internalInstance < props.length; internalInstance++)
              otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
          }
          break a;
        case "textarea":
          updateTextarea(target, props.value, props.defaultValue);
          break a;
        case "select":
          internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
      }
    }
  }
  var isInsideEventHandler = false;
  function batchedUpdates$1(fn, a, b) {
    if (isInsideEventHandler) return fn(a, b);
    isInsideEventHandler = true;
    try {
      var JSCompiler_inline_result = fn(a);
      return JSCompiler_inline_result;
    } finally {
      if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
        if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
          for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
      }
    }
  }
  function getListener(inst, registrationName) {
    var stateNode = inst.stateNode;
    if (null === stateNode) return null;
    var props = stateNode[internalPropsKey] || null;
    if (null === props) return null;
    stateNode = props[registrationName];
    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
        inst = !props;
        break a;
      default:
        inst = false;
    }
    if (inst) return null;
    if (stateNode && "function" !== typeof stateNode)
      throw Error(
        formatProdErrorMessage(231, registrationName, typeof stateNode)
      );
    return stateNode;
  }
  var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
  if (canUseDOM)
    try {
      var options = {};
      Object.defineProperty(options, "passive", {
        get: function() {
          passiveBrowserEventsSupported = true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (e) {
      passiveBrowserEventsSupported = false;
    }
  var root = null, startText = null, fallbackText = null;
  function getData() {
    if (fallbackText) return fallbackText;
    var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
    for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
    var minEnd = startLength - start;
    for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
    return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
  }
  function getEventCharCode(nativeEvent) {
    var keyCode = nativeEvent.keyCode;
    "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
    10 === nativeEvent && (nativeEvent = 13);
    return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
  }
  function functionThatReturnsTrue() {
    return true;
  }
  function functionThatReturnsFalse() {
    return false;
  }
  function createSyntheticEvent(Interface) {
    function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
      this._reactName = reactName;
      this._targetInst = targetInst;
      this.type = reactEventType;
      this.nativeEvent = nativeEvent;
      this.target = nativeEventTarget;
      this.currentTarget = null;
      for (var propName in Interface)
        Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
      this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
      this.isPropagationStopped = functionThatReturnsFalse;
      return this;
    }
    assign(SyntheticBaseEvent.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
      },
      stopPropagation: function() {
        var event = this.nativeEvent;
        event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
      },
      persist: function() {
      },
      isPersistent: functionThatReturnsTrue
    });
    return SyntheticBaseEvent;
  }
  var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function(event) {
      return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
    },
    movementX: function(event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
      return lastMovementX;
    },
    movementY: function(event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function(event) {
      return "clipboardData" in event ? event.clipboardData : window.clipboardData;
    }
  }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function modifierStateGetter(keyArg) {
    var nativeEvent = this.nativeEvent;
    return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
  }
  function getEventModifierState() {
    return modifierStateGetter;
  }
  var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function(nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function(event) {
      return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
    },
    which: function(event) {
      return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
    }
  }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function(event) {
      return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function(event) {
      return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
  }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
  canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
  var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
  function isFallbackCompositionEnd(domEventName, nativeEvent) {
    switch (domEventName) {
      case "keyup":
        return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
      case "keydown":
        return 229 !== nativeEvent.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    nativeEvent = nativeEvent.detail;
    return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
  }
  var isComposing = false;
  function getNativeBeforeInputChars(domEventName, nativeEvent) {
    switch (domEventName) {
      case "compositionend":
        return getDataFromCustomEvent(nativeEvent);
      case "keypress":
        if (32 !== nativeEvent.which) return null;
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case "textInput":
        return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(domEventName, nativeEvent) {
    if (isComposing)
      return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
    switch (domEventName) {
      case "paste":
        return null;
      case "keypress":
        if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
          if (nativeEvent.char && 1 < nativeEvent.char.length)
            return nativeEvent.char;
          if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case "compositionend":
        return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  var supportedInputTypes = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
  }
  function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
    restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
    inst = accumulateTwoPhaseListeners(inst, "onChange");
    0 < inst.length && (nativeEvent = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
  }
  var activeElement$1 = null, activeElementInst$1 = null;
  function runEventInBatch(dispatchQueue) {
    processDispatchQueue(dispatchQueue, 0);
  }
  function getInstIfValueChanged(targetInst) {
    var targetNode = getNodeFromInstance(targetInst);
    if (updateValueIfChanged(targetNode)) return targetInst;
  }
  function getTargetInstForChangeEvent(domEventName, targetInst) {
    if ("change" === domEventName) return targetInst;
  }
  var isInputEventSupported = false;
  if (canUseDOM) {
    var JSCompiler_inline_result$jscomp$282;
    if (canUseDOM) {
      var isSupported$jscomp$inline_417 = "oninput" in document;
      if (!isSupported$jscomp$inline_417) {
        var element$jscomp$inline_418 = document.createElement("div");
        element$jscomp$inline_418.setAttribute("oninput", "return;");
        isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
      }
      JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
    } else JSCompiler_inline_result$jscomp$282 = false;
    isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
  }
  function stopWatchingForValueChange() {
    activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
  }
  function handlePropertyChange(nativeEvent) {
    if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
      var dispatchQueue = [];
      createAndAccumulateChangeEvent(
        dispatchQueue,
        activeElementInst$1,
        nativeEvent,
        getEventTarget(nativeEvent)
      );
      batchedUpdates$1(runEventInBatch, dispatchQueue);
    }
  }
  function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
    "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
  }
  function getTargetInstForInputEventPolyfill(domEventName) {
    if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
      return getInstIfValueChanged(activeElementInst$1);
  }
  function getTargetInstForClickEvent(domEventName, targetInst) {
    if ("click" === domEventName) return getInstIfValueChanged(targetInst);
  }
  function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
    if ("input" === domEventName || "change" === domEventName)
      return getInstIfValueChanged(targetInst);
  }
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is;
  function shallowEqual(objA, objB) {
    if (objectIs(objA, objB)) return true;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
      return false;
    var keysA = Object.keys(objA), keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for (keysB = 0; keysB < keysA.length; keysB++) {
      var currentKey = keysA[keysB];
      if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
        return false;
    }
    return true;
  }
  function getLeafNode(node) {
    for (; node && node.firstChild; ) node = node.firstChild;
    return node;
  }
  function getNodeForCharacterOffset(root2, offset) {
    var node = getLeafNode(root2);
    root2 = 0;
    for (var nodeEnd; node; ) {
      if (3 === node.nodeType) {
        nodeEnd = root2 + node.textContent.length;
        if (root2 <= offset && nodeEnd >= offset)
          return { node, offset: offset - root2 };
        root2 = nodeEnd;
      }
      a: {
        for (; node; ) {
          if (node.nextSibling) {
            node = node.nextSibling;
            break a;
          }
          node = node.parentNode;
        }
        node = void 0;
      }
      node = getLeafNode(node);
    }
  }
  function containsNode(outerNode, innerNode) {
    return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
  }
  function getActiveElementDeep(containerInfo) {
    containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
    for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
      try {
        var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
      } catch (err) {
        JSCompiler_inline_result = false;
      }
      if (JSCompiler_inline_result) containerInfo = element.contentWindow;
      else break;
      element = getActiveElement(containerInfo.document);
    }
    return element;
  }
  function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
  }
  var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
  function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
    mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
      anchorNode: doc.anchorNode,
      anchorOffset: doc.anchorOffset,
      focusNode: doc.focusNode,
      focusOffset: doc.focusOffset
    }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
      "onSelect",
      "select",
      null,
      nativeEvent,
      nativeEventTarget
    ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
  }
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit" + styleProp] = "webkit" + eventName;
    prefixes["Moz" + styleProp] = "moz" + eventName;
    return prefixes;
  }
  var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  }, prefixedEventNames = {}, style = {};
  canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
    if (!vendorPrefixes[eventName]) return eventName;
    var prefixMap = vendorPrefixes[eventName], styleProp;
    for (styleProp in prefixMap)
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
        return prefixedEventNames[eventName] = prefixMap[styleProp];
    return eventName;
  }
  var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  simpleEventPluginEvents.push("scrollEnd");
  function registerSimpleEvent(domEventName, reactName) {
    topLevelEventsToReactNames.set(domEventName, reactName);
    registerTwoPhaseEvent(reactName, [domEventName]);
  }
  var CapturedStacks = /* @__PURE__ */ new WeakMap();
  function createCapturedValueAtFiber(value, source) {
    if ("object" === typeof value && null !== value) {
      var existing = CapturedStacks.get(value);
      if (void 0 !== existing) return existing;
      source = {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
      CapturedStacks.set(value, source);
      return source;
    }
    return {
      value,
      source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }
  var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
  function finishQueueingConcurrentUpdates() {
    for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
      var fiber = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var queue = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var update = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var lane = concurrentQueues[i];
      concurrentQueues[i++] = null;
      if (null !== queue && null !== update) {
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
    }
  }
  function enqueueUpdate$1(fiber, queue, update, lane) {
    concurrentQueues[concurrentQueuesIndex++] = fiber;
    concurrentQueues[concurrentQueuesIndex++] = queue;
    concurrentQueues[concurrentQueuesIndex++] = update;
    concurrentQueues[concurrentQueuesIndex++] = lane;
    concurrentlyUpdatedLanes |= lane;
    fiber.lanes |= lane;
    fiber = fiber.alternate;
    null !== fiber && (fiber.lanes |= lane);
  }
  function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
    enqueueUpdate$1(fiber, queue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function enqueueConcurrentRenderForLane(fiber, lane) {
    enqueueUpdate$1(fiber, null, null, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
    sourceFiber.lanes |= lane;
    var alternate = sourceFiber.alternate;
    null !== alternate && (alternate.lanes |= lane);
    for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
      parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
    return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
  }
  function getRootForUpdatedFiber(sourceFiber) {
    if (50 < nestedUpdateCount)
      throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
    for (var parent = sourceFiber.return; null !== parent; )
      sourceFiber = parent, parent = sourceFiber.return;
    return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
  }
  var emptyContextObject = {};
  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.refCleanup = this.ref = null;
    this.pendingProps = pendingProps;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function createFiberImplClass(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }
  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }
  function createWorkInProgress(current, pendingProps) {
    var workInProgress2 = current.alternate;
    null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
      current.tag,
      pendingProps,
      current.key,
      current.mode
    ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
    workInProgress2.flags = current.flags & 65011712;
    workInProgress2.childLanes = current.childLanes;
    workInProgress2.lanes = current.lanes;
    workInProgress2.child = current.child;
    workInProgress2.memoizedProps = current.memoizedProps;
    workInProgress2.memoizedState = current.memoizedState;
    workInProgress2.updateQueue = current.updateQueue;
    pendingProps = current.dependencies;
    workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
    workInProgress2.sibling = current.sibling;
    workInProgress2.index = current.index;
    workInProgress2.ref = current.ref;
    workInProgress2.refCleanup = current.refCleanup;
    return workInProgress2;
  }
  function resetWorkInProgress(workInProgress2, renderLanes2) {
    workInProgress2.flags &= 65011714;
    var current = workInProgress2.alternate;
    null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
      lanes: renderLanes2.lanes,
      firstContext: renderLanes2.firstContext
    });
    return workInProgress2;
  }
  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
    var fiberTag = 0;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
    else if ("string" === typeof type)
      fiberTag = isHostHoistableType(
        type,
        pendingProps,
        contextStackCursor.current
      ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
    else
      a: switch (type) {
        case REACT_ACTIVITY_TYPE:
          return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
        case REACT_FRAGMENT_TYPE:
          return createFiberFromFragment(pendingProps.children, mode, lanes, key);
        case REACT_STRICT_MODE_TYPE:
          fiberTag = 8;
          mode |= 24;
          break;
        case REACT_PROFILER_TYPE:
          return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
        case REACT_SUSPENSE_TYPE:
          return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
        case REACT_SUSPENSE_LIST_TYPE:
          return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
        default:
          if ("object" === typeof type && null !== type)
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
              case REACT_CONTEXT_TYPE:
                fiberTag = 10;
                break a;
              case REACT_CONSUMER_TYPE:
                fiberTag = 9;
                break a;
              case REACT_FORWARD_REF_TYPE:
                fiberTag = 11;
                break a;
              case REACT_MEMO_TYPE:
                fiberTag = 14;
                break a;
              case REACT_LAZY_TYPE:
                fiberTag = 16;
                owner = null;
                break a;
            }
          fiberTag = 29;
          pendingProps = Error(
            formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
          );
          owner = null;
      }
    key = createFiberImplClass(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.lanes = lanes;
    return key;
  }
  function createFiberFromFragment(elements, mode, lanes, key) {
    elements = createFiberImplClass(7, elements, key, mode);
    elements.lanes = lanes;
    return elements;
  }
  function createFiberFromText(content, mode, lanes) {
    content = createFiberImplClass(6, content, null, mode);
    content.lanes = lanes;
    return content;
  }
  function createFiberFromPortal(portal, mode, lanes) {
    mode = createFiberImplClass(
      4,
      null !== portal.children ? portal.children : [],
      portal.key,
      mode
    );
    mode.lanes = lanes;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }
  var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
  function pushTreeFork(workInProgress2, totalChildren) {
    forkStack[forkStackIndex++] = treeForkCount;
    forkStack[forkStackIndex++] = treeForkProvider;
    treeForkProvider = workInProgress2;
    treeForkCount = totalChildren;
  }
  function pushTreeId(workInProgress2, totalChildren, index2) {
    idStack[idStackIndex++] = treeContextId;
    idStack[idStackIndex++] = treeContextOverflow;
    idStack[idStackIndex++] = treeContextProvider;
    treeContextProvider = workInProgress2;
    var baseIdWithLeadingBit = treeContextId;
    workInProgress2 = treeContextOverflow;
    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
    baseIdWithLeadingBit &= ~(1 << baseLength);
    index2 += 1;
    var length = 32 - clz32(totalChildren) + baseLength;
    if (30 < length) {
      var numberOfOverflowBits = baseLength - baseLength % 5;
      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
      baseIdWithLeadingBit >>= numberOfOverflowBits;
      baseLength -= numberOfOverflowBits;
      treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
      treeContextOverflow = length + workInProgress2;
    } else
      treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
  }
  function pushMaterializedTreeId(workInProgress2) {
    null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
  }
  function popTreeContext(workInProgress2) {
    for (; workInProgress2 === treeForkProvider; )
      treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
    for (; workInProgress2 === treeContextProvider; )
      treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
  }
  var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
  function throwOnHydrationMismatch(fiber) {
    var error = Error(formatProdErrorMessage(418, ""));
    queueHydrationError(createCapturedValueAtFiber(error, fiber));
    throw HydrationMismatchException;
  }
  function prepareToHydrateHostInstance(fiber) {
    var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
    instance[internalInstanceKey] = fiber;
    instance[internalPropsKey] = props;
    switch (type) {
      case "dialog":
        listenToNonDelegatedEvent("cancel", instance);
        listenToNonDelegatedEvent("close", instance);
        break;
      case "iframe":
      case "object":
      case "embed":
        listenToNonDelegatedEvent("load", instance);
        break;
      case "video":
      case "audio":
        for (type = 0; type < mediaEventTypes.length; type++)
          listenToNonDelegatedEvent(mediaEventTypes[type], instance);
        break;
      case "source":
        listenToNonDelegatedEvent("error", instance);
        break;
      case "img":
      case "image":
      case "link":
        listenToNonDelegatedEvent("error", instance);
        listenToNonDelegatedEvent("load", instance);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", instance);
        break;
      case "input":
        listenToNonDelegatedEvent("invalid", instance);
        initInput(
          instance,
          props.value,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name,
          true
        );
        track(instance);
        break;
      case "select":
        listenToNonDelegatedEvent("invalid", instance);
        break;
      case "textarea":
        listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
    }
    type = props.children;
    "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
    instance || throwOnHydrationMismatch(fiber);
  }
  function popToNextHostParent(fiber) {
    for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
      switch (hydrationParentFiber.tag) {
        case 5:
        case 13:
          rootOrSingletonContext = false;
          return;
        case 27:
        case 3:
          rootOrSingletonContext = true;
          return;
        default:
          hydrationParentFiber = hydrationParentFiber.return;
      }
  }
  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) return false;
    if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
    var tag = fiber.tag, JSCompiler_temp;
    if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
      if (JSCompiler_temp = 5 === tag)
        JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
      JSCompiler_temp = !JSCompiler_temp;
    }
    JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
    popToNextHostParent(fiber);
    if (13 === tag) {
      fiber = fiber.memoizedState;
      fiber = null !== fiber ? fiber.dehydrated : null;
      if (!fiber) throw Error(formatProdErrorMessage(317));
      a: {
        fiber = fiber.nextSibling;
        for (tag = 0; fiber; ) {
          if (8 === fiber.nodeType)
            if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
              if (0 === tag) {
                nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                break a;
              }
              tag--;
            } else
              "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
          fiber = fiber.nextSibling;
        }
        nextHydratableInstance = null;
      }
    } else
      27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
    return true;
  }
  function resetHydrationState() {
    nextHydratableInstance = hydrationParentFiber = null;
    isHydrating = false;
  }
  function upgradeHydrationErrorsToRecoverable() {
    var queuedErrors = hydrationErrors;
    null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
      workInProgressRootRecoverableErrors,
      queuedErrors
    ), hydrationErrors = null);
    return queuedErrors;
  }
  function queueHydrationError(error) {
    null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
  }
  var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
  function pushProvider(providerFiber, context, nextValue) {
    push(valueCursor, context._currentValue);
    context._currentValue = nextValue;
  }
  function popProvider(context) {
    context._currentValue = valueCursor.current;
    pop(valueCursor);
  }
  function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
    for (; null !== parent; ) {
      var alternate = parent.alternate;
      (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
      if (parent === propagationRoot) break;
      parent = parent.return;
    }
  }
  function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
    var fiber = workInProgress2.child;
    null !== fiber && (fiber.return = workInProgress2);
    for (; null !== fiber; ) {
      var list = fiber.dependencies;
      if (null !== list) {
        var nextFiber = fiber.child;
        list = list.firstContext;
        a: for (; null !== list; ) {
          var dependency = list;
          list = fiber;
          for (var i = 0; i < contexts.length; i++)
            if (dependency.context === contexts[i]) {
              list.lanes |= renderLanes2;
              dependency = list.alternate;
              null !== dependency && (dependency.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                list.return,
                renderLanes2,
                workInProgress2
              );
              forcePropagateEntireTree || (nextFiber = null);
              break a;
            }
          list = dependency.next;
        }
      } else if (18 === fiber.tag) {
        nextFiber = fiber.return;
        if (null === nextFiber) throw Error(formatProdErrorMessage(341));
        nextFiber.lanes |= renderLanes2;
        list = nextFiber.alternate;
        null !== list && (list.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
        nextFiber = null;
      } else nextFiber = fiber.child;
      if (null !== nextFiber) nextFiber.return = fiber;
      else
        for (nextFiber = fiber; null !== nextFiber; ) {
          if (nextFiber === workInProgress2) {
            nextFiber = null;
            break;
          }
          fiber = nextFiber.sibling;
          if (null !== fiber) {
            fiber.return = nextFiber.return;
            nextFiber = fiber;
            break;
          }
          nextFiber = nextFiber.return;
        }
      fiber = nextFiber;
    }
  }
  function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
    current = null;
    for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
      if (!isInsidePropagationBailout) {
        if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
        else if (0 !== (parent.flags & 262144)) break;
      }
      if (10 === parent.tag) {
        var currentParent = parent.alternate;
        if (null === currentParent) throw Error(formatProdErrorMessage(387));
        currentParent = currentParent.memoizedProps;
        if (null !== currentParent) {
          var context = parent.type;
          objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
        }
      } else if (parent === hostTransitionProviderCursor.current) {
        currentParent = parent.alternate;
        if (null === currentParent) throw Error(formatProdErrorMessage(387));
        currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
      }
      parent = parent.return;
    }
    null !== current && propagateContextChanges(
      workInProgress2,
      current,
      renderLanes2,
      forcePropagateEntireTree
    );
    workInProgress2.flags |= 262144;
  }
  function checkIfContextChanged(currentDependencies) {
    for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
      if (!objectIs(
        currentDependencies.context._currentValue,
        currentDependencies.memoizedValue
      ))
        return true;
      currentDependencies = currentDependencies.next;
    }
    return false;
  }
  function prepareToReadContext(workInProgress2) {
    currentlyRenderingFiber$1 = workInProgress2;
    lastContextDependency = null;
    workInProgress2 = workInProgress2.dependencies;
    null !== workInProgress2 && (workInProgress2.firstContext = null);
  }
  function readContext(context) {
    return readContextForConsumer(currentlyRenderingFiber$1, context);
  }
  function readContextDuringReconciliation(consumer, context) {
    null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
    return readContextForConsumer(consumer, context);
  }
  function readContextForConsumer(consumer, context) {
    var value = context._currentValue;
    context = { context, memoizedValue: value, next: null };
    if (null === lastContextDependency) {
      if (null === consumer) throw Error(formatProdErrorMessage(308));
      lastContextDependency = context;
      consumer.dependencies = { lanes: 0, firstContext: context };
      consumer.flags |= 524288;
    } else lastContextDependency = lastContextDependency.next = context;
    return value;
  }
  var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
    var listeners = [], signal = this.signal = {
      aborted: false,
      addEventListener: function(type, listener) {
        listeners.push(listener);
      }
    };
    this.abort = function() {
      signal.aborted = true;
      listeners.forEach(function(listener) {
        return listener();
      });
    };
  }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function createCache() {
    return {
      controller: new AbortControllerLocal(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function releaseCache(cache) {
    cache.refCount--;
    0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
      cache.controller.abort();
    });
  }
  var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
  function entangleAsyncAction(transition, thenable) {
    if (null === currentEntangledListeners) {
      var entangledListeners = currentEntangledListeners = [];
      currentEntangledPendingCount = 0;
      currentEntangledLane = requestTransitionLane();
      currentEntangledActionThenable = {
        status: "pending",
        value: void 0,
        then: function(resolve) {
          entangledListeners.push(resolve);
        }
      };
    }
    currentEntangledPendingCount++;
    thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
    return thenable;
  }
  function pingEngtangledActionScope() {
    if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
      null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
      var listeners = currentEntangledListeners;
      currentEntangledListeners = null;
      currentEntangledLane = 0;
      currentEntangledActionThenable = null;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
    }
  }
  function chainThenableValue(thenable, result) {
    var listeners = [], thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function(resolve) {
        listeners.push(resolve);
      }
    };
    thenable.then(
      function() {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
      },
      function(error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0; error < listeners.length; error++)
          (0, listeners[error])(void 0);
      }
    );
    return thenableWithOverride;
  }
  var prevOnStartTransitionFinish = ReactSharedInternals.S;
  ReactSharedInternals.S = function(transition, returnValue) {
    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
    null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
  };
  var resumedCache = createCursor(null);
  function peekCacheFromPool() {
    var cacheResumedFromPreviousRender = resumedCache.current;
    return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
  }
  function pushTransition(offscreenWorkInProgress, prevCachePool) {
    null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
  }
  function getSuspendedCache() {
    var cacheFromPool = peekCacheFromPool();
    return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
  }
  var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
  } };
  function isThenableResolved(thenable) {
    thenable = thenable.status;
    return "fulfilled" === thenable || "rejected" === thenable;
  }
  function noop$3() {
  }
  function trackUsedThenable(thenableState2, thenable, index2) {
    index2 = thenableState2[index2];
    void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
      default:
        if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
        else {
          thenableState2 = workInProgressRoot;
          if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
            throw Error(formatProdErrorMessage(482));
          thenableState2 = thenable;
          thenableState2.status = "pending";
          thenableState2.then(
            function(fulfilledValue) {
              if ("pending" === thenable.status) {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            },
            function(error) {
              if ("pending" === thenable.status) {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            }
          );
        }
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        }
        suspendedThenable = thenable;
        throw SuspenseException;
    }
  }
  var suspendedThenable = null;
  function getSuspendedThenable() {
    if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
    var thenable = suspendedThenable;
    suspendedThenable = null;
    return thenable;
  }
  function checkIfUseWrappedInAsyncCatch(rejectedReason) {
    if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
      throw Error(formatProdErrorMessage(483));
  }
  var hasForceUpdate = false;
  function initializeUpdateQueue(fiber) {
    fiber.updateQueue = {
      baseState: fiber.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function cloneUpdateQueue(current, workInProgress2) {
    current = current.updateQueue;
    workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
  }
  function createUpdate(lane) {
    return { lane, tag: 0, payload: null, callback: null, next: null };
  }
  function enqueueUpdate(fiber, update, lane) {
    var updateQueue = fiber.updateQueue;
    if (null === updateQueue) return null;
    updateQueue = updateQueue.shared;
    if (0 !== (executionContext & 2)) {
      var pending = updateQueue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      updateQueue.pending = update;
      update = getRootForUpdatedFiber(fiber);
      markUpdateLaneFromFiberToRoot(fiber, null, lane);
      return update;
    }
    enqueueUpdate$1(fiber, updateQueue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function entangleTransitions(root2, fiber, lane) {
    fiber = fiber.updateQueue;
    if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
      var queueLanes = fiber.lanes;
      queueLanes &= root2.pendingLanes;
      lane |= queueLanes;
      fiber.lanes = lane;
      markRootEntangled(root2, lane);
    }
  }
  function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
    var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
    if (null !== current && (current = current.updateQueue, queue === current)) {
      var newFirst = null, newLast = null;
      queue = queue.firstBaseUpdate;
      if (null !== queue) {
        do {
          var clone = {
            lane: queue.lane,
            tag: queue.tag,
            payload: queue.payload,
            callback: null,
            next: null
          };
          null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
          queue = queue.next;
        } while (null !== queue);
        null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
      } else newFirst = newLast = capturedUpdate;
      queue = {
        baseState: current.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: current.shared,
        callbacks: current.callbacks
      };
      workInProgress2.updateQueue = queue;
      return;
    }
    workInProgress2 = queue.lastBaseUpdate;
    null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
    queue.lastBaseUpdate = capturedUpdate;
  }
  var didReadFromEntangledAsyncAction = false;
  function suspendIfUpdateReadFromEntangledAsyncAction() {
    if (didReadFromEntangledAsyncAction) {
      var entangledActionThenable = currentEntangledActionThenable;
      if (null !== entangledActionThenable) throw entangledActionThenable;
    }
  }
  function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
    didReadFromEntangledAsyncAction = false;
    var queue = workInProgress$jscomp$0.updateQueue;
    hasForceUpdate = false;
    var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
    if (null !== pendingQueue) {
      queue.shared.pending = null;
      var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
      lastPendingUpdate.next = null;
      null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
      lastBaseUpdate = lastPendingUpdate;
      var current = workInProgress$jscomp$0.alternate;
      null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
    }
    if (null !== firstBaseUpdate) {
      var newState = queue.baseState;
      lastBaseUpdate = 0;
      current = firstPendingUpdate = lastPendingUpdate = null;
      pendingQueue = firstBaseUpdate;
      do {
        var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
        if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
          0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
          null !== current && (current = current.next = {
            lane: 0,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: null,
            next: null
          });
          a: {
            var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
            updateLane = props;
            var instance = instance$jscomp$0;
            switch (update.tag) {
              case 1:
                workInProgress2 = update.payload;
                if ("function" === typeof workInProgress2) {
                  newState = workInProgress2.call(instance, newState, updateLane);
                  break a;
                }
                newState = workInProgress2;
                break a;
              case 3:
                workInProgress2.flags = workInProgress2.flags & -65537 | 128;
              case 0:
                workInProgress2 = update.payload;
                updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                if (null === updateLane || void 0 === updateLane) break a;
                newState = assign({}, newState, updateLane);
                break a;
              case 2:
                hasForceUpdate = true;
            }
          }
          updateLane = pendingQueue.callback;
          null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
        } else
          isHiddenUpdate = {
            lane: updateLane,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: pendingQueue.callback,
            next: null
          }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
        pendingQueue = pendingQueue.next;
        if (null === pendingQueue)
          if (pendingQueue = queue.shared.pending, null === pendingQueue)
            break;
          else
            isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
      } while (1);
      null === current && (lastPendingUpdate = newState);
      queue.baseState = lastPendingUpdate;
      queue.firstBaseUpdate = firstPendingUpdate;
      queue.lastBaseUpdate = current;
      null === firstBaseUpdate && (queue.shared.lanes = 0);
      workInProgressRootSkippedLanes |= lastBaseUpdate;
      workInProgress$jscomp$0.lanes = lastBaseUpdate;
      workInProgress$jscomp$0.memoizedState = newState;
    }
  }
  function callCallback(callback, context) {
    if ("function" !== typeof callback)
      throw Error(formatProdErrorMessage(191, callback));
    callback.call(context);
  }
  function commitCallbacks(updateQueue, context) {
    var callbacks = updateQueue.callbacks;
    if (null !== callbacks)
      for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
        callCallback(callbacks[updateQueue], context);
  }
  var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
  function pushHiddenContext(fiber, context) {
    fiber = entangledRenderLanes;
    push(prevEntangledRenderLanesCursor, fiber);
    push(currentTreeHiddenStackCursor, context);
    entangledRenderLanes = fiber | context.baseLanes;
  }
  function reuseHiddenContextOnStack() {
    push(prevEntangledRenderLanesCursor, entangledRenderLanes);
    push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
  }
  function popHiddenContext() {
    entangledRenderLanes = prevEntangledRenderLanesCursor.current;
    pop(currentTreeHiddenStackCursor);
    pop(prevEntangledRenderLanesCursor);
  }
  var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0;
  function throwInvalidHookError() {
    throw Error(formatProdErrorMessage(321));
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
    if (null === prevDeps) return false;
    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
      if (!objectIs(nextDeps[i], prevDeps[i])) return false;
    return true;
  }
  function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
    renderLanes = nextRenderLanes;
    currentlyRenderingFiber = workInProgress2;
    workInProgress2.memoizedState = null;
    workInProgress2.updateQueue = null;
    workInProgress2.lanes = 0;
    ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
    shouldDoubleInvokeUserFnsInHooksDEV = false;
    nextRenderLanes = Component(props, secondArg);
    shouldDoubleInvokeUserFnsInHooksDEV = false;
    didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
      workInProgress2,
      Component,
      props,
      secondArg
    ));
    finishRenderingHooks(current);
    return nextRenderLanes;
  }
  function finishRenderingHooks(current) {
    ReactSharedInternals.H = ContextOnlyDispatcher;
    var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber = null;
    didScheduleRenderPhaseUpdate = false;
    thenableIndexCounter$1 = 0;
    thenableState$1 = null;
    if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
    null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
  }
  function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
    currentlyRenderingFiber = workInProgress2;
    var numberOfReRenders = 0;
    do {
      didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
      thenableIndexCounter$1 = 0;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
      numberOfReRenders += 1;
      workInProgressHook = currentHook = null;
      if (null != workInProgress2.updateQueue) {
        var children = workInProgress2.updateQueue;
        children.lastEffect = null;
        children.events = null;
        children.stores = null;
        null != children.memoCache && (children.memoCache.index = 0);
      }
      ReactSharedInternals.H = HooksDispatcherOnRerender;
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
    return children;
  }
  function TransitionAwareHostComponent() {
    var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
    maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
    dispatcher = dispatcher.useState()[0];
    (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
    return maybeThenable;
  }
  function checkDidRenderIdHook() {
    var didRenderIdHook = 0 !== localIdCounter;
    localIdCounter = 0;
    return didRenderIdHook;
  }
  function bailoutHooks(current, workInProgress2, lanes) {
    workInProgress2.updateQueue = current.updateQueue;
    workInProgress2.flags &= -2053;
    current.lanes &= ~lanes;
  }
  function resetHooksOnUnwind(workInProgress2) {
    if (didScheduleRenderPhaseUpdate) {
      for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
        var queue = workInProgress2.queue;
        null !== queue && (queue.pending = null);
        workInProgress2 = workInProgress2.next;
      }
      didScheduleRenderPhaseUpdate = false;
    }
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber = null;
    didScheduleRenderPhaseUpdateDuringThisPass = false;
    thenableIndexCounter$1 = localIdCounter = 0;
    thenableState$1 = null;
  }
  function mountWorkInProgressHook() {
    var hook = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
    return workInProgressHook;
  }
  function updateWorkInProgressHook() {
    if (null === currentHook) {
      var nextCurrentHook = currentlyRenderingFiber.alternate;
      nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
    } else nextCurrentHook = currentHook.next;
    var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
    if (null !== nextWorkInProgressHook)
      workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
    else {
      if (null === nextCurrentHook) {
        if (null === currentlyRenderingFiber.alternate)
          throw Error(formatProdErrorMessage(467));
        throw Error(formatProdErrorMessage(310));
      }
      currentHook = nextCurrentHook;
      nextCurrentHook = {
        memoizedState: currentHook.memoizedState,
        baseState: currentHook.baseState,
        baseQueue: currentHook.baseQueue,
        queue: currentHook.queue,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
    }
    return workInProgressHook;
  }
  function createFunctionComponentUpdateQueue() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function useThenable(thenable) {
    var index2 = thenableIndexCounter$1;
    thenableIndexCounter$1 += 1;
    null === thenableState$1 && (thenableState$1 = []);
    thenable = trackUsedThenable(thenableState$1, thenable, index2);
    index2 = currentlyRenderingFiber;
    null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
    return thenable;
  }
  function use(usable) {
    if (null !== usable && "object" === typeof usable) {
      if ("function" === typeof usable.then) return useThenable(usable);
      if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
    }
    throw Error(formatProdErrorMessage(438, String(usable)));
  }
  function useMemoCache(size) {
    var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
    null !== updateQueue && (memoCache = updateQueue.memoCache);
    if (null == memoCache) {
      var current = currentlyRenderingFiber.alternate;
      null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
        data: current.data.map(function(array) {
          return array.slice();
        }),
        index: 0
      })));
    }
    null == memoCache && (memoCache = { data: [], index: 0 });
    null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
    updateQueue.memoCache = memoCache;
    updateQueue = memoCache.data[memoCache.index];
    if (void 0 === updateQueue)
      for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
        updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
    memoCache.index++;
    return updateQueue;
  }
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  function updateReducer(reducer) {
    var hook = updateWorkInProgressHook();
    return updateReducerImpl(hook, currentHook, reducer);
  }
  function updateReducerImpl(hook, current, reducer) {
    var queue = hook.queue;
    if (null === queue) throw Error(formatProdErrorMessage(311));
    queue.lastRenderedReducer = reducer;
    var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
    if (null !== pendingQueue) {
      if (null !== baseQueue) {
        var baseFirst = baseQueue.next;
        baseQueue.next = pendingQueue.next;
        pendingQueue.next = baseFirst;
      }
      current.baseQueue = baseQueue = pendingQueue;
      queue.pending = null;
    }
    pendingQueue = hook.baseState;
    if (null === baseQueue) hook.memoizedState = pendingQueue;
    else {
      current = baseQueue.next;
      var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
      do {
        var updateLane = update.lane & -536870913;
        if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
          var revertLane = update.revertLane;
          if (0 === revertLane)
            null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
              lane: 0,
              revertLane: 0,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
          else if ((renderLanes & revertLane) === revertLane) {
            update = update.next;
            revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
            continue;
          } else
            updateLane = {
              lane: 0,
              revertLane: update.revertLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
          updateLane = update.action;
          shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
          pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
        } else
          revertLane = {
            lane: updateLane,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
        update = update.next;
      } while (null !== update && update !== current);
      null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
      if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer)))
        throw reducer;
      hook.memoizedState = pendingQueue;
      hook.baseState = baseFirst;
      hook.baseQueue = newBaseQueueLast;
      queue.lastRenderedState = pendingQueue;
    }
    null === baseQueue && (queue.lanes = 0);
    return [hook.memoizedState, queue.dispatch];
  }
  function rerenderReducer(reducer) {
    var hook = updateWorkInProgressHook(), queue = hook.queue;
    if (null === queue) throw Error(formatProdErrorMessage(311));
    queue.lastRenderedReducer = reducer;
    var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
    if (null !== lastRenderPhaseUpdate) {
      queue.pending = null;
      var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      do
        newState = reducer(newState, update.action), update = update.next;
      while (update !== lastRenderPhaseUpdate);
      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
      hook.memoizedState = newState;
      null === hook.baseQueue && (hook.baseState = newState);
      queue.lastRenderedState = newState;
    }
    return [newState, dispatch];
  }
  function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
    if (isHydrating$jscomp$0) {
      if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
      getServerSnapshot = getServerSnapshot();
    } else getServerSnapshot = getSnapshot();
    var snapshotChanged = !objectIs(
      (currentHook || hook).memoizedState,
      getServerSnapshot
    );
    snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
    hook = hook.queue;
    var create = subscribeToStore.bind(null, fiber, hook, subscribe);
    updateEffectImpl(2048, 8, create, [subscribe]);
    if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        createEffectInstance(),
        updateStoreInstance.bind(
          null,
          fiber,
          hook,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
      isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    return getServerSnapshot;
  }
  function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
    fiber.flags |= 16384;
    fiber = { getSnapshot, value: renderedSnapshot };
    getSnapshot = currentlyRenderingFiber.updateQueue;
    null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
  }
  function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
    inst.value = nextSnapshot;
    inst.getSnapshot = getSnapshot;
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  }
  function subscribeToStore(fiber, inst, subscribe) {
    return subscribe(function() {
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    });
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function forceStoreRerender(fiber) {
    var root2 = enqueueConcurrentRenderForLane(fiber, 2);
    null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
  }
  function mountStateImpl(initialState) {
    var hook = mountWorkInProgressHook();
    if ("function" === typeof initialState) {
      var initialStateInitializer = initialState;
      initialState = initialStateInitializer();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          initialStateInitializer();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
    }
    hook.memoizedState = hook.baseState = initialState;
    hook.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialState
    };
    return hook;
  }
  function updateOptimisticImpl(hook, current, passthrough, reducer) {
    hook.baseState = passthrough;
    return updateReducerImpl(
      hook,
      currentHook,
      "function" === typeof reducer ? reducer : basicStateReducer
    );
  }
  function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
    if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
    fiber = actionQueue.action;
    if (null !== fiber) {
      var actionNode = {
        payload,
        action: fiber,
        next: null,
        isTransition: true,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(listener) {
          actionNode.listeners.push(listener);
        }
      };
      null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
      setState(actionNode);
      setPendingState = actionQueue.pending;
      null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
    }
  }
  function runActionStateAction(actionQueue, node) {
    var action = node.action, payload = node.payload, prevState = actionQueue.state;
    if (node.isTransition) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        handleActionReturnValue(actionQueue, node, returnValue);
      } catch (error) {
        onActionError(actionQueue, node, error);
      } finally {
        ReactSharedInternals.T = prevTransition;
      }
    } else
      try {
        prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
      } catch (error$38) {
        onActionError(actionQueue, node, error$38);
      }
  }
  function handleActionReturnValue(actionQueue, node, returnValue) {
    null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
      function(nextState) {
        onActionSuccess(actionQueue, node, nextState);
      },
      function(error) {
        return onActionError(actionQueue, node, error);
      }
    ) : onActionSuccess(actionQueue, node, returnValue);
  }
  function onActionSuccess(actionQueue, actionNode, nextState) {
    actionNode.status = "fulfilled";
    actionNode.value = nextState;
    notifyActionListeners(actionNode);
    actionQueue.state = nextState;
    actionNode = actionQueue.pending;
    null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
  }
  function onActionError(actionQueue, actionNode, error) {
    var last = actionQueue.pending;
    actionQueue.pending = null;
    if (null !== last) {
      last = last.next;
      do
        actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
      while (actionNode !== last);
    }
    actionQueue.action = null;
  }
  function notifyActionListeners(actionNode) {
    actionNode = actionNode.listeners;
    for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
  }
  function actionStateReducer(oldState, newState) {
    return newState;
  }
  function mountActionState(action, initialStateProp) {
    if (isHydrating) {
      var ssrFormState = workInProgressRoot.formState;
      if (null !== ssrFormState) {
        a: {
          var JSCompiler_inline_result = currentlyRenderingFiber;
          if (isHydrating) {
            if (nextHydratableInstance) {
              b: {
                var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                  if (!inRootOrSingleton) {
                    JSCompiler_inline_result$jscomp$0 = null;
                    break b;
                  }
                  JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  if (null === JSCompiler_inline_result$jscomp$0) {
                    JSCompiler_inline_result$jscomp$0 = null;
                    break b;
                  }
                }
                inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
              }
              if (JSCompiler_inline_result$jscomp$0) {
                nextHydratableInstance = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                break a;
              }
            }
            throwOnHydrationMismatch(JSCompiler_inline_result);
          }
          JSCompiler_inline_result = false;
        }
        JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
      }
    }
    ssrFormState = mountWorkInProgressHook();
    ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
    JSCompiler_inline_result = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: actionStateReducer,
      lastRenderedState: initialStateProp
    };
    ssrFormState.queue = JSCompiler_inline_result;
    ssrFormState = dispatchSetState.bind(
      null,
      currentlyRenderingFiber,
      JSCompiler_inline_result
    );
    JSCompiler_inline_result.dispatch = ssrFormState;
    JSCompiler_inline_result = mountStateImpl(false);
    inRootOrSingleton = dispatchOptimisticSetState.bind(
      null,
      currentlyRenderingFiber,
      false,
      JSCompiler_inline_result.queue
    );
    JSCompiler_inline_result = mountWorkInProgressHook();
    JSCompiler_inline_result$jscomp$0 = {
      state: initialStateProp,
      dispatch: null,
      action,
      pending: null
    };
    JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
    ssrFormState = dispatchActionState.bind(
      null,
      currentlyRenderingFiber,
      JSCompiler_inline_result$jscomp$0,
      inRootOrSingleton,
      ssrFormState
    );
    JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
    JSCompiler_inline_result.memoizedState = action;
    return [initialStateProp, ssrFormState, false];
  }
  function updateActionState(action) {
    var stateHook = updateWorkInProgressHook();
    return updateActionStateImpl(stateHook, currentHook, action);
  }
  function updateActionStateImpl(stateHook, currentStateHook, action) {
    currentStateHook = updateReducerImpl(
      stateHook,
      currentStateHook,
      actionStateReducer
    )[0];
    stateHook = updateReducer(basicStateReducer)[0];
    if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
      try {
        var state = useThenable(currentStateHook);
      } catch (x) {
        if (x === SuspenseException) throw SuspenseActionException;
        throw x;
      }
    else state = currentStateHook;
    currentStateHook = updateWorkInProgressHook();
    var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
    action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
      9,
      createEffectInstance(),
      actionStateActionEffect.bind(null, actionQueue, action),
      null
    ));
    return [state, dispatch, stateHook];
  }
  function actionStateActionEffect(actionQueue, action) {
    actionQueue.action = action;
  }
  function rerenderActionState(action) {
    var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
    if (null !== currentStateHook)
      return updateActionStateImpl(stateHook, currentStateHook, action);
    updateWorkInProgressHook();
    stateHook = stateHook.memoizedState;
    currentStateHook = updateWorkInProgressHook();
    var dispatch = currentStateHook.queue.dispatch;
    currentStateHook.memoizedState = action;
    return [stateHook, dispatch, false];
  }
  function pushSimpleEffect(tag, inst, create, createDeps) {
    tag = { tag, create, deps: createDeps, inst, next: null };
    inst = currentlyRenderingFiber.updateQueue;
    null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
    create = inst.lastEffect;
    null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
    return tag;
  }
  function createEffectInstance() {
    return { destroy: void 0, resource: void 0 };
  }
  function updateRef() {
    return updateWorkInProgressHook().memoizedState;
  }
  function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
    var hook = mountWorkInProgressHook();
    createDeps = void 0 === createDeps ? null : createDeps;
    currentlyRenderingFiber.flags |= fiberFlags;
    hook.memoizedState = pushSimpleEffect(
      1 | hookFlags,
      createEffectInstance(),
      create,
      createDeps
    );
  }
  function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var inst = hook.memoizedState.inst;
    null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
      1 | hookFlags,
      inst,
      create,
      deps
    ));
  }
  function mountEffect(create, createDeps) {
    mountEffectImpl(8390656, 8, create, createDeps);
  }
  function updateEffect(create, createDeps) {
    updateEffectImpl(2048, 8, create, createDeps);
  }
  function updateInsertionEffect(create, deps) {
    return updateEffectImpl(4, 2, create, deps);
  }
  function updateLayoutEffect(create, deps) {
    return updateEffectImpl(4, 4, create, deps);
  }
  function imperativeHandleEffect(create, ref) {
    if ("function" === typeof ref) {
      create = create();
      var refCleanup = ref(create);
      return function() {
        "function" === typeof refCleanup ? refCleanup() : ref(null);
      };
    }
    if (null !== ref && void 0 !== ref)
      return create = create(), ref.current = create, function() {
        ref.current = null;
      };
  }
  function updateImperativeHandle(ref, create, deps) {
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
  }
  function mountDebugValue() {
  }
  function updateCallback(callback, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
      return prevState[0];
    hook.memoizedState = [callback, deps];
    return callback;
  }
  function updateMemo(nextCreate, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
      return prevState[0];
    prevState = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    hook.memoizedState = [prevState, deps];
    return prevState;
  }
  function mountDeferredValueImpl(hook, value, initialValue) {
    if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
      return hook.memoizedState = value;
    hook.memoizedState = initialValue;
    hook = requestDeferredLane();
    currentlyRenderingFiber.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return initialValue;
  }
  function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
    if (objectIs(value, prevValue)) return value;
    if (null !== currentTreeHiddenStackCursor.current)
      return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
    if (0 === (renderLanes & 42))
      return didReceiveUpdate = true, hook.memoizedState = value;
    hook = requestDeferredLane();
    currentlyRenderingFiber.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return prevValue;
  }
  function startTransition(fiber, queue, pendingState, finishedState, callback) {
    var previousPriority = ReactDOMSharedInternals.p;
    ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
    var prevTransition = ReactSharedInternals.T, currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    dispatchOptimisticSetState(fiber, false, queue, pendingState);
    try {
      var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
        var thenableForFinishedState = chainThenableValue(
          returnValue,
          finishedState
        );
        dispatchSetStateInternal(
          fiber,
          queue,
          thenableForFinishedState,
          requestUpdateLane(fiber)
        );
      } else
        dispatchSetStateInternal(
          fiber,
          queue,
          finishedState,
          requestUpdateLane(fiber)
        );
    } catch (error) {
      dispatchSetStateInternal(
        fiber,
        queue,
        { then: function() {
        }, status: "rejected", reason: error },
        requestUpdateLane()
      );
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function noop$2() {
  }
  function startHostTransition(formFiber, pendingState, action, formData) {
    if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
    var queue = ensureFormComponentIsStateful(formFiber).queue;
    startTransition(
      formFiber,
      queue,
      pendingState,
      sharedNotPendingObject,
      null === action ? noop$2 : function() {
        requestFormReset$1(formFiber);
        return action(formData);
      }
    );
  }
  function ensureFormComponentIsStateful(formFiber) {
    var existingStateHook = formFiber.memoizedState;
    if (null !== existingStateHook) return existingStateHook;
    existingStateHook = {
      memoizedState: sharedNotPendingObject,
      baseState: sharedNotPendingObject,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: sharedNotPendingObject
      },
      next: null
    };
    var initialResetState = {};
    existingStateHook.next = {
      memoizedState: initialResetState,
      baseState: initialResetState,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialResetState
      },
      next: null
    };
    formFiber.memoizedState = existingStateHook;
    formFiber = formFiber.alternate;
    null !== formFiber && (formFiber.memoizedState = existingStateHook);
    return existingStateHook;
  }
  function requestFormReset$1(formFiber) {
    var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
    dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
  }
  function useHostTransitionStatus() {
    return readContext(HostTransitionContext);
  }
  function updateId() {
    return updateWorkInProgressHook().memoizedState;
  }
  function updateRefresh() {
    return updateWorkInProgressHook().memoizedState;
  }
  function refreshCache(fiber) {
    for (var provider = fiber.return; null !== provider; ) {
      switch (provider.tag) {
        case 24:
        case 3:
          var lane = requestUpdateLane();
          fiber = createUpdate(lane);
          var root$41 = enqueueUpdate(provider, fiber, lane);
          null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
          provider = { cache: createCache() };
          fiber.payload = provider;
          return;
      }
      provider = provider.return;
    }
  }
  function dispatchReducerAction(fiber, queue, action) {
    var lane = requestUpdateLane();
    action = {
      lane,
      revertLane: 0,
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
  }
  function dispatchSetState(fiber, queue, action) {
    var lane = requestUpdateLane();
    dispatchSetStateInternal(fiber, queue, action, lane);
  }
  function dispatchSetStateInternal(fiber, queue, action, lane) {
    var update = {
      lane,
      revertLane: 0,
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
    else {
      var alternate = fiber.alternate;
      if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
        try {
          var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
          update.hasEagerState = true;
          update.eagerState = eagerState;
          if (objectIs(eagerState, currentState))
            return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
        } catch (error) {
        } finally {
        }
      action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
      if (null !== action)
        return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
    }
    return false;
  }
  function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
    action = {
      lane: 2,
      revertLane: requestTransitionLane(),
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) {
      if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
    } else
      throwIfDuringRender = enqueueConcurrentHookUpdate(
        fiber,
        queue,
        action,
        2
      ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
  }
  function isRenderPhaseUpdate(fiber) {
    var alternate = fiber.alternate;
    return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
  }
  function enqueueRenderPhaseUpdate(queue, update) {
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
    var pending = queue.pending;
    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
    queue.pending = update;
  }
  function entangleTransitionUpdate(root2, queue, lane) {
    if (0 !== (lane & 4194048)) {
      var queueLanes = queue.lanes;
      queueLanes &= root2.pendingLanes;
      lane |= queueLanes;
      queue.lanes = lane;
      markRootEntangled(root2, lane);
    }
  }
  var ContextOnlyDispatcher = {
    readContext,
    use,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useInsertionEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useSyncExternalStore: throwInvalidHookError,
    useId: throwInvalidHookError,
    useHostTransitionStatus: throwInvalidHookError,
    useFormState: throwInvalidHookError,
    useActionState: throwInvalidHookError,
    useOptimistic: throwInvalidHookError,
    useMemoCache: throwInvalidHookError,
    useCacheRefresh: throwInvalidHookError
  }, HooksDispatcherOnMount = {
    readContext,
    use,
    useCallback: function(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function(ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      mountEffectImpl(
        4194308,
        4,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    },
    useLayoutEffect: function(create, deps) {
      return mountEffectImpl(4194308, 4, create, deps);
    },
    useInsertionEffect: function(create, deps) {
      mountEffectImpl(4, 2, create, deps);
    },
    useMemo: function(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    },
    useReducer: function(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber,
        reducer
      );
      return [hook.memoizedState, reducer];
    },
    useRef: function(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return hook.memoizedState = initialValue;
    },
    useState: function(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    },
    useTransition: function() {
      var stateHook = mountStateImpl(false);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber,
        stateHook.queue,
        true,
        false
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [false, stateHook];
    },
    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else {
        getServerSnapshot = getSnapshot();
        if (null === workInProgressRoot)
          throw Error(formatProdErrorMessage(349));
        0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      hook.memoizedState = getServerSnapshot;
      var inst = { value: getServerSnapshot, getSnapshot };
      hook.queue = inst;
      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
        subscribe
      ]);
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        createEffectInstance(),
        updateStoreInstance.bind(
          null,
          fiber,
          inst,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      return getServerSnapshot;
    },
    useId: function() {
      var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var JSCompiler_inline_result = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
        identifierPrefix = "" + identifierPrefix + "R" + JSCompiler_inline_result;
        JSCompiler_inline_result = localIdCounter++;
        0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
        identifierPrefix += "";
      } else
        JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "";
      return hook.memoizedState = identifierPrefix;
    },
    useHostTransitionStatus,
    useFormState: mountActionState,
    useActionState: mountActionState,
    useOptimistic: function(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        true,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    },
    useMemoCache,
    useCacheRefresh: function() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber
      );
    }
  }, HooksDispatcherOnUpdate = {
    readContext,
    use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function() {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: updateActionState,
    useActionState: updateActionState,
    useOptimistic: function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
  }, HooksDispatcherOnRerender = {
    readContext,
    use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: rerenderReducer,
    useRef: updateRef,
    useState: function() {
      return rerenderReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: rerenderActionState,
    useActionState: rerenderActionState,
    useOptimistic: function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
  }, thenableState = null, thenableIndexCounter = 0;
  function unwrapThenable(thenable) {
    var index2 = thenableIndexCounter;
    thenableIndexCounter += 1;
    null === thenableState && (thenableState = []);
    return trackUsedThenable(thenableState, thenable, index2);
  }
  function coerceRef(workInProgress2, element) {
    element = element.props.ref;
    workInProgress2.ref = void 0 !== element ? element : null;
  }
  function throwOnInvalidObjectType(returnFiber, newChild) {
    if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
      throw Error(formatProdErrorMessage(525));
    returnFiber = Object.prototype.toString.call(newChild);
    throw Error(
      formatProdErrorMessage(
        31,
        "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
      )
    );
  }
  function resolveLazy(lazyType) {
    var init = lazyType._init;
    return init(lazyType._payload);
  }
  function createChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var deletions = returnFiber.deletions;
        null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
      }
    }
    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;
      for (; null !== currentFirstChild; )
        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return null;
    }
    function mapRemainingChildren(currentFirstChild) {
      for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
        null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return existingChildren;
    }
    function useFiber(fiber, pendingProps) {
      fiber = createWorkInProgress(fiber, pendingProps);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }
    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects)
        return newFiber.flags |= 1048576, lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex)
        return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
      newFiber.flags |= 67108866;
      return lastPlacedIndex;
    }
    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
      return newFiber;
    }
    function updateTextNode(returnFiber, current, textContent, lanes) {
      if (null === current || 6 !== current.tag)
        return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, textContent);
      current.return = returnFiber;
      return current;
    }
    function updateElement(returnFiber, current, element, lanes) {
      var elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE)
        return updateFragment(
          returnFiber,
          current,
          element.props.children,
          lanes,
          element.key
        );
      if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
        return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
      current = createFiberFromTypeAndProps(
        element.type,
        element.key,
        element.props,
        null,
        returnFiber.mode,
        lanes
      );
      coerceRef(current, element);
      current.return = returnFiber;
      return current;
    }
    function updatePortal(returnFiber, current, portal, lanes) {
      if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
        return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, portal.children || []);
      current.return = returnFiber;
      return current;
    }
    function updateFragment(returnFiber, current, fragment, lanes, key) {
      if (null === current || 7 !== current.tag)
        return current = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          lanes,
          key
        ), current.return = returnFiber, current;
      current = useFiber(current, fragment);
      current.return = returnFiber;
      return current;
    }
    function createChild(returnFiber, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return newChild = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          lanes
        ), newChild.return = returnFiber, newChild;
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(
              newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          case REACT_LAZY_TYPE:
            var init = newChild._init;
            newChild = init(newChild._payload);
            return createChild(returnFiber, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return newChild = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            lanes,
            null
          ), newChild.return = returnFiber, newChild;
        if ("function" === typeof newChild.then)
          return createChild(returnFiber, unwrapThenable(newChild), lanes);
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return createChild(
            returnFiber,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_LAZY_TYPE:
            return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
        if ("function" === typeof newChild.then)
          return updateSlot(
            returnFiber,
            oldFiber,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return updateSlot(
            returnFiber,
            oldFiber,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(
              null === newChild.key ? newIdx : newChild.key
            ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(
              null === newChild.key ? newIdx : newChild.key
            ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
          case REACT_LAZY_TYPE:
            var init = newChild._init;
            newChild = init(newChild._payload);
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              newChild,
              lanes
            );
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
        if ("function" === typeof newChild.then)
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          newChildren[newIdx],
          lanes
        );
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (newIdx === newChildren.length)
        return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++)
          oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
            oldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
        nextOldFiber = updateFromMap(
          oldFiber,
          returnFiber,
          newIdx,
          newChildren[newIdx],
          lanes
        ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
          null === nextOldFiber.key ? newIdx : nextOldFiber.key
        ), currentFirstChild = placeChild(
          nextOldFiber,
          currentFirstChild,
          newIdx
        ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
      shouldTrackSideEffects && oldFiber.forEach(function(child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
      if (null == newChildren) throw Error(formatProdErrorMessage(151));
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (step.done)
        return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildren.next())
          step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
        step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
      shouldTrackSideEffects && oldFiber.forEach(function(child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
      "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            a: {
              for (var key = newChild.key; null !== currentFirstChild; ) {
                if (currentFirstChild.key === key) {
                  key = newChild.type;
                  if (key === REACT_FRAGMENT_TYPE) {
                    if (7 === currentFirstChild.tag) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(
                        currentFirstChild,
                        newChild.props.children
                      );
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                  } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(currentFirstChild, newChild.props);
                    coerceRef(lanes, newChild);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                newChild.props.children,
                returnFiber.mode,
                lanes,
                newChild.key
              ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
            }
            return placeSingleChild(returnFiber);
          case REACT_PORTAL_TYPE:
            a: {
              for (key = newChild.key; null !== currentFirstChild; ) {
                if (currentFirstChild.key === key)
                  if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(currentFirstChild, newChild.children || []);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  } else {
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  }
                else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
              lanes.return = returnFiber;
              returnFiber = lanes;
            }
            return placeSingleChild(returnFiber);
          case REACT_LAZY_TYPE:
            return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
        }
        if (isArrayImpl(newChild))
          return reconcileChildrenArray(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
        if (getIteratorFn(newChild)) {
          key = getIteratorFn(newChild);
          if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
          newChild = key.call(newChild);
          return reconcileChildrenIterator(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
        }
        if ("function" === typeof newChild.then)
          return reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
    }
    return function(returnFiber, currentFirstChild, newChild, lanes) {
      try {
        thenableIndexCounter = 0;
        var firstChildFiber = reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
        thenableState = null;
        return firstChildFiber;
      } catch (x) {
        if (x === SuspenseException || x === SuspenseActionException) throw x;
        var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
        fiber.lanes = lanes;
        fiber.return = returnFiber;
        return fiber;
      } finally {
      }
    };
  }
  var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
  function pushPrimaryTreeSuspenseHandler(handler) {
    var current = handler.alternate;
    push(suspenseStackCursor, suspenseStackCursor.current & 1);
    push(suspenseHandlerStackCursor, handler);
    null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
  }
  function pushOffscreenSuspenseHandler(fiber) {
    if (22 === fiber.tag) {
      if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
        var current = fiber.alternate;
        null !== current && null !== current.memoizedState && (shellBoundary = fiber);
      }
    } else reuseSuspenseHandlerOnStack();
  }
  function reuseSuspenseHandlerOnStack() {
    push(suspenseStackCursor, suspenseStackCursor.current);
    push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
  }
  function popSuspenseHandler(fiber) {
    pop(suspenseHandlerStackCursor);
    shellBoundary === fiber && (shellBoundary = null);
    pop(suspenseStackCursor);
  }
  var suspenseStackCursor = createCursor(0);
  function findFirstSuspended(row) {
    for (var node = row; null !== node; ) {
      if (13 === node.tag) {
        var state = node.memoizedState;
        if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
          return node;
      } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
        if (0 !== (node.flags & 128)) return node;
      } else if (null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === row) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === row) return null;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
    return null;
  }
  function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
    ctor = workInProgress2.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
    workInProgress2.memoizedState = getDerivedStateFromProps;
    0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
  }
  var classComponentUpdater = {
    enqueueSetState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueReplaceState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.tag = 1;
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueForceUpdate: function(inst, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.tag = 2;
      void 0 !== callback && null !== callback && (update.callback = callback);
      callback = enqueueUpdate(inst, update, lane);
      null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
    }
  };
  function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
    workInProgress2 = workInProgress2.stateNode;
    return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
  }
  function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
    workInProgress2 = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
  function resolveClassComponentProps(Component, baseProps) {
    var newProps = baseProps;
    if ("ref" in baseProps) {
      newProps = {};
      for (var propName in baseProps)
        "ref" !== propName && (newProps[propName] = baseProps[propName]);
    }
    if (Component = Component.defaultProps) {
      newProps === baseProps && (newProps = assign({}, newProps));
      for (var propName$73 in Component)
        void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
    }
    return newProps;
  }
  var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
        error
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  };
  function defaultOnUncaughtError(error) {
    reportGlobalError(error);
  }
  function defaultOnCaughtError(error) {
    console.error(error);
  }
  function defaultOnRecoverableError(error) {
    reportGlobalError(error);
  }
  function logUncaughtError(root2, errorInfo) {
    try {
      var onUncaughtError = root2.onUncaughtError;
      onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
    } catch (e$74) {
      setTimeout(function() {
        throw e$74;
      });
    }
  }
  function logCaughtError(root2, boundary, errorInfo) {
    try {
      var onCaughtError = root2.onCaughtError;
      onCaughtError(errorInfo.value, {
        componentStack: errorInfo.stack,
        errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
      });
    } catch (e$75) {
      setTimeout(function() {
        throw e$75;
      });
    }
  }
  function createRootErrorUpdate(root2, errorInfo, lane) {
    lane = createUpdate(lane);
    lane.tag = 3;
    lane.payload = { element: null };
    lane.callback = function() {
      logUncaughtError(root2, errorInfo);
    };
    return lane;
  }
  function createClassErrorUpdate(lane) {
    lane = createUpdate(lane);
    lane.tag = 3;
    return lane;
  }
  function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
    if ("function" === typeof getDerivedStateFromError) {
      var error = errorInfo.value;
      update.payload = function() {
        return getDerivedStateFromError(error);
      };
      update.callback = function() {
        logCaughtError(root2, fiber, errorInfo);
      };
    }
    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
      logCaughtError(root2, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
  }
  function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
    sourceFiber.flags |= 32768;
    if (null !== value && "object" === typeof value && "function" === typeof value.then) {
      returnFiber = sourceFiber.alternate;
      null !== returnFiber && propagateParentContextChanges(
        returnFiber,
        sourceFiber,
        rootRenderLanes,
        true
      );
      sourceFiber = suspenseHandlerStackCursor.current;
      if (null !== sourceFiber) {
        switch (sourceFiber.tag) {
          case 13:
            return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
          case 22:
            return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([value])
            }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
        }
        throw Error(formatProdErrorMessage(435, sourceFiber.tag));
      }
      attachPingListener(root2, value, rootRenderLanes);
      renderDidSuspendDelayIfPossible();
      return false;
    }
    if (isHydrating)
      return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
        cause: value
      }), queueHydrationError(
        createCapturedValueAtFiber(returnFiber, sourceFiber)
      )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
        root2.stateNode,
        value,
        rootRenderLanes
      ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
    var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
    wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
    null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
    4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
    if (null === returnFiber) return true;
    value = createCapturedValueAtFiber(value, sourceFiber);
    sourceFiber = returnFiber;
    do {
      switch (sourceFiber.tag) {
        case 3:
          return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
        case 1:
          if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
            return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
              rootRenderLanes,
              root2,
              sourceFiber,
              value
            ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
      }
      sourceFiber = sourceFiber.return;
    } while (null !== sourceFiber);
    return false;
  }
  var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
  function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
    workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
      workInProgress2,
      current.child,
      nextChildren,
      renderLanes2
    );
  }
  function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
    Component = Component.render;
    var ref = workInProgress2.ref;
    if ("ref" in nextProps) {
      var propsWithoutRef = {};
      for (var key in nextProps)
        "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
    } else propsWithoutRef = nextProps;
    prepareToReadContext(workInProgress2);
    nextProps = renderWithHooks(
      current,
      workInProgress2,
      Component,
      propsWithoutRef,
      ref,
      renderLanes2
    );
    key = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && key && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
    return workInProgress2.child;
  }
  function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    if (null === current) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
        return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
          current,
          workInProgress2,
          type,
          nextProps,
          renderLanes2
        );
      current = createFiberFromTypeAndProps(
        Component.type,
        null,
        nextProps,
        workInProgress2,
        workInProgress2.mode,
        renderLanes2
      );
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    type = current.child;
    if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
      var prevProps = type.memoizedProps;
      Component = Component.compare;
      Component = null !== Component ? Component : shallowEqual;
      if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    workInProgress2.flags |= 1;
    current = createWorkInProgress(type, nextProps);
    current.ref = workInProgress2.ref;
    current.return = workInProgress2;
    return workInProgress2.child = current;
  }
  function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    if (null !== current) {
      var prevProps = current.memoizedProps;
      if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
        if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
          0 !== (current.flags & 131072) && (didReceiveUpdate = true);
        else
          return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    return updateFunctionComponent(
      current,
      workInProgress2,
      Component,
      nextProps,
      renderLanes2
    );
  }
  function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
    if ("hidden" === nextProps.mode) {
      if (0 !== (workInProgress2.flags & 128)) {
        nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
        if (null !== current) {
          nextChildren = workInProgress2.child = current.child;
          for (prevState = 0; null !== nextChildren; )
            prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
          workInProgress2.childLanes = prevState & ~nextProps;
        } else workInProgress2.childLanes = 0, workInProgress2.child = null;
        return deferHiddenOffscreenComponent(
          current,
          workInProgress2,
          nextProps,
          renderLanes2
        );
      }
      if (0 !== (renderLanes2 & 536870912))
        workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
          workInProgress2,
          null !== prevState ? prevState.cachePool : null
        ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
      else
        return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
          current,
          workInProgress2,
          null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
          renderLanes2
        );
    } else
      null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
    reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
    return workInProgress2.child;
  }
  function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
    var JSCompiler_inline_result = peekCacheFromPool();
    JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
    workInProgress2.memoizedState = {
      baseLanes: nextBaseLanes,
      cachePool: JSCompiler_inline_result
    };
    null !== current && pushTransition(workInProgress2, null);
    reuseHiddenContextOnStack();
    pushOffscreenSuspenseHandler(workInProgress2);
    null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
    return null;
  }
  function markRef(current, workInProgress2) {
    var ref = workInProgress2.ref;
    if (null === ref)
      null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
    else {
      if ("function" !== typeof ref && "object" !== typeof ref)
        throw Error(formatProdErrorMessage(284));
      if (null === current || current.ref !== ref)
        workInProgress2.flags |= 4194816;
    }
  }
  function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    prepareToReadContext(workInProgress2);
    Component = renderWithHooks(
      current,
      workInProgress2,
      Component,
      nextProps,
      void 0,
      renderLanes2
    );
    nextProps = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, Component, renderLanes2);
    return workInProgress2.child;
  }
  function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
    prepareToReadContext(workInProgress2);
    workInProgress2.updateQueue = null;
    nextProps = renderWithHooksAgain(
      workInProgress2,
      Component,
      nextProps,
      secondArg
    );
    finishRenderingHooks(current);
    Component = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && Component && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
    return workInProgress2.child;
  }
  function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    prepareToReadContext(workInProgress2);
    if (null === workInProgress2.stateNode) {
      var context = emptyContextObject, contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
      context = new Component(nextProps, context);
      workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
      context.updater = classComponentUpdater;
      workInProgress2.stateNode = context;
      context._reactInternals = workInProgress2;
      context = workInProgress2.stateNode;
      context.props = nextProps;
      context.state = workInProgress2.memoizedState;
      context.refs = {};
      initializeUpdateQueue(workInProgress2);
      contextType = Component.contextType;
      context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
      context.state = workInProgress2.memoizedState;
      contextType = Component.getDerivedStateFromProps;
      "function" === typeof contextType && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        contextType,
        nextProps
      ), context.state = workInProgress2.memoizedState);
      "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
      "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
      nextProps = true;
    } else if (null === current) {
      context = workInProgress2.stateNode;
      var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
      context.props = oldProps;
      var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
      contextType = emptyContextObject;
      "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
      contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
      unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
      contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
        workInProgress2,
        context,
        nextProps,
        contextType
      );
      hasForceUpdate = false;
      var oldState = workInProgress2.memoizedState;
      context.state = oldState;
      processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
      suspendIfUpdateReadFromEntangledAsyncAction();
      oldContext = workInProgress2.memoizedState;
      unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        getDerivedStateFromProps,
        nextProps
      ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
        workInProgress2,
        Component,
        oldProps,
        nextProps,
        oldState,
        oldContext,
        contextType
      )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
    } else {
      context = workInProgress2.stateNode;
      cloneUpdateQueue(current, workInProgress2);
      contextType = workInProgress2.memoizedProps;
      contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
      context.props = contextType$jscomp$0;
      getDerivedStateFromProps = workInProgress2.pendingProps;
      oldState = context.context;
      oldContext = Component.contextType;
      oldProps = emptyContextObject;
      "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
      unresolvedOldProps = Component.getDerivedStateFromProps;
      (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
        workInProgress2,
        context,
        nextProps,
        oldProps
      );
      hasForceUpdate = false;
      oldState = workInProgress2.memoizedState;
      context.state = oldState;
      processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
      suspendIfUpdateReadFromEntangledAsyncAction();
      var newState = workInProgress2.memoizedState;
      contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        unresolvedOldProps,
        nextProps
      ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
        workInProgress2,
        Component,
        contextType$jscomp$0,
        nextProps,
        oldState,
        newState,
        oldProps
      ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
        nextProps,
        newState,
        oldProps
      )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
    }
    context = nextProps;
    markRef(current, workInProgress2);
    nextProps = 0 !== (workInProgress2.flags & 128);
    context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
      workInProgress2,
      current.child,
      null,
      renderLanes2
    ), workInProgress2.child = reconcileChildFibers(
      workInProgress2,
      null,
      Component,
      renderLanes2
    )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
      current,
      workInProgress2,
      renderLanes2
    );
    return current;
  }
  function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
    resetHydrationState();
    workInProgress2.flags |= 256;
    reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
    return workInProgress2.child;
  }
  var SUSPENDED_MARKER = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function mountSuspenseOffscreenState(renderLanes2) {
    return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
  }
  function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
    current = null !== current ? current.childLanes & ~renderLanes2 : 0;
    primaryTreeDidDefer && (current |= workInProgressDeferredLane);
    return current;
  }
  function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
    (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
    JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
    JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
    workInProgress2.flags &= -33;
    if (null === current) {
      if (isHydrating) {
        showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
        if (isHydrating) {
          var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
          if (JSCompiler_temp$jscomp$0 = nextInstance) {
            c: {
              JSCompiler_temp$jscomp$0 = nextInstance;
              for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                if (!nextInstance) {
                  nextInstance = null;
                  break c;
                }
                JSCompiler_temp$jscomp$0 = getNextHydratable(
                  JSCompiler_temp$jscomp$0.nextSibling
                );
                if (null === JSCompiler_temp$jscomp$0) {
                  nextInstance = null;
                  break c;
                }
              }
              nextInstance = JSCompiler_temp$jscomp$0;
            }
            null !== nextInstance ? (workInProgress2.memoizedState = {
              dehydrated: nextInstance,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
              18,
              null,
              null,
              0
            ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
          }
          JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
        }
        nextInstance = workInProgress2.memoizedState;
        if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
          return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
        popSuspenseHandler(workInProgress2);
      }
      nextInstance = nextProps.children;
      nextProps = nextProps.fallback;
      if (showFallback)
        return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
          { mode: "hidden", children: nextInstance },
          showFallback
        ), nextProps = createFiberFromFragment(
          nextProps,
          showFallback,
          renderLanes2,
          null
        ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
    }
    JSCompiler_temp$jscomp$0 = current.memoizedState;
    if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
      if (didSuspend)
        workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: nextProps.children },
          nextInstance
        ), showFallback = createFiberFromFragment(
          showFallback,
          nextInstance,
          renderLanes2,
          null
        ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
      else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
        JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
        if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
        JSCompiler_temp = digest;
        nextProps = Error(formatProdErrorMessage(419));
        nextProps.stack = "";
        nextProps.digest = JSCompiler_temp;
        queueHydrationError({ value: nextProps, source: null, stack: null });
        workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        );
      } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
        JSCompiler_temp = workInProgressRoot;
        if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
          throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
        "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
        workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        );
      } else
        "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
          nextInstance.nextSibling
        ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
          workInProgress2,
          nextProps.children
        ), workInProgress2.flags |= 4096);
      return workInProgress2;
    }
    if (showFallback)
      return reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
        mode: "hidden",
        children: nextProps.children
      }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
        showFallback,
        nextInstance,
        renderLanes2,
        null
      ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
        baseLanes: nextInstance.baseLanes | renderLanes2,
        cachePool: JSCompiler_temp$jscomp$0
      }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes2
      ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
    pushPrimaryTreeSuspenseHandler(workInProgress2);
    renderLanes2 = current.child;
    current = renderLanes2.sibling;
    renderLanes2 = createWorkInProgress(renderLanes2, {
      mode: "visible",
      children: nextProps.children
    });
    renderLanes2.return = workInProgress2;
    renderLanes2.sibling = null;
    null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
    workInProgress2.child = renderLanes2;
    workInProgress2.memoizedState = null;
    return renderLanes2;
  }
  function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
    primaryChildren = mountWorkInProgressOffscreenFiber(
      { mode: "visible", children: primaryChildren },
      workInProgress2.mode
    );
    primaryChildren.return = workInProgress2;
    return workInProgress2.child = primaryChildren;
  }
  function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
    offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
    offscreenProps.lanes = 0;
    offscreenProps.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    };
    return offscreenProps;
  }
  function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
    reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
    current = mountSuspensePrimaryChildren(
      workInProgress2,
      workInProgress2.pendingProps.children
    );
    current.flags |= 2;
    workInProgress2.memoizedState = null;
    return current;
  }
  function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
    fiber.lanes |= renderLanes2;
    var alternate = fiber.alternate;
    null !== alternate && (alternate.lanes |= renderLanes2);
    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
  }
  function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
    var renderState = workInProgress2.memoizedState;
    null === renderState ? workInProgress2.memoizedState = {
      isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail,
      tailMode
    } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
  }
  function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
    reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
    nextProps = suspenseStackCursor.current;
    if (0 !== (nextProps & 2))
      nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
    else {
      if (null !== current && 0 !== (current.flags & 128))
        a: for (current = workInProgress2.child; null !== current; ) {
          if (13 === current.tag)
            null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (19 === current.tag)
            scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress2) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress2)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      nextProps &= 1;
    }
    push(suspenseStackCursor, nextProps);
    switch (revealOrder) {
      case "forwards":
        renderLanes2 = workInProgress2.child;
        for (revealOrder = null; null !== renderLanes2; )
          current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
        renderLanes2 = revealOrder;
        null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
        initSuspenseListRenderState(
          workInProgress2,
          false,
          revealOrder,
          renderLanes2,
          tailMode
        );
        break;
      case "backwards":
        renderLanes2 = null;
        revealOrder = workInProgress2.child;
        for (workInProgress2.child = null; null !== revealOrder; ) {
          current = revealOrder.alternate;
          if (null !== current && null === findFirstSuspended(current)) {
            workInProgress2.child = revealOrder;
            break;
          }
          current = revealOrder.sibling;
          revealOrder.sibling = renderLanes2;
          renderLanes2 = revealOrder;
          revealOrder = current;
        }
        initSuspenseListRenderState(
          workInProgress2,
          true,
          renderLanes2,
          null,
          tailMode
        );
        break;
      case "together":
        initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
        break;
      default:
        workInProgress2.memoizedState = null;
    }
    return workInProgress2.child;
  }
  function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
    null !== current && (workInProgress2.dependencies = current.dependencies);
    workInProgressRootSkippedLanes |= workInProgress2.lanes;
    if (0 === (renderLanes2 & workInProgress2.childLanes))
      if (null !== current) {
        if (propagateParentContextChanges(
          current,
          workInProgress2,
          renderLanes2,
          false
        ), 0 === (renderLanes2 & workInProgress2.childLanes))
          return null;
      } else return null;
    if (null !== current && workInProgress2.child !== current.child)
      throw Error(formatProdErrorMessage(153));
    if (null !== workInProgress2.child) {
      current = workInProgress2.child;
      renderLanes2 = createWorkInProgress(current, current.pendingProps);
      workInProgress2.child = renderLanes2;
      for (renderLanes2.return = workInProgress2; null !== current.sibling; )
        current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
    }
    return workInProgress2.child;
  }
  function checkScheduledUpdateOrContext(current, renderLanes2) {
    if (0 !== (current.lanes & renderLanes2)) return true;
    current = current.dependencies;
    return null !== current && checkIfContextChanged(current) ? true : false;
  }
  function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
    switch (workInProgress2.tag) {
      case 3:
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        resetHydrationState();
        break;
      case 27:
      case 5:
        pushHostContext(workInProgress2);
        break;
      case 4:
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        break;
      case 10:
        pushProvider(
          workInProgress2,
          workInProgress2.type,
          workInProgress2.memoizedProps.value
        );
        break;
      case 13:
        var state = workInProgress2.memoizedState;
        if (null !== state) {
          if (null !== state.dehydrated)
            return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
          if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          current = bailoutOnAlreadyFinishedWork(
            current,
            workInProgress2,
            renderLanes2
          );
          return null !== current ? current.sibling : null;
        }
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        break;
      case 19:
        var didSuspendBefore = 0 !== (current.flags & 128);
        state = 0 !== (renderLanes2 & workInProgress2.childLanes);
        state || (propagateParentContextChanges(
          current,
          workInProgress2,
          renderLanes2,
          false
        ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
        if (didSuspendBefore) {
          if (state)
            return updateSuspenseListComponent(
              current,
              workInProgress2,
              renderLanes2
            );
          workInProgress2.flags |= 128;
        }
        didSuspendBefore = workInProgress2.memoizedState;
        null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
        push(suspenseStackCursor, suspenseStackCursor.current);
        if (state) break;
        else return null;
      case 22:
      case 23:
        return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
      case 24:
        pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
    }
    return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
  }
  function beginWork(current, workInProgress2, renderLanes2) {
    if (null !== current)
      if (current.memoizedProps !== workInProgress2.pendingProps)
        didReceiveUpdate = true;
      else {
        if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
          return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
            current,
            workInProgress2,
            renderLanes2
          );
        didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
      }
    else
      didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
    workInProgress2.lanes = 0;
    switch (workInProgress2.tag) {
      case 16:
        a: {
          current = workInProgress2.pendingProps;
          var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
          lazyComponent = init(lazyComponent._payload);
          workInProgress2.type = lazyComponent;
          if ("function" === typeof lazyComponent)
            shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
              null,
              workInProgress2,
              lazyComponent,
              current,
              renderLanes2
            )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
              null,
              workInProgress2,
              lazyComponent,
              current,
              renderLanes2
            ));
          else {
            if (void 0 !== lazyComponent && null !== lazyComponent) {
              if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                workInProgress2.tag = 11;
                workInProgress2 = updateForwardRef(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                );
                break a;
              } else if (init === REACT_MEMO_TYPE) {
                workInProgress2.tag = 14;
                workInProgress2 = updateMemoComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                );
                break a;
              }
            }
            workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
            throw Error(formatProdErrorMessage(306, workInProgress2, ""));
          }
        }
        return workInProgress2;
      case 0:
        return updateFunctionComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 1:
        return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
          lazyComponent,
          workInProgress2.pendingProps
        ), updateClassComponent(
          current,
          workInProgress2,
          lazyComponent,
          init,
          renderLanes2
        );
      case 3:
        a: {
          pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          );
          if (null === current) throw Error(formatProdErrorMessage(387));
          lazyComponent = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          init = prevState.element;
          cloneUpdateQueue(current, workInProgress2);
          processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          lazyComponent = nextState.cache;
          pushProvider(workInProgress2, CacheContext, lazyComponent);
          lazyComponent !== prevState.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          );
          suspendIfUpdateReadFromEntangledAsyncAction();
          lazyComponent = nextState.element;
          if (prevState.isDehydrated)
            if (prevState = {
              element: lazyComponent,
              isDehydrated: false,
              cache: nextState.cache
            }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
              workInProgress2 = mountHostRootWithoutHydrating(
                current,
                workInProgress2,
                lazyComponent,
                renderLanes2
              );
              break a;
            } else if (lazyComponent !== init) {
              init = createCapturedValueAtFiber(
                Error(formatProdErrorMessage(424)),
                workInProgress2
              );
              queueHydrationError(init);
              workInProgress2 = mountHostRootWithoutHydrating(
                current,
                workInProgress2,
                lazyComponent,
                renderLanes2
              );
              break a;
            } else {
              current = workInProgress2.stateNode.containerInfo;
              switch (current.nodeType) {
                case 9:
                  current = current.body;
                  break;
                default:
                  current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
              }
              nextHydratableInstance = getNextHydratable(current.firstChild);
              hydrationParentFiber = workInProgress2;
              isHydrating = true;
              hydrationErrors = null;
              rootOrSingletonContext = true;
              renderLanes2 = mountChildFibers(
                workInProgress2,
                null,
                lazyComponent,
                renderLanes2
              );
              for (workInProgress2.child = renderLanes2; renderLanes2; )
                renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
            }
          else {
            resetHydrationState();
            if (lazyComponent === init) {
              workInProgress2 = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              break a;
            }
            reconcileChildren(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            );
          }
          workInProgress2 = workInProgress2.child;
        }
        return workInProgress2;
      case 26:
        return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
          workInProgress2.type,
          null,
          workInProgress2.pendingProps,
          null
        )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
          rootInstanceStackCursor.current
        ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
          workInProgress2.type,
          current.memoizedProps,
          workInProgress2.pendingProps,
          current.memoizedState
        ), null;
      case 27:
        return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
          workInProgress2.type,
          workInProgress2.pendingProps,
          rootInstanceStackCursor.current
        ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(
          lazyComponent.firstChild
        )) : nextHydratableInstance = init), reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
      case 5:
        if (null === current && isHydrating) {
          if (init = lazyComponent = nextHydratableInstance)
            lazyComponent = canHydrateInstance(
              lazyComponent,
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
              lazyComponent.firstChild
            ), rootOrSingletonContext = false, init = true) : init = false;
          init || throwOnHydrationMismatch(workInProgress2);
        }
        pushHostContext(workInProgress2);
        init = workInProgress2.type;
        prevState = workInProgress2.pendingProps;
        nextState = null !== current ? current.memoizedProps : null;
        lazyComponent = prevState.children;
        shouldSetTextContent(init, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
        null !== workInProgress2.memoizedState && (init = renderWithHooks(
          current,
          workInProgress2,
          TransitionAwareHostComponent,
          null,
          null,
          renderLanes2
        ), HostTransitionContext._currentValue = init);
        markRef(current, workInProgress2);
        reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
        return workInProgress2.child;
      case 6:
        if (null === current && isHydrating) {
          if (current = renderLanes2 = nextHydratableInstance)
            renderLanes2 = canHydrateTextInstance(
              renderLanes2,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
          current || throwOnHydrationMismatch(workInProgress2);
        }
        return null;
      case 13:
        return updateSuspenseComponent(current, workInProgress2, renderLanes2);
      case 4:
        return pushHostContainer(
          workInProgress2,
          workInProgress2.stateNode.containerInfo
        ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          lazyComponent,
          renderLanes2
        ) : reconcileChildren(
          current,
          workInProgress2,
          lazyComponent,
          renderLanes2
        ), workInProgress2.child;
      case 11:
        return updateForwardRef(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 7:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps,
          renderLanes2
        ), workInProgress2.child;
      case 8:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 12:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 10:
        return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
          current,
          workInProgress2,
          lazyComponent.children,
          renderLanes2
        ), workInProgress2.child;
      case 9:
        return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
      case 14:
        return updateMemoComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 15:
        return updateSimpleMemoComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 19:
        return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
      case 31:
        return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
          mode: lazyComponent.mode,
          children: lazyComponent.children
        }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
          lazyComponent,
          renderLanes2
        ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
      case 22:
        return updateOffscreenComponent(current, workInProgress2, renderLanes2);
      case 24:
        return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, prevState = createCache(), init.pooledCache = prevState, prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes2), init = prevState), workInProgress2.memoizedState = {
          parent: lazyComponent,
          cache: init
        }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
          workInProgress2,
          [CacheContext],
          renderLanes2,
          true
        ))), reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 29:
        throw workInProgress2.pendingProps;
    }
    throw Error(formatProdErrorMessage(156, workInProgress2.tag));
  }
  function markUpdate(workInProgress2) {
    workInProgress2.flags |= 4;
  }
  function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
    if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
      workInProgress2.flags &= -16777217;
    else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
      resource = suspenseHandlerStackCursor.current;
      if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
        throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      workInProgress2.flags |= 8192;
    }
  }
  function scheduleRetryEffect(workInProgress2, retryQueue) {
    null !== retryQueue && (workInProgress2.flags |= 4);
    workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
  }
  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
    if (!isHydrating)
      switch (renderState.tailMode) {
        case "hidden":
          hasRenderedATailFallback = renderState.tail;
          for (var lastTailNode = null; null !== hasRenderedATailFallback; )
            null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
          null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
          break;
        case "collapsed":
          lastTailNode = renderState.tail;
          for (var lastTailNode$113 = null; null !== lastTailNode; )
            null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
          null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
      }
  }
  function bubbleProperties(completedWork) {
    var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
    if (didBailout)
      for (var child$114 = completedWork.child; null !== child$114; )
        newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
    else
      for (child$114 = completedWork.child; null !== child$114; )
        newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
    completedWork.subtreeFlags |= subtreeFlags;
    completedWork.childLanes = newChildLanes;
    return didBailout;
  }
  function completeWork(current, workInProgress2, renderLanes2) {
    var newProps = workInProgress2.pendingProps;
    popTreeContext(workInProgress2);
    switch (workInProgress2.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bubbleProperties(workInProgress2), null;
      case 1:
        return bubbleProperties(workInProgress2), null;
      case 3:
        renderLanes2 = workInProgress2.stateNode;
        newProps = null;
        null !== current && (newProps = current.memoizedState.cache);
        workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
        popProvider(CacheContext);
        popHostContainer();
        renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
        if (null === current || null === current.child)
          popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
        bubbleProperties(workInProgress2);
        return null;
      case 26:
        return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
      case 27:
        popHostContext(workInProgress2);
        renderLanes2 = rootInstanceStackCursor.current;
        var type = workInProgress2.type;
        if (null !== current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if (!newProps) {
            if (null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            bubbleProperties(workInProgress2);
            return null;
          }
          current = contextStackCursor.current;
          popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
        }
        bubbleProperties(workInProgress2);
        return null;
      case 5:
        popHostContext(workInProgress2);
        renderLanes2 = workInProgress2.type;
        if (null !== current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if (!newProps) {
            if (null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            bubbleProperties(workInProgress2);
            return null;
          }
          current = contextStackCursor.current;
          if (popHydrationState(workInProgress2))
            prepareToHydrateHostInstance(workInProgress2);
          else {
            type = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            );
            switch (current) {
              case 1:
                current = type.createElementNS(
                  "http://www.w3.org/2000/svg",
                  renderLanes2
                );
                break;
              case 2:
                current = type.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  renderLanes2
                );
                break;
              default:
                switch (renderLanes2) {
                  case "svg":
                    current = type.createElementNS(
                      "http://www.w3.org/2000/svg",
                      renderLanes2
                    );
                    break;
                  case "math":
                    current = type.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      renderLanes2
                    );
                    break;
                  case "script":
                    current = type.createElement("div");
                    current.innerHTML = "<script><\/script>";
                    current = current.removeChild(current.firstChild);
                    break;
                  case "select":
                    current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                    newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                    break;
                  default:
                    current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
                }
            }
            current[internalInstanceKey] = workInProgress2;
            current[internalPropsKey] = newProps;
            a: for (type = workInProgress2.child; null !== type; ) {
              if (5 === type.tag || 6 === type.tag)
                current.appendChild(type.stateNode);
              else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                type.child.return = type;
                type = type.child;
                continue;
              }
              if (type === workInProgress2) break a;
              for (; null === type.sibling; ) {
                if (null === type.return || type.return === workInProgress2)
                  break a;
                type = type.return;
              }
              type.sibling.return = type.return;
              type = type.sibling;
            }
            workInProgress2.stateNode = current;
            a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                current = !!newProps.autoFocus;
                break a;
              case "img":
                current = true;
                break a;
              default:
                current = false;
            }
            current && markUpdate(workInProgress2);
          }
        }
        bubbleProperties(workInProgress2);
        workInProgress2.flags &= -16777217;
        return null;
      case 6:
        if (current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if ("string" !== typeof newProps && null === workInProgress2.stateNode)
            throw Error(formatProdErrorMessage(166));
          current = rootInstanceStackCursor.current;
          if (popHydrationState(workInProgress2)) {
            current = workInProgress2.stateNode;
            renderLanes2 = workInProgress2.memoizedProps;
            newProps = null;
            type = hydrationParentFiber;
            if (null !== type)
              switch (type.tag) {
                case 27:
                case 5:
                  newProps = type.memoizedProps;
              }
            current[internalInstanceKey] = workInProgress2;
            current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
            current || throwOnHydrationMismatch(workInProgress2);
          } else
            current = getOwnerDocumentFromRootContainer(current).createTextNode(
              newProps
            ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
        }
        bubbleProperties(workInProgress2);
        return null;
      case 13:
        newProps = workInProgress2.memoizedState;
        if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
          type = popHydrationState(workInProgress2);
          if (null !== newProps && null !== newProps.dehydrated) {
            if (null === current) {
              if (!type) throw Error(formatProdErrorMessage(318));
              type = workInProgress2.memoizedState;
              type = null !== type ? type.dehydrated : null;
              if (!type) throw Error(formatProdErrorMessage(317));
              type[internalInstanceKey] = workInProgress2;
            } else
              resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
            bubbleProperties(workInProgress2);
            type = false;
          } else
            type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
          if (!type) {
            if (workInProgress2.flags & 256)
              return popSuspenseHandler(workInProgress2), workInProgress2;
            popSuspenseHandler(workInProgress2);
            return null;
          }
        }
        popSuspenseHandler(workInProgress2);
        if (0 !== (workInProgress2.flags & 128))
          return workInProgress2.lanes = renderLanes2, workInProgress2;
        renderLanes2 = null !== newProps;
        current = null !== current && null !== current.memoizedState;
        if (renderLanes2) {
          newProps = workInProgress2.child;
          type = null;
          null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
          var cache$127 = null;
          null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
          cache$127 !== type && (newProps.flags |= 2048);
        }
        renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
        scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
        bubbleProperties(workInProgress2);
        return null;
      case 4:
        return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
      case 10:
        return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
      case 19:
        pop(suspenseStackCursor);
        type = workInProgress2.memoizedState;
        if (null === type) return bubbleProperties(workInProgress2), null;
        newProps = 0 !== (workInProgress2.flags & 128);
        cache$127 = type.rendering;
        if (null === cache$127)
          if (newProps) cutOffTailIfNeeded(type, false);
          else {
            if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
              for (current = workInProgress2.child; null !== current; ) {
                cache$127 = findFirstSuspended(current);
                if (null !== cache$127) {
                  workInProgress2.flags |= 128;
                  cutOffTailIfNeeded(type, false);
                  current = cache$127.updateQueue;
                  workInProgress2.updateQueue = current;
                  scheduleRetryEffect(workInProgress2, current);
                  workInProgress2.subtreeFlags = 0;
                  current = renderLanes2;
                  for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                    resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                  push(
                    suspenseStackCursor,
                    suspenseStackCursor.current & 1 | 2
                  );
                  return workInProgress2.child;
                }
                current = current.sibling;
              }
            null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
          }
        else {
          if (!newProps)
            if (current = findFirstSuspended(cache$127), null !== current) {
              if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
                return bubbleProperties(workInProgress2), null;
            } else
              2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
          type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
        }
        if (null !== type.tail)
          return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
        bubbleProperties(workInProgress2);
        return null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
      case 24:
        return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(formatProdErrorMessage(156, workInProgress2.tag));
  }
  function unwindWork(current, workInProgress2) {
    popTreeContext(workInProgress2);
    switch (workInProgress2.tag) {
      case 1:
        return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 3:
        return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 26:
      case 27:
      case 5:
        return popHostContext(workInProgress2), null;
      case 13:
        popSuspenseHandler(workInProgress2);
        current = workInProgress2.memoizedState;
        if (null !== current && null !== current.dehydrated) {
          if (null === workInProgress2.alternate)
            throw Error(formatProdErrorMessage(340));
          resetHydrationState();
        }
        current = workInProgress2.flags;
        return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 19:
        return pop(suspenseStackCursor), null;
      case 4:
        return popHostContainer(), null;
      case 10:
        return popProvider(workInProgress2.type), null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 24:
        return popProvider(CacheContext), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function unwindInterruptedWork(current, interruptedWork) {
    popTreeContext(interruptedWork);
    switch (interruptedWork.tag) {
      case 3:
        popProvider(CacheContext);
        popHostContainer();
        break;
      case 26:
      case 27:
      case 5:
        popHostContext(interruptedWork);
        break;
      case 4:
        popHostContainer();
        break;
      case 13:
        popSuspenseHandler(interruptedWork);
        break;
      case 19:
        pop(suspenseStackCursor);
        break;
      case 10:
        popProvider(interruptedWork.type);
        break;
      case 22:
      case 23:
        popSuspenseHandler(interruptedWork);
        popHiddenContext();
        null !== current && pop(resumedCache);
        break;
      case 24:
        popProvider(CacheContext);
    }
  }
  function commitHookEffectListMount(flags, finishedWork) {
    try {
      var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            lastEffect = void 0;
            var create = updateQueue.create, inst = updateQueue.inst;
            lastEffect = create();
            inst.destroy = lastEffect;
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
    try {
      var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            var inst = updateQueue.inst, destroy = inst.destroy;
            if (void 0 !== destroy) {
              inst.destroy = void 0;
              lastEffect = finishedWork;
              var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
              try {
                destroy_();
              } catch (error) {
                captureCommitPhaseError(
                  lastEffect,
                  nearestMountedAncestor,
                  error
                );
              }
            }
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitClassCallbacks(finishedWork) {
    var updateQueue = finishedWork.updateQueue;
    if (null !== updateQueue) {
      var instance = finishedWork.stateNode;
      try {
        commitCallbacks(updateQueue, instance);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
  }
  function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
    instance.props = resolveClassComponentProps(
      current.type,
      current.memoizedProps
    );
    instance.state = current.memoizedState;
    try {
      instance.componentWillUnmount();
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyAttachRef(current, nearestMountedAncestor) {
    try {
      var ref = current.ref;
      if (null !== ref) {
        switch (current.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = current.stateNode;
            break;
          case 30:
            instanceToUse = current.stateNode;
            break;
          default:
            instanceToUse = current.stateNode;
        }
        "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
      }
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyDetachRef(current, nearestMountedAncestor) {
    var ref = current.ref, refCleanup = current.refCleanup;
    if (null !== ref)
      if ("function" === typeof refCleanup)
        try {
          refCleanup();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        } finally {
          current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
        }
      else if ("function" === typeof ref)
        try {
          ref(null);
        } catch (error$143) {
          captureCommitPhaseError(current, nearestMountedAncestor, error$143);
        }
      else ref.current = null;
  }
  function commitHostMount(finishedWork) {
    var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
    try {
      a: switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          props.autoFocus && instance.focus();
          break a;
        case "img":
          props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHostUpdate(finishedWork, newProps, oldProps) {
    try {
      var domElement = finishedWork.stateNode;
      updateProperties(domElement, finishedWork.type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
  }
  function getHostSibling(fiber) {
    a: for (; ; ) {
      for (; null === fiber.sibling; ) {
        if (null === fiber.return || isHostParent(fiber.return)) return null;
        fiber = fiber.return;
      }
      fiber.sibling.return = fiber.return;
      for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
        if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
        if (fiber.flags & 2) continue a;
        if (null === fiber.child || 4 === fiber.tag) continue a;
        else fiber.child.return = fiber, fiber = fiber.child;
      }
      if (!(fiber.flags & 2)) return fiber.stateNode;
    }
  }
  function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag)
      node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
    else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
      for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
        insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
  }
  function insertOrAppendPlacementNode(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag)
      node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
    else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
      for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
        insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
  }
  function commitHostSingletonAcquisition(finishedWork) {
    var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
    try {
      for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
        singleton.removeAttributeNode(attributes[0]);
      setInitialProperties(singleton, type, props);
      singleton[internalInstanceKey] = finishedWork;
      singleton[internalPropsKey] = props;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
  function commitBeforeMutationEffects(root2, firstChild) {
    root2 = root2.containerInfo;
    eventsEnabled = _enabled;
    root2 = getActiveElementDeep(root2);
    if (hasSelectionCapabilities(root2)) {
      if ("selectionStart" in root2)
        var JSCompiler_temp = {
          start: root2.selectionStart,
          end: root2.selectionEnd
        };
      else
        a: {
          JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
          var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
          if (selection && 0 !== selection.rangeCount) {
            JSCompiler_temp = selection.anchorNode;
            var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
            selection = selection.focusOffset;
            try {
              JSCompiler_temp.nodeType, focusNode.nodeType;
            } catch (e$20) {
              JSCompiler_temp = null;
              break a;
            }
            var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
            b: for (; ; ) {
              for (var next; ; ) {
                node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                3 === node.nodeType && (length += node.nodeValue.length);
                if (null === (next = node.firstChild)) break;
                parentNode = node;
                node = next;
              }
              for (; ; ) {
                if (node === root2) break b;
                parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                if (null !== (next = node.nextSibling)) break;
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
            JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
          } else JSCompiler_temp = null;
        }
      JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
    } else JSCompiler_temp = null;
    selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
    _enabled = false;
    for (nextEffect = firstChild; null !== nextEffect; )
      if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
        root2.return = firstChild, nextEffect = root2;
      else
        for (; null !== nextEffect; ) {
          firstChild = nextEffect;
          focusNode = firstChild.alternate;
          root2 = firstChild.flags;
          switch (firstChild.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if (0 !== (root2 & 1024) && null !== focusNode) {
                root2 = void 0;
                JSCompiler_temp = firstChild;
                anchorOffset = focusNode.memoizedProps;
                focusNode = focusNode.memoizedState;
                selection = JSCompiler_temp.stateNode;
                try {
                  var resolvedPrevProps = resolveClassComponentProps(
                    JSCompiler_temp.type,
                    anchorOffset,
                    JSCompiler_temp.elementType === JSCompiler_temp.type
                  );
                  root2 = selection.getSnapshotBeforeUpdate(
                    resolvedPrevProps,
                    focusNode
                  );
                  selection.__reactInternalSnapshotBeforeUpdate = root2;
                } catch (error) {
                  captureCommitPhaseError(
                    JSCompiler_temp,
                    JSCompiler_temp.return,
                    error
                  );
                }
              }
              break;
            case 3:
              if (0 !== (root2 & 1024)) {
                if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                  clearContainerSparingly(root2);
                else if (1 === JSCompiler_temp)
                  switch (root2.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      clearContainerSparingly(root2);
                      break;
                    default:
                      root2.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
          }
          root2 = firstChild.sibling;
          if (null !== root2) {
            root2.return = firstChild.return;
            nextEffect = root2;
            break;
          }
          nextEffect = firstChild.return;
        }
  }
  function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitHookEffectListMount(5, finishedWork);
        break;
      case 1:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 4)
          if (finishedRoot = finishedWork.stateNode, null === current)
            try {
              finishedRoot.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          else {
            var prevProps = resolveClassComponentProps(
              finishedWork.type,
              current.memoizedProps
            );
            current = current.memoizedState;
            try {
              finishedRoot.componentDidUpdate(
                prevProps,
                current,
                finishedRoot.__reactInternalSnapshotBeforeUpdate
              );
            } catch (error$142) {
              captureCommitPhaseError(
                finishedWork,
                finishedWork.return,
                error$142
              );
            }
          }
        flags & 64 && commitClassCallbacks(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 3:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
          current = null;
          if (null !== finishedWork.child)
            switch (finishedWork.child.tag) {
              case 27:
              case 5:
                current = finishedWork.child.stateNode;
                break;
              case 1:
                current = finishedWork.child.stateNode;
            }
          try {
            commitCallbacks(finishedRoot, current);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 27:
        null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        null === current && flags & 4 && commitHostMount(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        break;
      case 13:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
          null,
          finishedWork
        ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
        break;
      case 22:
        flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
        if (!flags) {
          current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
          prevProps = offscreenSubtreeIsHidden;
          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = flags;
          (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            0 !== (finishedWork.subtreeFlags & 8772)
          ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          offscreenSubtreeIsHidden = prevProps;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        }
        break;
      case 30:
        break;
      default:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
    }
  }
  function detachFiberAfterEffects(fiber) {
    var alternate = fiber.alternate;
    null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
    fiber.child = null;
    fiber.deletions = null;
    fiber.sibling = null;
    5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
    fiber.stateNode = null;
    fiber.return = null;
    fiber.dependencies = null;
    fiber.memoizedProps = null;
    fiber.memoizedState = null;
    fiber.pendingProps = null;
    fiber.stateNode = null;
    fiber.updateQueue = null;
  }
  var hostParent = null, hostParentIsContainer = false;
  function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
    for (parent = parent.child; null !== parent; )
      commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
  }
  function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
      try {
        injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
      } catch (err) {
      }
    switch (deletedFiber.tag) {
      case 26:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
        break;
      case 27:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
        isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        releaseSingletonInstance(deletedFiber.stateNode);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 5:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      case 6:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = null;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        if (null !== hostParent)
          if (hostParentIsContainer)
            try {
              (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
            } catch (error) {
              captureCommitPhaseError(
                deletedFiber,
                nearestMountedAncestor,
                error
              );
            }
          else
            try {
              hostParent.removeChild(deletedFiber.stateNode);
            } catch (error) {
              captureCommitPhaseError(
                deletedFiber,
                nearestMountedAncestor,
                error
              );
            }
        break;
      case 18:
        null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
          9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
          deletedFiber.stateNode
        ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
        break;
      case 4:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = deletedFiber.stateNode.containerInfo;
        hostParentIsContainer = true;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 1:
        offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
          deletedFiber,
          nearestMountedAncestor,
          prevHostParent
        ));
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 21:
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 22:
        offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        offscreenSubtreeWasHidden = prevHostParent;
        break;
      default:
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
    }
  }
  function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
    if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
      try {
        retryIfBlockedOn(finishedRoot);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
  }
  function getRetryCache(finishedWork) {
    switch (finishedWork.tag) {
      case 13:
      case 19:
        var retryCache = finishedWork.stateNode;
        null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
        return retryCache;
      case 22:
        return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
      default:
        throw Error(formatProdErrorMessage(435, finishedWork.tag));
    }
  }
  function attachSuspenseRetryListeners(finishedWork, wakeables) {
    var retryCache = getRetryCache(finishedWork);
    wakeables.forEach(function(wakeable) {
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
      retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
    });
  }
  function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
    var deletions = parentFiber.deletions;
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
        a: for (; null !== parent; ) {
          switch (parent.tag) {
            case 27:
              if (isSingletonScope(parent.type)) {
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              }
              break;
            case 5:
              hostParent = parent.stateNode;
              hostParentIsContainer = false;
              break a;
            case 3:
            case 4:
              hostParent = parent.stateNode.containerInfo;
              hostParentIsContainer = true;
              break a;
          }
          parent = parent.return;
        }
        if (null === hostParent) throw Error(formatProdErrorMessage(160));
        commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
        hostParent = null;
        hostParentIsContainer = false;
        root2 = childToDelete.alternate;
        null !== root2 && (root2.return = null);
        childToDelete.return = null;
      }
    if (parentFiber.subtreeFlags & 13878)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
  }
  var currentHoistableRoot = null;
  function commitMutationEffectsOnFiber(finishedWork, root2) {
    var current = finishedWork.alternate, flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
        break;
      case 1:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
        break;
      case 26:
        var hoistableRoot = currentHoistableRoot;
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (flags & 4) {
          var currentResource = null !== current ? current.memoizedState : null;
          flags = finishedWork.memoizedState;
          if (null === current)
            if (null === flags)
              if (null === finishedWork.stateNode) {
                a: {
                  flags = finishedWork.type;
                  current = finishedWork.memoizedProps;
                  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                  b: switch (flags) {
                    case "title":
                      currentResource = hoistableRoot.getElementsByTagName("title")[0];
                      if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                        currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                          currentResource,
                          hoistableRoot.querySelector("head > title")
                        );
                      setInitialProperties(currentResource, flags, current);
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                      break a;
                    case "link":
                      var maybeNodes = getHydratableHoistableCache(
                        "link",
                        "href",
                        hoistableRoot
                      ).get(flags + (current.href || ""));
                      if (maybeNodes) {
                        for (var i = 0; i < maybeNodes.length; i++)
                          if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                            maybeNodes.splice(i, 1);
                            break b;
                          }
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    case "meta":
                      if (maybeNodes = getHydratableHoistableCache(
                        "meta",
                        "content",
                        hoistableRoot
                      ).get(flags + (current.content || ""))) {
                        for (i = 0; i < maybeNodes.length; i++)
                          if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                            maybeNodes.splice(i, 1);
                            break b;
                          }
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    default:
                      throw Error(formatProdErrorMessage(468, flags));
                  }
                  currentResource[internalInstanceKey] = finishedWork;
                  markNodeAsHoistable(currentResource);
                  flags = currentResource;
                }
                finishedWork.stateNode = flags;
              } else
                mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                );
            else
              finishedWork.stateNode = acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              );
          else
            currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
              hoistableRoot,
              finishedWork.type,
              finishedWork.stateNode
            ) : acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
        }
        break;
      case 27:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        null !== current && flags & 4 && commitHostUpdate(
          finishedWork,
          finishedWork.memoizedProps,
          current.memoizedProps
        );
        break;
      case 5:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (finishedWork.flags & 32) {
          hoistableRoot = finishedWork.stateNode;
          try {
            setTextContent(hoistableRoot, "");
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
          finishedWork,
          hoistableRoot,
          null !== current ? current.memoizedProps : hoistableRoot
        ));
        flags & 1024 && (needsFormReset = true);
        break;
      case 6:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        if (flags & 4) {
          if (null === finishedWork.stateNode)
            throw Error(formatProdErrorMessage(162));
          flags = finishedWork.memoizedProps;
          current = finishedWork.stateNode;
          try {
            current.nodeValue = flags;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 3:
        tagCaches = null;
        hoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(root2.containerInfo);
        recursivelyTraverseMutationEffects(root2, finishedWork);
        currentHoistableRoot = hoistableRoot;
        commitReconciliationEffects(finishedWork);
        if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
          try {
            retryIfBlockedOn(root2.containerInfo);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
        break;
      case 4:
        flags = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(
          finishedWork.stateNode.containerInfo
        );
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        currentHoistableRoot = flags;
        break;
      case 12:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        break;
      case 13:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 22:
        hoistableRoot = null !== finishedWork.memoizedState;
        var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
        recursivelyTraverseMutationEffects(root2, finishedWork);
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
        commitReconciliationEffects(finishedWork);
        if (flags & 8192)
          a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
            if (5 === root2.tag || 26 === root2.tag) {
              if (null === current) {
                wasHidden = current = root2;
                try {
                  if (currentResource = wasHidden.stateNode, hoistableRoot)
                    maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                  else {
                    i = wasHidden.stateNode;
                    var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                    i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                  }
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if (6 === root2.tag) {
              if (null === current) {
                wasHidden = root2;
                try {
                  wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
              root2.child.return = root2;
              root2 = root2.child;
              continue;
            }
            if (root2 === finishedWork) break a;
            for (; null === root2.sibling; ) {
              if (null === root2.return || root2.return === finishedWork) break a;
              current === root2 && (current = null);
              root2 = root2.return;
            }
            current === root2 && (current = null);
            root2.sibling.return = root2.return;
            root2 = root2.sibling;
          }
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
        break;
      case 19:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
    }
  }
  function commitReconciliationEffects(finishedWork) {
    var flags = finishedWork.flags;
    if (flags & 2) {
      try {
        for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
          if (isHostParent(parentFiber)) {
            hostParentFiber = parentFiber;
            break;
          }
          parentFiber = parentFiber.return;
        }
        if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
        switch (hostParentFiber.tag) {
          case 27:
            var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent);
            break;
          case 5:
            var parent$144 = hostParentFiber.stateNode;
            hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
            var before$145 = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
            break;
          case 3:
          case 4:
            var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(
              finishedWork,
              before$147,
              parent$146
            );
            break;
          default:
            throw Error(formatProdErrorMessage(161));
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
      finishedWork.flags &= -3;
    }
    flags & 4096 && (finishedWork.flags &= -4097);
  }
  function recursivelyResetForms(parentFiber) {
    if (parentFiber.subtreeFlags & 1024)
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var fiber = parentFiber;
        recursivelyResetForms(fiber);
        5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
        parentFiber = parentFiber.sibling;
      }
  }
  function recursivelyTraverseLayoutEffects(root2, parentFiber) {
    if (parentFiber.subtreeFlags & 8772)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
  }
  function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedWork = parentFiber;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
            finishedWork,
            finishedWork.return,
            instance
          );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          releaseSingletonInstance(finishedWork.stateNode);
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          commitHookEffectListMount(4, finishedWork);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          current = finishedWork;
          finishedRoot = current.stateNode;
          if ("function" === typeof finishedRoot.componentDidMount)
            try {
              finishedRoot.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(current, current.return, error);
            }
          current = finishedWork;
          finishedRoot = current.updateQueue;
          if (null !== finishedRoot) {
            var instance = current.stateNode;
            try {
              var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
              if (null !== hiddenCallbacks)
                for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                  callCallback(hiddenCallbacks[finishedRoot], instance);
            } catch (error) {
              captureCommitPhaseError(current, current.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function commitOffscreenPassiveMountEffects(current, finishedWork) {
    var previousCache = null;
    null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
    current = null;
    null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
    current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
  }
  function commitCachePassiveMountEffect(current, finishedWork) {
    current = null;
    null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
    finishedWork = finishedWork.memoizedState.cache;
    finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
  }
  function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitPassiveMountOnFiber(
          root2,
          parentFiber,
          committedLanes,
          committedTransitions
        ), parentFiber = parentFiber.sibling;
  }
  function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && commitHookEffectListMount(9, finishedWork);
        break;
      case 1:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        break;
      case 3:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
        break;
      case 12:
        if (flags & 2048) {
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          finishedRoot = finishedWork.stateNode;
          try {
            var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
            "function" === typeof onPostCommit && onPostCommit(
              id,
              null === finishedWork.alternate ? "mount" : "update",
              finishedRoot.passiveEffectDuration,
              -0
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        } else
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
        break;
      case 13:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        break;
      case 23:
        break;
      case 22:
        _finishedWork$memoize2 = finishedWork.stateNode;
        id = finishedWork.alternate;
        null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          0 !== (finishedWork.subtreeFlags & 10256)
        ));
        flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
        break;
      case 24:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
    }
  }
  function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          commitHookEffectListMount(8, finishedWork);
          break;
        case 23:
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          ) : recursivelyTraverseAtomicPassiveEffects(
            finishedRoot,
            finishedWork
          ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          ));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 22:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
  }
  var suspenseyCommitFlag = 8192;
  function recursivelyAccumulateSuspenseyCommit(parentFiber) {
    if (parentFiber.subtreeFlags & suspenseyCommitFlag)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
  }
  function accumulateSuspenseyCommitOnFiber(fiber) {
    switch (fiber.tag) {
      case 26:
        recursivelyAccumulateSuspenseyCommit(fiber);
        fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
          currentHoistableRoot,
          fiber.memoizedState,
          fiber.memoizedProps
        );
        break;
      case 5:
        recursivelyAccumulateSuspenseyCommit(fiber);
        break;
      case 3:
      case 4:
        var previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
        recursivelyAccumulateSuspenseyCommit(fiber);
        currentHoistableRoot = previousHoistableRoot;
        break;
      case 22:
        null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
        break;
      default:
        recursivelyAccumulateSuspenseyCommit(fiber);
    }
  }
  function detachAlternateSiblings(parentFiber) {
    var previousFiber = parentFiber.alternate;
    if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
      previousFiber.child = null;
      do
        previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
      while (null !== parentFiber);
    }
  }
  function recursivelyTraversePassiveUnmountEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
            childToDelete,
            parentFiber
          );
        }
      detachAlternateSiblings(parentFiber);
    }
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
  }
  function commitPassiveUnmountOnFiber(finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
        break;
      case 3:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      case 12:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      default:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
    }
  }
  function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
            childToDelete,
            parentFiber
          );
        }
      detachAlternateSiblings(parentFiber);
    }
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      deletions = parentFiber;
      switch (deletions.tag) {
        case 0:
        case 11:
        case 15:
          commitHookEffectListUnmount(8, deletions, deletions.return);
          recursivelyTraverseDisconnectPassiveEffects(deletions);
          break;
        case 22:
          i = deletions.stateNode;
          i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(deletions);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
    for (; null !== nextEffect; ) {
      var fiber = nextEffect;
      switch (fiber.tag) {
        case 0:
        case 11:
        case 15:
          commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
          break;
        case 23:
        case 22:
          if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
            var cache = fiber.memoizedState.cachePool.pool;
            null != cache && cache.refCount++;
          }
          break;
        case 24:
          releaseCache(fiber.memoizedState.cache);
      }
      cache = fiber.child;
      if (null !== cache) cache.return = fiber, nextEffect = cache;
      else
        a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
          cache = nextEffect;
          var sibling = cache.sibling, returnFiber = cache.return;
          detachFiberAfterEffects(cache);
          if (cache === fiber) {
            nextEffect = null;
            break a;
          }
          if (null !== sibling) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            break a;
          }
          nextEffect = returnFiber;
        }
    }
  }
  var DefaultAsyncDispatcher = {
    getCacheForType: function(resourceType) {
      var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
      return cacheForType;
    }
  }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
  function requestUpdateLane() {
    if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
      return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
    if (null !== ReactSharedInternals.T) {
      var actionScopeLane = currentEntangledLane;
      return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
    }
    return resolveUpdatePriority();
  }
  function requestDeferredLane() {
    0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
    var suspenseHandler = suspenseHandlerStackCursor.current;
    null !== suspenseHandler && (suspenseHandler.flags |= 32);
    return workInProgressDeferredLane;
  }
  function scheduleUpdateOnFiber(root2, fiber, lane) {
    if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
      prepareFreshStack(root2, 0), markRootSuspended(
        root2,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    markRootUpdated$1(root2, lane);
    if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
      root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
        root2,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      )), ensureRootIsScheduled(root2);
  }
  function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
    var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
    do {
      if (0 === exitStatus) {
        workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
        break;
      } else {
        forceSync = root$jscomp$0.current.alternate;
        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
          exitStatus = renderRootSync(root$jscomp$0, lanes, false);
          renderWasConcurrent = false;
          continue;
        }
        if (2 === exitStatus) {
          renderWasConcurrent = lanes;
          if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
            var JSCompiler_inline_result = 0;
          else
            JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
          if (0 !== JSCompiler_inline_result) {
            lanes = JSCompiler_inline_result;
            a: {
              var root2 = root$jscomp$0;
              exitStatus = workInProgressRootConcurrentErrors;
              var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
              wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
              JSCompiler_inline_result = renderRootSync(
                root2,
                JSCompiler_inline_result,
                false
              );
              if (2 !== JSCompiler_inline_result) {
                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                  root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                  workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                  exitStatus = 4;
                  break a;
                }
                renderWasConcurrent = workInProgressRootRecoverableErrors;
                workInProgressRootRecoverableErrors = exitStatus;
                null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                  workInProgressRootRecoverableErrors,
                  renderWasConcurrent
                ));
              }
              exitStatus = JSCompiler_inline_result;
            }
            renderWasConcurrent = false;
            if (2 !== exitStatus) continue;
          }
        }
        if (1 === exitStatus) {
          prepareFreshStack(root$jscomp$0, 0);
          markRootSuspended(root$jscomp$0, lanes, 0, true);
          break;
        }
        a: {
          shouldTimeSlice = root$jscomp$0;
          renderWasConcurrent = exitStatus;
          switch (renderWasConcurrent) {
            case 0:
            case 1:
              throw Error(formatProdErrorMessage(345));
            case 4:
              if ((lanes & 4194048) !== lanes) break;
            case 6:
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              break a;
            case 2:
              workInProgressRootRecoverableErrors = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(formatProdErrorMessage(329));
          }
          if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
            markRootSuspended(
              shouldTimeSlice,
              lanes,
              workInProgressDeferredLane,
              !workInProgressRootDidSkipSuspendedSiblings
            );
            if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
            shouldTimeSlice.timeoutHandle = scheduleTimeout(
              commitRootWhenReady.bind(
                null,
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                2,
                -0,
                0
              ),
              exitStatus
            );
            break a;
          }
          commitRootWhenReady(
            shouldTimeSlice,
            forceSync,
            workInProgressRootRecoverableErrors,
            workInProgressTransitions,
            workInProgressRootDidIncludeRecursiveRenderUpdate,
            lanes,
            workInProgressDeferredLane,
            workInProgressRootInterleavedUpdatedLanes,
            workInProgressSuspendedRetryLanes,
            workInProgressRootDidSkipSuspendedSiblings,
            renderWasConcurrent,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (1);
    ensureRootIsScheduled(root$jscomp$0);
  }
  function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
    root2.timeoutHandle = -1;
    suspendedCommitReason = finishedWork.subtreeFlags;
    if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
      if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
        root2.cancelPendingCommit = suspendedCommitReason(
          commitRoot.bind(
            null,
            root2,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            1,
            completedRenderStartTime,
            completedRenderEndTime
          )
        );
        markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
        return;
      }
    }
    commitRoot(
      root2,
      finishedWork,
      lanes,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    );
  }
  function isRenderConsistentWithExternalStores(finishedWork) {
    for (var node = finishedWork; ; ) {
      var tag = node.tag;
      if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
        for (var i = 0; i < tag.length; i++) {
          var check = tag[i], getSnapshot = check.getSnapshot;
          check = check.value;
          try {
            if (!objectIs(getSnapshot(), check)) return false;
          } catch (error) {
            return false;
          }
        }
      tag = node.child;
      if (node.subtreeFlags & 16384 && null !== tag)
        tag.return = node, node = tag;
      else {
        if (node === finishedWork) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === finishedWork) return true;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return true;
  }
  function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
    suspendedLanes &= ~workInProgressRootPingedLanes;
    suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
    root2.suspendedLanes |= suspendedLanes;
    root2.pingedLanes &= ~suspendedLanes;
    didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
    didAttemptEntireTree = root2.expirationTimes;
    for (var lanes = suspendedLanes; 0 < lanes; ) {
      var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
      didAttemptEntireTree[index$4] = -1;
      lanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
  }
  function flushSyncWork$1() {
    return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
  }
  function resetWorkInProgressStack() {
    if (null !== workInProgress) {
      if (0 === workInProgressSuspendedReason)
        var interruptedWork = workInProgress.return;
      else
        interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
      for (; null !== interruptedWork; )
        unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
      workInProgress = null;
    }
  }
  function prepareFreshStack(root2, lanes) {
    var timeoutHandle = root2.timeoutHandle;
    -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
    timeoutHandle = root2.cancelPendingCommit;
    null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
    resetWorkInProgressStack();
    workInProgressRoot = root2;
    workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
    workInProgressRootRenderLanes = lanes;
    workInProgressSuspendedReason = 0;
    workInProgressThrownValue = null;
    workInProgressRootDidSkipSuspendedSiblings = false;
    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
    workInProgressRootDidAttachPingListener = false;
    workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
    workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
    workInProgressRootDidIncludeRecursiveRenderUpdate = false;
    0 !== (lanes & 8) && (lanes |= lanes & 32);
    var allEntangledLanes = root2.entangledLanes;
    if (0 !== allEntangledLanes)
      for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
        var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
        lanes |= root2[index$2];
        allEntangledLanes &= ~lane;
      }
    entangledRenderLanes = lanes;
    finishQueueingConcurrentUpdates();
    return timeoutHandle;
  }
  function handleThrow(root2, thrownValue) {
    currentlyRenderingFiber = null;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
    workInProgressThrownValue = thrownValue;
    null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
      root2,
      createCapturedValueAtFiber(thrownValue, root2.current)
    ));
  }
  function pushDispatcher() {
    var prevDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
  }
  function pushAsyncDispatcher() {
    var prevAsyncDispatcher = ReactSharedInternals.A;
    ReactSharedInternals.A = DefaultAsyncDispatcher;
    return prevAsyncDispatcher;
  }
  function renderDidSuspendDelayIfPossible() {
    workInProgressRootExitStatus = 4;
    workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
    0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      false
    );
  }
  function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
    var prevExecutionContext = executionContext;
    executionContext |= 2;
    var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
    if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
      workInProgressTransitions = null, prepareFreshStack(root2, lanes);
    lanes = false;
    var exitStatus = workInProgressRootExitStatus;
    a: do
      try {
        if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
          var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
          switch (workInProgressSuspendedReason) {
            case 8:
              resetWorkInProgressStack();
              exitStatus = 6;
              break a;
            case 3:
            case 2:
            case 9:
            case 6:
              null === suspenseHandlerStackCursor.current && (lanes = true);
              var reason = workInProgressSuspendedReason;
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                exitStatus = 0;
                break a;
              }
              break;
            default:
              reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
          }
        }
        workLoopSync();
        exitStatus = workInProgressRootExitStatus;
        break;
      } catch (thrownValue$167) {
        handleThrow(root2, thrownValue$167);
      }
    while (1);
    lanes && root2.shellSuspendCounter++;
    lastContextDependency = currentlyRenderingFiber$1 = null;
    executionContext = prevExecutionContext;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
    return exitStatus;
  }
  function workLoopSync() {
    for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
  }
  function renderRootConcurrent(root2, lanes) {
    var prevExecutionContext = executionContext;
    executionContext |= 2;
    var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
    workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
      root2,
      lanes
    );
    a: do
      try {
        if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
          lanes = workInProgress;
          var thrownValue = workInProgressThrownValue;
          b: switch (workInProgressSuspendedReason) {
            case 1:
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
              break;
            case 2:
            case 9:
              if (isThenableResolved(thrownValue)) {
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                replaySuspendedUnitOfWork(lanes);
                break;
              }
              lanes = function() {
                2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                ensureRootIsScheduled(root2);
              };
              thrownValue.then(lanes, lanes);
              break a;
            case 3:
              workInProgressSuspendedReason = 7;
              break a;
            case 4:
              workInProgressSuspendedReason = 5;
              break a;
            case 7:
              isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
              break;
            case 5:
              var resource = null;
              switch (workInProgress.tag) {
                case 26:
                  resource = workInProgress.memoizedState;
                case 5:
                case 27:
                  var hostFiber = workInProgress;
                  if (resource ? preloadResource(resource) : 1) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    var sibling = hostFiber.sibling;
                    if (null !== sibling) workInProgress = sibling;
                    else {
                      var returnFiber = hostFiber.return;
                      null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                    }
                    break b;
                  }
              }
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
              break;
            case 6:
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
              break;
            case 8:
              resetWorkInProgressStack();
              workInProgressRootExitStatus = 6;
              break a;
            default:
              throw Error(formatProdErrorMessage(462));
          }
        }
        workLoopConcurrentByScheduler();
        break;
      } catch (thrownValue$169) {
        handleThrow(root2, thrownValue$169);
      }
    while (1);
    lastContextDependency = currentlyRenderingFiber$1 = null;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    executionContext = prevExecutionContext;
    if (null !== workInProgress) return 0;
    workInProgressRoot = null;
    workInProgressRootRenderLanes = 0;
    finishQueueingConcurrentUpdates();
    return workInProgressRootExitStatus;
  }
  function workLoopConcurrentByScheduler() {
    for (; null !== workInProgress && !shouldYield(); )
      performUnitOfWork(workInProgress);
  }
  function performUnitOfWork(unitOfWork) {
    var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function replaySuspendedUnitOfWork(unitOfWork) {
    var next = unitOfWork;
    var current = next.alternate;
    switch (next.tag) {
      case 15:
      case 0:
        next = replayFunctionComponent(
          current,
          next,
          next.pendingProps,
          next.type,
          void 0,
          workInProgressRootRenderLanes
        );
        break;
      case 11:
        next = replayFunctionComponent(
          current,
          next,
          next.pendingProps,
          next.type.render,
          next.ref,
          workInProgressRootRenderLanes
        );
        break;
      case 5:
        resetHooksOnUnwind(next);
      default:
        unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
    }
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
    lastContextDependency = currentlyRenderingFiber$1 = null;
    resetHooksOnUnwind(unitOfWork);
    thenableState = null;
    thenableIndexCounter = 0;
    var returnFiber = unitOfWork.return;
    try {
      if (throwException(
        root2,
        returnFiber,
        unitOfWork,
        thrownValue,
        workInProgressRootRenderLanes
      )) {
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        );
        workInProgress = null;
        return;
      }
    } catch (error) {
      if (null !== returnFiber) throw workInProgress = returnFiber, error;
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root2,
        createCapturedValueAtFiber(thrownValue, root2.current)
      );
      workInProgress = null;
      return;
    }
    if (unitOfWork.flags & 32768) {
      if (isHydrating || 1 === suspendedReason) root2 = true;
      else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
        root2 = false;
      else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
        suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
      unwindUnitOfWork(unitOfWork, root2);
    } else completeUnitOfWork(unitOfWork);
  }
  function completeUnitOfWork(unitOfWork) {
    var completedWork = unitOfWork;
    do {
      if (0 !== (completedWork.flags & 32768)) {
        unwindUnitOfWork(
          completedWork,
          workInProgressRootDidSkipSuspendedSiblings
        );
        return;
      }
      unitOfWork = completedWork.return;
      var next = completeWork(
        completedWork.alternate,
        completedWork,
        entangledRenderLanes
      );
      if (null !== next) {
        workInProgress = next;
        return;
      }
      completedWork = completedWork.sibling;
      if (null !== completedWork) {
        workInProgress = completedWork;
        return;
      }
      workInProgress = completedWork = unitOfWork;
    } while (null !== completedWork);
    0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
  }
  function unwindUnitOfWork(unitOfWork, skipSiblings) {
    do {
      var next = unwindWork(unitOfWork.alternate, unitOfWork);
      if (null !== next) {
        next.flags &= 32767;
        workInProgress = next;
        return;
      }
      next = unitOfWork.return;
      null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
      if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
        workInProgress = unitOfWork;
        return;
      }
      workInProgress = unitOfWork = next;
    } while (null !== unitOfWork);
    workInProgressRootExitStatus = 6;
    workInProgress = null;
  }
  function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
    root2.cancelPendingCommit = null;
    do
      flushPendingEffects();
    while (0 !== pendingEffectsStatus);
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
    if (null !== finishedWork) {
      if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
      didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
      didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
      markRootFinished(
        root2,
        lanes,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
      root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
      pendingFinishedWork = finishedWork;
      pendingEffectsRoot = root2;
      pendingEffectsLanes = lanes;
      pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
      pendingPassiveTransitions = transitions;
      pendingRecoverableErrors = recoverableErrors;
      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
        flushPassiveEffects();
        return null;
      })) : (root2.callbackNode = null, root2.callbackPriority = 0);
      recoverableErrors = 0 !== (finishedWork.flags & 13878);
      if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
        recoverableErrors = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        transitions = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        spawnedLane = executionContext;
        executionContext |= 4;
        try {
          commitBeforeMutationEffects(root2, finishedWork, lanes);
        } finally {
          executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
        }
      }
      pendingEffectsStatus = 1;
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
    }
  }
  function flushMutationEffects() {
    if (1 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
      if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
        rootMutationHasEffect = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        try {
          commitMutationEffectsOnFiber(finishedWork, root2);
          var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
            priorFocusedElem.ownerDocument.documentElement,
            priorFocusedElem
          )) {
            if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
              var start = priorSelectionRange.start, end = priorSelectionRange.end;
              void 0 === end && (end = start);
              if ("selectionStart" in priorFocusedElem)
                priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                  end,
                  priorFocusedElem.value.length
                );
              else {
                var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                if (win.getSelection) {
                  var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                  !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                  var startMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    start$jscomp$0
                  ), endMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    end$jscomp$0
                  );
                  if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                    var range = doc.createRange();
                    range.setStart(startMarker.node, startMarker.offset);
                    selection.removeAllRanges();
                    start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                  }
                }
              }
            }
            doc = [];
            for (selection = priorFocusedElem; selection = selection.parentNode; )
              1 === selection.nodeType && doc.push({
                element: selection,
                left: selection.scrollLeft,
                top: selection.scrollTop
              });
            "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
            for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
              var info = doc[priorFocusedElem];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
          _enabled = !!eventsEnabled;
          selectionInformation = eventsEnabled = null;
        } finally {
          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
        }
      }
      root2.current = finishedWork;
      pendingEffectsStatus = 2;
    }
  }
  function flushLayoutEffects() {
    if (2 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
      if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
        rootHasLayoutEffect = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        try {
          commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
        } finally {
          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
        }
      }
      pendingEffectsStatus = 3;
    }
  }
  function flushSpawnedWork() {
    if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      requestPaint();
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
      var remainingLanes = root2.pendingLanes;
      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
      lanesToEventPriority(lanes);
      finishedWork = finishedWork.stateNode;
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
        try {
          injectedHook.onCommitFiberRoot(
            rendererID,
            finishedWork,
            void 0,
            128 === (finishedWork.current.flags & 128)
          );
        } catch (err) {
        }
      if (null !== recoverableErrors) {
        finishedWork = ReactSharedInternals.T;
        remainingLanes = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        ReactSharedInternals.T = null;
        try {
          for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
            var recoverableError = recoverableErrors[i];
            onRecoverableError(recoverableError.value, {
              componentStack: recoverableError.stack
            });
          }
        } finally {
          ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
        }
      }
      0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
      ensureRootIsScheduled(root2);
      remainingLanes = root2.pendingLanes;
      0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
      flushSyncWorkAcrossRoots_impl(0);
    }
  }
  function releaseRootPooledCache(root2, remainingLanes) {
    0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
  }
  function flushPendingEffects(wasDelayedCommit) {
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
    return flushPassiveEffects();
  }
  function flushPassiveEffects() {
    if (5 !== pendingEffectsStatus) return false;
    var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
    pendingEffectsRemainingLanes = 0;
    var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
      ReactSharedInternals.T = null;
      renderPriority = pendingPassiveTransitions;
      pendingPassiveTransitions = null;
      var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
      pendingEffectsStatus = 0;
      pendingFinishedWork = pendingEffectsRoot = null;
      pendingEffectsLanes = 0;
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      commitPassiveUnmountOnFiber(root$jscomp$0.current);
      commitPassiveMountOnFiber(
        root$jscomp$0,
        root$jscomp$0.current,
        lanes,
        renderPriority
      );
      executionContext = prevExecutionContext;
      flushSyncWorkAcrossRoots_impl(0, false);
      if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
        try {
          injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
        } catch (err) {
        }
      return true;
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
    }
  }
  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
    sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
    sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
    rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
    null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
  }
  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
    if (3 === sourceFiber.tag)
      captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    else
      for (; null !== nearestMountedAncestor; ) {
        if (3 === nearestMountedAncestor.tag) {
          captureCommitPhaseErrorOnRoot(
            nearestMountedAncestor,
            sourceFiber,
            error
          );
          break;
        } else if (1 === nearestMountedAncestor.tag) {
          var instance = nearestMountedAncestor.stateNode;
          if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
            sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
            error = createClassErrorUpdate(2);
            instance = enqueueUpdate(nearestMountedAncestor, error, 2);
            null !== instance && (initializeClassErrorUpdate(
              error,
              instance,
              nearestMountedAncestor,
              sourceFiber
            ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
            break;
          }
        }
        nearestMountedAncestor = nearestMountedAncestor.return;
      }
  }
  function attachPingListener(root2, wakeable, lanes) {
    var pingCache = root2.pingCache;
    if (null === pingCache) {
      pingCache = root2.pingCache = new PossiblyWeakMap();
      var threadIDs = /* @__PURE__ */ new Set();
      pingCache.set(wakeable, threadIDs);
    } else
      threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
    threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
  }
  function pingSuspendedRoot(root2, wakeable, pingedLanes) {
    var pingCache = root2.pingCache;
    null !== pingCache && pingCache.delete(wakeable);
    root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
    root2.warmLanes &= ~pingedLanes;
    workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
    ensureRootIsScheduled(root2);
  }
  function retryTimedOutBoundary(boundaryFiber, retryLane) {
    0 === retryLane && (retryLane = claimNextRetryLane());
    boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
    null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
  }
  function retryDehydratedSuspenseBoundary(boundaryFiber) {
    var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
    null !== suspenseState && (retryLane = suspenseState.retryLane);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function resolveRetryWakeable(boundaryFiber, wakeable) {
    var retryLane = 0;
    switch (boundaryFiber.tag) {
      case 13:
        var retryCache = boundaryFiber.stateNode;
        var suspenseState = boundaryFiber.memoizedState;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        break;
      case 19:
        retryCache = boundaryFiber.stateNode;
        break;
      case 22:
        retryCache = boundaryFiber.stateNode._retryCache;
        break;
      default:
        throw Error(formatProdErrorMessage(314));
    }
    null !== retryCache && retryCache.delete(wakeable);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function scheduleCallback$1(priorityLevel, callback) {
    return scheduleCallback$3(priorityLevel, callback);
  }
  var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
  function ensureRootIsScheduled(root2) {
    root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
    mightHavePendingSyncWork = true;
    didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
  }
  function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
    if (!isFlushingWork && mightHavePendingSyncWork) {
      isFlushingWork = true;
      do {
        var didPerformSomeWork = false;
        for (var root$174 = firstScheduledRoot; null !== root$174; ) {
          if (0 !== syncTransitionLanes) {
            var pendingLanes = root$174.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
            else {
              var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
              JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
              JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
            }
            0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
          } else
            JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
              root$174,
              root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
              null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
            ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
          root$174 = root$174.next;
        }
      } while (didPerformSomeWork);
      isFlushingWork = false;
    }
  }
  function processRootScheduleInImmediateTask() {
    processRootScheduleInMicrotask();
  }
  function processRootScheduleInMicrotask() {
    mightHavePendingSyncWork = didScheduleMicrotask = false;
    var syncTransitionLanes = 0;
    0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
    for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
      var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
      if (0 === nextLanes)
        root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
      else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
        mightHavePendingSyncWork = true;
      root2 = next;
    }
    flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
  }
  function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
    for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
      var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
      if (-1 === expirationTime) {
        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
          expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
      } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
      lanes &= ~lane;
    }
    currentTime = workInProgressRoot;
    suspendedLanes = workInProgressRootRenderLanes;
    suspendedLanes = getNextLanes(
      root2,
      root2 === currentTime ? suspendedLanes : 0,
      null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
    );
    pingedLanes = root2.callbackNode;
    if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
      return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
    if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
      currentTime = suspendedLanes & -suspendedLanes;
      if (currentTime === root2.callbackPriority) return currentTime;
      null !== pingedLanes && cancelCallback$1(pingedLanes);
      switch (lanesToEventPriority(suspendedLanes)) {
        case 2:
        case 8:
          suspendedLanes = UserBlockingPriority;
          break;
        case 32:
          suspendedLanes = NormalPriority$1;
          break;
        case 268435456:
          suspendedLanes = IdlePriority;
          break;
        default:
          suspendedLanes = NormalPriority$1;
      }
      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
      suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
      root2.callbackPriority = currentTime;
      root2.callbackNode = suspendedLanes;
      return currentTime;
    }
    null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
    root2.callbackPriority = 2;
    root2.callbackNode = null;
    return 2;
  }
  function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
    if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
      return root2.callbackNode = null, root2.callbackPriority = 0, null;
    var originalCallbackNode = root2.callbackNode;
    if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
      return null;
    var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
    workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
      root2,
      root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
      null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
    );
    if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
    performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
    scheduleTaskForRootDuringMicrotask(root2, now());
    return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
  }
  function performSyncWorkOnRoot(root2, lanes) {
    if (flushPendingEffects()) return null;
    performWorkOnRoot(root2, lanes, true);
  }
  function scheduleImmediateRootScheduleTask() {
    scheduleMicrotask(function() {
      0 !== (executionContext & 6) ? scheduleCallback$3(
        ImmediatePriority,
        processRootScheduleInImmediateTask
      ) : processRootScheduleInMicrotask();
    });
  }
  function requestTransitionLane() {
    0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
    return currentEventTransitionLane;
  }
  function coerceFormActionProp(actionProp) {
    return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
  }
  function createFormDataWithSubmitter(form, submitter) {
    var temp = submitter.ownerDocument.createElement("input");
    temp.name = submitter.name;
    temp.value = submitter.value;
    form.id && temp.setAttribute("form", form.id);
    submitter.parentNode.insertBefore(temp, submitter);
    form = new FormData(form);
    temp.parentNode.removeChild(temp);
    return form;
  }
  function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
    if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
      var action = coerceFormActionProp(
        (nativeEventTarget[internalPropsKey] || null).action
      ), submitter = nativeEvent.submitter;
      submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
      var event = new SyntheticEvent(
        "action",
        "action",
        null,
        nativeEvent,
        nativeEventTarget
      );
      dispatchQueue.push({
        event,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (nativeEvent.defaultPrevented) {
                if (0 !== currentEventTransitionLane) {
                  var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                  startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    null,
                    formData
                  );
                }
              } else
                "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                  maybeTargetInst,
                  {
                    pending: true,
                    data: formData,
                    method: nativeEventTarget.method,
                    action
                  },
                  action,
                  formData
                ));
            },
            currentTarget: nativeEventTarget
          }
        ]
      });
    }
  }
  for (var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
    var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
    registerSimpleEvent(
      domEventName$jscomp$inline_1530,
      "on" + capitalizedEvent$jscomp$inline_1531
    );
  }
  registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
  registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
  registerSimpleEvent(ANIMATION_START, "onAnimationStart");
  registerSimpleEvent("dblclick", "onDoubleClick");
  registerSimpleEvent("focusin", "onFocus");
  registerSimpleEvent("focusout", "onBlur");
  registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
  registerSimpleEvent(TRANSITION_START, "onTransitionStart");
  registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
  registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
  registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
  registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
  registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
  registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
  registerTwoPhaseEvent(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  );
  registerTwoPhaseEvent(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  );
  registerTwoPhaseEvent("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  registerTwoPhaseEvent(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  );
  registerTwoPhaseEvent(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  );
  registerTwoPhaseEvent(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), nonDelegatedEvents = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
  );
  function processDispatchQueue(dispatchQueue, eventSystemFlags) {
    eventSystemFlags = 0 !== (eventSystemFlags & 4);
    for (var i = 0; i < dispatchQueue.length; i++) {
      var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
      _dispatchQueue$i = _dispatchQueue$i.listeners;
      a: {
        var previousInstance = void 0;
        if (eventSystemFlags)
          for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
            var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped())
              break a;
            previousInstance = _dispatchListeners$i;
            event.currentTarget = currentTarget;
            try {
              previousInstance(event);
            } catch (error) {
              reportGlobalError(error);
            }
            event.currentTarget = null;
            previousInstance = instance;
          }
        else
          for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
            _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
            instance = _dispatchListeners$i.instance;
            currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped())
              break a;
            previousInstance = _dispatchListeners$i;
            event.currentTarget = currentTarget;
            try {
              previousInstance(event);
            } catch (error) {
              reportGlobalError(error);
            }
            event.currentTarget = null;
            previousInstance = instance;
          }
      }
    }
  }
  function listenToNonDelegatedEvent(domEventName, targetElement) {
    var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
    void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
    var listenerSetKey = domEventName + "__bubble";
    JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
  }
  function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
    var eventSystemFlags = 0;
    isCapturePhaseListener && (eventSystemFlags |= 4);
    addTrappedEventListener(
      target,
      domEventName,
      eventSystemFlags,
      isCapturePhaseListener
    );
  }
  var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
  function listenToAllSupportedEvents(rootContainerElement) {
    if (!rootContainerElement[listeningMarker]) {
      rootContainerElement[listeningMarker] = true;
      allNativeEvents.forEach(function(domEventName) {
        "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
      });
      var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
    }
  }
  function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
    switch (getEventPriority(domEventName)) {
      case 2:
        var listenerWrapper = dispatchDiscreteEvent;
        break;
      case 8:
        listenerWrapper = dispatchContinuousEvent;
        break;
      default:
        listenerWrapper = dispatchEvent;
    }
    eventSystemFlags = listenerWrapper.bind(
      null,
      domEventName,
      eventSystemFlags,
      targetContainer
    );
    listenerWrapper = void 0;
    !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
    isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      capture: true,
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
  }
  function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
    var ancestorInst = targetInst$jscomp$0;
    if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
      a: for (; ; ) {
        if (null === targetInst$jscomp$0) return;
        var nodeTag = targetInst$jscomp$0.tag;
        if (3 === nodeTag || 4 === nodeTag) {
          var container = targetInst$jscomp$0.stateNode.containerInfo;
          if (container === targetContainer) break;
          if (4 === nodeTag)
            for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
              var grandTag = nodeTag.tag;
              if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                return;
              nodeTag = nodeTag.return;
            }
          for (; null !== container; ) {
            nodeTag = getClosestInstanceFromNode(container);
            if (null === nodeTag) return;
            grandTag = nodeTag.tag;
            if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
              targetInst$jscomp$0 = ancestorInst = nodeTag;
              continue a;
            }
            container = container.parentNode;
          }
        }
        targetInst$jscomp$0 = targetInst$jscomp$0.return;
      }
    batchedUpdates$1(function() {
      var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
      a: {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (void 0 !== reactName) {
          var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (0 === getEventCharCode(nativeEvent)) break a;
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (2 === nativeEvent.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
            case "scrollend":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
            case "toggle":
            case "beforetoggle":
              SyntheticEventCtor = SyntheticToggleEvent;
          }
          var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
          inCapturePhase = [];
          for (var instance = targetInst, lastHostComponent; null !== instance; ) {
            var _instance = instance;
            lastHostComponent = _instance.stateNode;
            _instance = _instance.tag;
            5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
              createDispatchListener(instance, _instance, lastHostComponent)
            ));
            if (accumulateTargetOnly) break;
            instance = instance.return;
          }
          0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
            reactName,
            reactEventType,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
        }
      }
      if (0 === (eventSystemFlags & 7)) {
        a: {
          reactName = "mouseover" === domEventName || "pointerover" === domEventName;
          SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
          if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
            break a;
          if (SyntheticEventCtor || reactName) {
            reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
            if (SyntheticEventCtor) {
              if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                reactEventType = null;
            } else SyntheticEventCtor = null, reactEventType = targetInst;
            if (SyntheticEventCtor !== reactEventType) {
              inCapturePhase = SyntheticMouseEvent;
              _instance = "onMouseLeave";
              reactEventName = "onMouseEnter";
              instance = "mouse";
              if ("pointerout" === domEventName || "pointerover" === domEventName)
                inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
              accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
              lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
              reactName = new inCapturePhase(
                _instance,
                instance + "leave",
                SyntheticEventCtor,
                nativeEvent,
                nativeEventTarget
              );
              reactName.target = accumulateTargetOnly;
              reactName.relatedTarget = lastHostComponent;
              _instance = null;
              getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                reactEventName,
                instance + "enter",
                reactEventType,
                nativeEvent,
                nativeEventTarget
              ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
              accumulateTargetOnly = _instance;
              if (SyntheticEventCtor && reactEventType)
                b: {
                  inCapturePhase = SyntheticEventCtor;
                  reactEventName = reactEventType;
                  instance = 0;
                  for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                    instance++;
                  lastHostComponent = 0;
                  for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                    lastHostComponent++;
                  for (; 0 < instance - lastHostComponent; )
                    inCapturePhase = getParent(inCapturePhase), instance--;
                  for (; 0 < lastHostComponent - instance; )
                    reactEventName = getParent(reactEventName), lastHostComponent--;
                  for (; instance--; ) {
                    if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                      break b;
                    inCapturePhase = getParent(inCapturePhase);
                    reactEventName = getParent(reactEventName);
                  }
                  inCapturePhase = null;
                }
              else inCapturePhase = null;
              null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                false
              );
              null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                accumulateTargetOnly,
                reactEventType,
                inCapturePhase,
                true
              );
            }
          }
        }
        a: {
          reactName = targetInst ? getNodeFromInstance(targetInst) : window;
          SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
          if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
            var getTargetInstFunc = getTargetInstForChangeEvent;
          else if (isTextInputElement(reactName))
            if (isInputEventSupported)
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              var handleEventFunc = handleEventsForInputEventPolyfill;
            }
          else
            SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
          if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
            createAndAccumulateChangeEvent(
              dispatchQueue,
              getTargetInstFunc,
              nativeEvent,
              nativeEventTarget
            );
            break a;
          }
          handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
          "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
        }
        handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
              activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
            break;
          case "focusout":
            lastSelection = activeElementInst = activeElement = null;
            break;
          case "mousedown":
            mouseDown = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = false;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) break;
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
        var fallbackData;
        if (canUseCompositionEvent)
          b: {
            switch (domEventName) {
              case "compositionstart":
                var eventType = "onCompositionStart";
                break b;
              case "compositionend":
                eventType = "onCompositionEnd";
                break b;
              case "compositionupdate":
                eventType = "onCompositionUpdate";
                break b;
            }
            eventType = void 0;
          }
        else
          isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
        eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
          eventType,
          domEventName,
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
        if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
          eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
            "onBeforeInput",
            "beforeinput",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({
            event: handleEventFunc,
            listeners: eventType
          }), handleEventFunc.data = fallbackData);
        extractEvents$1(
          dispatchQueue,
          domEventName,
          targetInst,
          nativeEvent,
          nativeEventTarget
        );
      }
      processDispatchQueue(dispatchQueue, eventSystemFlags);
    });
  }
  function createDispatchListener(instance, listener, currentTarget) {
    return {
      instance,
      listener,
      currentTarget
    };
  }
  function accumulateTwoPhaseListeners(targetFiber, reactName) {
    for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
      var _instance2 = targetFiber, stateNode = _instance2.stateNode;
      _instance2 = _instance2.tag;
      5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
        createDispatchListener(targetFiber, _instance2, stateNode)
      ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
        createDispatchListener(targetFiber, _instance2, stateNode)
      ));
      if (3 === targetFiber.tag) return listeners;
      targetFiber = targetFiber.return;
    }
    return [];
  }
  function getParent(inst) {
    if (null === inst) return null;
    do
      inst = inst.return;
    while (inst && 5 !== inst.tag && 27 !== inst.tag);
    return inst ? inst : null;
  }
  function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
    for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
      var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
      _instance3 = _instance3.tag;
      if (null !== alternate && alternate === common) break;
      5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
        createDispatchListener(target, stateNode, alternate)
      )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
        createDispatchListener(target, stateNode, alternate)
      )));
      target = target.return;
    }
    0 !== listeners.length && dispatchQueue.push({ event, listeners });
  }
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
  function normalizeMarkupForTextOrAttribute(markup) {
    return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
  }
  function checkForUnmatchedText(serverText, clientText) {
    clientText = normalizeMarkupForTextOrAttribute(clientText);
    return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
  }
  function noop$1() {
  }
  function setProp(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "children":
        "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
        break;
      case "className":
        setValueForKnownAttribute(domElement, "class", value);
        break;
      case "tabIndex":
        setValueForKnownAttribute(domElement, "tabindex", value);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        setValueForKnownAttribute(domElement, key, value);
        break;
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "data":
        if ("object" !== tag) {
          setValueForKnownAttribute(domElement, "data", value);
          break;
        }
      case "src":
      case "href":
        if ("" === value && ("a" !== tag || "href" !== key)) {
          domElement.removeAttribute(key);
          break;
        }
        if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "action":
      case "formAction":
        if ("function" === typeof value) {
          domElement.setAttribute(
            key,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
            domElement,
            tag,
            "formEncType",
            props.formEncType,
            props,
            null
          ), setProp(
            domElement,
            tag,
            "formMethod",
            props.formMethod,
            props,
            null
          ), setProp(
            domElement,
            tag,
            "formTarget",
            props.formTarget,
            props,
            null
          )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
        if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "onClick":
        null != value && (domElement.onclick = noop$1);
        break;
      case "onScroll":
        null != value && listenToNonDelegatedEvent("scroll", domElement);
        break;
      case "onScrollEnd":
        null != value && listenToNonDelegatedEvent("scrollend", domElement);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value))
            throw Error(formatProdErrorMessage(61));
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error(formatProdErrorMessage(60));
            domElement.innerHTML = key;
          }
        }
        break;
      case "multiple":
        domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "muted":
        domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
          domElement.removeAttribute("xlink:href");
          break;
        }
        key = sanitizeURL("" + value);
        domElement.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          key
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
        break;
      case "capture":
      case "download":
        true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
        break;
      case "rowSpan":
      case "start":
        null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
        break;
      case "popover":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        setValueForAttribute(domElement, "popover", value);
        break;
      case "xlinkActuate":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          value
        );
        break;
      case "xlinkArcrole":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          value
        );
        break;
      case "xlinkRole":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          value
        );
        break;
      case "xlinkShow":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          value
        );
        break;
      case "xlinkTitle":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          value
        );
        break;
      case "xlinkType":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          value
        );
        break;
      case "xmlBase":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          value
        );
        break;
      case "xmlLang":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          value
        );
        break;
      case "xmlSpace":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          value
        );
        break;
      case "is":
        setValueForAttribute(domElement, "is", value);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
          key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
    }
  }
  function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value))
            throw Error(formatProdErrorMessage(61));
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error(formatProdErrorMessage(60));
            domElement.innerHTML = key;
          }
        }
        break;
      case "children":
        "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
        break;
      case "onScroll":
        null != value && listenToNonDelegatedEvent("scroll", domElement);
        break;
      case "onScrollEnd":
        null != value && listenToNonDelegatedEvent("scrollend", domElement);
        break;
      case "onClick":
        null != value && (domElement.onclick = noop$1);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!registrationNameDependencies.hasOwnProperty(key))
          a: {
            if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
              "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
              domElement.addEventListener(tag, value, props);
              break a;
            }
            key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
          }
    }
  }
  function setInitialProperties(domElement, tag, props) {
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        var hasSrc = false, hasSrcSet = false, propKey;
        for (propKey in props)
          if (props.hasOwnProperty(propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "src":
                  hasSrc = true;
                  break;
                case "srcSet":
                  hasSrcSet = true;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, propKey, propValue, props, null);
              }
          }
        hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
        hasSrc && setProp(domElement, tag, "src", props.src, props, null);
        return;
      case "input":
        listenToNonDelegatedEvent("invalid", domElement);
        var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
        for (hasSrc in props)
          if (props.hasOwnProperty(hasSrc)) {
            var propValue$188 = props[hasSrc];
            if (null != propValue$188)
              switch (hasSrc) {
                case "name":
                  hasSrcSet = propValue$188;
                  break;
                case "type":
                  propValue = propValue$188;
                  break;
                case "checked":
                  checked = propValue$188;
                  break;
                case "defaultChecked":
                  defaultChecked = propValue$188;
                  break;
                case "value":
                  propKey = propValue$188;
                  break;
                case "defaultValue":
                  defaultValue = propValue$188;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propValue$188)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(domElement, tag, hasSrc, propValue$188, props, null);
              }
          }
        initInput(
          domElement,
          propKey,
          defaultValue,
          checked,
          defaultChecked,
          propValue,
          hasSrcSet,
          false
        );
        track(domElement);
        return;
      case "select":
        listenToNonDelegatedEvent("invalid", domElement);
        hasSrc = propValue = propKey = null;
        for (hasSrcSet in props)
          if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
            switch (hasSrcSet) {
              case "value":
                propKey = defaultValue;
                break;
              case "defaultValue":
                propValue = defaultValue;
                break;
              case "multiple":
                hasSrc = defaultValue;
              default:
                setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
            }
        tag = propKey;
        props = propValue;
        domElement.multiple = !!hasSrc;
        null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
        return;
      case "textarea":
        listenToNonDelegatedEvent("invalid", domElement);
        propKey = hasSrcSet = hasSrc = null;
        for (propValue in props)
          if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
            switch (propValue) {
              case "value":
                hasSrc = defaultValue;
                break;
              case "defaultValue":
                hasSrcSet = defaultValue;
                break;
              case "children":
                propKey = defaultValue;
                break;
              case "dangerouslySetInnerHTML":
                if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                break;
              default:
                setProp(domElement, tag, propValue, defaultValue, props, null);
            }
        initTextarea(domElement, hasSrc, hasSrcSet, propKey);
        track(domElement);
        return;
      case "option":
        for (checked in props)
          if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
            switch (checked) {
              case "selected":
                domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                break;
              default:
                setProp(domElement, tag, checked, hasSrc, props, null);
            }
        return;
      case "dialog":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        listenToNonDelegatedEvent("cancel", domElement);
        listenToNonDelegatedEvent("close", domElement);
        break;
      case "iframe":
      case "object":
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "video":
      case "audio":
        for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
          listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
        break;
      case "image":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", domElement);
        break;
      case "embed":
      case "source":
      case "link":
        listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (defaultChecked in props)
          if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
            switch (defaultChecked) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, defaultChecked, hasSrc, props, null);
            }
        return;
      default:
        if (isCustomElement(tag)) {
          for (propValue$188 in props)
            props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
              domElement,
              tag,
              propValue$188,
              hasSrc,
              props,
              void 0
            ));
          return;
        }
    }
    for (defaultValue in props)
      props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
  }
  function updateProperties(domElement, tag, lastProps, nextProps) {
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
        for (propKey in lastProps) {
          var lastProp = lastProps[propKey];
          if (lastProps.hasOwnProperty(propKey) && null != lastProp)
            switch (propKey) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                lastDefaultValue = lastProp;
              default:
                nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
            }
        }
        for (var propKey$205 in nextProps) {
          var propKey = nextProps[propKey$205];
          lastProp = lastProps[propKey$205];
          if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
            switch (propKey$205) {
              case "type":
                type = propKey;
                break;
              case "name":
                name = propKey;
                break;
              case "checked":
                checked = propKey;
                break;
              case "defaultChecked":
                defaultChecked = propKey;
                break;
              case "value":
                value = propKey;
                break;
              case "defaultValue":
                defaultValue = propKey;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propKey)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                propKey !== lastProp && setProp(
                  domElement,
                  tag,
                  propKey$205,
                  propKey,
                  nextProps,
                  lastProp
                );
            }
        }
        updateInput(
          domElement,
          value,
          defaultValue,
          lastDefaultValue,
          checked,
          defaultChecked,
          type,
          name
        );
        return;
      case "select":
        propKey = value = defaultValue = propKey$205 = null;
        for (type in lastProps)
          if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
            switch (type) {
              case "value":
                break;
              case "multiple":
                propKey = lastDefaultValue;
              default:
                nextProps.hasOwnProperty(type) || setProp(
                  domElement,
                  tag,
                  type,
                  null,
                  nextProps,
                  lastDefaultValue
                );
            }
        for (name in nextProps)
          if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
            switch (name) {
              case "value":
                propKey$205 = type;
                break;
              case "defaultValue":
                defaultValue = type;
                break;
              case "multiple":
                value = type;
              default:
                type !== lastDefaultValue && setProp(
                  domElement,
                  tag,
                  name,
                  type,
                  nextProps,
                  lastDefaultValue
                );
            }
        tag = defaultValue;
        lastProps = value;
        nextProps = propKey;
        null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
        return;
      case "textarea":
        propKey = propKey$205 = null;
        for (defaultValue in lastProps)
          if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
            switch (defaultValue) {
              case "value":
                break;
              case "children":
                break;
              default:
                setProp(domElement, tag, defaultValue, null, nextProps, name);
            }
        for (value in nextProps)
          if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
            switch (value) {
              case "value":
                propKey$205 = name;
                break;
              case "defaultValue":
                propKey = name;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (null != name) throw Error(formatProdErrorMessage(91));
                break;
              default:
                name !== type && setProp(domElement, tag, value, name, nextProps, type);
            }
        updateTextarea(domElement, propKey$205, propKey);
        return;
      case "option":
        for (var propKey$221 in lastProps)
          if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
            switch (propKey$221) {
              case "selected":
                domElement.selected = false;
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  propKey$221,
                  null,
                  nextProps,
                  propKey$205
                );
            }
        for (lastDefaultValue in nextProps)
          if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
            switch (lastDefaultValue) {
              case "selected":
                domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  lastDefaultValue,
                  propKey$205,
                  nextProps,
                  propKey
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var propKey$226 in lastProps)
          propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
        for (checked in nextProps)
          if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
            switch (checked) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propKey$205)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  checked,
                  propKey$205,
                  nextProps,
                  propKey
                );
            }
        return;
      default:
        if (isCustomElement(tag)) {
          for (var propKey$231 in lastProps)
            propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
              domElement,
              tag,
              propKey$231,
              void 0,
              nextProps,
              propKey$205
            );
          for (defaultChecked in nextProps)
            propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
              domElement,
              tag,
              defaultChecked,
              propKey$205,
              nextProps,
              propKey
            );
          return;
        }
    }
    for (var propKey$236 in lastProps)
      propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
    for (lastProp in nextProps)
      propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
  }
  var eventsEnabled = null, selectionInformation = null;
  function getOwnerDocumentFromRootContainer(rootContainerElement) {
    return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
  }
  function getOwnHostContext(namespaceURI) {
    switch (namespaceURI) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function getChildHostContextProd(parentNamespace, type) {
    if (0 === parentNamespace)
      switch (type) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
  }
  function shouldSetTextContent(type, props) {
    return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
  }
  var currentPopstateTransitionEvent = null;
  function shouldAttemptEagerTransition() {
    var event = window.event;
    if (event && "popstate" === event.type) {
      if (event === currentPopstateTransitionEvent) return false;
      currentPopstateTransitionEvent = event;
      return true;
    }
    currentPopstateTransitionEvent = null;
    return false;
  }
  var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
    return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
  } : scheduleTimeout;
  function handleErrorInNextTick(error) {
    setTimeout(function() {
      throw error;
    });
  }
  function isSingletonScope(type) {
    return "head" === type;
  }
  function clearSuspenseBoundary(parentInstance, suspenseInstance) {
    var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
    do {
      var nextNode = node.nextSibling;
      parentInstance.removeChild(node);
      if (nextNode && 8 === nextNode.nodeType)
        if (node = nextNode.data, "/$" === node) {
          if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
            node = possiblePreambleContribution;
            var ownerDocument = parentInstance.ownerDocument;
            node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
            node & 2 && releaseSingletonInstance(ownerDocument.body);
            if (node & 4)
              for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                ownerDocument = nextNode$jscomp$0;
              }
          }
          if (0 === depth) {
            parentInstance.removeChild(nextNode);
            retryIfBlockedOn(suspenseInstance);
            return;
          }
          depth--;
        } else
          "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
      else possiblePreambleContribution = 0;
      node = nextNode;
    } while (node);
    retryIfBlockedOn(suspenseInstance);
  }
  function clearContainerSparingly(container) {
    var nextNode = container.firstChild;
    nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
    for (; nextNode; ) {
      var node = nextNode;
      nextNode = nextNode.nextSibling;
      switch (node.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          clearContainerSparingly(node);
          detachDeletedInstance(node);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if ("stylesheet" === node.rel.toLowerCase()) continue;
      }
      container.removeChild(node);
    }
  }
  function canHydrateInstance(instance, type, props, inRootOrSingleton) {
    for (; 1 === instance.nodeType; ) {
      var anyProps = props;
      if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
        if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
          break;
      } else if (!inRootOrSingleton)
        if ("input" === type && "hidden" === instance.type) {
          var name = null == anyProps.name ? null : "" + anyProps.name;
          if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
            return instance;
        } else return instance;
      else if (!instance[internalHoistableMarker])
        switch (type) {
          case "meta":
            if (!instance.hasAttribute("itemprop")) break;
            return instance;
          case "link":
            name = instance.getAttribute("rel");
            if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
              break;
            else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
              break;
            return instance;
          case "style":
            if (instance.hasAttribute("data-precedence")) break;
            return instance;
          case "script":
            name = instance.getAttribute("src");
            if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
              break;
            return instance;
          default:
            return instance;
        }
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) break;
    }
    return null;
  }
  function canHydrateTextInstance(instance, text, inRootOrSingleton) {
    if ("" === text) return null;
    for (; 3 !== instance.nodeType; ) {
      if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
        return null;
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) return null;
    }
    return instance;
  }
  function isSuspenseInstanceFallback(instance) {
    return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
  }
  function registerSuspenseInstanceRetry(instance, callback) {
    var ownerDocument = instance.ownerDocument;
    if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
      callback();
    else {
      var listener = function() {
        callback();
        ownerDocument.removeEventListener("DOMContentLoaded", listener);
      };
      ownerDocument.addEventListener("DOMContentLoaded", listener);
      instance._reactRetry = listener;
    }
  }
  function getNextHydratable(node) {
    for (; null != node; node = node.nextSibling) {
      var nodeType = node.nodeType;
      if (1 === nodeType || 3 === nodeType) break;
      if (8 === nodeType) {
        nodeType = node.data;
        if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
          break;
        if ("/$" === nodeType) return null;
      }
    }
    return node;
  }
  var previousHydratableOnEnteringScopedSingleton = null;
  function getParentSuspenseInstance(targetInstance) {
    targetInstance = targetInstance.previousSibling;
    for (var depth = 0; targetInstance; ) {
      if (8 === targetInstance.nodeType) {
        var data = targetInstance.data;
        if ("$" === data || "$!" === data || "$?" === data) {
          if (0 === depth) return targetInstance;
          depth--;
        } else "/$" === data && depth++;
      }
      targetInstance = targetInstance.previousSibling;
    }
    return null;
  }
  function resolveSingletonInstance(type, props, rootContainerInstance) {
    props = getOwnerDocumentFromRootContainer(rootContainerInstance);
    switch (type) {
      case "html":
        type = props.documentElement;
        if (!type) throw Error(formatProdErrorMessage(452));
        return type;
      case "head":
        type = props.head;
        if (!type) throw Error(formatProdErrorMessage(453));
        return type;
      case "body":
        type = props.body;
        if (!type) throw Error(formatProdErrorMessage(454));
        return type;
      default:
        throw Error(formatProdErrorMessage(451));
    }
  }
  function releaseSingletonInstance(instance) {
    for (var attributes = instance.attributes; attributes.length; )
      instance.removeAttributeNode(attributes[0]);
    detachDeletedInstance(instance);
  }
  var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
  function getHoistableRoot(container) {
    return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
  }
  var previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: flushSyncWork,
    r: requestFormReset,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  function flushSyncWork() {
    var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
    return previousWasRendering || wasRendering;
  }
  function requestFormReset(form) {
    var formInst = getInstanceFromNode(form);
    null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
  }
  var globalDocument = "undefined" === typeof document ? null : document;
  function preconnectAs(rel, href, crossOrigin) {
    var ownerDocument = globalDocument;
    if (ownerDocument && "string" === typeof href && href) {
      var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
      limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
      "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
      preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
    }
  }
  function prefetchDNS(href) {
    previousDispatcher.D(href);
    preconnectAs("dns-prefetch", href, null);
  }
  function preconnect(href, crossOrigin) {
    previousDispatcher.C(href, crossOrigin);
    preconnectAs("preconnect", href, crossOrigin);
  }
  function preload(href, as, options2) {
    previousDispatcher.L(href, as, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href && as) {
      var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
      "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
        options2.imageSrcSet
      ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
        options2.imageSizes
      ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
      var key = preloadSelector;
      switch (as) {
        case "style":
          key = getStyleKey(href);
          break;
        case "script":
          key = getScriptKey(href);
      }
      preloadPropsMap.has(key) || (href = assign(
        {
          rel: "preload",
          href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
          as
        },
        options2
      ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
    }
  }
  function preloadModule(href, options2) {
    previousDispatcher.m(href, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href) {
      var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          key = getScriptKey(href);
      }
      if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
              return;
        }
        as = ownerDocument.createElement("link");
        setInitialProperties(as, "link", href);
        markNodeAsHoistable(as);
        ownerDocument.head.appendChild(as);
      }
    }
  }
  function preinitStyle(href, precedence, options2) {
    previousDispatcher.S(href, precedence, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href) {
      var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
      precedence = precedence || "default";
      var resource = styles.get(key);
      if (!resource) {
        var state = { loading: 0, preload: null };
        if (resource = ownerDocument.querySelector(
          getStylesheetSelectorFromKey(key)
        ))
          state.loading = 5;
        else {
          href = assign(
            { rel: "stylesheet", href, "data-precedence": precedence },
            options2
          );
          (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
          var link = resource = ownerDocument.createElement("link");
          markNodeAsHoistable(link);
          setInitialProperties(link, "link", href);
          link._p = new Promise(function(resolve, reject) {
            link.onload = resolve;
            link.onerror = reject;
          });
          link.addEventListener("load", function() {
            state.loading |= 1;
          });
          link.addEventListener("error", function() {
            state.loading |= 2;
          });
          state.loading |= 4;
          insertStylesheet(resource, precedence, ownerDocument);
        }
        resource = {
          type: "stylesheet",
          instance: resource,
          count: 1,
          state
        };
        styles.set(key, resource);
      }
    }
  }
  function preinitScript(src, options2) {
    previousDispatcher.X(src, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && src) {
      var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
      resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }, scripts.set(key, resource));
    }
  }
  function preinitModuleScript(src, options2) {
    previousDispatcher.M(src, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && src) {
      var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
      resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }, scripts.set(key, resource));
    }
  }
  function getResource(type, currentProps, pendingProps, currentResource) {
    var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
    if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
    switch (type) {
      case "meta":
      case "title":
        return null;
      case "style":
        return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
          JSCompiler_inline_result
        ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
          type = getStyleKey(pendingProps.href);
          var styles$244 = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, resource$245 = styles$244.get(type);
          resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
            getStylesheetSelectorFromKey(type)
          )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
            rel: "preload",
            as: "style",
            href: pendingProps.href,
            crossOrigin: pendingProps.crossOrigin,
            integrity: pendingProps.integrity,
            media: pendingProps.media,
            hrefLang: pendingProps.hrefLang,
            referrerPolicy: pendingProps.referrerPolicy
          }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
            JSCompiler_inline_result,
            type,
            pendingProps,
            resource$245.state
          )));
          if (currentProps && null === currentResource)
            throw Error(formatProdErrorMessage(528, ""));
          return resource$245;
        }
        if (currentProps && null !== currentResource)
          throw Error(formatProdErrorMessage(529, ""));
        return null;
      case "script":
        return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
          JSCompiler_inline_result
        ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(formatProdErrorMessage(444, type));
    }
  }
  function getStyleKey(href) {
    return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
  }
  function getStylesheetSelectorFromKey(key) {
    return 'link[rel="stylesheet"][' + key + "]";
  }
  function stylesheetPropsFromRawProps(rawProps) {
    return assign({}, rawProps, {
      "data-precedence": rawProps.precedence,
      precedence: null
    });
  }
  function preloadStylesheet(ownerDocument, key, preloadProps, state) {
    ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
      return state.loading |= 1;
    }), key.addEventListener("error", function() {
      return state.loading |= 2;
    }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
  }
  function getScriptKey(src) {
    return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
  }
  function getScriptSelectorFromKey(key) {
    return "script[async]" + key;
  }
  function acquireResource(hoistableRoot, resource, props) {
    resource.count++;
    if (null === resource.instance)
      switch (resource.type) {
        case "style":
          var instance = hoistableRoot.querySelector(
            'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
          );
          if (instance)
            return resource.instance = instance, markNodeAsHoistable(instance), instance;
          var styleProps = assign({}, props, {
            "data-href": props.href,
            "data-precedence": props.precedence,
            href: null,
            precedence: null
          });
          instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
            "style"
          );
          markNodeAsHoistable(instance);
          setInitialProperties(instance, "style", styleProps);
          insertStylesheet(instance, props.precedence, hoistableRoot);
          return resource.instance = instance;
        case "stylesheet":
          styleProps = getStyleKey(props.href);
          var instance$250 = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(styleProps)
          );
          if (instance$250)
            return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
          instance = stylesheetPropsFromRawProps(props);
          (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
          instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
          markNodeAsHoistable(instance$250);
          var linkInstance = instance$250;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance$250, "link", instance);
          resource.state.loading |= 4;
          insertStylesheet(instance$250, props.precedence, hoistableRoot);
          return resource.instance = instance$250;
        case "script":
          instance$250 = getScriptKey(props.src);
          if (styleProps = hoistableRoot.querySelector(
            getScriptSelectorFromKey(instance$250)
          ))
            return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
          instance = props;
          if (styleProps = preloadPropsMap.get(instance$250))
            instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          styleProps = hoistableRoot.createElement("script");
          markNodeAsHoistable(styleProps);
          setInitialProperties(styleProps, "link", instance);
          hoistableRoot.head.appendChild(styleProps);
          return resource.instance = styleProps;
        case "void":
          return null;
        default:
          throw Error(formatProdErrorMessage(443, resource.type));
      }
    else
      "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
    return resource.instance;
  }
  function insertStylesheet(instance, precedence, root2) {
    for (var nodes = root2.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (node.dataset.precedence === precedence) prior = node;
      else if (prior !== last) break;
    }
    prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
  }
  function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
    null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
    null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
    null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
  }
  function adoptPreloadPropsForScript(scriptProps, preloadProps) {
    null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
    null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
    null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
  }
  var tagCaches = null;
  function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
    if (null === tagCaches) {
      var cache = /* @__PURE__ */ new Map();
      var caches = tagCaches = /* @__PURE__ */ new Map();
      caches.set(ownerDocument, cache);
    } else
      caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
    if (cache.has(type)) return cache;
    cache.set(type, null);
    ownerDocument = ownerDocument.getElementsByTagName(type);
    for (caches = 0; caches < ownerDocument.length; caches++) {
      var node = ownerDocument[caches];
      if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
        var nodeKey = node.getAttribute(keyAttribute) || "";
        nodeKey = type + nodeKey;
        var existing = cache.get(nodeKey);
        existing ? existing.push(node) : cache.set(nodeKey, [node]);
      }
    }
    return cache;
  }
  function mountHoistable(hoistableRoot, type, instance) {
    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
    hoistableRoot.head.insertBefore(
      instance,
      "title" === type ? hoistableRoot.querySelector("head > title") : null
    );
  }
  function isHostHoistableType(type, props, hostContext) {
    if (1 === hostContext || null != props.itemProp) return false;
    switch (type) {
      case "meta":
      case "title":
        return true;
      case "style":
        if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
          break;
        return true;
      case "link":
        if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
          break;
        switch (props.rel) {
          case "stylesheet":
            return type = props.disabled, "string" === typeof props.precedence && null == type;
          default:
            return true;
        }
      case "script":
        if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
          return true;
    }
    return false;
  }
  function preloadResource(resource) {
    return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
  }
  var suspendedState = null;
  function noop() {
  }
  function suspendResource(hoistableRoot, resource, props) {
    if (null === suspendedState) throw Error(formatProdErrorMessage(475));
    var state = suspendedState;
    if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
      if (null === resource.instance) {
        var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(key)
        );
        if (instance) {
          hoistableRoot = instance._p;
          null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
          resource.state.loading |= 4;
          resource.instance = instance;
          markNodeAsHoistable(instance);
          return;
        }
        instance = hoistableRoot.ownerDocument || hoistableRoot;
        props = stylesheetPropsFromRawProps(props);
        (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
        instance = instance.createElement("link");
        markNodeAsHoistable(instance);
        var linkInstance = instance;
        linkInstance._p = new Promise(function(resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance, "link", props);
        resource.instance = instance;
      }
      null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
      state.stylesheets.set(resource, hoistableRoot);
      (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
    }
  }
  function waitForCommitToBeReady() {
    if (null === suspendedState) throw Error(formatProdErrorMessage(475));
    var state = suspendedState;
    state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
    return 0 < state.count ? function(commit) {
      var stylesheetTimer = setTimeout(function() {
        state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
        if (state.unsuspend) {
          var unsuspend = state.unsuspend;
          state.unsuspend = null;
          unsuspend();
        }
      }, 6e4);
      state.unsuspend = commit;
      return function() {
        state.unsuspend = null;
        clearTimeout(stylesheetTimer);
      };
    } : null;
  }
  function onUnsuspend() {
    this.count--;
    if (0 === this.count) {
      if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
      else if (this.unsuspend) {
        var unsuspend = this.unsuspend;
        this.unsuspend = null;
        unsuspend();
      }
    }
  }
  var precedencesByRoot = null;
  function insertSuspendedStylesheets(state, resources) {
    state.stylesheets = null;
    null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
  }
  function insertStylesheetIntoRoot(root2, resource) {
    if (!(resource.state.loading & 4)) {
      var precedences = precedencesByRoot.get(root2);
      if (precedences) var last = precedences.get(null);
      else {
        precedences = /* @__PURE__ */ new Map();
        precedencesByRoot.set(root2, precedences);
        for (var nodes = root2.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
            precedences.set(node.dataset.precedence, node), last = node;
        }
        last && precedences.set(null, last);
      }
      nodes = resource.instance;
      node = nodes.getAttribute("data-precedence");
      i = precedences.get(node) || last;
      i === last && precedences.set(null, nodes);
      precedences.set(node, nodes);
      this.count++;
      last = onUnsuspend.bind(this);
      nodes.addEventListener("load", last);
      nodes.addEventListener("error", last);
      i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
      resource.state.loading |= 4;
    }
  }
  var HostTransitionContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Provider: null,
    Consumer: null,
    _currentValue: sharedNotPendingObject,
    _currentValue2: sharedNotPendingObject,
    _threadCount: 0
  };
  function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
    this.tag = 1;
    this.containerInfo = containerInfo;
    this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
    this.callbackPriority = 0;
    this.expirationTimes = createLaneMap(-1);
    this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = createLaneMap(0);
    this.hiddenUpdates = createLaneMap(null);
    this.identifierPrefix = identifierPrefix;
    this.onUncaughtError = onUncaughtError;
    this.onCaughtError = onCaughtError;
    this.onRecoverableError = onRecoverableError;
    this.pooledCache = null;
    this.pooledCacheLanes = 0;
    this.formState = formState;
    this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
    containerInfo = new FiberRootNode(
      containerInfo,
      tag,
      hydrate,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      formState
    );
    tag = 1;
    true === isStrictMode && (tag |= 24);
    isStrictMode = createFiberImplClass(3, null, null, tag);
    containerInfo.current = isStrictMode;
    isStrictMode.stateNode = containerInfo;
    tag = createCache();
    tag.refCount++;
    containerInfo.pooledCache = tag;
    tag.refCount++;
    isStrictMode.memoizedState = {
      element: initialChildren,
      isDehydrated: hydrate,
      cache: tag
    };
    initializeUpdateQueue(isStrictMode);
    return containerInfo;
  }
  function getContextForSubtree(parentComponent) {
    if (!parentComponent) return emptyContextObject;
    parentComponent = emptyContextObject;
    return parentComponent;
  }
  function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
    parentComponent = getContextForSubtree(parentComponent);
    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    container = createUpdate(lane);
    container.payload = { element };
    callback = void 0 === callback ? null : callback;
    null !== callback && (container.callback = callback);
    element = enqueueUpdate(rootFiber, container, lane);
    null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
  }
  function markRetryLaneImpl(fiber, retryLane) {
    fiber = fiber.memoizedState;
    if (null !== fiber && null !== fiber.dehydrated) {
      var a = fiber.retryLane;
      fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
    }
  }
  function markRetryLaneIfNotHydrated(fiber, retryLane) {
    markRetryLaneImpl(fiber, retryLane);
    (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
  }
  function attemptContinuousHydration(fiber) {
    if (13 === fiber.tag) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
      markRetryLaneIfNotHydrated(fiber, 67108864);
    }
  }
  var _enabled = true;
  function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (_enabled) {
      var blockedOn = findInstanceBlockingEvent(nativeEvent);
      if (null === blockedOn)
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          return_targetInst,
          targetContainer
        ), clearIfContinuousEvent(domEventName, nativeEvent);
      else if (queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      ))
        nativeEvent.stopPropagation();
      else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
        for (; null !== blockedOn; ) {
          var fiber = getInstanceFromNode(blockedOn);
          if (null !== fiber)
            switch (fiber.tag) {
              case 3:
                fiber = fiber.stateNode;
                if (fiber.current.memoizedState.isDehydrated) {
                  var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                  if (0 !== lanes) {
                    var root2 = fiber;
                    root2.pendingLanes |= 2;
                    for (root2.entangledLanes |= 2; lanes; ) {
                      var lane = 1 << 31 - clz32(lanes);
                      root2.entanglements[1] |= lane;
                      lanes &= ~lane;
                    }
                    ensureRootIsScheduled(fiber);
                    0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                  }
                }
                break;
              case 13:
                root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
            }
          fiber = findInstanceBlockingEvent(nativeEvent);
          null === fiber && dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          );
          if (fiber === blockedOn) break;
          blockedOn = fiber;
        }
        null !== blockedOn && nativeEvent.stopPropagation();
      } else
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          null,
          targetContainer
        );
    }
  }
  function findInstanceBlockingEvent(nativeEvent) {
    nativeEvent = getEventTarget(nativeEvent);
    return findInstanceBlockingTarget(nativeEvent);
  }
  var return_targetInst = null;
  function findInstanceBlockingTarget(targetNode) {
    return_targetInst = null;
    targetNode = getClosestInstanceFromNode(targetNode);
    if (null !== targetNode) {
      var nearestMounted = getNearestMountedFiber(targetNode);
      if (null === nearestMounted) targetNode = null;
      else {
        var tag = nearestMounted.tag;
        if (13 === tag) {
          targetNode = getSuspenseInstanceFromFiber(nearestMounted);
          if (null !== targetNode) return targetNode;
          targetNode = null;
        } else if (3 === tag) {
          if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
            return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          targetNode = null;
        } else nearestMounted !== targetNode && (targetNode = null);
      }
    }
    return_targetInst = targetNode;
    return null;
  }
  function getEventPriority(domEventName) {
    switch (domEventName) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (getCurrentPriorityLevel()) {
          case ImmediatePriority:
            return 2;
          case UserBlockingPriority:
            return 8;
          case NormalPriority$1:
          case LowPriority:
            return 32;
          case IdlePriority:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function clearIfContinuousEvent(domEventName, nativeEvent) {
    switch (domEventName) {
      case "focusin":
      case "focusout":
        queuedFocus = null;
        break;
      case "dragenter":
      case "dragleave":
        queuedDrag = null;
        break;
      case "mouseover":
      case "mouseout":
        queuedMouse = null;
        break;
      case "pointerover":
      case "pointerout":
        queuedPointers.delete(nativeEvent.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        queuedPointerCaptures.delete(nativeEvent.pointerId);
    }
  }
  function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
      return existingQueuedEvent = {
        blockedOn,
        domEventName,
        eventSystemFlags,
        nativeEvent,
        targetContainers: [targetContainer]
      }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
    existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
    blockedOn = existingQueuedEvent.targetContainers;
    null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
    return existingQueuedEvent;
  }
  function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    switch (domEventName) {
      case "focusin":
        return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedFocus,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "dragenter":
        return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedDrag,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "mouseover":
        return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedMouse,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "pointerover":
        var pointerId = nativeEvent.pointerId;
        queuedPointers.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointers.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        );
        return true;
      case "gotpointercapture":
        return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointerCaptures.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        ), true;
    }
    return false;
  }
  function attemptExplicitHydrationTarget(queuedTarget) {
    var targetInst = getClosestInstanceFromNode(queuedTarget.target);
    if (null !== targetInst) {
      var nearestMounted = getNearestMountedFiber(targetInst);
      if (null !== nearestMounted) {
        if (targetInst = nearestMounted.tag, 13 === targetInst) {
          if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
            queuedTarget.blockedOn = targetInst;
            runWithPriority(queuedTarget.priority, function() {
              if (13 === nearestMounted.tag) {
                var lane = requestUpdateLane();
                lane = getBumpedLaneForHydrationByLane(lane);
                var root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                markRetryLaneIfNotHydrated(nearestMounted, lane);
              }
            });
            return;
          }
        } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
          queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          return;
        }
      }
    }
    queuedTarget.blockedOn = null;
  }
  function attemptReplayContinuousQueuedEvent(queuedEvent) {
    if (null !== queuedEvent.blockedOn) return false;
    for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
      var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
      if (null === nextBlockedOn) {
        nextBlockedOn = queuedEvent.nativeEvent;
        var nativeEventClone = new nextBlockedOn.constructor(
          nextBlockedOn.type,
          nextBlockedOn
        );
        currentReplayingEvent = nativeEventClone;
        nextBlockedOn.target.dispatchEvent(nativeEventClone);
        currentReplayingEvent = null;
      } else
        return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
      targetContainers.shift();
    }
    return true;
  }
  function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
    attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
  }
  function replayUnblockedEvents() {
    hasScheduledReplayAttempt = false;
    null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
    null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
    null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
    queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
    queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
  }
  function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
    queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      replayUnblockedEvents
    )));
  }
  var lastScheduledReplayQueue = null;
  function scheduleReplayQueueIfNeeded(formReplayingQueue) {
    lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      function() {
        lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
        for (var i = 0; i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
          if ("function" !== typeof submitterOrAction)
            if (null === findInstanceBlockingTarget(submitterOrAction || form))
              continue;
            else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
            formInst,
            {
              pending: true,
              data: formData,
              method: form.method,
              action: submitterOrAction
            },
            submitterOrAction,
            formData
          ));
        }
      }
    ));
  }
  function retryIfBlockedOn(unblocked) {
    function unblock(queuedEvent) {
      return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
    }
    null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
    null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
    null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
    queuedPointers.forEach(unblock);
    queuedPointerCaptures.forEach(unblock);
    for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
      var queuedTarget = queuedExplicitHydrationTargets[i];
      queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
    }
    for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
      attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
    i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
    if (null != i)
      for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
        var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
        if ("function" === typeof submitterOrAction)
          formProps || scheduleReplayQueueIfNeeded(i);
        else if (formProps) {
          var action = null;
          if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
            if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
              action = formProps.formAction;
            else {
              if (null !== findInstanceBlockingTarget(form)) continue;
            }
          else action = formProps.action;
          "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
          scheduleReplayQueueIfNeeded(i);
        }
      }
  }
  function ReactDOMRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
    var root2 = this._internalRoot;
    if (null === root2) throw Error(formatProdErrorMessage(409));
    var current = root2.current, lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root2, null, null);
  };
  ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
    var root2 = this._internalRoot;
    if (null !== root2) {
      this._internalRoot = null;
      var container = root2.containerInfo;
      updateContainerImpl(root2.current, 2, null, root2, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
  function ReactDOMHydrationRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
    if (target) {
      var updatePriority = resolveUpdatePriority();
      target = { blockedOn: null, target, priority: updatePriority };
      for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
      queuedExplicitHydrationTargets.splice(i, 0, target);
      0 === i && attemptExplicitHydrationTarget(target);
    }
  };
  var isomorphicReactPackageVersion$jscomp$inline_1785 = React2.version;
  if ("19.1.1" !== isomorphicReactPackageVersion$jscomp$inline_1785)
    throw Error(
      formatProdErrorMessage(
        527,
        isomorphicReactPackageVersion$jscomp$inline_1785,
        "19.1.1"
      )
    );
  ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
    var fiber = componentOrElement._reactInternals;
    if (void 0 === fiber) {
      if ("function" === typeof componentOrElement.render)
        throw Error(formatProdErrorMessage(188));
      componentOrElement = Object.keys(componentOrElement).join(",");
      throw Error(formatProdErrorMessage(268, componentOrElement));
    }
    componentOrElement = findCurrentFiberUsingSlowPath(fiber);
    componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
    componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
    return componentOrElement;
  };
  var internals$jscomp$inline_2256 = {
    bundleType: 0,
    version: "19.1.1",
    rendererPackageName: "react-dom",
    currentDispatcherRef: ReactSharedInternals,
    reconcilerVersion: "19.1.1"
  };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
      try {
        rendererID = hook$jscomp$inline_2257.inject(
          internals$jscomp$inline_2256
        ), injectedHook = hook$jscomp$inline_2257;
      } catch (err) {
      }
  }
  reactDomClient_production.createRoot = function(container, options2) {
    if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
    var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
    null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
    options2 = createFiberRoot(
      container,
      1,
      false,
      null,
      null,
      isStrictMode,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      transitionCallbacks,
      null
    );
    container[internalContainerInstanceKey] = options2.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMRoot(options2);
  };
  reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
    if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
    var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
    null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
    initialChildren = createFiberRoot(
      container,
      1,
      true,
      initialChildren,
      null != options2 ? options2 : null,
      isStrictMode,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      transitionCallbacks,
      formState
    );
    initialChildren.context = getContextForSubtree(null);
    options2 = initialChildren.current;
    isStrictMode = requestUpdateLane();
    isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
    identifierPrefix = createUpdate(isStrictMode);
    identifierPrefix.callback = null;
    enqueueUpdate(options2, identifierPrefix, isStrictMode);
    options2 = isStrictMode;
    initialChildren.current.lanes = options2;
    markRootUpdated$1(initialChildren, options2);
    ensureRootIsScheduled(initialChildren);
    container[internalContainerInstanceKey] = initialChildren.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMHydrationRoot(initialChildren);
  };
  reactDomClient_production.version = "19.1.1";
  return reactDomClient_production;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client.exports;
  hasRequiredClient = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    client.exports = requireReactDomClient_production();
  }
  return client.exports;
}
var clientExports = requireClient();
const WalletContext = reactExports.createContext(void 0);
const useWallet$1 = () => {
  const context = reactExports.useContext(WalletContext);
  if (context === void 0) {
    throw new Error("useWallet must be used within a WalletProvider");
  }
  return context;
};
const _ErrorMessageService = class _ErrorMessageService {
  /**
   * Get a standard error message configuration
   */
  static getMessage(key) {
    return _ErrorMessageService.MESSAGES[key];
  }
  /**
   * Create a custom error message with consistent formatting
   */
  static createMessage(title, message, action) {
    return { title, message, action };
  }
  /**
   * Format an error object into a user-friendly message
   */
  static formatError(error, fallbackMessage) {
    if (error instanceof Error) {
      const message = error.message.toLowerCase();
      const errorName = error.name.toLowerCase();
      if (message.includes("network") || message.includes("fetch") || message.includes("connection")) {
        return _ErrorMessageService.MESSAGES.NETWORK_ERROR;
      }
      if (message.includes("timeout") || message.includes("aborted") || errorName.includes("timeout")) {
        return _ErrorMessageService.MESSAGES.TIMEOUT_ERROR;
      }
      if (message.includes("rejected") || message.includes("cancelled")) {
        return _ErrorMessageService.MESSAGES.TRANSACTION_REJECTED;
      }
      if (message.includes("insufficient")) {
        return _ErrorMessageService.MESSAGES.INSUFFICIENT_BALANCE;
      }
      if (message.includes("not found")) {
        return _ErrorMessageService.MESSAGES.NFT_NOT_FOUND;
      }
      if (errorName === "chunkloaderror") {
        return _ErrorMessageService.MESSAGES.LOAD_FAILED;
      }
      if (message.includes("api") || message.includes("http") || message.includes("server")) {
        return _ErrorMessageService.MESSAGES.API_ERROR;
      }
      if (window.location.hostname === "localhost") {
        return _ErrorMessageService.createMessage(
          `Error: ${error.name}`,
          error.message,
          "Retry"
        );
      }
      return _ErrorMessageService.createMessage(
        "Error",
        "An error occurred while processing your request.",
        "Retry"
      );
    }
    return fallbackMessage || _ErrorMessageService.MESSAGES.UNKNOWN_ERROR;
  }
  /**
   * Log error consistently across the application
   * @deprecated Use log.error from loggingService instead
   */
  static logError(context, error, additionalInfo) {
    __vitePreload(async () => {
      const { log: log2 } = await Promise.resolve().then(() => loggingService);
      return { log: log2 };
    }, true ? void 0 : void 0).then(({ log: log2 }) => {
      const errorInstance = error instanceof Error ? error : new Error(String(error));
      log2.error(`Error in ${context}`, context, errorInstance, additionalInfo);
    }).catch(() => {
      console.error(`Error in ${context}:`, error, additionalInfo);
    });
  }
};
// Standard error messages for common scenarios
__publicField(_ErrorMessageService, "MESSAGES", {
  // Network and API errors
  NETWORK_ERROR: {
    title: "Connection Error",
    message: "Unable to connect to the server. Please check your internet connection and try again.",
    action: "Retry"
  },
  TIMEOUT_ERROR: {
    title: "Request Timeout",
    message: "The request took too long to complete. Please try again.",
    action: "Retry"
  },
  API_ERROR: {
    title: "Service Unavailable",
    message: "The service is temporarily unavailable. Please try again in a moment.",
    action: "Retry"
  },
  LOAD_FAILED: {
    title: "Loading Failed",
    message: "Failed to load data. Please refresh the page or try again later.",
    action: "Refresh"
  },
  // Authentication and wallet errors
  WALLET_CONNECTION_FAILED: {
    title: "Wallet Connection Failed",
    message: "Unable to connect to your wallet. Please ensure your wallet is unlocked and try again.",
    action: "Retry"
  },
  WALLET_DISCONNECTED: {
    title: "Wallet Disconnected",
    message: "Your wallet has been disconnected. Please reconnect to continue.",
    action: "Connect Wallet"
  },
  INSUFFICIENT_BALANCE: {
    title: "Insufficient Balance",
    message: "You do not have enough balance to complete this transaction.",
    action: "Add Funds"
  },
  // Transaction errors
  TRANSACTION_FAILED: {
    title: "Transaction Failed",
    message: "The transaction could not be completed. Please try again.",
    action: "Retry"
  },
  TRANSACTION_REJECTED: {
    title: "Transaction Rejected",
    message: "The transaction was rejected. Please try again if this was unintentional.",
    action: "Retry"
  },
  // Data validation errors
  INVALID_INPUT: {
    title: "Invalid Input",
    message: "Please check your input and try again.",
    action: "Correct Input"
  },
  REQUIRED_FIELD: {
    title: "Required Field Missing",
    message: "Please fill in all required fields.",
    action: "Complete Form"
  },
  // NFT and marketplace specific errors
  NFT_NOT_FOUND: {
    title: "NFT Not Found",
    message: "The requested NFT could not be found or may no longer be available.",
    action: "Go Back"
  },
  COLLECTION_NOT_FOUND: {
    title: "Collection Not Found",
    message: "The requested collection could not be found or may not exist.",
    action: "Browse Collections"
  },
  PURCHASE_FAILED: {
    title: "Purchase Failed",
    message: "Unable to complete the purchase. The item may no longer be available.",
    action: "Refresh Listings"
  },
  LISTING_FAILED: {
    title: "Listing Failed",
    message: "Unable to list your NFT. Please check your wallet and try again.",
    action: "Retry"
  },
  // Generic fallback
  UNKNOWN_ERROR: {
    title: "Something Went Wrong",
    message: "An unexpected error occurred. Please try again or contact support if the problem persists.",
    action: "Retry"
  }
});
let ErrorMessageService = _ErrorMessageService;
function formatDynamicDecimals(value, maxDecimals = 8, minDecimals = 0) {
  const num = typeof value === "string" ? parseFloat(value) : value;
  if (isNaN(num)) return "0";
  if (num === 0) return minDecimals > 0 ? "0." + "0".repeat(minDecimals) : "0";
  if (Math.abs(num) < Math.pow(10, -maxDecimals)) {
    return num.toExponential(2);
  }
  let formatted = num.toFixed(maxDecimals);
  if (formatted.includes(".")) {
    formatted = formatted.replace(/\.?0+$/, "");
  }
  if (minDecimals > 0) {
    const decimalIndex = formatted.indexOf(".");
    if (decimalIndex === -1) {
      formatted += "." + "0".repeat(minDecimals);
    } else {
      const currentDecimals = formatted.length - decimalIndex - 1;
      if (currentDecimals < minDecimals) {
        formatted += "0".repeat(minDecimals - currentDecimals);
      }
    }
  }
  return formatted;
}
function formatWaxPrice(price, showCurrency = true) {
  const numPrice = typeof price === "string" ? parseFloat(price.replace(" WAX", "")) : price;
  if (isNaN(numPrice)) return showCurrency ? "0 WAX" : "0";
  let formatted;
  if (numPrice >= 1e3) {
    formatted = formatDynamicDecimals(numPrice, 4, 0);
  } else if (numPrice >= 1) {
    formatted = formatDynamicDecimals(numPrice, 4, 0);
  } else if (numPrice >= 0.01) {
    formatted = formatDynamicDecimals(numPrice, 6, 0);
  } else {
    formatted = formatDynamicDecimals(numPrice, 8, 0);
  }
  return showCurrency ? `${formatted} WAX` : formatted;
}
const formatWAXPrice = formatWaxPrice;
const formatNumber = formatDynamicDecimals;
const LogLevel = {
  DEBUG: "debug",
  INFO: "info",
  WARN: "warn",
  ERROR: "error"
};
class LoggingService {
  constructor() {
    __publicField(this, "logLevel", LogLevel.INFO);
    __publicField(this, "isDevelopment", false);
    __publicField(this, "logs", []);
    __publicField(this, "maxLogs", 1e3);
    this.logLevel = this.isDevelopment ? LogLevel.DEBUG : LogLevel.WARN;
  }
  createLogEntry(level, message, context, data, error) {
    return {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level,
      message,
      context,
      data,
      error
    };
  }
  shouldLog(level) {
    return level >= this.logLevel;
  }
  storeLog(entry) {
    this.logs.push(entry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
  }
  formatMessage(entry) {
    const levelName = entry.level.toUpperCase();
    const context = entry.context ? `[${entry.context}]` : "";
    return `${entry.timestamp} ${levelName} ${context} ${entry.message}`;
  }
  debug(message, context, data) {
    if (!this.shouldLog(LogLevel.DEBUG)) return;
    const entry = this.createLogEntry(LogLevel.DEBUG, message, context, data);
    this.storeLog(entry);
    if (this.isDevelopment) {
      console.debug(this.formatMessage(entry), data || "");
    }
  }
  info(message, context, data) {
    if (!this.shouldLog(LogLevel.INFO)) return;
    const entry = this.createLogEntry(LogLevel.INFO, message, context, data);
    this.storeLog(entry);
    if (this.isDevelopment) {
      console.info(this.formatMessage(entry), data || "");
    }
  }
  warn(message, context, data) {
    if (!this.shouldLog(LogLevel.WARN)) return;
    const entry = this.createLogEntry(LogLevel.WARN, message, context, data);
    this.storeLog(entry);
    console.warn(this.formatMessage(entry), data || "");
  }
  error(message, context, error, data) {
    if (!this.shouldLog(LogLevel.ERROR)) return;
    const entry = this.createLogEntry(LogLevel.ERROR, message, context, data, error);
    this.storeLog(entry);
    console.error(this.formatMessage(entry), error || "", data || "");
    if (!this.isDevelopment && error) {
      this.reportError(error, { message, context, data });
    }
  }
  async reportError(error, metadata) {
    try {
      const reportingPromises = [
        this.sendToErrorReportingAPI(error, metadata),
        this.sendToLocalStorage(error, metadata),
        this.sendToConsole(error, metadata)
      ];
      await Promise.allSettled(reportingPromises);
    } catch (reportingError) {
      console.error("Failed to report error:", reportingError);
      console.error("Original error:", error);
    }
  }
  async sendToErrorReportingAPI(error, metadata) {
    try {
      const errorReport = {
        message: error.message,
        stack: error.stack,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href,
        userId: this.getUserId(),
        sessionId: this.getSessionId(),
        buildVersion: this.getBuildVersion(),
        environment: this.getEnvironment(),
        metadata
      };
      const response = await fetch("/api/errors/report", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.getAuthToken()}`
        },
        body: JSON.stringify(errorReport)
      });
      if (!response.ok) {
        throw new Error(`Error reporting failed: ${response.status} ${response.statusText}`);
      }
      console.log("Error successfully reported to server");
    } catch {
      await this.sendToFallbackErrorService(error, metadata);
    }
  }
  async sendToFallbackErrorService(error, metadata) {
    try {
      const errorData = {
        error: {
          message: error.message,
          stack: error.stack,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        },
        context: {
          ...metadata,
          userAgent: navigator.userAgent,
          url: window.location.href
        }
      };
      if (typeof window !== "undefined" && window.Sentry) {
        window.Sentry.captureException(error, {
          extra: errorData.context,
          level: "error"
        });
      }
    } catch (fallbackError) {
      console.warn("Fallback error reporting also failed:", fallbackError);
    }
  }
  async sendToLocalStorage(error, metadata) {
    try {
      const storageKey = "error_reports";
      const maxStoredErrors = 50;
      const errorReport = {
        message: error.message,
        stack: error.stack,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href,
        metadata
      };
      let storedErrors = [];
      const existing = localStorage.getItem(storageKey);
      if (existing) {
        try {
          storedErrors = JSON.parse(existing);
        } catch (parseError) {
          console.warn("Failed to parse stored errors:", parseError);
        }
      }
      storedErrors.unshift(errorReport);
      storedErrors = storedErrors.slice(0, maxStoredErrors);
      localStorage.setItem(storageKey, JSON.stringify(storedErrors));
    } catch (storageError) {
      console.warn("Failed to store error in localStorage:", storageError);
    }
  }
  sendToConsole(error, metadata) {
    const style = "color: #ff4444; font-weight: bold; background: #ffe6e6; padding: 2px 4px; border-radius: 3px;";
    console.group(`%cERROR: ${error.message}`, style);
    if (metadata) {
      console.log("Metadata:", metadata);
    }
    if (error.stack) {
      console.log("Stack:", error.stack);
    }
    console.log("Timestamp:", (/* @__PURE__ */ new Date()).toISOString());
    console.groupEnd();
  }
  getUserId() {
    return localStorage.getItem("user_id") || sessionStorage.getItem("user_id") || "anonymous";
  }
  getSessionId() {
    let sessionId = sessionStorage.getItem("session_id");
    if (!sessionId) {
      sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      sessionStorage.setItem("session_id", sessionId);
    }
    return sessionId;
  }
  getAuthToken() {
    return localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token") || "";
  }
  getBuildVersion() {
    return "unknown";
  }
  getEnvironment() {
    return "production";
  }
  getLogs(level) {
    if (level !== void 0) {
      return this.logs.filter((log2) => log2.level >= level);
    }
    return [...this.logs];
  }
  clearLogs() {
    this.logs = [];
  }
  exportLogs() {
    return JSON.stringify(this.logs, null, 2);
  }
}
const logger = new LoggingService();
const log = {
  debug: (message, context, data) => logger.debug(message, context, data),
  info: (message, context, data) => logger.info(message, context, data),
  warn: (message, context, data) => logger.warn(message, context, data),
  error: (message, context, error, data) => logger.error(message, context, error, data)
};
const loggingService = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LogLevel,
  log,
  logger
}, Symbol.toStringTag, { value: "Module" }));
const WAXROCK_TYPES = [
  "Citrine",
  "Tourmaline",
  "Emerald",
  "Garnet",
  "Peridot",
  "Jade",
  "Sapphire",
  "Turquoise",
  "Pigeon Blood Ruby",
  "Blue Rock",
  "Black Rock",
  "Rock"
];
const PARTNER_COLLECTIONS = [
  "friedfactory",
  "pixeljourney"
];
const TOKEN_CONTRACTS = [
  "alien.worlds",
  "prospectorsc",
  "token.nefty"
];
const PIXAL_TEMPLATE_ID = "781515";
const API_ENDPOINTS = {
  // Atomic Assets API endpoints
  ATOMIC_ASSETS: [
    "https://atomic.wax.eosrio.io",
    "https://wax-atomic.alcor.exchange",
    "https://atomic-wax-mainnet.wecan.dev",
    "https://wax.eosusa.io",
    "https://wax-atomic-api.eosphere.io",
    "https://atomic.3dkrender.com",
    "https://aa-wax-public1.neftyblocks.com",
    "https://atomic-wax.tacocrypto.io"
  ],
  // WAX Chain API endpoints
  WAX_CHAIN: {
    EOSRIO: "https://wax.eosrio.io",
    WAXSWEDEN: "https://api.waxsweden.org",
    GREYMASS: "https://wax.greymass.com",
    EOSPHERE: "https://wax.eosphere.io",
    ALOHAEOS: "https://api.wax.alohaeos.com",
    PINK: "https://wax.pink.gg",
    CRYPTOLIONS: "https://wax.cryptolions.io",
    FALLBACK_ENDPOINTS: [
      "https://wax.eosphere.io",
      "https://wax.eosrio.io",
      "https://api.wax.alohaeos.com",
      "https://wax.pink.gg",
      "https://api.waxsweden.org",
      "https://wax.greymass.com",
      "https://wax.cryptolions.io"
    ],
    HYPERION_ENDPOINTS: [
      "https://wax-hyperion.eosdetroit.io",
      "https://wax.eosrio.io",
      "https://api.waxsweden.org"
    ],
    HIVEBP: "https://wax-api.hivebp.io",
    LIGHT_API: "https://wax.light-api.net"
  },
  // Specialized API endpoints
  SPECIALIZED: {
    ALCOR: "https://alcor.exchange/api/v2",
    DAPPLICA: "https://aa.dapplica.io",
    NEFTY: "https://api.neftyblocks.com"
  },
  // External services
  IPFS: {
    GATEWAYS: [
      "https://ipfs.io/ipfs/",
      "https://gateway.pinata.cloud/ipfs/",
      "https://dweb.link/ipfs/"
    ]
  },
  // Avatar services
  AVATAR: {
    DICEBEAR: "https://api.dicebear.com/7.x/identicon/svg"
  },
  // Hyperion endpoints
  HYPERION: [
    "https://wax-hyperion.eosdetroit.io",
    "https://wax.eosrio.io",
    "https://api.waxsweden.org"
  ],
  // Price and currency APIs
  COINGECKO_API: "https://api.coingecko.com/api/v3/simple/price",
  EXCHANGE_RATE_API: "https://api.exchangerate-api.com/v4/latest/USD",
  // Social and external links
  SOCIAL: {
    TWITTER_INTENT: "https://twitter.com/intent/tweet",
    FACEBOOK_SHARE: "https://www.facebook.com/sharer/sharer.php",
    REDDIT_SUBMIT: "https://reddit.com/submit",
    TELEGRAM_SHARE: "https://t.me/share/url",
    DISCORD: "https://discord.gg/pixeljourney",
    ATOMICHUB_EXPLORER: "https://wax.atomichub.io/explorer",
    BLOKS_EXPLORER: "https://wax.bloks.io"
  },
  // Pixel Journey specific
  PIXEL_JOURNEY: {
    MAIN_SITE: "https://pixeljourney.xyz",
    DOCS: "https://docs.pixeljourney.xyz",
    LOGO: "/logo.png",
    DEFAULT_IMAGE: "https://pixeljourney.xyz/img/toppixals/10.webp",
    LEADERBOARD: "https://lb.pixeljourney.xyz/",
    CRAFTING_DOCS: "https://docs.pixeljourney.xyz/season-1/recycling-and-crafting"
  },
  // Avatar and image services
  DICEBEAR_API: "https://api.dicebear.com/7.x/identicon/svg",
  // Fonts and external resources
  GOOGLE_FONTS: "https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap",
  // WAX wallet
  WAX_WALLET: "https://wallet.wax.io"
};
class MarketplaceConfigService {
  // 5 minutes
  /**
   * Check if a WaxRock type is valid (not "none")
   */
  static isValidWaxRock(waxRock) {
    return waxRock !== "none" && WAXROCK_TYPES.includes(waxRock);
  }
  /**
   * Get all valid WaxRock types (excluding "none")
   */
  static getWaxRockTypes() {
    return WAXROCK_TYPES;
  }
  /**
   * Get partner collections from API with caching
   * Falls back to hardcoded values if API fails
   */
  static async getPartnerCollections() {
    const now = Date.now();
    if (this.configCache.partnerCollections && this.configCache.lastFetch && now - this.configCache.lastFetch < this.CACHE_DURATION) {
      return this.configCache.partnerCollections;
    }
    try {
      const { apiService: apiService2 } = await __vitePreload(async () => {
        const { apiService: apiService3 } = await Promise.resolve().then(() => api);
        return { apiService: apiService3 };
      }, true ? void 0 : void 0);
      const collections = await apiService2.getPartnerCollections();
      this.configCache.partnerCollections = collections;
      this.configCache.lastFetch = now;
      return collections;
    } catch (error) {
      log.warn("Failed to fetch partner collections from API, using fallback", "MarketplaceConfig", { error });
      return [...PARTNER_COLLECTIONS];
    }
  }
  /**
   * Get partner collections synchronously (for backward compatibility)
   * Returns cached data or hardcoded fallback
   */
  static getPartnerCollectionsSync() {
    return this.configCache.partnerCollections || PARTNER_COLLECTIONS;
  }
  /**
   * Get token contracts from API with caching
   * Falls back to hardcoded values if API fails
   */
  static async getTokenContracts() {
    const now = Date.now();
    if (this.configCache.tokenContracts && this.configCache.lastFetch && now - this.configCache.lastFetch < this.CACHE_DURATION) {
      return this.configCache.tokenContracts;
    }
    try {
      const { apiService: apiService2 } = await __vitePreload(async () => {
        const { apiService: apiService3 } = await Promise.resolve().then(() => api);
        return { apiService: apiService3 };
      }, true ? void 0 : void 0);
      const contracts = await apiService2.getTokenContracts();
      this.configCache.tokenContracts = contracts;
      this.configCache.lastFetch = now;
      return contracts;
    } catch (error) {
      log.warn("Failed to fetch token contracts from API, using fallback", "MarketplaceConfig", { error });
      return [...TOKEN_CONTRACTS];
    }
  }
  /**
   * Get token contracts synchronously (for backward compatibility)
   * Returns cached data or hardcoded fallback
   */
  static getTokenContractsSync() {
    return this.configCache.tokenContracts || TOKEN_CONTRACTS;
  }
  /**
   * Get Pixal PFP template ID
   */
  static getPixalTemplateId() {
    return PIXAL_TEMPLATE_ID;
  }
  /**
   * Check if an asset is a Pixal PFP (including WaxRocks)
   */
  static isPixalPFP(templateId) {
    return templateId === PIXAL_TEMPLATE_ID;
  }
  /**
   * Generate dynamic filters based on API data
   * Analyzes actual asset attributes to create meaningful filter categories
   */
  static generateFiltersFromAssets(assets) {
    const filters = /* @__PURE__ */ new Set();
    const attributeCounts = /* @__PURE__ */ new Map();
    filters.add("All Items");
    assets.forEach((asset) => {
      if (asset.traits && typeof asset.traits === "object" && asset.traits !== null) {
        Object.keys(asset.traits).forEach((traitKey) => {
          const traitValue = asset.traits[traitKey];
          if (traitValue && traitValue !== "none" && traitValue !== "") {
            const filterKey = `${traitKey}: ${traitValue}`;
            attributeCounts.set(filterKey, (attributeCounts.get(filterKey) || 0) + 1);
          }
        });
      }
      if (asset.data && typeof asset.data === "object" && asset.data !== null) {
        Object.keys(asset.data).forEach((dataKey) => {
          const dataValue = asset.data[dataKey];
          if (dataValue && dataValue !== "none" && dataValue !== "") {
            const filterKey = `${dataKey}: ${dataValue}`;
            attributeCounts.set(filterKey, (attributeCounts.get(filterKey) || 0) + 1);
          }
        });
      }
      if (asset.collection) {
        const collectionFilter = `Collection: ${asset.collection}`;
        attributeCounts.set(collectionFilter, (attributeCounts.get(collectionFilter) || 0) + 1);
      }
      if (asset.schema) {
        const schemaFilter = `Schema: ${asset.schema}`;
        attributeCounts.set(schemaFilter, (attributeCounts.get(schemaFilter) || 0) + 1);
      }
    });
    const minOccurrences = Math.max(2, Math.floor(assets.length * 0.05));
    attributeCounts.forEach((count, filterKey) => {
      if (count >= minOccurrences) {
        filters.add(filterKey);
      }
    });
    return Array.from(filters).sort();
  }
  /**
   * Preload configuration data to populate cache
   * Should be called during app initialization
   */
  static async preloadConfiguration() {
    try {
      await Promise.all([
        this.getPartnerCollections(),
        this.getTokenContracts()
      ]);
    } catch (error) {
      log.warn("Failed to preload marketplace configuration", "MarketplaceConfig", { error });
    }
  }
  /**
   * Clear configuration cache (useful for testing or forced refresh)
   */
  static clearCache() {
    this.configCache = {};
  }
}
__publicField(MarketplaceConfigService, "configCache", {});
__publicField(MarketplaceConfigService, "CACHE_DURATION", 5 * 60 * 1e3);
const marketplaceConfig = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  API_ENDPOINTS,
  MarketplaceConfigService,
  PARTNER_COLLECTIONS,
  PIXAL_TEMPLATE_ID,
  TOKEN_CONTRACTS,
  WAXROCK_TYPES
}, Symbol.toStringTag, { value: "Module" }));
class CurrencyService {
  constructor() {
    __publicField(this, "exchangeRates", {});
    __publicField(this, "cryptoRates", { bitcoin: { usd: 0 }, ethereum: { usd: 0 } });
    __publicField(this, "lastFetchTime", 0);
    __publicField(this, "CACHE_DURATION", 10 * 60 * 1e3);
    // 10 minutes
    __publicField(this, "EXCHANGE_API", API_ENDPOINTS.EXCHANGE_RATE_API);
    __publicField(this, "CRYPTO_API", API_ENDPOINTS.COINGECKO_API);
    // Fallback exchange rates (approximate)
    __publicField(this, "FALLBACK_RATES", {
      USD: 1,
      EUR: 0.85,
      DKK: 6.3,
      AED: 3.67,
      INR: 83.12,
      RUB: 74.5,
      CNY: 7.1,
      JPY: 110
    });
    __publicField(this, "FALLBACK_CRYPTO", {
      bitcoin: { usd: 115e3 },
      ethereum: { usd: 4e3 }
    });
  }
  async getExchangeRates() {
    const now = Date.now();
    if (Object.keys(this.exchangeRates).length > 0 && now - this.lastFetchTime < this.CACHE_DURATION) {
      return this.exchangeRates;
    }
    try {
      const response = await fetch(this.EXCHANGE_API, {
        method: "GET",
        headers: {
          "Accept": "application/json"
        }
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      this.exchangeRates = {
        USD: 1,
        EUR: data.rates?.EUR || this.FALLBACK_RATES.EUR,
        DKK: data.rates?.DKK || this.FALLBACK_RATES.DKK,
        AED: data.rates?.AED || this.FALLBACK_RATES.AED,
        INR: data.rates?.INR || this.FALLBACK_RATES.INR,
        RUB: data.rates?.RUB || this.FALLBACK_RATES.RUB,
        CNY: data.rates?.CNY || this.FALLBACK_RATES.CNY,
        JPY: data.rates?.JPY || this.FALLBACK_RATES.JPY
      };
      try {
        const cryptoResponse = await fetch(this.CRYPTO_API, {
          method: "GET",
          headers: {
            "Accept": "application/json"
          }
        });
        if (cryptoResponse.ok) {
          const cryptoData = await cryptoResponse.json();
          this.cryptoRates = {
            bitcoin: { usd: cryptoData.bitcoin?.usd || this.FALLBACK_CRYPTO.bitcoin.usd },
            ethereum: { usd: cryptoData.ethereum?.usd || this.FALLBACK_CRYPTO.ethereum.usd }
          };
        }
      } catch (cryptoError) {
        ErrorMessageService.logError("CurrencyService.getCryptoRates", cryptoError);
        this.cryptoRates = this.FALLBACK_CRYPTO;
      }
      this.lastFetchTime = now;
      return this.exchangeRates;
    } catch (error) {
      ErrorMessageService.logError("CurrencyService.getExchangeRates", error, { api: this.EXCHANGE_API });
      this.exchangeRates = this.FALLBACK_RATES;
      this.cryptoRates = this.FALLBACK_CRYPTO;
      this.lastFetchTime = now;
      return this.exchangeRates;
    }
  }
  async convertUSDToCurrency(usdAmount, targetCurrency) {
    if (usdAmount <= 0) return "0.00";
    if (targetCurrency === "BTC") {
      await this.getExchangeRates();
      const btcPrice = this.cryptoRates.bitcoin.usd;
      const btcAmount = usdAmount / btcPrice;
      return btcAmount >= 1e-3 ? btcAmount.toFixed(6) : btcAmount.toExponential(2);
    }
    if (targetCurrency === "ETH") {
      await this.getExchangeRates();
      const ethPrice = this.cryptoRates.ethereum.usd;
      const ethAmount = usdAmount / ethPrice;
      return ethAmount >= 1e-3 ? ethAmount.toFixed(6) : ethAmount.toExponential(2);
    }
    const rates = await this.getExchangeRates();
    const rate = rates[targetCurrency];
    if (!rate) {
      return "0.00";
    }
    const convertedAmount = usdAmount * rate;
    if (targetCurrency === "JPY") {
      return Math.round(convertedAmount).toString();
    }
    return convertedAmount.toFixed(2);
  }
  async convertWaxToCurrency(waxAmount, targetCurrency) {
    try {
      const { priceService: priceService2 } = await __vitePreload(async () => {
        const { priceService: priceService3 } = await Promise.resolve().then(() => priceService$1);
        return { priceService: priceService3 };
      }, true ? void 0 : void 0);
      const usdString = await priceService2.convertWaxToUSDAsync(waxAmount);
      const usdAmount = parseFloat(usdString.replace(/[$,]/g, ""));
      if (targetCurrency === "USD") {
        return usdString;
      }
      const convertedAmount = await this.convertUSDToCurrency(usdAmount, targetCurrency);
      return this.formatCurrencyAmount(convertedAmount, targetCurrency);
    } catch (error) {
      ErrorMessageService.logError("CurrencyService.convertWaxToCurrency", error, { waxAmount, targetCurrency });
      return "0.00";
    }
  }
  formatCurrencyAmount(amount, currency) {
    switch (currency) {
      case "USD":
        return `$${amount}`;
      case "EUR":
        return `${amount}`;
      case "DKK":
        return `${amount} kr`;
      case "AED":
        return `${amount} .`;
      case "INR":
        return `${amount}`;
      case "RUB":
        return `${amount} `;
      case "CNY":
        return `${amount}`;
      case "JPY":
        return `${amount}`;
      case "BTC":
        return `${amount}`;
      case "ETH":
        return `${amount}`;
      default:
        return `${amount} ${currency}`;
    }
  }
  getCurrencySymbol(currency) {
    const symbols = {
      USD: "$",
      EUR: "",
      DKK: "kr",
      AED: ".",
      INR: "",
      RUB: "",
      CNY: "",
      JPY: "",
      BTC: "",
      ETH: ""
    };
    return symbols[currency] || currency;
  }
}
const currencyService = new CurrencyService();
class PriceService {
  constructor() {
    __publicField(this, "waxPriceUSD", 0.02);
    __publicField(this, "wpixalPriceUSD", 2e-5);
    __publicField(this, "wpixalPriceWAX", 1e-3);
    __publicField(this, "pxjPriceUSD", 1e-4);
    __publicField(this, "lastFetchTime", 0);
    __publicField(this, "CACHE_DURATION", 5 * 60 * 1e3);
    // 5 minutes
    __publicField(this, "COINGECKO_WAX_API", "https://api.coingecko.com/api/v3/simple/price?ids=wax&vs_currencies=usd");
    __publicField(this, "GECKOTERMINAL_WPIXAL_API", "https://api.geckoterminal.com/api/v2/networks/wax/pools/swap.alcor:7845");
    __publicField(this, "GECKOTERMINAL_PXJ_POOLS", [
      "https://api.geckoterminal.com/api/v2/networks/wax/pools/swap.alcor:1195",
      // PXJ/WAX
      "https://api.geckoterminal.com/api/v2/networks/wax/pools/swap.alcor:1657",
      // PXJ/WUF
      "https://api.geckoterminal.com/api/v2/networks/wax/pools/swap.alcor:6560"
      // PXJ/KING
    ]);
    __publicField(this, "FALLBACK_WAX_PRICE", 0.02);
    // Fallback WAX price in USD
    __publicField(this, "FALLBACK_WPIXAL_PRICE", 2e-5);
    // Fallback WPIXAL price in USD
    __publicField(this, "FALLBACK_PXJ_PRICE", 1e-4);
  }
  // Fallback PXJ price in USD
  /**
   * Fetch all prices from Alcor Exchange API
   */
  async fetchPrices() {
    const now = Date.now();
    if (now - this.lastFetchTime < this.CACHE_DURATION && this.waxPriceUSD > 0 && this.wpixalPriceUSD > 0) {
      return;
    }
    try {
      const [waxResponse, wpixalResponse, ...pxjResponses] = await Promise.all([
        fetch(this.COINGECKO_WAX_API).catch(() => null),
        fetch(this.GECKOTERMINAL_WPIXAL_API).catch(() => null),
        ...this.GECKOTERMINAL_PXJ_POOLS.map((pool) => fetch(pool).catch(() => null))
      ]);
      let waxPriceFromAPI = null;
      if (waxResponse && waxResponse.ok) {
        try {
          const waxData = await waxResponse.json();
          waxPriceFromAPI = waxData.wax?.usd;
        } catch (error) {
          log.warn("Failed to parse WAX price data:", "PriceService.fetchPrices", { error });
        }
      }
      let wpixalPriceFromAPI = null;
      if (wpixalResponse && wpixalResponse.ok) {
        try {
          const wpixalData = await wpixalResponse.json();
          wpixalPriceFromAPI = wpixalData.data?.attributes?.quote_token_price_usd;
          if (wpixalPriceFromAPI) {
            wpixalPriceFromAPI = parseFloat(wpixalPriceFromAPI);
          }
        } catch (error) {
          log.warn("Failed to parse WPIXAL price data:", "PriceService.fetchPrices", { error });
        }
      }
      let pxjPriceFromAPI = null;
      for (const response of pxjResponses) {
        if (response && response.ok) {
          try {
            const pxjData = await response.json();
            const quoteTokenPrice = pxjData.data?.attributes?.quote_token_price_usd;
            if (quoteTokenPrice) {
              pxjPriceFromAPI = parseFloat(quoteTokenPrice);
              break;
            }
          } catch (error) {
            log.warn("Failed to parse PXJ price data from pool:", "PriceService.fetchPrices", { error });
          }
        }
      }
      this.waxPriceUSD = waxPriceFromAPI || this.FALLBACK_WAX_PRICE;
      this.wpixalPriceUSD = wpixalPriceFromAPI || this.FALLBACK_WPIXAL_PRICE;
      this.pxjPriceUSD = pxjPriceFromAPI || this.FALLBACK_PXJ_PRICE;
      if (this.waxPriceUSD > 0) {
        this.wpixalPriceWAX = this.wpixalPriceUSD / this.waxPriceUSD;
      } else {
        this.wpixalPriceWAX = 1e-3;
      }
      this.lastFetchTime = now;
    } catch (error) {
      ErrorMessageService.logError("PriceService.fetchPrices", error, {
        waxApi: this.COINGECKO_WAX_API,
        wpixalApi: this.GECKOTERMINAL_WPIXAL_API,
        pxjPools: this.GECKOTERMINAL_PXJ_POOLS,
        fallbackWaxPrice: this.FALLBACK_WAX_PRICE,
        fallbackWpixalPrice: this.FALLBACK_WPIXAL_PRICE,
        fallbackPxjPrice: this.FALLBACK_PXJ_PRICE
      });
      this.waxPriceUSD = this.FALLBACK_WAX_PRICE;
      this.wpixalPriceUSD = this.FALLBACK_WPIXAL_PRICE;
      this.pxjPriceUSD = this.FALLBACK_PXJ_PRICE;
      this.wpixalPriceWAX = this.FALLBACK_WPIXAL_PRICE / this.FALLBACK_WAX_PRICE;
      this.lastFetchTime = now;
    }
  }
  async getWaxPriceUSD() {
    await this.fetchPrices();
    return this.waxPriceUSD;
  }
  async getWpixalPriceWAX() {
    await this.fetchPrices();
    return this.wpixalPriceWAX;
  }
  async getWpixalPriceUSD() {
    await this.fetchPrices();
    return this.wpixalPriceUSD;
  }
  async getPxjPriceUSD() {
    await this.fetchPrices();
    return this.pxjPriceUSD;
  }
  convertWaxToUSD(waxAmount) {
    const amount = parseFloat(waxAmount.replace(/[^0-9.]/g, ""));
    if (isNaN(amount) || this.waxPriceUSD <= 0) {
      return "$0.00";
    }
    const usdValue = amount * this.waxPriceUSD;
    return `$${formatNumber(usdValue, 2)}`;
  }
  async convertWaxToUSDAsync(waxAmount) {
    await this.getWaxPriceUSD();
    return this.convertWaxToUSD(waxAmount);
  }
  async convertWaxToCurrencyAsync(waxAmount, currency = "USD") {
    if (currency === "USD") {
      return this.convertWaxToUSDAsync(waxAmount);
    }
    return currencyService.convertWaxToCurrency(waxAmount, currency);
  }
  /**
   * Convert WPIXAL amount to WAX
   */
  async convertWpixalToWAX(wpixalAmount) {
    try {
      const amount = parseFloat(wpixalAmount.replace(/[^0-9.]/g, ""));
      if (isNaN(amount)) return "0.0000 WAX";
      const wpixalPriceWAX = await this.getWpixalPriceWAX();
      const waxValue = amount * wpixalPriceWAX;
      return formatWAXPrice(waxValue);
    } catch (error) {
      ErrorMessageService.logError("PriceService.convertWpixalToWAX", error, { wpixalAmount });
      return "0.0000 WAX";
    }
  }
  /**
   * Convert WPIXAL amount to USD
   */
  async convertWpixalToUSD(wpixalAmount) {
    try {
      const amount = parseFloat(wpixalAmount.replace(/[^0-9.]/g, ""));
      if (isNaN(amount)) return "$0.00";
      const wpixalPriceUSD = await this.getWpixalPriceUSD();
      const usdValue = amount * wpixalPriceUSD;
      return `$${formatNumber(usdValue, 2)}`;
    } catch (error) {
      ErrorMessageService.logError("PriceService.convertWpixalToUSD", error, { wpixalAmount });
      return "$0.00";
    }
  }
  /**
   * Convert PXJ amount to USD
   */
  async convertPxjToUSD(pxjAmount) {
    try {
      const amount = parseFloat(pxjAmount.replace(/[^0-9.]/g, ""));
      if (isNaN(amount)) return "$0.00";
      const pxjPriceUSD = await this.getPxjPriceUSD();
      const usdValue = amount * pxjPriceUSD;
      return `$${formatNumber(usdValue, 6)}`;
    } catch (error) {
      ErrorMessageService.logError("PriceService.convertPxjToUSD", error, { pxjAmount });
      return "$0.00";
    }
  }
  /**
   * Convert PXJ amount to WAX
   */
  async convertPxjToWAX(pxjAmount) {
    try {
      const amount = parseFloat(pxjAmount.replace(/[^0-9.]/g, ""));
      if (isNaN(amount)) return "0.0000 WAX";
      const pxjPriceUSD = await this.getPxjPriceUSD();
      const waxPriceUSD = await this.getWaxPriceUSD();
      const waxValue = amount * pxjPriceUSD / waxPriceUSD;
      return formatWAXPrice(waxValue);
    } catch (error) {
      ErrorMessageService.logError("PriceService.convertPxjToWAX", error, { pxjAmount });
      return "0.0000 WAX";
    }
  }
  // Helper method to get the selected currency from display settings
  async convertWaxWithDisplaySettings(waxAmount) {
    try {
      const selectedCurrency = localStorage.getItem("selectedCurrency") || "USD";
      const showPricesInUSD = JSON.parse(localStorage.getItem("showPricesInUSD") || "true");
      if (!showPricesInUSD) {
        const amount = parseFloat(waxAmount.replace(/[^0-9.]/g, ""));
        return formatWAXPrice(amount);
      }
      return this.convertWaxToCurrencyAsync(waxAmount, selectedCurrency);
    } catch (error) {
      ErrorMessageService.logError("PriceService.convertWaxWithDisplaySettings", error, { waxAmount });
      return this.convertWaxToUSDAsync(waxAmount);
    }
  }
}
const priceService = new PriceService();
const priceService$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  priceService
}, Symbol.toStringTag, { value: "Module" }));
class StorageService {
  isStorageAvailable(storage) {
    try {
      const test = "__storage_test__";
      storage.setItem(test, test);
      storage.removeItem(test);
      return true;
    } catch {
      return false;
    }
  }
  get isLocalStorageAvailable() {
    return typeof window !== "undefined" && this.isStorageAvailable(localStorage);
  }
  get isSessionStorageAvailable() {
    return typeof window !== "undefined" && this.isStorageAvailable(sessionStorage);
  }
  /**
   * Get item from storage with fallback and error handling
   */
  getItem(key, useSessionStorage = false) {
    try {
      const storage = useSessionStorage ? sessionStorage : localStorage;
      if (useSessionStorage && this.isSessionStorageAvailable) {
        return storage.getItem(key);
      } else if (!useSessionStorage && this.isLocalStorageAvailable) {
        return storage.getItem(key);
      }
      const fallbackStorage = useSessionStorage ? localStorage : sessionStorage;
      const isFallbackAvailable = useSessionStorage ? this.isLocalStorageAvailable : this.isSessionStorageAvailable;
      if (isFallbackAvailable) {
        logger.warn(`Primary storage unavailable, using fallback for key: ${key}`);
        return fallbackStorage.getItem(key);
      }
      logger.warn(`No storage available for key: ${key}`);
      return null;
    } catch (error) {
      logger.error("StorageService.getItem failed", "StorageService", error, { key, useSessionStorage });
      return null;
    }
  }
  /**
   * Set item in storage with fallback and error handling
   */
  setItem(key, value, useSessionStorage = false) {
    try {
      const storage = useSessionStorage ? sessionStorage : localStorage;
      if (useSessionStorage && this.isSessionStorageAvailable) {
        storage.setItem(key, value);
        return true;
      } else if (!useSessionStorage && this.isLocalStorageAvailable) {
        storage.setItem(key, value);
        return true;
      }
      const fallbackStorage = useSessionStorage ? localStorage : sessionStorage;
      const isFallbackAvailable = useSessionStorage ? this.isLocalStorageAvailable : this.isSessionStorageAvailable;
      if (isFallbackAvailable) {
        logger.warn(`Primary storage unavailable, using fallback for key: ${key}`);
        fallbackStorage.setItem(key, value);
        return true;
      }
      logger.warn(`No storage available for key: ${key}`);
      return false;
    } catch (error) {
      logger.error("StorageService.setItem failed", "StorageService", error, { key, useSessionStorage });
      return false;
    }
  }
  /**
   * Remove item from storage with error handling
   */
  removeItem(key, useSessionStorage = false) {
    try {
      const storage = useSessionStorage ? sessionStorage : localStorage;
      if (useSessionStorage && this.isSessionStorageAvailable) {
        storage.removeItem(key);
        return true;
      } else if (!useSessionStorage && this.isLocalStorageAvailable) {
        storage.removeItem(key);
        return true;
      }
      let removed = false;
      if (this.isLocalStorageAvailable) {
        localStorage.removeItem(key);
        removed = true;
      }
      if (this.isSessionStorageAvailable) {
        sessionStorage.removeItem(key);
        removed = true;
      }
      if (!removed) {
        logger.warn(`No storage available to remove key: ${key}`);
      }
      return removed;
    } catch (error) {
      logger.error("StorageService.removeItem failed", "StorageService", error, { key, useSessionStorage });
      return false;
    }
  }
  /**
   * Clear all items from storage with error handling
   */
  clear(useSessionStorage = false) {
    try {
      const storage = useSessionStorage ? sessionStorage : localStorage;
      if (useSessionStorage && this.isSessionStorageAvailable) {
        storage.clear();
        return true;
      } else if (!useSessionStorage && this.isLocalStorageAvailable) {
        storage.clear();
        return true;
      }
      logger.warn("No storage available to clear");
      return false;
    } catch (error) {
      logger.error("StorageService.clear failed", "StorageService", error, { useSessionStorage });
      return false;
    }
  }
  /**
   * Get JSON object from storage with parsing error handling
   */
  getJSON(key, defaultValue, useSessionStorage = false) {
    try {
      const item = this.getItem(key, useSessionStorage);
      if (item === null) {
        return defaultValue;
      }
      return JSON.parse(item);
    } catch (error) {
      logger.error("StorageService.getJSON failed", "StorageService", error, { key, useSessionStorage });
      return defaultValue;
    }
  }
  /**
   * Set JSON object in storage with stringification error handling
   */
  setJSON(key, value, useSessionStorage = false) {
    try {
      const jsonString = JSON.stringify(value);
      return this.setItem(key, jsonString, useSessionStorage);
    } catch (error) {
      logger.error("StorageService.setJSON failed", "StorageService", error, { key, useSessionStorage });
      return false;
    }
  }
  /**
   * Get storage statistics
   */
  getStorageStats() {
    const getStorageSize = (storage) => {
      try {
        let used = 0;
        for (const key in storage) {
          if (Object.prototype.hasOwnProperty.call(storage, key)) {
            used += storage[key].length + key.length;
          }
        }
        const total = 5 * 1024 * 1024;
        return { used, total };
      } catch {
        return { used: 0, total: 0 };
      }
    };
    return {
      localStorage: {
        available: this.isLocalStorageAvailable,
        ...getStorageSize(this.isLocalStorageAvailable ? localStorage : {})
      },
      sessionStorage: {
        available: this.isSessionStorageAvailable,
        ...getStorageSize(this.isSessionStorageAvailable ? sessionStorage : {})
      }
    };
  }
  /**
   * Check if storage quota is exceeded
   */
  isQuotaExceeded() {
    const stats = this.getStorageStats();
    const localStorageUsage = stats.localStorage.used / stats.localStorage.total;
    const sessionStorageUsage = stats.sessionStorage.used / stats.sessionStorage.total;
    return localStorageUsage > 0.9 || sessionStorageUsage > 0.9;
  }
  /**
   * Clean up old or expired data
   */
  cleanup(keyPatterns = []) {
    let cleaned = 0;
    try {
      const storages = [
        { storage: localStorage, available: this.isLocalStorageAvailable },
        { storage: sessionStorage, available: this.isSessionStorageAvailable }
      ];
      for (const { storage, available } of storages) {
        if (!available) continue;
        const keysToRemove = [];
        for (let i = 0; i < storage.length; i++) {
          const key = storage.key(i);
          if (!key) continue;
          for (const pattern of keyPatterns) {
            if (key.includes(pattern)) {
              keysToRemove.push(key);
              break;
            }
          }
        }
        for (const key of keysToRemove) {
          storage.removeItem(key);
          cleaned++;
        }
      }
    } catch (error) {
      logger.error("StorageService.cleanup failed", "StorageService", error, { keyPatterns });
    }
    return cleaned;
  }
}
const storageService = new StorageService();
class CartService {
  constructor() {
    __publicField(this, "storageKey", "pixal-marketplace-cart");
    __publicField(this, "cart", []);
    __publicField(this, "listeners", []);
    this.loadCart();
  }
  // Load cart from storage with proper error handling
  loadCart() {
    try {
      this.cart = storageService.getJSON(this.storageKey, []);
    } catch (error) {
      ErrorMessageService.logError("CartService.loadCart", error);
      this.cart = [];
    }
  }
  // Save cart to storage with proper error handling
  saveCart() {
    try {
      const success = storageService.setJSON(this.storageKey, this.cart);
      if (!success) {
        ErrorMessageService.logError("CartService.saveCart", new Error("Failed to save cart to storage"), {
          storageKey: this.storageKey,
          cartSize: this.cart.length
        });
      }
      this.notifyListeners();
    } catch (error) {
      ErrorMessageService.logError("CartService.saveCart", error, { storageKey: this.storageKey, cartSize: this.cart.length });
    }
  }
  // Add listener for cart changes
  addListener(listener) {
    this.listeners.push(listener);
  }
  // Remove listener
  removeListener(listener) {
    this.listeners = this.listeners.filter((l) => l !== listener);
  }
  // Notify all listeners of cart changes
  notifyListeners() {
    this.listeners.forEach((listener) => listener([...this.cart]));
  }
  // Add item to cart
  addToCart(nft) {
    const existingIndex = this.cart.findIndex((item) => item.nft.asset_id === nft.asset_id);
    if (existingIndex !== -1) {
      return false;
    }
    const cartItem = {
      nft,
      addedAt: Date.now(),
      isAvailable: true,
      sale_id: nft.sale_id
    };
    this.cart.push(cartItem);
    this.saveCart();
    return true;
  }
  // Remove item from cart
  removeFromCart(assetId) {
    const initialLength = this.cart.length;
    this.cart = this.cart.filter((item) => item.nft.asset_id !== assetId);
    if (this.cart.length !== initialLength) {
      this.saveCart();
      return true;
    }
    return false;
  }
  // Check if item is in cart
  isInCart(assetId) {
    return this.cart.some((item) => item.nft.asset_id === assetId);
  }
  // Get cart items
  getCart() {
    return [...this.cart];
  }
  // Get cart count
  getCartCount() {
    return this.cart.length;
  }
  // Clear entire cart
  clearCart() {
    this.cart = [];
    this.saveCart();
  }
  // Remove unavailable items from cart
  cleanupUnavailableItems() {
    const initialLength = this.cart.length;
    this.cart = this.cart.filter((item) => item.isAvailable !== false);
    if (this.cart.length !== initialLength) {
      this.saveCart();
    }
  }
  // Calculate cart totals
  async calculateTotals() {
    const availableItems = this.cart.filter((item) => item.isAvailable !== false);
    let totalWAXValue = 0;
    availableItems.forEach((item) => {
      if (item.nft.price) {
        const waxAmount = parseFloat(item.nft.price.replace(" WAX", ""));
        if (!isNaN(waxAmount)) {
          totalWAXValue += waxAmount;
        }
      }
    });
    const totalWAX = `${totalWAXValue.toFixed(4)} WAX`;
    const totalUSD = await priceService.convertWaxToUSDAsync(totalWAX);
    return {
      totalWAX,
      totalUSD,
      itemCount: availableItems.length
    };
  }
  // Check availability of cart items using AtomicAssets API with batching
  async checkAvailability() {
    if (this.cart.length === 0) return;
    const { apiService: apiService2 } = await __vitePreload(async () => {
      const { apiService: apiService3 } = await Promise.resolve().then(() => api);
      return { apiService: apiService3 };
    }, true ? void 0 : void 0);
    try {
      const saleIds = this.cart.map((item) => item.sale_id).filter(Boolean);
      if (saleIds.length === 0) return;
      const url = `${apiService2.atomicMarketAPI}/atomicmarket/v1/sales?ids=${saleIds.join(",")}&state=1&limit=${saleIds.length}`;
      const response = await apiService2.fetchWithRetry(url);
      const data = await response.json();
      const activeSaleIds = new Set(
        data.success && data.data ? data.data.map((sale) => sale.sale_id) : []
      );
      for (const item of this.cart) {
        item.isAvailable = item.sale_id ? activeSaleIds.has(item.sale_id) : false;
      }
    } catch (error) {
      ErrorMessageService.logError("CartService.checkAvailability", error, { cartSize: this.cart.length });
      for (const item of this.cart) {
        item.isAvailable = false;
      }
    }
    this.saveCart();
  }
  // Toggle item selection (for multi-select functionality)
  toggleSelection(assetId) {
    const item = this.cart.find((item2) => item2.nft.asset_id === assetId);
    if (item) {
      item.selected = !item.selected;
      this.saveCart();
    }
  }
  // Select all available items
  selectAll() {
    this.cart.forEach((item) => {
      if (item.isAvailable !== false) {
        item.selected = true;
      }
    });
    this.saveCart();
  }
  // Deselect all items
  deselectAll() {
    this.cart.forEach((item) => {
      item.selected = false;
    });
    this.saveCart();
  }
  // Get selected items
  getSelectedItems() {
    return this.cart.filter((item) => item.selected === true);
  }
  // Get selected item count
  getSelectedCount() {
    return this.cart.filter((item) => item.selected === true).length;
  }
  // Remove selected items from cart
  removeSelectedItems() {
    this.cart = this.cart.filter((item) => item.selected !== true);
    this.saveCart();
  }
  // Check if item is selected
  isSelected(assetId) {
    const item = this.cart.find((item2) => item2.nft.asset_id === assetId);
    return item?.selected === true;
  }
}
const cartService = new CartService();
const DisplaySettingsContext = reactExports.createContext(void 0);
const DisplaySettingsProvider = ({ children }) => {
  const [settings, setSettings] = reactExports.useState(() => {
    return {
      showOtherCollections: JSON.parse(localStorage.getItem("showOtherCollections") || "true"),
      showWhitelistedOnly: JSON.parse(localStorage.getItem("showWhitelistedOnly") || "true"),
      enableAnimatedNFTs: JSON.parse(localStorage.getItem("enableAnimatedNFTs") || "true"),
      showExplicitContent: JSON.parse(localStorage.getItem("showExplicitContent") || "false"),
      blockNSFW: JSON.parse(localStorage.getItem("blockNSFW") || "false"),
      blockAI: JSON.parse(localStorage.getItem("blockAI") || "false"),
      showChatButton: JSON.parse(localStorage.getItem("showChatButton") || "true"),
      autoPlayVideos: JSON.parse(localStorage.getItem("autoPlayVideos") || "false"),
      muteVideos: JSON.parse(localStorage.getItem("muteVideos") || "true"),
      showVideoControls: JSON.parse(localStorage.getItem("showVideoControls") || "true"),
      showPricesInUSD: JSON.parse(localStorage.getItem("showPricesInUSD") || "true"),
      selectedCurrency: localStorage.getItem("selectedCurrency") || "USD",
      showRarityRankings: JSON.parse(localStorage.getItem("showRarityRankings") || "true")
    };
  });
  const updateSetting = (key, value) => {
    setSettings((prev) => {
      const newSettings = { ...prev, [key]: value };
      if (typeof value === "string") {
        localStorage.setItem(key, value);
      } else {
        localStorage.setItem(key, JSON.stringify(value));
      }
      return newSettings;
    });
  };
  const contextValue = {
    settings,
    updateSetting
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DisplaySettingsContext.Provider, { value: contextValue, children });
};
const useDisplaySettings = () => {
  const context = reactExports.useContext(DisplaySettingsContext);
  if (context === void 0) {
    throw new Error("useDisplaySettings must be used within a DisplaySettingsProvider");
  }
  return context;
};
class MonitoringService {
  constructor() {
    __publicField(this, "sessionId");
    __publicField(this, "userId");
    __publicField(this, "session");
    __publicField(this, "performanceMetrics", []);
    __publicField(this, "apiMetrics", []);
    __publicField(this, "errorReports", []);
    __publicField(this, "isEnabled", true);
    __publicField(this, "batchSize", 50);
    __publicField(this, "flushInterval", 3e4);
    // 30 seconds
    __publicField(this, "maxStoredMetrics", 1e3);
    __publicField(this, "pendingBatches", []);
    __publicField(this, "batchTimeout", null);
    this.sessionId = this.generateSessionId();
    this.session = {
      sessionId: this.sessionId,
      startTime: Date.now(),
      lastActivity: Date.now(),
      pageViews: 0,
      events: []
    };
    this.initializeMonitoring();
    this.startPerformanceObserver();
    this.setupErrorHandlers();
    this.startFlushTimer();
  }
  generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  initializeMonitoring() {
    if (typeof window !== "undefined" && window.performance) {
      window.addEventListener("load", () => {
        setTimeout(() => {
          this.trackPageLoadPerformance();
        }, 0);
      });
      document.addEventListener("visibilitychange", () => {
        this.trackEvent("page_visibility_change", {
          hidden: document.hidden
        });
      });
      this.setupUserInteractionTracking();
    }
  }
  startPerformanceObserver() {
    if (typeof window !== "undefined" && "PerformanceObserver" in window) {
      try {
        const navObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.entryType === "navigation") {
              this.trackNavigationTiming(entry);
            }
          }
        });
        navObserver.observe({ entryTypes: ["navigation"] });
        const resourceObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.entryType === "resource") {
              this.trackResourceTiming(entry);
            }
          }
        });
        resourceObserver.observe({ entryTypes: ["resource"] });
        const lcpObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.trackPerformanceMetric("largest_contentful_paint", entry.startTime);
          }
        });
        lcpObserver.observe({ entryTypes: ["largest-contentful-paint"] });
        const fidObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.trackPerformanceMetric("first_input_delay", entry.processingStart - entry.startTime);
          }
        });
        fidObserver.observe({ entryTypes: ["first-input"] });
      } catch (error) {
        log.warn("Performance Observer not fully supported", "MonitoringService.startPerformanceObserver", { error });
      }
    }
  }
  setupErrorHandlers() {
    if (typeof window !== "undefined") {
      window.addEventListener("error", (event) => {
        this.reportError(event.error || new Error(event.message), "global_error", {
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno
        });
      });
      window.addEventListener("unhandledrejection", (event) => {
        this.reportError(
          event.reason instanceof Error ? event.reason : new Error(String(event.reason)),
          "unhandled_promise_rejection"
        );
      });
    }
  }
  setupUserInteractionTracking() {
    if (typeof window !== "undefined") {
      document.addEventListener("click", (event) => {
        const target = event.target;
        if (target.matches('button, a, [role="button"], .clickable')) {
          this.trackEvent("user_click", {
            element: target.tagName.toLowerCase(),
            className: target.className,
            id: target.id,
            text: target.textContent?.slice(0, 50)
          });
        }
      });
      document.addEventListener("submit", (event) => {
        const form = event.target;
        this.trackEvent("form_submit", {
          formId: form.id,
          formClass: form.className,
          action: form.action
        });
      });
    }
  }
  startFlushTimer() {
    setInterval(() => {
      this.flushMetrics();
    }, this.flushInterval);
  }
  // Public API methods
  setUserId(userId) {
    this.userId = userId;
    this.session.userId = userId;
  }
  trackEvent(event, properties = {}) {
    if (!this.isEnabled) return;
    const userEvent = {
      event,
      properties,
      timestamp: Date.now(),
      userId: this.userId,
      sessionId: this.sessionId
    };
    this.session.events.push(userEvent);
    this.session.lastActivity = Date.now();
    this.addToBatch("events", userEvent);
    if (this.session.events.length > this.maxStoredMetrics) {
      this.session.events = this.session.events.slice(-this.maxStoredMetrics / 2);
    }
  }
  trackPerformanceMetric(name, value, context) {
    if (!this.isEnabled) return;
    const metric = {
      name,
      value,
      timestamp: Date.now(),
      context
    };
    this.performanceMetrics.push(metric);
    this.addToBatch("performance", metric);
    if (this.performanceMetrics.length > this.maxStoredMetrics) {
      this.performanceMetrics = this.performanceMetrics.slice(-this.maxStoredMetrics / 2);
    }
  }
  trackAPICall(endpoint, method, duration, status, success, retryCount) {
    if (!this.isEnabled) return;
    const apiMetric = {
      endpoint,
      method,
      duration,
      status,
      timestamp: Date.now(),
      success,
      retryCount
    };
    this.apiMetrics.push(apiMetric);
    this.addToBatch("api", apiMetric);
    if (duration > 5e3) {
      this.trackPerformanceMetric("slow_api_call", duration, {
        endpoint,
        method,
        status
      });
    }
    if (this.apiMetrics.length > this.maxStoredMetrics) {
      this.apiMetrics = this.apiMetrics.slice(-this.maxStoredMetrics / 2);
    }
  }
  reportError(error, context, additionalInfo) {
    if (!this.isEnabled) return;
    log.error(`${context}: ${error.message}`, "monitoringService.reportError", error, { ...additionalInfo });
    const errorReport = {
      error,
      context,
      additionalInfo,
      timestamp: Date.now(),
      userId: this.userId,
      sessionId: this.sessionId,
      userAgent: navigator.userAgent,
      url: window.location.href,
      stackTrace: error.stack
    };
    this.errorReports.push(errorReport);
    this.trackEvent("error_occurred", {
      context,
      errorName: error.name,
      errorMessage: error.message,
      ...additionalInfo
    });
    if (this.errorReports.length > this.maxStoredMetrics) {
      this.errorReports = this.errorReports.slice(-this.maxStoredMetrics / 2);
    }
  }
  // Performance tracking methods
  trackPageLoadPerformance() {
    if (!window.performance || !window.performance.timing) return;
    const timing = window.performance.timing;
    const navigation = window.performance.navigation;
    const pageLoadTime = timing.loadEventEnd - timing.navigationStart;
    const domContentLoadedTime = timing.domContentLoadedEventEnd - timing.navigationStart;
    const firstByteTime = timing.responseStart - timing.navigationStart;
    const domInteractiveTime = timing.domInteractive - timing.navigationStart;
    this.trackPerformanceMetric("page_load_time", pageLoadTime);
    this.trackPerformanceMetric("dom_content_loaded_time", domContentLoadedTime);
    this.trackPerformanceMetric("first_byte_time", firstByteTime);
    this.trackPerformanceMetric("dom_interactive_time", domInteractiveTime);
    this.trackEvent("page_load", {
      pageLoadTime,
      domContentLoadedTime,
      firstByteTime,
      domInteractiveTime,
      navigationType: navigation.type,
      redirectCount: navigation.redirectCount
    });
  }
  trackNavigationTiming(entry) {
    this.trackPerformanceMetric("dns_lookup_time", entry.domainLookupEnd - entry.domainLookupStart);
    this.trackPerformanceMetric("tcp_connect_time", entry.connectEnd - entry.connectStart);
    this.trackPerformanceMetric("request_response_time", entry.responseEnd - entry.requestStart);
    this.trackPerformanceMetric("dom_processing_time", entry.domComplete - entry.domContentLoadedEventStart);
  }
  trackResourceTiming(entry) {
    if (entry.name.includes(".js") || entry.name.includes(".css") || entry.name.includes("api")) {
      this.trackPerformanceMetric("resource_load_time", entry.duration, {
        resource: entry.name,
        type: entry.initiatorType,
        size: entry.transferSize
      });
    }
  }
  // Analytics and reporting methods
  getSessionSummary() {
    return {
      ...this.session,
      events: [...this.session.events]
    };
  }
  getPerformanceMetrics() {
    return [...this.performanceMetrics];
  }
  getAPIMetrics() {
    return [...this.apiMetrics];
  }
  getErrorReports() {
    return [...this.errorReports];
  }
  // Data export and external service integration
  async flushMetrics() {
    if (!this.isEnabled) return;
    const data = {
      session: this.getSessionSummary(),
      performance: this.getPerformanceMetrics(),
      api: this.getAPIMetrics(),
      errors: this.getErrorReports(),
      timestamp: Date.now()
    };
    try {
      const existingData = JSON.parse(localStorage.getItem("monitoring_data") || "[]");
      existingData.push(data);
      const recentData = existingData.slice(-10);
      localStorage.setItem("monitoring_data", JSON.stringify(recentData));
    } catch (error) {
      log.warn("Failed to store monitoring data", "MonitoringService.flushMetrics", { error });
    }
    this.performanceMetrics = [];
    this.apiMetrics = [];
    this.errorReports = [];
    this.session.events = [];
  }
  // Configuration methods
  enable() {
    this.isEnabled = true;
  }
  disable() {
    this.isEnabled = false;
  }
  isMonitoringEnabled() {
    return this.isEnabled;
  }
  setBatchSize(size) {
    this.batchSize = Math.max(10, Math.min(size, 200));
  }
  /**
   * Add data to batch for processing
   */
  addToBatch(type, data) {
    if (!this.isEnabled) return;
    let batch = this.pendingBatches.find((b) => b.type === type);
    if (!batch) {
      batch = {
        type,
        data: [],
        timestamp: Date.now()
      };
      this.pendingBatches.push(batch);
    }
    batch.data.push(data);
    if (batch.data.length >= this.batchSize) {
      this.processBatch(batch);
      this.pendingBatches = this.pendingBatches.filter((b) => b !== batch);
    }
    this.scheduleBatchProcessing();
  }
  /**
   * Schedule batch processing
   */
  scheduleBatchProcessing() {
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
    }
    this.batchTimeout = setTimeout(() => {
      this.processAllPendingBatches();
    }, 5e3);
  }
  /**
   * Process a single batch
   */
  async processBatch(batch) {
    try {
      const batchData = {
        ...batch,
        batchId: this.generateBatchId(),
        processedAt: Date.now()
      };
      const existingBatches = JSON.parse(localStorage.getItem("monitoring_batches") || "[]");
      existingBatches.push(batchData);
      const recentBatches = existingBatches.slice(-20);
      localStorage.setItem("monitoring_batches", JSON.stringify(recentBatches));
    } catch (error) {
      console.warn("Failed to process batch:", error);
    }
  }
  /**
   * Process all pending batches
   */
  async processAllPendingBatches() {
    const batches = [...this.pendingBatches];
    this.pendingBatches = [];
    for (const batch of batches) {
      await this.processBatch(batch);
    }
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }
  }
  /**
   * Generate unique batch ID
   */
  generateBatchId() {
    return `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  setFlushInterval(interval) {
    this.flushInterval = Math.max(5e3, Math.min(interval, 3e5));
  }
  // Utility methods for external service integration
  async exportData() {
    const data = {
      session: this.getSessionSummary(),
      performance: this.getPerformanceMetrics(),
      api: this.getAPIMetrics(),
      errors: this.getErrorReports()
    };
    return JSON.stringify(data, null, 2);
  }
  clearAllData() {
    this.performanceMetrics = [];
    this.apiMetrics = [];
    this.errorReports = [];
    this.session.events = [];
    localStorage.removeItem("monitoring_data");
  }
}
const monitoringService = new MonitoringService();
class CacheService {
  constructor(config = {}) {
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    __publicField(this, "config");
    __publicField(this, "cleanupTimer", null);
    this.config = {
      defaultTTL: 5 * 60 * 1e3,
      // 5 minutes
      maxSize: 1e3,
      cleanupInterval: 60 * 1e3,
      // 1 minute
      ...config
    };
    this.startCleanup();
  }
  startCleanup() {
    this.cleanupTimer = setInterval(() => {
      this.cleanup();
    }, this.config.cleanupInterval);
  }
  cleanup() {
    const now = Date.now();
    const keysToDelete = [];
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > entry.ttl) {
        keysToDelete.push(key);
      }
    }
    keysToDelete.forEach((key) => this.cache.delete(key));
    if (this.cache.size > this.config.maxSize) {
      const entries = Array.from(this.cache.entries()).sort(([, a], [, b]) => a.timestamp - b.timestamp);
      const toRemove = entries.slice(0, this.cache.size - this.config.maxSize);
      toRemove.forEach(([key]) => this.cache.delete(key));
    }
  }
  set(key, data, ttl) {
    const entry = {
      data,
      timestamp: Date.now(),
      ttl: ttl || this.config.defaultTTL
    };
    this.cache.set(key, entry);
  }
  get(key) {
    const entry = this.cache.get(key);
    if (!entry) {
      return null;
    }
    const now = Date.now();
    if (now - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }
    return entry.data;
  }
  has(key) {
    const entry = this.cache.get(key);
    if (!entry) return false;
    const now = Date.now();
    if (now - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return false;
    }
    return true;
  }
  delete(key) {
    return this.cache.delete(key);
  }
  clear() {
    this.cache.clear();
  }
  // Cache with fetch pattern
  async getOrFetch(key, fetchFn, ttl) {
    const cached = this.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = await fetchFn();
    this.set(key, data, ttl);
    return data;
  }
  // Batch operations
  setMany(entries) {
    entries.forEach(({ key, data, ttl }) => {
      this.set(key, data, ttl);
    });
  }
  getMany(keys) {
    return keys.map((key) => ({
      key,
      data: this.get(key)
    }));
  }
  // Statistics
  getStats() {
    const now = Date.now();
    let validEntries = 0;
    let expiredEntries = 0;
    for (const entry of this.cache.values()) {
      if (now - entry.timestamp > entry.ttl) {
        expiredEntries++;
      } else {
        validEntries++;
      }
    }
    return {
      totalEntries: this.cache.size,
      validEntries,
      expiredEntries,
      hitRate: validEntries / (validEntries + expiredEntries) || 0
    };
  }
  destroy() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
    this.clear();
  }
}
const cacheService = new CacheService({
  defaultTTL: 5 * 60 * 1e3,
  // 5 minutes for general data
  maxSize: 1e3,
  cleanupInterval: 60 * 1e3
});
const assetCache = new CacheService({
  defaultTTL: 10 * 60 * 1e3,
  // 10 minutes for asset data
  maxSize: 500,
  cleanupInterval: 2 * 60 * 1e3
});
const collectionCache = new CacheService({
  defaultTTL: 30 * 60 * 1e3,
  // 30 minutes for collection data
  maxSize: 200,
  cleanupInterval: 5 * 60 * 1e3
});
const userCache = new CacheService({
  defaultTTL: 2 * 60 * 1e3,
  // 2 minutes for user data
  maxSize: 100,
  cleanupInterval: 30 * 1e3
});
class ApiEndpointManager {
  constructor() {
    __publicField(this, "endpointGroups", /* @__PURE__ */ new Map());
    __publicField(this, "HEALTH_CHECK_TIMEOUT", 5e3);
    // 5 seconds
    __publicField(this, "MAX_CONSECUTIVE_FAILURES", 3);
    __publicField(this, "HEALTH_CHECK_INTERVAL", 3e5);
    // 5 minutes
    __publicField(this, "healthCheckTimers", /* @__PURE__ */ new Map());
    this.initializeEndpointGroups();
    this.startHealthChecks();
  }
  initializeEndpointGroups() {
    this.endpointGroups.set("atomic", {
      name: "atomic",
      currentIndex: 0,
      fallbackStrategy: "priority",
      healthCheckInterval: this.HEALTH_CHECK_INTERVAL,
      endpoints: [
        {
          url: "https://atomic.wax.eosrio.io",
          priority: 1,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 3
        },
        {
          url: "https://wax-atomic.alcor.exchange",
          priority: 2,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 3
        },
        {
          url: "https://atomic-wax-mainnet.wecan.dev",
          priority: 3,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 3
        },
        {
          url: "https://wax.eosusa.io",
          priority: 4,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 3
        }
      ]
    });
    this.endpointGroups.set("waxChain", {
      name: "waxChain",
      currentIndex: 0,
      fallbackStrategy: "priority",
      healthCheckInterval: this.HEALTH_CHECK_INTERVAL,
      endpoints: [
        {
          url: "https://wax.eosphere.io",
          priority: 1,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 3
        },
        {
          url: "https://wax.eosrio.io",
          priority: 2,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 3
        },
        {
          url: "https://api.wax.alohaeos.com",
          priority: 3,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 3
        }
      ]
    });
    this.endpointGroups.set("hyperion", {
      name: "hyperion",
      currentIndex: 0,
      fallbackStrategy: "fastest",
      healthCheckInterval: this.HEALTH_CHECK_INTERVAL,
      endpoints: [
        {
          url: "https://wax.eosrio.io",
          priority: 1,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 2
        },
        {
          url: "https://api.wax.alohaeos.com",
          priority: 2,
          healthStatus: "healthy",
          lastHealthCheck: 0,
          consecutiveFailures: 0,
          averageResponseTime: 0,
          maxRetries: 2
        }
      ]
    });
  }
  /**
   * Get the best available endpoint for a group
   */
  getBestEndpoint(groupName) {
    const group = this.endpointGroups.get(groupName);
    if (!group) return null;
    const healthyEndpoints = group.endpoints.filter((ep) => ep.healthStatus === "healthy");
    if (healthyEndpoints.length === 0) {
      const degradedEndpoints = group.endpoints.filter((ep) => ep.healthStatus === "degraded");
      if (degradedEndpoints.length > 0) {
        return this.selectEndpoint(degradedEndpoints, group.fallbackStrategy);
      }
      return group.endpoints[0]?.url || null;
    }
    return this.selectEndpoint(healthyEndpoints, group.fallbackStrategy);
  }
  selectEndpoint(endpoints, strategy) {
    switch (strategy) {
      case "priority":
        return endpoints.sort((a, b) => a.priority - b.priority)[0].url;
      case "fastest":
        return endpoints.sort((a, b) => a.averageResponseTime - b.averageResponseTime)[0].url;
      case "round-robin":
      default:
        return endpoints[Math.floor(Math.random() * endpoints.length)].url;
    }
  }
  /**
   * Report endpoint failure to update health status
   */
  reportFailure(groupName, endpointUrl) {
    const group = this.endpointGroups.get(groupName);
    if (!group) return;
    const endpoint = group.endpoints.find((ep) => ep.url === endpointUrl);
    if (!endpoint) return;
    endpoint.consecutiveFailures++;
    if (endpoint.consecutiveFailures >= this.MAX_CONSECUTIVE_FAILURES) {
      endpoint.healthStatus = "unhealthy";
    } else if (endpoint.consecutiveFailures >= 1) {
      endpoint.healthStatus = "degraded";
    }
  }
  /**
   * Report successful endpoint response
   */
  reportSuccess(groupName, endpointUrl, responseTime) {
    const group = this.endpointGroups.get(groupName);
    if (!group) return;
    const endpoint = group.endpoints.find((ep) => ep.url === endpointUrl);
    if (!endpoint) return;
    endpoint.consecutiveFailures = 0;
    endpoint.healthStatus = "healthy";
    if (endpoint.averageResponseTime === 0) {
      endpoint.averageResponseTime = responseTime;
    } else {
      endpoint.averageResponseTime = endpoint.averageResponseTime * 0.8 + responseTime * 0.2;
    }
  }
  /**
   * Get all endpoints for a group (for backward compatibility)
   */
  getEndpoints(groupName) {
    const group = this.endpointGroups.get(groupName);
    return group ? group.endpoints.map((ep) => ep.url) : [];
  }
  /**
   * Get current endpoint index for a group
   */
  getCurrentIndex(groupName) {
    const group = this.endpointGroups.get(groupName);
    return group ? group.currentIndex : 0;
  }
  /**
   * Set current endpoint index for a group
   */
  setCurrentIndex(groupName, index) {
    const group = this.endpointGroups.get(groupName);
    if (group && index >= 0 && index < group.endpoints.length) {
      group.currentIndex = index;
    }
  }
  /**
   * Start periodic health checks
   */
  startHealthChecks() {
    for (const [groupName, group] of this.endpointGroups) {
      const timer = setInterval(() => {
        this.performHealthCheck(groupName);
      }, group.healthCheckInterval);
      this.healthCheckTimers.set(groupName, timer);
    }
  }
  /**
   * Perform health check for a group
   */
  async performHealthCheck(groupName) {
    const group = this.endpointGroups.get(groupName);
    if (!group) return;
    const healthCheckPromises = group.endpoints.map(async (endpoint) => {
      try {
        const startTime = Date.now();
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.HEALTH_CHECK_TIMEOUT);
        const response = await fetch(`${endpoint.url}/health`, {
          method: "GET",
          signal: controller.signal,
          headers: { "Accept": "application/json" }
        });
        clearTimeout(timeoutId);
        const responseTime = Date.now() - startTime;
        endpoint.lastHealthCheck = Date.now();
        if (response.ok) {
          this.reportSuccess(groupName, endpoint.url, responseTime);
        } else {
          this.reportFailure(groupName, endpoint.url);
        }
      } catch {
        endpoint.lastHealthCheck = Date.now();
        this.reportFailure(groupName, endpoint.url);
      }
    });
    await Promise.allSettled(healthCheckPromises);
  }
  /**
   * Get health status for all endpoint groups
   */
  getHealthStatus() {
    const status = {};
    for (const [groupName, group] of this.endpointGroups) {
      status[groupName] = {
        healthy: group.endpoints.filter((ep) => ep.healthStatus === "healthy").length,
        degraded: group.endpoints.filter((ep) => ep.healthStatus === "degraded").length,
        unhealthy: group.endpoints.filter((ep) => ep.healthStatus === "unhealthy").length
      };
    }
    return status;
  }
  /**
   * Cleanup timers on service destruction
   */
  destroy() {
    for (const timer of this.healthCheckTimers.values()) {
      clearInterval(timer);
    }
    this.healthCheckTimers.clear();
  }
}
const apiEndpointManager = new ApiEndpointManager();
class ApiService {
  constructor() {
    // Multiple API endpoints for redundancy and fallback support
    // Updated: Removed failing endpoints based on health checks
    __publicField(this, "atomicEndpoints", [...API_ENDPOINTS.ATOMIC_ASSETS]);
    __publicField(this, "hiveBPAPI", API_ENDPOINTS.WAX_CHAIN.HIVEBP);
    // WAX Light API endpoint
    __publicField(this, "waxLightAPI", API_ENDPOINTS.WAX_CHAIN.LIGHT_API);
    // Alcor Exchange API endpoint - WAX specific
    __publicField(this, "alcorAPI", API_ENDPOINTS.SPECIALIZED.ALCOR);
    // WAX Chain API endpoints
    // Updated: Prioritize working endpoints, keep others as fallbacks
    __publicField(this, "waxChainEndpoints", [...API_ENDPOINTS.WAX_CHAIN.FALLBACK_ENDPOINTS]);
    // WAX Hyperion History API endpoints
    __publicField(this, "hyperionEndpoints", API_ENDPOINTS.WAX_CHAIN.HYPERION_ENDPOINTS);
    __publicField(this, "currentEndpointIndex", 0);
    __publicField(this, "currentWaxChainIndex", 0);
    __publicField(this, "currentHyperionIndex", 0);
    __publicField(this, "adaptiveLimits", /* @__PURE__ */ new Map());
    // Track optimal limits per endpoint
    // Optimized cache configuration
    __publicField(this, "DEFAULT_CACHE_TTL", 3e5);
    __publicField(this, "approvedCollections", [
      "pixeljourney",
      "friedfactory"
    ]);
    // Circuit breaker state management
    __publicField(this, "circuitBreakerState", /* @__PURE__ */ new Map());
    __publicField(this, "CIRCUIT_BREAKER_THRESHOLD", 5);
    __publicField(this, "CIRCUIT_BREAKER_TIMEOUT", 6e4);
    // 1 minute
    __publicField(this, "MAX_TIMEOUT", 3e4);
    // 30 seconds
    // Health check management
    __publicField(this, "endpointHealth", /* @__PURE__ */ new Map());
    __publicField(this, "HEALTH_CHECK_INTERVAL", 3e5);
    // 5 minutes
    __publicField(this, "MAX_CONSECUTIVE_FAILURES", 3);
    __publicField(this, "healthCheckIntervalId", null);
    __publicField(this, "healthConfigs", /* @__PURE__ */ new Map());
    // EOS Nation endpoint validation data
    __publicField(this, "eosNationEndpoints", {
      atomicEndpoints: [],
      waxChainEndpoints: [],
      hyperionEndpoints: [],
      lastUpdated: 0
    });
    __publicField(this, "EOS_NATION_UPDATE_INTERVAL", 36e5);
    // Top WAX collections whitelist for better performance and reliability
    __publicField(this, "COLLECTION_WHITELIST", [
      "alien.worlds",
      "defiminingio",
      "pixeljourney",
      "crptomuffins",
      "kogsofficial",
      "mlb.topps",
      "gpk.topps",
      // 'warsaken', 'pocketsizedp', 'taco', // Removed problematic collections
      "pantheon",
      "cbreakgaming",
      "akufishheads",
      "battleminers",
      "twitchytides",
      "novopangeaio",
      "fadedmonsuta",
      "bcbrawlers",
      "nftopiafrens",
      "drwawncompany",
      "talesofcrypt",
      "official.wax",
      "music.worlds",
      "gkniftyheads",
      "dungeonitems",
      "outlawtroops",
      "byronartset1",
      "prospectorsg",
      "street.hero",
      "crewtoonswax"
    ]);
    this.currentEndpointIndex = 0;
    this.currentWaxChainIndex = 0;
    this.currentHyperionIndex = 0;
    this.initializeHealthConfigs();
  }
  // 5 minutes in milliseconds
  get waxChainAPI() {
    return apiEndpointManager.getBestEndpoint("waxChain") || this.waxChainEndpoints[this.currentWaxChainIndex];
  }
  get atomicMarketAPI() {
    return this.atomicEndpoints[this.currentEndpointIndex];
  }
  get atomicAssetsAPI() {
    return this.atomicEndpoints[this.currentEndpointIndex];
  }
  /**
   * Get current healthy atomic endpoint with intelligent load balancing
   */
  getCurrentAtomicEndpoint() {
    const bestEndpoint = apiEndpointManager.getBestEndpoint("atomic");
    if (bestEndpoint) {
      return bestEndpoint;
    }
    const healthyEndpoints = this.getHealthyEndpoints(this.atomicEndpoints);
    if (healthyEndpoints.length > 0) {
      const healthyEndpoint = healthyEndpoints[0];
      this.currentEndpointIndex = this.atomicEndpoints.indexOf(healthyEndpoint);
      return healthyEndpoint;
    }
    return this.atomicEndpoints[this.currentEndpointIndex] || this.atomicEndpoints[0];
  }
  // Enhanced cache helper methods
  getFromCache(key) {
    if (key.startsWith("asset_")) {
      return assetCache.get(key);
    } else if (key.startsWith("collection_")) {
      return collectionCache.get(key);
    } else if (key.startsWith("user_")) {
      return userCache.get(key);
    }
    return cacheService.get(key);
  }
  setCache(key, data, ttl = this.DEFAULT_CACHE_TTL) {
    if (key.startsWith("asset_")) {
      assetCache.set(key, data, ttl);
    } else if (key.startsWith("collection_")) {
      collectionCache.set(key, data, ttl);
    } else if (key.startsWith("user_")) {
      userCache.set(key, data, ttl);
    } else {
      cacheService.set(key, data, ttl);
    }
  }
  // Legacy cache cleanup method removed - handled by centralized cache service
  /**
   * Report endpoint health status to the endpoint manager
   */
  reportEndpointHealth(url, success, responseTime) {
    try {
      const urlObj = new URL(url);
      const baseUrl = `${urlObj.protocol}//${urlObj.host}`;
      let groupName = "atomic";
      if (url.includes("wax.eosphere.io") || url.includes("wax.eosrio.io") || url.includes("api.wax.alohaeos.com")) {
        if (url.includes("/v2/history") || url.includes("/v1/history")) {
          groupName = "hyperion";
        } else {
          groupName = "waxChain";
        }
      }
      if (success && responseTime !== void 0) {
        apiEndpointManager.reportSuccess(groupName, baseUrl, responseTime);
      } else if (!success) {
        apiEndpointManager.reportFailure(groupName, baseUrl);
      }
    } catch (error) {
      logger.warn("Failed to report endpoint health:", "ApiService.reportEndpointHealth", error);
    }
  }
  /**
   * Get cache statistics for monitoring (aggregated from centralized cache service)
   */
  getCacheStats() {
    const assetStats = assetCache.getStats();
    const collectionStats = collectionCache.getStats();
    const userStats = userCache.getStats();
    const generalStats = cacheService.getStats();
    return {
      totalEntries: assetStats.totalEntries + collectionStats.totalEntries + userStats.totalEntries + generalStats.totalEntries,
      validEntries: assetStats.validEntries + collectionStats.validEntries + userStats.validEntries + generalStats.validEntries,
      expiredEntries: assetStats.expiredEntries + collectionStats.expiredEntries + userStats.expiredEntries + generalStats.expiredEntries,
      hitRate: (assetStats.hitRate + collectionStats.hitRate + userStats.hitRate + generalStats.hitRate) / 4
    };
  }
  /**
    * Clear all cache entries (using centralized cache service)
    */
  clearCache() {
    assetCache.clear();
    collectionCache.clear();
    userCache.clear();
    cacheService.clear();
  }
  /**
   * Warm up cache with commonly accessed data
   */
  async warmupCache(account) {
    try {
      const warmupTasks = [];
      const topCollections = this.approvedCollections.slice(0, 5);
      for (const collection of topCollections) {
        warmupTasks.push(
          this.getCollectionStats(collection).catch(
            (error) => ErrorMessageService.logError("ApiService.warmupCache.collectionStats", error, { collection })
          )
        );
      }
      warmupTasks.push(
        this.getMarketStats().catch(
          (error) => ErrorMessageService.logError("ApiService.warmupCache.marketStats", error)
        )
      );
      if (account) {
        warmupTasks.push(
          this.getUserInventoryOverview(account).catch(
            (error) => ErrorMessageService.logError("ApiService.warmupCache.userInventory", error, { account })
          )
        );
      }
      await Promise.allSettled(warmupTasks);
    } catch (error) {
      ErrorMessageService.logError("ApiService.warmupCache", error);
    }
  }
  /**
   * Intelligent prefetching based on user behavior patterns
   */
  async prefetchData(context) {
    try {
      const prefetchTasks = [];
      if (context.currentPage === "marketplace") {
        prefetchTasks.push(
          this.getPxApprovedListings(100, 100).catch(
            (error) => ErrorMessageService.logError("ApiService.prefetch.marketplaceAssets", error)
          )
        );
      }
      if (context.currentPage === "inventory" && context.userAccount) {
        prefetchTasks.push(
          this.getUserInventoryOptimized(context.userAccount, { page: 2 }).catch(
            (error) => ErrorMessageService.logError("ApiService.prefetch.userInventory", error, { account: context.userAccount })
          )
        );
      }
      if (context.recentCollections) {
        for (const collection of context.recentCollections.slice(0, 3)) {
          prefetchTasks.push(
            this.getCollectionStats(collection).catch(
              (error) => ErrorMessageService.logError("ApiService.prefetch.recentCollection", error, { collection })
            )
          );
        }
      }
      setTimeout(() => {
        Promise.allSettled(prefetchTasks);
      }, 1e3);
    } catch (error) {
      ErrorMessageService.logError("ApiService.prefetchData", error);
    }
  }
  /**
   * Cache invalidation for specific data types (using centralized cache service)
   */
  invalidateCache(pattern) {
    if (typeof pattern === "string") {
      assetCache.clear();
      collectionCache.clear();
      userCache.clear();
      cacheService.clear();
    } else {
      assetCache.clear();
      collectionCache.clear();
      userCache.clear();
      cacheService.clear();
    }
  }
  getAdaptiveLimit(baseUrl, requestedLimit) {
    const key = new URL(baseUrl).hostname;
    const storedLimit = this.adaptiveLimits.get(key);
    if (storedLimit) {
      return Math.min(requestedLimit, storedLimit, 100);
    }
    return Math.min(requestedLimit, 100);
  }
  updateAdaptiveLimit(baseUrl, limit, success) {
    const key = new URL(baseUrl).hostname;
    if (!success) {
      const newLimit = Math.max(Math.floor(limit * 0.7), 20);
      this.adaptiveLimits.set(key, newLimit);
    } else if (limit < 100) {
      const currentLimit = this.adaptiveLimits.get(key) || limit;
      const newLimit = Math.min(Math.floor(currentLimit * 1.1), 100);
      this.adaptiveLimits.set(key, newLimit);
    }
  }
  // /**
  //  * Start periodic cache maintenance
  //  */
  // private startCacheMaintenance(): void {
  //   // Clean expired cache entries every 5 minutes
  //   setInterval(() => {
  //     this.clearExpiredCache()
  //   }, 5 * 60 * 1000)
  //   // Cache optimization is now handled by centralized cache services
  //   // Each cache service manages its own cleanup and eviction policies
  // }
  // Separate fetch method for Alcor Exchange API calls
  async fetchAlcorAPI(url, retries = 3, options) {
    let lastError = null;
    const startTime = Date.now();
    const method = options?.method || "GET";
    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(url, {
          method,
          headers: {
            "Accept": "application/json",
            "Content-Type": "application/json",
            ...options?.headers
          },
          mode: "cors",
          signal: options?.signal,
          ...options
        });
        const duration = Date.now() - startTime;
        if (response.ok) {
          monitoringService.trackAPICall(url, method, duration, response.status, true, i);
          return response;
        }
        lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
        if (i < retries - 1) {
          await new Promise((resolve) => setTimeout(resolve, 1e3 * (i + 1)));
        } else {
          monitoringService.trackAPICall(url, method, duration, response.status, false, i);
        }
      } catch (error) {
        const duration = Date.now() - startTime;
        lastError = error;
        if (i === retries - 1) {
          monitoringService.trackAPICall(url, method, duration, 0, false, i);
          monitoringService.reportError(lastError, "alcor_api_error", { url, method, retries: i + 1 });
        }
        if (error instanceof Error && error.name === "AbortError") {
          monitoringService.reportError(error, "alcor_api_abort", { url, method });
          throw error;
        }
        if (i < retries - 1) {
          await new Promise((resolve) => setTimeout(resolve, 1e3 * (i + 1)));
        }
      }
    }
    throw lastError || new Error("Failed to fetch from Alcor Exchange API");
  }
  /**
   * Initialize health configurations for all endpoints
   */
  initializeHealthConfigs() {
    this.healthConfigs.clear();
    this.getValidatedEndpoints("atomic").forEach((ep) => {
      this.healthConfigs.set(ep, {
        path: "/atomicassets/v1/collections?limit=1",
        validator: (data) => {
          const atomicData = data;
          return Array.isArray(atomicData.data) && atomicData.success === true;
        }
      });
    });
    this.getValidatedEndpoints("waxChain").forEach((ep) => {
      this.healthConfigs.set(ep, {
        path: "/v1/chain/get_info",
        validator: (data) => {
          const chainData = data;
          return typeof chainData.head_block_num === "number" && chainData.head_block_num > 0;
        }
      });
    });
    this.getValidatedEndpoints("hyperion").forEach((ep) => {
      this.healthConfigs.set(ep, {
        path: "/v2/health",
        validator: (data) => {
          const healthData = data;
          return healthData.health && (typeof healthData.health === "object" && healthData.health.status === "OK") || healthData.health === "OK";
        }
      });
    });
    logger.info(`[Health Config] Initialized configurations for ${this.healthConfigs.size} endpoints`);
  }
  // 1 hour
  getCircuitBreakerKey(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname;
    } catch {
      return url;
    }
  }
  isCircuitBreakerOpen(key) {
    const state = this.circuitBreakerState.get(key);
    if (!state) return false;
    if (state.state === "open") {
      if (Date.now() - state.lastFailure > this.CIRCUIT_BREAKER_TIMEOUT) {
        state.state = "half-open";
        return false;
      }
      return true;
    }
    return false;
  }
  recordCircuitBreakerFailure(key) {
    const state = this.circuitBreakerState.get(key) || {
      failures: 0,
      lastFailure: 0,
      state: "closed"
    };
    state.failures++;
    state.lastFailure = Date.now();
    if (state.failures >= this.CIRCUIT_BREAKER_THRESHOLD) {
      state.state = "open";
    }
    this.circuitBreakerState.set(key, state);
  }
  recordCircuitBreakerSuccess(key) {
    const state = this.circuitBreakerState.get(key);
    if (state) {
      state.failures = 0;
      state.state = "closed";
      this.circuitBreakerState.set(key, state);
    }
  }
  /**
   * Update endpoint health status
   */
  updateEndpointHealth(endpointKey, success, responseTime) {
    let health = this.endpointHealth.get(endpointKey);
    if (!health) {
      health = {
        isHealthy: true,
        lastCheck: Date.now(),
        consecutiveFailures: 0,
        responseTime: 0
      };
      this.endpointHealth.set(endpointKey, health);
    }
    health.lastCheck = Date.now();
    if (success) {
      health.consecutiveFailures = 0;
      health.isHealthy = true;
      health.responseTime = responseTime;
    } else {
      health.consecutiveFailures++;
      if (health.consecutiveFailures >= this.MAX_CONSECUTIVE_FAILURES) {
        health.isHealthy = false;
      }
    }
    this.endpointHealth.set(endpointKey, health);
  }
  /**
   * Check if endpoint is healthy
   */
  isEndpointHealthy(endpointKey) {
    const health = this.endpointHealth.get(endpointKey);
    if (!health) return true;
    const timeSinceLastCheck = Date.now() - health.lastCheck;
    if (timeSinceLastCheck > this.HEALTH_CHECK_INTERVAL * 2) {
      return false;
    }
    return health.isHealthy;
  }
  /**
   * Perform periodic health checks on endpoints
   */
  async performHealthCheck(endpoint) {
    const endpointKey = this.getCircuitBreakerKey(endpoint);
    const config = this.healthConfigs.get(endpoint) || { path: "", fallback: true };
    const healthCheckUrl = config.path ? `${endpoint}${config.path}` : endpoint;
    try {
      const startTime = Date.now();
      const response = await fetch(healthCheckUrl, {
        method: config.path ? "GET" : "HEAD",
        // HEAD for root fallback
        signal: AbortSignal.timeout(1e4),
        // Bump for reliability
        headers: { "Accept": "application/json" }
      });
      let isHealthy = response.ok;
      const duration = Date.now() - startTime;
      if (response.ok && config.validator) {
        const data = await response.json();
        isHealthy = config.validator(data);
        const currentHealth = this.endpointHealth.get(endpointKey);
        if (!isHealthy || currentHealth && currentHealth.consecutiveFailures > 0) {
          logger.info(`[HealthCheck] ${endpoint}:`, "ApiService.performHealthCheck", { healthy: isHealthy, duration: `${duration}ms` });
        }
      }
      this.updateEndpointHealth(endpointKey, isHealthy, duration);
      if (!isHealthy) {
        logger.warn(`[HealthCheck] ${endpoint} failed validation`);
      }
    } catch (error) {
      logger.error(`[HealthCheck] ${endpoint} error:`, "ApiService.performHealthCheck", error);
      this.updateEndpointHealth(endpointKey, false, 0);
    }
  }
  /**
   * Start periodic health checks for all endpoints
   */
  startHealthChecks() {
    if (this.healthCheckIntervalId) {
      clearInterval(this.healthCheckIntervalId);
      this.healthCheckIntervalId = null;
    }
    this.healthCheckIntervalId = setInterval(() => {
      logger.info("[HealthCheck] Starting periodic health check cycle...");
      this.getValidatedEndpoints("atomic").forEach((endpoint) => {
        this.performHealthCheck(endpoint);
      });
      this.getValidatedEndpoints("waxChain").forEach((endpoint) => {
        this.performHealthCheck(endpoint);
      });
      this.getValidatedEndpoints("hyperion").forEach((endpoint) => {
        this.performHealthCheck(endpoint);
      });
      logger.info("[HealthCheck] Completed periodic health check cycle");
    }, this.HEALTH_CHECK_INTERVAL);
    this.updateEosNationEndpoints();
  }
  /**
   * Stop health checks to prevent memory leaks
   */
  stopHealthChecks() {
    if (this.healthCheckIntervalId) {
      clearInterval(this.healthCheckIntervalId);
      this.healthCheckIntervalId = null;
      logger.info("[HealthCheck] Health check interval stopped");
    }
  }
  /**
   * Manually start health checks if needed
   */
  enableHealthChecks() {
    logger.info("[HealthCheck] Enabling health checks...");
    this.startHealthChecks();
  }
  /**
   * Fetch and update endpoint data from EOS Nation validator
   */
  async updateEosNationEndpoints() {
    try {
      const now = Date.now();
      if (now - this.eosNationEndpoints.lastUpdated < this.EOS_NATION_UPDATE_INTERVAL) {
        return;
      }
      logger.info("[EOS Nation] Fetching latest endpoint data...");
      const response = await fetch("https://validate.eosnation.io/wax/reports/endpoints.json", {
        method: "GET",
        headers: { "Accept": "application/json" },
        signal: AbortSignal.timeout(1e4)
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      if (!data || typeof data !== "object") {
        throw new Error("Invalid JSON response from EOS Nation API");
      }
      if (!data.report || typeof data.report !== "object") {
        logger.warn("[EOS Nation] No report data found in response:", data);
        throw new Error("Invalid response format from EOS Nation API");
      }
      const eosNationData = data;
      const report = eosNationData.report;
      const atomicEndpoints = this.parseEosNationEndpoints(report.atomic_https || []);
      const waxChainEndpoints = this.parseEosNationEndpoints(report.api_https2 || []);
      const hyperionEndpoints = this.parseEosNationEndpoints(report.hyperion_https || []);
      logger.info("[EOS Nation] Raw endpoint counts:", "ApiService.updateEosNationEndpoints", {
        atomic_https: Array.isArray(report.atomic_https) ? report.atomic_https.length : "not array",
        api_https2: Array.isArray(report.api_https2) ? report.api_https2.length : "not array",
        hyperion_https: Array.isArray(report.hyperion_https) ? report.hyperion_https.length : "not array"
      });
      this.eosNationEndpoints = {
        atomicEndpoints,
        waxChainEndpoints,
        hyperionEndpoints,
        lastUpdated: now
      };
      logger.info(`[EOS Nation] Updated endpoints: ${atomicEndpoints.length} atomic, ${waxChainEndpoints.length} wax chain, ${hyperionEndpoints.length} hyperion`);
      this.initializeHealthConfigs();
      setTimeout(() => this.updateEosNationEndpoints(), this.EOS_NATION_UPDATE_INTERVAL);
    } catch (error) {
      logger.error("[EOS Nation] Failed to update endpoint data:", "ApiService.updateEosNationEndpoints", error);
      setTimeout(() => this.updateEosNationEndpoints(), 6e5);
    }
  }
  /**
   * Parse EOS Nation endpoint data into clean URLs
   */
  parseEosNationEndpoints(endpoints) {
    if (!Array.isArray(endpoints)) {
      logger.warn("[EOS Nation] Expected array of endpoints, got:", typeof endpoints);
      return [];
    }
    return endpoints.map((endpoint) => {
      try {
        let endpointStr;
        if (typeof endpoint === "string") {
          endpointStr = endpoint;
        } else if (typeof endpoint === "object" && endpoint !== null) {
          const obj = endpoint;
          endpointStr = obj.url || obj.endpoint || obj.api_url || String(endpoint);
        } else {
          endpointStr = String(endpoint);
        }
        const trimmed = endpointStr.trim();
        const urlMatch = trimmed.match(/https?:\/\/[^\s]+/);
        return urlMatch ? urlMatch[0] : null;
      } catch (error) {
        logger.warn("[EOS Nation] Failed to parse endpoint", "ApiService.updateEosNationEndpoints", error);
        return null;
      }
    }).filter((url) => url !== null).filter((url) => {
      try {
        new URL(url);
        return true;
      } catch {
        return false;
      }
    });
  }
  /**
   * Get validated endpoints from EOS Nation data combined with our static endpoints
   */
  getValidatedEndpoints(type) {
    const staticEndpoints = type === "atomic" ? this.atomicEndpoints : type === "waxChain" ? this.waxChainEndpoints : this.hyperionEndpoints;
    const eosNationEndpoints = type === "atomic" ? this.eosNationEndpoints.atomicEndpoints : type === "waxChain" ? this.eosNationEndpoints.waxChainEndpoints : this.eosNationEndpoints.hyperionEndpoints;
    const combined = [.../* @__PURE__ */ new Set([...eosNationEndpoints, ...staticEndpoints])];
    logger.info(`[Endpoint Selection] ${type}: ${combined.length} total (${eosNationEndpoints.length} from EOS Nation, ${staticEndpoints.length} static)`);
    return combined;
  }
  /**
   * Get healthy endpoints from a list
   */
  getHealthyEndpoints(endpoints) {
    return endpoints.filter((endpoint) => {
      const endpointKey = this.getCircuitBreakerKey(endpoint);
      return this.isEndpointHealthy(endpointKey) && !this.isCircuitBreakerOpen(endpointKey);
    });
  }
  classifyError(error, status) {
    if (status) {
      if (status === 429) return "rate-limit";
      if (status === 408 || status === 502 || status === 503 || status === 504) return "retryable";
      if (status >= 400 && status < 500) return "non-retryable";
      if (status >= 500) return "retryable";
    }
    const message = error.message.toLowerCase();
    if (message.includes("rate limit") || message.includes("429") || message.includes("too many requests")) {
      return "rate-limit";
    }
    if (message.includes("timeout") || message.includes("network") || message.includes("connection") || message.includes("fetch") || message.includes("enotfound") || message.includes("econnreset") || message.includes("econnrefused") || message.includes("socket hang up") || error.name === "AbortError") {
      return "retryable";
    }
    if (message.includes("400") || message.includes("401") || message.includes("403") || message.includes("404") || message.includes("unauthorized") || message.includes("forbidden") || message.includes("not found") || message.includes("bad request")) {
      return "non-retryable";
    }
    return "retryable";
  }
  calculateDelay(attempt, errorType, jitter = true) {
    let baseDelay;
    if (errorType === "rate-limit") {
      baseDelay = Math.min(Math.pow(2, attempt) * 1e3, this.MAX_TIMEOUT);
    } else {
      baseDelay = Math.min((attempt + 1) * 1e3, 5e3);
    }
    if (jitter) {
      const jitterAmount = baseDelay * 0.1;
      baseDelay += (Math.random() - 0.5) * 2 * jitterAmount;
    }
    return Math.max(baseDelay, 100);
  }
  async fetchWithRetry(url, retries = 3, options) {
    const circuitKey = this.getCircuitBreakerKey(url);
    let lastError = null;
    const startTime = Date.now();
    if (this.isCircuitBreakerOpen(circuitKey)) {
      throw new Error(`Circuit breaker is open for ${circuitKey}. Service temporarily unavailable.`);
    }
    const timeoutMs = options?.signal ? void 0 : 15e3;
    const controller = new AbortController();
    let timeoutId;
    if (timeoutMs && !options?.signal) {
      timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    }
    const fetchOptions = {
      method: options?.method || "GET",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json",
        "User-Agent": "PxMarket/2.0",
        ...options?.headers
      },
      mode: "cors",
      signal: options?.signal || controller.signal,
      ...options
    };
    try {
      if (url.includes("wax-api.hivebp.io")) {
        for (let i = 0; i < retries; i++) {
          try {
            const response = await fetch(url, fetchOptions);
            if (response.ok) {
              this.recordCircuitBreakerSuccess(circuitKey);
              const responseTime = Date.now() - startTime;
              this.reportEndpointHealth(url, true, responseTime);
              return response;
            }
            const errorType = this.classifyError(new Error(`HTTP ${response.status}`), response.status);
            lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
            if (errorType === "non-retryable" || i === retries - 1) {
              break;
            }
            const delay = this.calculateDelay(i, errorType);
            await new Promise((resolve) => setTimeout(resolve, delay));
          } catch (error) {
            const err = error;
            const errorType = this.classifyError(err);
            lastError = err;
            if (errorType === "non-retryable" || i === retries - 1) {
              break;
            }
            const delay = this.calculateDelay(i, errorType);
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
        this.recordCircuitBreakerFailure(circuitKey);
        throw lastError || new Error("Failed to fetch from HiveBP API");
      }
      if (this.waxChainEndpoints.some((endpoint) => url.includes(endpoint))) {
        const healthyWaxEndpoints = this.getHealthyEndpoints(this.waxChainEndpoints);
        const waxEndpointsToTry = healthyWaxEndpoints.length > 0 ? healthyWaxEndpoints : this.waxChainEndpoints;
        for (let endpointIndex = 0; endpointIndex < waxEndpointsToTry.length; endpointIndex++) {
          const endpoint = waxEndpointsToTry[endpointIndex];
          this.currentWaxChainIndex = this.waxChainEndpoints.indexOf(endpoint);
          const currentUrl = url.replace(/https:\/\/[^/]+/, endpoint);
          const endpointKey = this.getCircuitBreakerKey(currentUrl);
          if (this.isCircuitBreakerOpen(endpointKey)) {
            continue;
          }
          let endpointSuccess = false;
          for (let i = 0; i < retries; i++) {
            try {
              const response = await fetch(currentUrl, fetchOptions);
              if (response.ok) {
                this.recordCircuitBreakerSuccess(endpointKey);
                endpointSuccess = true;
                return response;
              }
              const errorType = this.classifyError(new Error(`HTTP ${response.status}`), response.status);
              lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
              if (response.status === 400 || errorType === "non-retryable") {
                break;
              }
              if (i < retries - 1) {
                const delay = this.calculateDelay(i, errorType);
                await new Promise((resolve) => setTimeout(resolve, delay));
              }
            } catch (error) {
              const err = error;
              const errorType = this.classifyError(err);
              lastError = err;
              if (errorType === "non-retryable") {
                break;
              }
              if (i < retries - 1) {
                const delay = this.calculateDelay(i, errorType);
                await new Promise((resolve) => setTimeout(resolve, delay));
              }
            }
          }
          if (!endpointSuccess) {
            this.recordCircuitBreakerFailure(endpointKey);
          }
        }
        throw lastError || new Error("All WAX Chain endpoints failed");
      }
      const healthyAtomicEndpoints = this.getHealthyEndpoints(this.atomicEndpoints);
      const endpointsToTry = healthyAtomicEndpoints.length > 0 ? healthyAtomicEndpoints : this.atomicEndpoints;
      for (let endpointIndex = 0; endpointIndex < endpointsToTry.length; endpointIndex++) {
        const endpoint = endpointsToTry[endpointIndex];
        this.currentEndpointIndex = this.atomicEndpoints.indexOf(endpoint);
        const currentUrl = url.replace(/https:\/\/[^/]+/, endpoint);
        const endpointKey = this.getCircuitBreakerKey(currentUrl);
        if (this.isCircuitBreakerOpen(endpointKey)) {
          continue;
        }
        let endpointSuccess = false;
        for (let i = 0; i < retries; i++) {
          try {
            const response = await fetch(currentUrl, fetchOptions);
            if (response.ok) {
              this.recordCircuitBreakerSuccess(endpointKey);
              endpointSuccess = true;
              const responseTime = Date.now() - startTime;
              this.reportEndpointHealth(currentUrl, true, responseTime);
              return response;
            }
            const errorType = this.classifyError(new Error(`HTTP ${response.status}`), response.status);
            lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
            if (response.status === 400 || errorType === "non-retryable") {
              break;
            }
            if (i < retries - 1) {
              const delay = this.calculateDelay(i, errorType);
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
          } catch (error) {
            const err = error;
            const errorType = this.classifyError(err);
            lastError = err;
            if (errorType === "non-retryable") {
              break;
            }
            if (i < retries - 1) {
              const delay = this.calculateDelay(i, errorType);
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
          }
        }
        if (!endpointSuccess) {
          this.recordCircuitBreakerFailure(endpointKey);
        }
      }
      throw lastError || new Error("All endpoints failed");
    } finally {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    }
  }
  formatSaleData(sale) {
    const asset = sale.assets[0];
    return {
      sale_id: sale.sale_id,
      asset_id: asset?.asset_id || "",
      name: asset?.name || `${asset?.collection?.collection_name || "Unknown"} #${asset?.asset_id || "N/A"}`,
      image: this.getAssetImage(asset),
      video: this.getAssetVideo(asset),
      price: sale.price ? this.formatPrice(sale.price) : "0 WAX",
      seller: sale.seller,
      collection: asset?.collection?.collection_name || "Unknown",
      schema: asset?.schema?.schema_name || "Unknown",
      template_mint: asset?.template_mint ? parseInt(asset.template_mint.toString()) : void 0,
      max_supply: asset?.template?.max_supply || void 0,
      traits: asset?.data ? Object.fromEntries(
        Object.entries(asset.data).filter(([, value]) => value !== void 0 && value !== null)
      ) : {}
    };
  }
  getAssetImage(asset) {
    const img = asset?.data?.img || asset?.template?.immutable_data?.img;
    if (!img) return API_ENDPOINTS.PIXEL_JOURNEY.DEFAULT_IMAGE;
    if (typeof img === "string") {
      return img.startsWith("http") ? img : img.startsWith("Qm") ? `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${img}` : img;
    }
    return API_ENDPOINTS.PIXEL_JOURNEY.DEFAULT_IMAGE;
  }
  getAssetVideo(asset) {
    const video = asset?.data?.video || asset?.template?.immutable_data?.video;
    if (!video || typeof video !== "string") return "";
    return video.startsWith("http") ? video : video.startsWith("Qm") ? `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${video}` : video;
  }
  formatPrice(price) {
    if (!price || !price.amount) return "0 WAX";
    const amount = parseFloat(price.amount) / Math.pow(10, price.token_precision || 8);
    if (price.token_symbol === "WAX" || !price.token_symbol) {
      return formatWAXPrice(amount);
    }
    return `${formatNumber(amount)} ${price.token_symbol}`;
  }
  async getCheapestPixals(limit = 50, page = 1) {
    const baseUrl = this.atomicMarketAPI;
    const adaptiveLimit = this.getAdaptiveLimit(baseUrl, limit);
    try {
      const url = `${baseUrl}/atomicmarket/v1/sales?state=1&collection_name=pixeljourney&schema_name=pixals&sort=price&order=asc&limit=${adaptiveLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        this.updateAdaptiveLimit(baseUrl, adaptiveLimit, true);
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      this.updateAdaptiveLimit(baseUrl, adaptiveLimit, false);
      ErrorMessageService.logError("ApiService.getCheapestPixals", error, { limit, adaptiveLimit, page });
      throw error;
    }
  }
  async getWaxRockPixals(limit = 50, page = 1) {
    const baseUrl = this.atomicMarketAPI;
    const adaptiveLimit = this.getAdaptiveLimit(baseUrl, limit);
    try {
      const { MarketplaceConfigService: MarketplaceConfigService2 } = await __vitePreload(async () => {
        const { MarketplaceConfigService: MarketplaceConfigService22 } = await Promise.resolve().then(() => marketplaceConfig);
        return { MarketplaceConfigService: MarketplaceConfigService22 };
      }, true ? void 0 : void 0);
      const waxRockTypes = MarketplaceConfigService2.getWaxRockTypes();
      let allWaxRockSales = [];
      for (const waxRockType of waxRockTypes) {
        try {
          const url = `${baseUrl}/atomicmarket/v1/sales?state=1&collection_name=pixeljourney&schema_name=pixals&immutable_data.WaxRock=${encodeURIComponent(waxRockType)}&sort=price&order=asc&limit=50&page=1`;
          const response = await this.fetchWithRetry(url);
          const data = await response.json();
          if (data.success && data.data) {
            allWaxRockSales.push(...data.data);
          }
        } catch (error) {
          logger.warn(`Failed to fetch ${waxRockType} WaxRocks:`, "ApiService.getWaxRockPixals", error);
        }
      }
      if (allWaxRockSales.length === 0) {
        const fallbackUrl = `${baseUrl}/atomicmarket/v1/sales?state=1&collection_name=pixeljourney&schema_name=pixals&sort=price&order=asc&limit=100&page=${page}`;
        const response = await this.fetchWithRetry(fallbackUrl);
        const data = await response.json();
        if (data.success && data.data) {
          allWaxRockSales = data.data.filter((sale) => {
            if (!sale.assets || !sale.assets[0]) return false;
            const asset = sale.assets[0];
            const waxRock = asset.data?.WaxRock || asset.template?.immutable_data?.WaxRock;
            if (waxRock && typeof waxRock === "string") {
              return waxRock !== "none" && MarketplaceConfigService2.isValidWaxRock(waxRock);
            }
            const validWaxRockTypes = waxRockTypes.map((type) => type.toLowerCase());
            if (asset.data) {
              return Object.values(asset.data).some((value) => {
                if (typeof value === "string") {
                  const lowerValue = value.toLowerCase();
                  return lowerValue !== "none" && validWaxRockTypes.includes(lowerValue);
                }
                return false;
              });
            }
            return false;
          });
        }
      }
      const uniqueSales = allWaxRockSales.filter(
        (sale, index, self) => index === self.findIndex((s) => s.sale_id === sale.sale_id)
      );
      uniqueSales.sort((a, b) => {
        const priceA = parseFloat(a.listing_price || "0");
        const priceB = parseFloat(b.listing_price || "0");
        return priceA - priceB;
      });
      const startIndex = (page - 1) * adaptiveLimit;
      const paginatedResults = uniqueSales.slice(startIndex, startIndex + adaptiveLimit);
      this.updateAdaptiveLimit(baseUrl, adaptiveLimit, true);
      return paginatedResults.map((sale) => this.formatSaleData(sale));
    } catch (error) {
      this.updateAdaptiveLimit(baseUrl, adaptiveLimit, false);
      ErrorMessageService.logError("ApiService.getWaxRockPixals", error, { limit, adaptiveLimit, page });
      throw error;
    }
  }
  async getPixelIngredients(limit = 20, page = 1) {
    try {
      const safeLimit = Math.min(limit, 50);
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=1&collection_name=pixeljourney&schema_name=ingredients&sort=price&order=asc&limit=${safeLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getPixelIngredients", error, { limit, page });
      throw error;
    }
  }
  async getBundleListings(limit = 20, page = 1) {
    try {
      const safeLimit = Math.min(limit, 50);
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=1&collection_name=pixeljourney&schema_name=bundles&sort=price&order=asc&limit=${safeLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getBundleListings", error, { limit, page });
      throw error;
    }
  }
  async getFriedFactoryNFTs(limit = 20, page = 1) {
    try {
      const safeLimit = Math.min(limit, 50);
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=1&collection_name=friedfactory&sort=price&order=asc&limit=${safeLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getFriedFactoryNFTs", error, { limit, page });
      throw error;
    }
  }
  async getCryptoMuffinsNFTs(limit = 20, page = 1) {
    try {
      const safeLimit = Math.min(limit, 50);
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=1&collection_name=cryptomuffins&sort=price&order=asc&limit=${safeLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCryptoMuffinsNFTs", error, { limit, page });
      throw error;
    }
  }
  async getPartnerListings(limit = 16, page = 1) {
    try {
      const safeLimit = Math.min(limit, 50);
      const partnerCollections = MarketplaceConfigService.getPartnerCollectionsSync();
      const collectionQuery = partnerCollections.join(",");
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=1&collection_name=${collectionQuery}&sort=created&order=desc&limit=${safeLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getPartnerListings", error, { limit, page });
      throw error;
    }
  }
  async getPxApprovedListings(limit = 16, page = 1) {
    try {
      const safeLimit = Math.min(limit, 50);
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=1&collection_name=pixeljourney&sort=created&order=desc&limit=${safeLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getPxApprovedListings", error, { limit, page });
      throw error;
    }
  }
  async getAHVerifiedListings(limit = 16, page = 1) {
    try {
      const safeLimit = Math.min(limit, 50);
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=1&verified=true&sort=created&order=desc&limit=${safeLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAHVerifiedListings", error, { limit, page });
      throw error;
    }
  }
  async getAllWaxListings(limit = 16, page = 1) {
    const baseUrl = this.atomicMarketAPI;
    const adaptiveLimit = this.getAdaptiveLimit(baseUrl, limit);
    try {
      const url = `${baseUrl}/atomicmarket/v1/sales?state=1&sort=created&order=desc&limit=${adaptiveLimit}&page=${page}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        this.updateAdaptiveLimit(baseUrl, adaptiveLimit, true);
        return data.data.map((sale) => this.formatSaleData(sale));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      this.updateAdaptiveLimit(baseUrl, adaptiveLimit, false);
      ErrorMessageService.logError("ApiService.getAllWaxListings", error, { limit, adaptiveLimit, page });
      throw error;
    }
  }
  async getRecentSales(limit = 50) {
    try {
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=3&limit=${limit}&order=desc&sort=updated`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getRecentSales", error, { limit });
      return [];
    }
  }
  async getSales(params = {}) {
    try {
      const {
        page = 1,
        limit = 100,
        order = "desc",
        sort = "updated",
        collection_name,
        schema_name,
        template_id,
        asset_id,
        seller,
        buyer,
        state = "1,3",
        // Default to listed and sold sales
        symbol = "WAX",
        min_price,
        max_price,
        before,
        after
      } = params;
      let url = `${this.atomicMarketAPI}/atomicmarket/v1/sales?page=${page}&limit=${limit}&order=${order}&sort=${sort}&state=${state}&symbol=${symbol}`;
      if (collection_name) url += `&collection_name=${collection_name}`;
      if (schema_name) url += `&schema_name=${schema_name}`;
      if (template_id) url += `&template_id=${template_id}`;
      if (asset_id) url += `&asset_id=${asset_id}`;
      if (seller) url += `&seller=${seller}`;
      if (buyer) url += `&buyer=${buyer}`;
      if (min_price) url += `&min_price=${min_price}`;
      if (max_price) url += `&max_price=${max_price}`;
      if (before) url += `&before=${before}`;
      if (after) url += `&after=${after}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return {
        success: data.success || false,
        data: data.data || [],
        query_total: data.query_total
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getSales", error, params);
      return { success: false, data: [] };
    }
  }
  async getCollections(options = {}) {
    try {
      const {
        limit = 20,
        page = 1,
        whitelistOnly = true,
        author,
        match,
        order = "desc",
        sort = "created",
        singleCollection
      } = options;
      const params = new URLSearchParams();
      if (singleCollection) {
        params.append("collection_name", singleCollection);
        params.append("limit", "1");
      } else if (whitelistOnly) {
        const collectionsToFetch = this.COLLECTION_WHITELIST.slice(0, Math.min(limit, 20));
        const collectionPromises = collectionsToFetch.map(async (collectionName) => {
          try {
            const response2 = await this.fetchWithRetry(`${this.atomicAssetsAPI}/atomicassets/v1/collections/${collectionName}`);
            const data2 = await response2.json();
            if (data2.success && data2.data) {
              return data2.data;
            }
            return null;
          } catch {
            return null;
          }
        });
        const results = await Promise.all(collectionPromises);
        const validCollections = results.filter((col) => col !== null);
        return validCollections;
      } else {
        params.append("limit", Math.min(limit, 100).toString());
        params.append("page", page.toString());
        if (author) params.append("author", author);
        if (match) params.append("match", match);
      }
      params.append("order", order);
      params.append("sort", sort);
      const url = `${this.atomicAssetsAPI}/atomicassets/v1/collections?${params.toString()}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollections", error, options);
      return [
        {
          collection_name: "pixeljourney",
          name: "Pixel Journey",
          img: "",
          author: "pixeljourney",
          allow_notify: true,
          authorized_accounts: [],
          notify_accounts: [],
          market_fee: 0,
          created_at_time: "",
          created_at_block: ""
        },
        {
          collection_name: "friedfactory",
          name: "Fried Factory",
          img: "",
          author: "friedfactory",
          allow_notify: true,
          authorized_accounts: [],
          notify_accounts: [],
          market_fee: 0,
          created_at_time: "",
          created_at_block: ""
        }
      ];
    }
  }
  // Removed loadCollectionsIndividually to prevent mass API calls that spam console errors
  async getMarketStats() {
    try {
      const url = `${this.atomicAssetsAPI}/atomicmarket/v1/stats/graph`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data && data.data.length > 0) {
        return data.data[data.data.length - 1];
      }
      return null;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getMarketStats", error);
      return null;
    }
  }
  // Get individual collection details more efficiently
  async getCollectionDetails(collectionName) {
    const cacheKey = `collection-${collectionName}`;
    if (this.isCircuitBreakerOpen(cacheKey)) {
      return null;
    }
    try {
      const url = `${this.atomicAssetsAPI}/atomicassets/v1/collections/${collectionName}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return null;
    } catch (error) {
      this.recordCircuitBreakerFailure(cacheKey);
      if (!this.isCircuitBreakerOpen(cacheKey)) {
        ErrorMessageService.logError("ApiService.getCollectionDetails", error, { collectionName });
      }
      return null;
    }
  }
  async getCollectionSchemas(collectionName, limit = 50) {
    try {
      const url = `${this.atomicAssetsAPI}/atomicassets/v1/schemas?collection_name=${collectionName}&limit=${limit}&order=desc&sort=created`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionAssets", error, { collectionName, limit });
      return [];
    }
  }
  async getCollectionTemplates(collectionName, schemaName, limit = 50) {
    try {
      let url = `${this.atomicAssetsAPI}/atomicassets/v1/templates?collection_name=${collectionName}&limit=${limit}&order=desc&sort=created`;
      if (schemaName) {
        url += `&schema_name=${schemaName}`;
      }
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionTemplates", error, { collectionName, schemaName, limit });
      return [];
    }
  }
  async getCollectionAssets(collectionName, schemaName, templateId, limit = 50) {
    try {
      let url = `${this.getCurrentAtomicEndpoint()}/atomicmarket/v1/assets?collection_name=${collectionName}&burned=false&limit=${limit}&order=desc&sort=asset_id`;
      if (schemaName) {
        url += `&schema_name=${schemaName}`;
      }
      if (templateId) {
        url += `&template_id=${templateId}`;
      }
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionAssets", error, { collectionName, schemaName, templateId, limit });
      return [];
    }
  }
  async getAssetDetails(assetId) {
    try {
      const url = `${this.atomicAssetsAPI}/atomicassets/v1/assets/${assetId}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return null;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAssetDetails", error, { assetId });
      return null;
    }
  }
  // Additional Atomic API endpoints for comprehensive collection data
  async getCollectionStats(collectionName) {
    try {
      const url = `${this.atomicAssetsAPI}/atomicassets/v1/collections/${collectionName}/stats`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return null;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionSchemas", error, { collectionName });
      return null;
    }
  }
  async getCollectionBurns(collectionName, limit = 50) {
    try {
      const url = `${this.atomicAssetsAPI}/atomicassets/v1/burns?collection_name=${collectionName}&limit=${limit}&order=desc&sort=created`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionBurns", error, { collectionName, limit });
      return [];
    }
  }
  async getCollectionTransfers(collectionName, limit = 50) {
    try {
      const url = `${this.atomicAssetsAPI}/atomicassets/v1/transfers?collection_name=${collectionName}&limit=${limit}&order=desc&sort=created`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionTransfers", error, { collectionName, limit });
      return [];
    }
  }
  // HiveBP WAX API integration for enhanced analytics
  async getCollectionVolumeGraph(collectionName, days = 30) {
    try {
      const url = `${this.hiveBPAPI}/v3/sales-volume-graph/${days}/${collectionName}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return data;
    } catch (error) {
      logger.warn(`HiveBP volume graph not available for ${collectionName}`, "API", error);
      return null;
    }
  }
  async getCollectionMarketCap(collectionName) {
    try {
      const url = `${this.hiveBPAPI}/v3/collection-marketcap/${collectionName}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return data;
    } catch (error) {
      logger.warn(`HiveBP market cap not available for ${collectionName}`, "API", error);
      return null;
    }
  }
  async getSimilarCollections(collectionName) {
    try {
      const url = `${this.hiveBPAPI}/v3/similar-collections/${collectionName}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return data || [];
    } catch (error) {
      logger.warn(`HiveBP similar collections not available for ${collectionName}`, "API", error);
      return [];
    }
  }
  async getCollectionAnalytics(collectionName) {
    try {
      const url = `${this.hiveBPAPI}/v3/collection-stats/${collectionName}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return data;
    } catch (error) {
      logger.warn(`HiveBP analytics not available for ${collectionName}`, "API", error);
      return null;
    }
  }
  // HiveBP API methods for collection statistics
  async getHiveBPMarketCap(collectionName) {
    try {
      const url = `${this.hiveBPAPI}/v3/marketcap/${collectionName}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return data?.marketcap || null;
    } catch (error) {
      logger.warn(`HiveBP market cap not available for ${collectionName}`, "API", error);
      return null;
    }
  }
  async getHiveBPVolumeDays(collectionName, days = 1) {
    try {
      const url = `${this.hiveBPAPI}/v3/volume/${days}/${collectionName}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return data?.volume || null;
    } catch (error) {
      logger.warn(`HiveBP volume data not available for ${collectionName}`, "API", error);
      return null;
    }
  }
  async getHiveBPFloorPrice(templateId) {
    try {
      const url = `${this.hiveBPAPI}/v3/floor/${templateId}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return data?.floor_price || null;
    } catch (error) {
      logger.warn(`HiveBP floor price not available for template ${templateId}`, "API", error);
      return null;
    }
  }
  // Enhanced collection stats using HiveBP APIs
  async getEnhancedCollectionStats(collectionName) {
    try {
      const [marketCap, volume24h, volume7d] = await Promise.all([
        this.getHiveBPMarketCap(collectionName),
        this.getHiveBPVolumeDays(collectionName, 1),
        this.getHiveBPVolumeDays(collectionName, 7)
      ]);
      let floorPrice = null;
      try {
        const templates2 = await this.getCollectionTemplates(collectionName, void 0, 1);
        if (templates2.length > 0) {
          floorPrice = await this.getHiveBPFloorPrice(templates2[0].template_id);
        }
      } catch (error) {
        logger.warn(`Could not fetch floor price for ${collectionName}`, "API", error);
      }
      return {
        marketCap,
        volume24h,
        volume7d,
        floorPrice
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionStats", error, { collectionName });
      return {
        marketCap: null,
        volume24h: null,
        volume7d: null,
        floorPrice: null
      };
    }
  }
  // Get collection top sales
  async getCollectionTopSales(collectionName, limit = 20) {
    try {
      const url = `${this.atomicAssetsAPI}/atomicmarket/v1/sales?collection_name=${collectionName}&state=3&limit=${limit}&order=desc&sort=price`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionTopSales", error, { collectionName, limit });
      return [];
    }
  }
  // Get collection floor price
  async getCollectionFloorPrice(collectionName) {
    try {
      const url = `${this.atomicAssetsAPI}/atomicmarket/v1/sales?collection_name=${collectionName}&state=1&limit=1&order=asc&sort=price`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data && data.data.length > 0) {
        const floorPrice = parseFloat(data.data[0].listing_price) / 1e8;
        return { floorPrice };
      }
      return { floorPrice: 0 };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionFloorPrice", error, { collectionName });
      return { floorPrice: 0 };
    }
  }
  // Get collection holder statistics
  async getCollectionHolders(collectionName, limit = 50, offset = 0) {
    try {
      let url = `${this.atomicAssetsAPI}/atomicassets/v1/accounts?collection_name=${collectionName}&limit=${limit}&order=desc&sort=assets`;
      if (offset > 0) {
        url += `&page=${Math.floor(offset / limit) + 1}`;
      }
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionHolders", error, { collectionName, limit, offset });
      return [];
    }
  }
  // NFT Trading Data API methods using AtomicAssets
  async getNFTTradingStats() {
    try {
      const salesResponse = await this.fetchWithRetry(
        `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=3&after=${Date.now() - 864e5}&limit=1000`
      );
      const salesData = await salesResponse.json();
      let dailyVolume = 0;
      let dailySales = 0;
      if (salesData.success && salesData.data) {
        dailySales = salesData.data.length;
        dailyVolume = salesData.data.reduce((total, sale) => {
          return total + (sale.price ? parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision) : 0);
        }, 0);
      }
      const listingsResponse = await this.fetchWithRetry(
        `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=1&limit=1`
      );
      const listingsData = await listingsResponse.json();
      const activeListings = listingsData.success ? parseInt(listingsData.query_time) : 0;
      return {
        collection_name: "global",
        dailyVolume: formatNumber(dailyVolume),
        dailySales,
        totalTransactions: dailySales,
        activeListings,
        averagePrice: dailySales > 0 ? formatNumber(dailyVolume / dailySales) : "0"
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getNFTTradingStats", error);
      return null;
    }
  }
  async getTopCollectionsByVolume(limit = 10) {
    try {
      const collectionsResponse = await this.fetchWithRetry(
        `${this.atomicMarketAPI}/atomicmarket/v1/stats/collections?limit=${limit}&sort=volume`
      );
      const collectionsData = await collectionsResponse.json();
      if (collectionsData.success && collectionsData.data) {
        return collectionsData.data.map((collection) => ({
          collection_name: collection.collection_name,
          volume_24h: collection.volume ? formatWAXPrice(parseFloat(collection.volume) / 1e8) : "0 WAX",
          sales_24h: parseInt(collection.sales || "0") || 0,
          floor_price: collection.floor_price ? formatWAXPrice(parseFloat(collection.floor_price) / 1e8) : "0 WAX",
          assets_count: collection.assets || "0"
        }));
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getTopCollectionsByVolume", error, { limit });
      return [];
    }
  }
  async getRecentNFTTrades(limit = 20) {
    try {
      const response = await this.fetchWithRetry(
        `${this.atomicMarketAPI}/atomicmarket/v1/sales?state=3&limit=${limit}&sort=updated`
      );
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((sale) => ({
          sale_id: sale.sale_id,
          collection_name: sale.collection_name || sale.assets[0]?.collection?.collection_name || "Unknown",
          asset_name: sale.assets[0]?.name || `Asset #${sale.assets[0]?.asset_id}`,
          price: sale.price ? formatWAXPrice(parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision)) : "0 WAX",
          buyer: sale.buyer,
          seller: sale.seller,
          timestamp: sale.updated_at_time
        }));
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getNFTTradingStats", error, { limit });
      return [];
    }
  }
  async getUserInventory(account, limit = 1e3) {
    try {
      const collectionQuery = this.approvedCollections.join(",");
      const url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&collection_name=${collectionQuery}&burned=false&limit=${limit}&order=desc&sort=asset_id`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_id: asset.template?.template_id || "0",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventory", error, { account });
      return [];
    }
  }
  async getUserInventoryPaginated(account, page = 1, limit = 1e3) {
    try {
      const collectionQuery = this.approvedCollections.join(",");
      const url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&collection_name=${collectionQuery}&burned=false&limit=${limit}&page=${page}&order=desc&sort=asset_id`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_id: asset.template?.template_id || "0",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
        const hasMore = data.data.length === limit;
        const total = (page - 1) * limit + data.data.length + (hasMore ? 1 : 0);
        return { assets, hasMore, total };
      }
      throw new Error("Invalid API response");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryPaginated", error, { account, page, limit });
      return { assets: [], hasMore: false, total: 0 };
    }
  }
  async getUserInventoryAll(account, page = 1, limit = 1e3) {
    try {
      const url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&burned=false&limit=${limit}&page=${page}&order=desc&sort=asset_id`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          video: this.getAssetVideo(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_id: asset.template?.template_id || "0",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
        const hasMore = data.data.length === limit;
        return {
          assets,
          total: (page - 1) * limit + assets.length + (hasMore ? 1 : 0),
          hasMore,
          currentPage: page
        };
      }
      return { assets: [], total: 0, hasMore: false, currentPage: page };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryAll", error, { account, page, limit });
      return { assets: [], total: 0, hasMore: false, currentPage: page };
    }
  }
  /**
   * Get user inventory for a specific collection - more efficient for filtered views
   */
  async getUserInventoryByCollection(account, collectionName, limit = 1e3, offset = 0) {
    try {
      const url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&collection_name=${collectionName}&burned=false&limit=${limit}&offset=${offset}&order=desc&sort=asset_id`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_id: asset.template?.template_id || "0",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
        const hasMore = data.data.length === limit;
        return { assets, total: offset + assets.length + (hasMore ? 1 : 0), hasMore };
      }
      return { assets: [], total: 0, hasMore: false };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryByCollection", error, { account, collectionName, limit, offset });
      return { assets: [], total: 0, hasMore: false };
    }
  }
  /**
   * Get user inventory for a specific schema within a collection - most precise query
   */
  async getUserInventoryBySchema(account, collectionName, schemaName, limit = 1e3, offset = 0) {
    try {
      const url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&collection_name=${collectionName}&schema_name=${schemaName}&burned=false&limit=${limit}&offset=${offset}&order=desc&sort=asset_id`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_id: asset.template?.template_id || "0",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
        const hasMore = data.data.length === limit;
        return { assets, total: offset + assets.length + (hasMore ? 1 : 0), hasMore };
      }
      return { assets: [], total: 0, hasMore: false };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryBySchema", error, { account, collectionName, schemaName, limit, offset });
      return { assets: [], total: 0, hasMore: false };
    }
  }
  /**
   * Get user inventory overview - efficient for large inventories (15-20k+ assets)
   * Returns collection counts and basic stats without fetching all assets
   */
  async getUserInventoryOverview(account) {
    try {
      const tableUrl = `${API_ENDPOINTS.WAX_CHAIN.EOSRIO}/v1/chain/get_table_rows`;
      const response = await fetch(tableUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          json: true,
          code: "atomicassets",
          scope: account,
          table: "assets",
          limit: 1e3,
          reverse: false
        })
      });
      const data = await response.json();
      const collections = /* @__PURE__ */ new Map();
      let totalAssets = 0;
      if (data.rows) {
        data.rows.forEach((row) => {
          if (!row.collection_name) return;
          totalAssets++;
          const collectionName = row.collection_name;
          const schemaName = row.schema_name || "unknown";
          if (!collections.has(collectionName)) {
            collections.set(collectionName, { count: 0, schemas: /* @__PURE__ */ new Map() });
          }
          const collection = collections.get(collectionName);
          collection.count++;
          collection.schemas.set(schemaName, (collection.schemas.get(schemaName) || 0) + 1);
        });
      }
      const collectionsArray = Array.from(collections.entries()).map(([name, data2]) => ({
        name,
        count: data2.count,
        schema_counts: Object.fromEntries(data2.schemas)
      })).sort((a, b) => b.count - a.count);
      return {
        totalAssets,
        collections: collectionsArray,
        topCollections: collectionsArray.slice(0, 10)
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryOverview", error, { account });
      try {
        const fallbackUrl = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicassets/v1/assets?owner=${account}&page=1&limit=1`;
        const fallbackResponse = await this.fetchWithRetry(fallbackUrl);
        const fallbackData = await fallbackResponse.json();
        const totalAssets = fallbackData.success ? fallbackData.query_total || 0 : 0;
        return {
          totalAssets,
          collections: [],
          topCollections: []
        };
      } catch (fallbackError) {
        ErrorMessageService.logError("ApiService.getUserInventoryOverview.fallback", fallbackError, { account });
        return { totalAssets: 0, collections: [], topCollections: [] };
      }
    }
  }
  /**
   * Get user inventory with lazy loading optimization for large inventories
   * Uses higher limits and caching for better performance
   */
  async getUserInventoryOptimized(account, options = {}) {
    const {
      page = 1,
      limit = 1e3,
      // Use higher default limit
      collectionName,
      schemaName,
      useCache = true,
      cacheTTL = 3e5
      // 5 minutes
    } = options;
    const cacheKey = `inventory_${account}_${page}_${limit}_${collectionName || "all"}_${schemaName || "all"}`;
    if (useCache) {
      const cached = this.getFromCache(cacheKey);
      if (cached) return cached;
    }
    try {
      let url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicassets/v1/assets?owner=${account}&burned=false&limit=${limit}&page=${page}&order=desc&sort=asset_id`;
      if (collectionName && collectionName !== "all") {
        url += `&collection_name=${collectionName}`;
      }
      if (schemaName) {
        url += `&schema_name=${schemaName}`;
      }
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_id: asset.template?.template_id || "0",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
        const hasMore = data.data.length === limit;
        const result = {
          assets,
          total: data.query_total || (page - 1) * limit + assets.length + (hasMore ? 1 : 0),
          hasMore,
          currentPage: page
        };
        if (useCache) {
          this.setCache(cacheKey, result, cacheTTL);
        }
        return result;
      }
      return { assets: [], total: 0, hasMore: false, currentPage: page };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryOptimized", error, { account, page, limit, collectionName, schemaName });
      return { assets: [], total: 0, hasMore: false, currentPage: page };
    }
  }
  /**
   * Background batch fetcher for large inventories
   * Fetches data in chunks with delays to avoid rate limits
   */
  async getUserInventoryBatch(account, options = {}) {
    const {
      batchSize = 1e3,
      maxBatches = 20,
      // Max 20k assets
      delayMs = 500,
      // 500ms delay between batches
      collectionName,
      onProgress,
      maxRetries = 3,
      onError
    } = options;
    const allAssets = [];
    const errors = [];
    let currentBatch = 1;
    let hasMore = true;
    let consecutiveFailures = 0;
    const maxConsecutiveFailures = 3;
    while (hasMore && currentBatch <= maxBatches && consecutiveFailures < maxConsecutiveFailures) {
      let batchSuccess = false;
      let lastError = null;
      for (let retryAttempt = 0; retryAttempt <= maxRetries; retryAttempt++) {
        try {
          if (retryAttempt > 0) {
            const adaptiveDelay = delayMs * Math.pow(1.5, consecutiveFailures);
            const retryDelay = Math.min(1e3 * Math.pow(2, retryAttempt - 1) + adaptiveDelay, 1e4);
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
          }
          const result = await this.getUserInventoryOptimized(account, {
            page: currentBatch,
            limit: batchSize,
            collectionName,
            useCache: false
            // Don't cache individual batches
          });
          allAssets.push(...result.assets);
          hasMore = result.hasMore;
          batchSuccess = true;
          consecutiveFailures = 0;
          if (onProgress) {
            onProgress({
              current: currentBatch,
              total: Math.min(maxBatches, Math.ceil(result.total / batchSize)),
              assets: [...allAssets],
              errors: [...errors]
            });
          }
          break;
        } catch (error) {
          lastError = error;
          const willRetry = retryAttempt < maxRetries;
          if (onError) {
            onError(lastError, currentBatch, willRetry);
          }
          ErrorMessageService.logError(
            `ApiService.getUserInventoryBatch.batch${currentBatch}.attempt${retryAttempt + 1}`,
            lastError,
            { account, batchSize, currentBatch, retryAttempt }
          );
          if (!willRetry) {
            const errorMsg = `Batch ${currentBatch} failed after ${maxRetries + 1} attempts: ${lastError.message}`;
            errors.push(errorMsg);
            consecutiveFailures++;
            if (this.isCriticalError(lastError)) {
              ErrorMessageService.logError(
                "ApiService.getUserInventoryBatch.criticalError",
                lastError,
                { account, currentBatch, errorType: "critical" }
              );
              return {
                assets: allAssets,
                errors: [...errors, "Critical error encountered, stopping batch processing"],
                partialSuccess: allAssets.length > 0
              };
            }
          }
        }
      }
      currentBatch++;
      if (hasMore && currentBatch <= maxBatches && batchSuccess) {
        const adaptiveDelay = delayMs * Math.pow(1.2, Math.min(consecutiveFailures, 3));
        await new Promise((resolve) => setTimeout(resolve, adaptiveDelay));
      }
    }
    if (consecutiveFailures >= maxConsecutiveFailures) {
      const errorMsg = `Stopped processing due to ${consecutiveFailures} consecutive batch failures`;
      errors.push(errorMsg);
      ErrorMessageService.logError(
        "ApiService.getUserInventoryBatch.tooManyFailures",
        new Error(errorMsg),
        { account, currentBatch, consecutiveFailures }
      );
    }
    return {
      assets: allAssets,
      errors,
      partialSuccess: allAssets.length > 0 && (errors.length > 0 || consecutiveFailures > 0)
    };
  }
  /**
    * Determines if an error is critical and should stop batch processing
    */
  isCriticalError(error) {
    const message = error.message.toLowerCase();
    return message.includes("unauthorized") || message.includes("forbidden") || message.includes("invalid account") || message.includes("network error") || message.includes("dns") || message.includes("connection refused");
  }
  /**
   * Generic batch operation wrapper with error handling and retry logic
   * Can be used by other services for consistent batch processing
   */
  async executeBatchOperation(items, batchProcessor, options = {}) {
    const {
      batchSize = 100,
      maxRetries = 3,
      delayMs = 500,
      onProgress,
      onError,
      stopOnCriticalError = true
    } = options;
    const results = [];
    const errors = [];
    const batches = this.chunkArray(items, batchSize);
    let consecutiveFailures = 0;
    const maxConsecutiveFailures = 3;
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
      const batch = batches[batchIndex];
      let batchSuccess = false;
      let lastError = null;
      for (let retryAttempt = 0; retryAttempt <= maxRetries; retryAttempt++) {
        try {
          if (retryAttempt > 0) {
            const retryDelay = Math.min(1e3 * Math.pow(2, retryAttempt - 1), 1e4);
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
          }
          const batchResults = await batchProcessor(batch, batchIndex);
          results.push(...batchResults);
          batchSuccess = true;
          consecutiveFailures = 0;
          if (onProgress) {
            onProgress({
              completed: batchIndex + 1,
              total: batches.length,
              errors: [...errors]
            });
          }
          break;
        } catch (error) {
          lastError = error;
          const willRetry = retryAttempt < maxRetries;
          if (onError) {
            onError(lastError, batchIndex, willRetry);
          }
          ErrorMessageService.logError(
            `ApiService.executeBatchOperation.batch${batchIndex}.attempt${retryAttempt + 1}`,
            lastError,
            { batchIndex, retryAttempt, batchSize: batch.length }
          );
          if (!willRetry) {
            const errorMsg = `Batch ${batchIndex} failed after ${maxRetries + 1} attempts: ${lastError.message}`;
            errors.push(errorMsg);
            consecutiveFailures++;
            if (stopOnCriticalError && this.isCriticalError(lastError)) {
              ErrorMessageService.logError(
                "ApiService.executeBatchOperation.criticalError",
                lastError,
                { batchIndex, errorType: "critical" }
              );
              return {
                results,
                errors: [...errors, "Critical error encountered, stopping batch processing"],
                partialSuccess: results.length > 0
              };
            }
          }
        }
      }
      if (consecutiveFailures >= maxConsecutiveFailures) {
        const errorMsg = `Stopped processing due to ${consecutiveFailures} consecutive batch failures`;
        errors.push(errorMsg);
        ErrorMessageService.logError(
          "ApiService.executeBatchOperation.tooManyFailures",
          new Error(errorMsg),
          { batchIndex, consecutiveFailures }
        );
        break;
      }
      if (batchIndex < batches.length - 1 && batchSuccess) {
        const adaptiveDelay = delayMs * Math.pow(1.2, Math.min(consecutiveFailures, 3));
        await new Promise((resolve) => setTimeout(resolve, adaptiveDelay));
      }
    }
    return {
      results,
      errors,
      partialSuccess: results.length > 0 && errors.length > 0
    };
  }
  /**
   * Utility method to chunk an array into smaller batches
   */
  chunkArray(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }
  /**
   * Get user inventory with optional collection filtering - for inventory page with dropdown
   */
  async getUserInventoryWithFilter(account, page = 1, limit = 1e3, collectionName) {
    try {
      let url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&burned=false&limit=${limit}&page=${page}&order=desc&sort=asset_id`;
      if (collectionName && collectionName !== "all") {
        url += `&collection_name=${collectionName}`;
      }
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          video: this.getAssetVideo(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_id: asset.template?.template_id || "0",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
        const hasMore = data.data.length === limit;
        return {
          assets,
          total: (page - 1) * limit + assets.length + (hasMore ? 1 : 0),
          hasMore,
          currentPage: page
        };
      }
      return { assets: [], total: 0, hasMore: false, currentPage: page };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryWithFilter", error, { account, page, limit, collectionName });
      return { assets: [], total: 0, hasMore: false, currentPage: page };
    }
  }
  /**
   * Enhanced user inventory method with comprehensive AtomicAssets API filtering and sorting options
   * Supports all available query parameters for maximum flexibility
   */
  async getUserInventoryEnhanced(account, options = {}) {
    const {
      page = 1,
      limit = 1e3,
      order = "desc",
      sort = "transferred",
      // Default to latest transferred (received)
      burned = false,
      ...filters
    } = options;
    try {
      const params = new URLSearchParams({
        owner: account,
        burned: burned.toString(),
        limit: limit.toString(),
        page: page.toString(),
        order,
        sort
      });
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== void 0 && value !== null && value !== "") {
          params.append(key, value.toString());
        }
      });
      const url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?${params.toString()}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          video: this.getAssetVideo(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_id: asset.template?.template_id || "0",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
        const collections = [...new Set(assets.map((asset) => asset.collection))].filter((c) => c !== "Unknown");
        const schemas = [...new Set(assets.map((asset) => asset.schema))].filter((s) => s !== "Unknown");
        const hasMore = data.data.length === limit;
        return {
          assets,
          total: (page - 1) * limit + assets.length + (hasMore ? 1 : 0),
          hasMore,
          currentPage: page,
          collections,
          schemas
        };
      }
      return { assets: [], total: 0, hasMore: false, currentPage: page, collections: [], schemas: [] };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryEnhanced", error, { account, options });
      return { assets: [], total: 0, hasMore: false, currentPage: page, collections: [], schemas: [] };
    }
  }
  /**
   * Get user inventory for a specific template - fastest for single template queries
   */
  async getUserInventoryByTemplate(account, templateId, limit = 1e3, offset = 0) {
    try {
      const url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&template_id=${templateId}&burned=false&limit=${limit}&offset=${offset}&order=desc&sort=asset_id`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          )
        }));
        const hasMore = data.data.length === limit;
        return { assets, total: offset + assets.length + (hasMore ? 1 : 0), hasMore };
      }
      return { assets: [], total: 0, hasMore: false };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryByTemplate", error, { account, templateId, limit, offset });
      return { assets: [], total: 0, hasMore: false };
    }
  }
  /**
   * Get user's WaxRock Pixal PFPs - filters for template 781515 with valid WaxRock attributes
   */
  async getUserInventoryWaxRocks(account, limit = 1e3, offset = 0) {
    try {
      const { MarketplaceConfigService: MarketplaceConfigService2 } = await __vitePreload(async () => {
        const { MarketplaceConfigService: MarketplaceConfigService22 } = await Promise.resolve().then(() => marketplaceConfig);
        return { MarketplaceConfigService: MarketplaceConfigService22 };
      }, true ? void 0 : void 0);
      const pixalTemplateId = MarketplaceConfigService2.getPixalTemplateId();
      const url = `${this.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&template_id=${pixalTemplateId}&burned=false&limit=${limit}&offset=${offset}&order=desc&sort=asset_id`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const waxRockAssets = data.data.filter((asset) => {
          const waxRock = asset.data?.WaxRock || asset.template?.immutable_data?.WaxRock;
          if (waxRock && typeof waxRock === "string") {
            return waxRock !== "none" && MarketplaceConfigService2.isValidWaxRock(waxRock);
          }
          return false;
        });
        const assets = waxRockAssets.map((asset) => ({
          sale_id: "",
          asset_id: asset.asset_id || "",
          name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id}`,
          image: this.getAssetImage(asset),
          price: "Not for sale",
          seller: account,
          collection: asset.collection?.collection_name || "Unknown",
          schema: asset.schema?.schema_name || "Unknown",
          template_mint: parseInt(asset.template?.template_id || "0") || 0,
          max_supply: asset.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(asset.data || {}).map(([key, value]) => [key, value ?? ""])
          ),
          data: asset.data
        }));
        const hasMore = data.data.length === limit;
        return { assets, total: assets.length, hasMore };
      }
      return { assets: [], total: 0, hasMore: false };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserInventoryWaxRocks", error, { account, limit, offset });
      return { assets: [], total: 0, hasMore: false };
    }
  }
  // WAX Chain API methods
  async getWaxChainInfo() {
    try {
      const response = await this.fetchWithRetry(`${this.waxChainAPI}/v1/chain/get_info`);
      if (response.ok) {
        return await response.json();
      }
      throw new Error("Failed to fetch chain info");
    } catch (error) {
      ErrorMessageService.logError("ApiService.getWaxChainInfo", error);
      if (this.currentWaxChainIndex < this.waxChainEndpoints.length - 1) {
        this.currentWaxChainIndex++;
        return this.getWaxChainInfo();
      }
      this.currentWaxChainIndex = 0;
      return null;
    }
  }
  async getWaxAccountInfo(accountName) {
    for (let endpointIndex = 0; endpointIndex < this.waxChainEndpoints.length; endpointIndex++) {
      const endpoint = this.waxChainEndpoints[endpointIndex];
      try {
        const response = await fetch(
          `${endpoint}/v1/chain/get_account`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Accept": "application/json"
            },
            mode: "cors",
            body: JSON.stringify({
              account_name: accountName
            })
          }
        );
        if (response.ok) {
          const data = await response.json();
          this.currentWaxChainIndex = endpointIndex;
          return data;
        } else {
          logger.warn(`Endpoint ${endpoint} returned status ${response.status}: ${response.statusText}`, "API");
        }
      } catch (error) {
        ErrorMessageService.logError("ApiService.getWaxAccountInfo", error, { endpoint, accountName });
      }
    }
    ErrorMessageService.logError("ApiService.getWaxAccountInfo", new Error("All WAX chain endpoints failed for get_account"), { accountName });
    return null;
  }
  async getWaxCurrencyBalance(accountName, contract = "eosio.token", symbol = "WAX") {
    logger.debug(`Attempting to fetch currency balance for: ${accountName}`, "API");
    for (let endpointIndex = 0; endpointIndex < this.waxChainEndpoints.length; endpointIndex++) {
      const endpoint = this.waxChainEndpoints[endpointIndex];
      logger.debug(`Trying endpoint ${endpointIndex + 1}/${this.waxChainEndpoints.length}: ${endpoint}`, "API");
      try {
        const response = await fetch(
          `${endpoint}/v1/chain/get_currency_balance`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Accept": "application/json"
            },
            mode: "cors",
            body: JSON.stringify({
              code: contract,
              account: accountName,
              symbol
            })
          }
        );
        if (response.ok) {
          const balances = await response.json();
          logger.debug(`Successfully fetched currency balance from ${endpoint}`, "API");
          this.currentWaxChainIndex = endpointIndex;
          return balances.map((balance) => ({
            balance,
            contract,
            symbol: balance.split(" ")[1] || symbol
          }));
        } else {
          logger.warn(`Endpoint ${endpoint} returned status ${response.status}: ${response.statusText}`, "API");
        }
      } catch (error) {
        ErrorMessageService.logError("ApiService.getWaxCurrencyBalance", error, { endpoint, accountName, contract, symbol });
      }
    }
    ErrorMessageService.logError("ApiService.getWaxCurrencyBalance", new Error("All WAX chain endpoints failed for get_currency_balance"), { accountName, contract, symbol });
    return [];
  }
  // === WAX Light API Methods ===
  /**
   * Get token balances for a WAX account using Light API
   * Much faster than standard RPC calls
   */
  async getLightApiBalances(accountName) {
    try {
      const url = `${this.waxLightAPI}/api/balances/wax/${accountName}`;
      const response = await fetch(url, {
        method: "GET",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        mode: "cors"
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      return data;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getLightApiBalances", error, { accountName });
      return null;
    }
  }
  /**
   * Get account information using Light API
   */
  async getLightApiAccountInfo(accountName) {
    try {
      const url = `${this.waxLightAPI}/api/account/wax/${accountName}`;
      const response = await fetch(url, {
        method: "GET",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        mode: "cors"
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      ErrorMessageService.logError("ApiService.getLightApiAccountInfo", error, { accountName });
      return null;
    }
  }
  // === Alcor Exchange API Methods ===
  /**
   * Get token price from Alcor Exchange
   */
  async getAlcorTokenPrice(symbol, contract) {
    let timeoutId = null;
    try {
      const tokenId = `${symbol.toLowerCase()}-${contract}`;
      const url = `${this.alcorAPI}/tokens/${tokenId}`;
      const controller = new AbortController();
      timeoutId = setTimeout(() => {
        controller.abort();
      }, 8e3);
      const response = await this.fetchAlcorAPI(url, 2, { signal: controller.signal });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const tokenData = await response.json();
      return tokenData;
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        logger.warn(`Alcor API request timeout for ${symbol}`, "API");
        return null;
      }
      logger.warn(`Error fetching Alcor token price for ${symbol}`, "API", error);
      if (symbol.toLowerCase() === "wax") {
        return {
          symbol: "WAX",
          contract: "eosio.token",
          id: "wax-eosio.token",
          system_price: 0.05,
          // Fallback price
          usd_price: 0.05,
          decimals: 8
        };
      }
      return null;
    } finally {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    }
  }
  /**
   * Get all available trading pairs from Alcor Exchange
   */
  async getAlcorMarkets() {
    try {
      const url = `${this.alcorAPI}/pairs`;
      const response = await this.fetchAlcorAPI(url);
      return await response.json();
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAlcorMarkets", error);
      return [];
    }
  }
  /**
   * Get marketplace configuration data
   * This would typically come from a backend API or configuration service
   * For now, we'll simulate API responses with the known data
   */
  async getMarketplaceConfig() {
    try {
      return {
        partnerCollections: [
          "friedfactory",
          "pixeljourney"
        ],
        tokenContracts: [
          "alien.worlds",
          "prospectorsc",
          "token.nefty"
        ],
        supportedTokens: [
          { contract: "eosio.token", symbol: "WAX", precision: 8 },
          { contract: "alien.worlds", symbol: "TLM", precision: 4 },
          { contract: "prospectorsc", symbol: "PGL", precision: 4 },
          { contract: "token.nefty", symbol: "NEFTY", precision: 8 }
        ]
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getMarketplaceConfig", error);
      return {
        partnerCollections: ["friedfactory", "pixeljourney"],
        tokenContracts: ["alien.worlds", "prospectorsc", "token.nefty"],
        supportedTokens: [
          { contract: "eosio.token", symbol: "WAX", precision: 8 }
        ]
      };
    }
  }
  /**
   * Get partner collections from API
   */
  async getPartnerCollections() {
    try {
      const config = await this.getMarketplaceConfig();
      return config.partnerCollections;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getPartnerCollections", error);
      return ["friedfactory", "pixeljourney"];
    }
  }
  /**
   * Get supported token contracts from API
   */
  async getTokenContracts() {
    try {
      const config = await this.getMarketplaceConfig();
      return config.tokenContracts;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getTokenContracts", error);
      return ["alien.worlds", "prospectorsc", "token.nefty"];
    }
  }
  /**
   * Get swap quote for token exchange on Alcor
   */
  async getAlcorSwapQuote(params) {
    try {
      const url = `${this.alcorAPI}/swap/quote`;
      const response = await this.fetchAlcorAPI(url, 3, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(params)
      });
      return await response.json();
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAlcorSwapQuote", error, { params });
      return null;
    }
  }
  /**
   * Get PXJ token price specifically (commonly used)
   */
  async getPXJPrice() {
    try {
      const priceData = await this.getAlcorTokenPrice("PXJ", "pixeljourney");
      return priceData?.system_price || 0;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getPXJPrice", error);
      return 0;
    }
  }
  /**
   * Calculate total portfolio value in USD
   */
  async calculatePortfolioValue(balances) {
    let totalValue = 0;
    for (const balance of balances) {
      try {
        const priceData = await this.getAlcorTokenPrice(balance.currency, balance.contract);
        if (priceData) {
          const amount = parseFloat(balance.amount);
          const decimals = parseInt(balance.decimals);
          const adjustedAmount = amount / Math.pow(10, decimals);
          totalValue += adjustedAmount * priceData.usd_price;
        }
      } catch (error) {
        logger.warn(`Could not get price for ${balance.currency}`, "API", error);
      }
    }
    return totalValue;
  }
  /**
   * Get marketplace listings for NFTs by asset_id
   */
  async getMarketplaceNFTs(params) {
    try {
      const { page = 1, limit = 100, asset_id, state = 1 } = params;
      let url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/sales?state=${state}&page=${page}&limit=${limit}&order=desc&sort=created`;
      if (asset_id) {
        url += `&asset_id=${asset_id}`;
      }
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return {
          success: true,
          data: data.data.map((sale) => ({
            sale_id: sale.sale_id,
            asset_id: sale.assets[0]?.asset_id || "",
            price: sale.price ? `${(parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision || 8)).toFixed(8)} ${sale.price.token_symbol}` : "0 WAX",
            seller: sale.seller,
            created_at_time: sale.created_at_time
          }))
        };
      }
      return { success: true, data: [] };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getMarketplaceNFTs", error, { params });
      return { success: false, data: [] };
    }
  }
  /**
   * Get offers for a specific NFT asset
   */
  async getAssetOffers(assetId) {
    try {
      const url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/buyoffers?asset_id=${assetId}&state=0&page=1&limit=100&order=desc&sort=price`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        return data.data.map((offer) => ({
          id: offer.buyoffer_id,
          buyer: offer.buyer,
          price: offer.price.amount,
          symbol: offer.price.token_symbol,
          timestamp: offer.created_at_time,
          memo: offer.memo || ""
        }));
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAssetOffers", error, { assetId });
      return [];
    }
  }
  /**
   * Get assets in batch using ids parameter for efficient API usage
   */
  async getAssetsBatch(assetIds) {
    if (!assetIds.length) {
      return { success: true, data: [], errors: [] };
    }
    try {
      const chunks = this.chunkArray(assetIds, 100);
      const allAssets = [];
      const errors = [];
      for (const chunk of chunks) {
        try {
          const idsParam = chunk.join(",");
          const url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicassets/v1/assets`;
          const response = await this.fetchWithRetry(url, 3, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              ids: idsParam,
              limit: "1000"
            })
          });
          const data = await response.json();
          if (data.success && data.data) {
            allAssets.push(...data.data);
          } else {
            errors.push(`Failed to fetch assets batch: ${chunk.join(", ")}`);
          }
        } catch (error) {
          ErrorMessageService.logError("ApiService.getAssetsBatch", error, { chunk });
          errors.push(`Error fetching assets: ${chunk.join(", ")}`);
        }
      }
      return {
        success: errors.length === 0,
        data: allAssets,
        errors
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAssetsBatch", error, { assetIds });
      return {
        success: false,
        data: [],
        errors: [`Failed to process asset batch: ${error}`]
      };
    }
  }
  /**
   * Get templates in batch using ids parameter for efficient API usage
   */
  async getTemplatesBatch(templateIds) {
    if (!templateIds.length) {
      return { success: true, data: [], errors: [] };
    }
    try {
      const chunks = this.chunkArray(templateIds, 100);
      const allTemplates = [];
      const errors = [];
      for (const chunk of chunks) {
        try {
          const idsParam = chunk.join(",");
          const url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicassets/v1/templates`;
          const response = await this.fetchWithRetry(url, 3, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              ids: idsParam,
              limit: "1000"
            })
          });
          const data = await response.json();
          if (data.success && data.data) {
            allTemplates.push(...data.data);
          } else {
            errors.push(`Failed to fetch templates batch: ${chunk.join(", ")}`);
          }
        } catch (error) {
          ErrorMessageService.logError("ApiService.getTemplatesBatch", error, { chunk });
          errors.push(`Error fetching templates: ${chunk.join(", ")}`);
        }
      }
      return {
        success: errors.length === 0,
        data: allTemplates,
        errors
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getTemplatesBatch", error, { templateIds });
      return {
        success: false,
        data: [],
        errors: [`Failed to process template batch: ${error}`]
      };
    }
  }
  /**
   * Get asset counts for multiple templates efficiently
   */
  async getAssetCountsBatch(templateIds, owner) {
    if (!templateIds.length) {
      return { success: true, data: {}, errors: [] };
    }
    try {
      const counts = {};
      const errors = [];
      const chunks = this.chunkArray(templateIds, 50);
      for (const chunk of chunks) {
        try {
          const promises = chunk.map(async (templateId) => {
            try {
              const params = {
                template_id: templateId,
                limit: 1
                // We only need the count
              };
              if (owner) {
                params.owner = owner;
              }
              const url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicassets/v1/assets`;
              const queryParams = new URLSearchParams();
              Object.entries(params).forEach(([key, value]) => {
                if (value !== void 0 && value !== null) {
                  queryParams.append(key, String(value));
                }
              });
              const response = await this.fetchWithRetry(`${url}?${queryParams}`);
              const data = await response.json();
              if (data.success) {
                return { templateId, count: parseInt(data.query_total || "0") };
              } else {
                return { templateId, count: 0, error: "API returned unsuccessful response" };
              }
            } catch (error) {
              return { templateId, count: 0, error: String(error) };
            }
          });
          const results = await Promise.all(promises);
          results.forEach((result) => {
            if (result.error) {
              errors.push(`Error fetching count for template ${result.templateId}: ${result.error}`);
            }
            counts[result.templateId] = result.count;
          });
          if (chunks.indexOf(chunk) < chunks.length - 1) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
        } catch (error) {
          ErrorMessageService.logError("ApiService.getAssetCountsBatch chunk", error, { chunk });
          chunk.forEach((templateId) => {
            counts[templateId] = 0;
            errors.push(`Error processing template ${templateId}: ${error}`);
          });
        }
      }
      return {
        success: errors.length === 0,
        data: counts,
        errors
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAssetCountsBatch", error, { templateIds });
      return {
        success: false,
        data: {},
        errors: [`Failed to process asset counts batch: ${error}`]
      };
    }
  }
  /**
   * Get all offers (buy offers) with comprehensive filtering
   */
  async getOffers(params = {}) {
    try {
      const {
        page = 1,
        limit = 100,
        order = "desc",
        sort = "created",
        state = "0",
        collection_name,
        schema_name,
        template_id,
        asset_id,
        buyer,
        seller,
        min_price,
        max_price,
        symbol = "WAX"
      } = params;
      let url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/buyoffers?page=${page}&limit=${limit}&order=${order}&sort=${sort}&state=${state}&symbol=${symbol}`;
      if (collection_name) url += `&collection_name=${collection_name}`;
      if (schema_name) url += `&schema_name=${schema_name}`;
      if (template_id) url += `&template_id=${template_id}`;
      if (asset_id) url += `&asset_id=${asset_id}`;
      if (buyer) url += `&buyer=${buyer}`;
      if (seller) url += `&seller=${seller}`;
      if (min_price) url += `&min_price=${min_price}`;
      if (max_price) url += `&max_price=${max_price}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return {
        success: data.success || false,
        data: data.data || [],
        query_total: data.query_total
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getOffers", error, params);
      return { success: false, data: [] };
    }
  }
  /**
   * Get price history and statistics for assets/templates
   */
  async getPrices(params = {}) {
    try {
      const {
        page = 1,
        limit = 100,
        order = "desc",
        sort = "created",
        collection_name,
        schema_name,
        template_id,
        symbol = "WAX"
      } = params;
      let url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/prices?page=${page}&limit=${limit}&order=${order}&sort=${sort}&symbol=${symbol}`;
      if (collection_name) url += `&collection_name=${collection_name}`;
      if (schema_name) url += `&schema_name=${schema_name}`;
      if (template_id) url += `&template_id=${template_id}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return {
        success: data.success || false,
        data: data.data || [],
        query_total: data.query_total
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getPrices", error, params);
      return { success: false, data: [] };
    }
  }
  /**
   * Get asset transfers history
   */
  async getTransfers(params = {}) {
    try {
      const {
        page = 1,
        limit = 100,
        order = "desc",
        sort = "created",
        collection_name,
        schema_name,
        template_id,
        asset_id,
        sender,
        recipient_name: recipient
      } = params;
      let url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicassets/v1/transfers?page=${page}&limit=${limit}&order=${order}&sort=${sort}`;
      if (collection_name) url += `&collection_name=${collection_name}`;
      if (schema_name) url += `&schema_name=${schema_name}`;
      if (template_id) url += `&template_id=${template_id}`;
      if (asset_id) url += `&asset_id=${asset_id}`;
      if (sender) url += `&sender_name=${sender}`;
      if (recipient) url += `&recipient_name=${recipient}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return {
        success: data.success || false,
        data: data.data || [],
        query_total: data.query_total
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getTransfers", error, params);
      return { success: false, data: [] };
    }
  }
  /**
   * Get comprehensive collection market statistics
   */
  async getCollectionMarketStats(params = {}) {
    try {
      const { collection_name, symbol = "WAX" } = params;
      let url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/stats/collections?symbol=${symbol}`;
      if (collection_name) {
        url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/stats/collections/${collection_name}?symbol=${symbol}`;
      }
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return {
        success: data.success || false,
        data: data.data || {}
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionMarketStats", error, params);
      return {
        success: false,
        data: {
          symbol: "",
          market_contract: "",
          sales: "0",
          volume: "0",
          suggested_median: "0",
          suggested_average: "0"
        }
      };
    }
  }
  /**
   * Get template statistics and pricing data
   */
  async getTemplateStats(collectionName, templateId, symbol = "WAX") {
    try {
      const url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/stats/templates/${collectionName}/${templateId}?symbol=${symbol}`;
      const response = await this.fetchWithRetry(url);
      const data = await response.json();
      return {
        success: data.success || false,
        data: data.data || {}
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getTemplateStats", error, { collectionName, templateId, symbol });
      return {
        success: false,
        data: {
          template_id: "",
          collection_name: "",
          assets: "0",
          burned: "0",
          sales: "0",
          volume: "0",
          suggested_median: "0",
          suggested_average: "0"
        }
      };
    }
  }
  /**
   * Get account transfers for a specific token
   */
  /**
   * Fetch transaction history using WAX Hyperion History API
   */
  async getHyperionTransactionHistory(account, limit = 100, skip = 0) {
    logger.debug(" Fetching Hyperion transaction history for:", "API", { account });
    try {
      const hyperionUrl = `${this.hyperionEndpoints[this.currentHyperionIndex]}/v2/history/get_actions`;
      const params = new URLSearchParams({
        account,
        limit: Math.min(limit, 1e3).toString(),
        skip: skip.toString(),
        sort: "desc"
      });
      logger.debug(" Hyperion API URL:", "API", { url: `${hyperionUrl}?${params}` });
      const response = await this.fetchWithRetry(`${hyperionUrl}?${params}`);
      const data = await response.json();
      if (!data.actions || !Array.isArray(data.actions)) {
        logger.warn("No actions found in Hyperion response", "API");
        return [];
      }
      logger.debug(` Found ${data.actions.length} Hyperion actions`, "API");
      const transactions = data.actions.map((action) => {
        const actionData = action.act.data;
        let transactionType = "unknown";
        if (action.act.account === "eosio.token" && action.act.name === "transfer") {
          transactionType = actionData.from === account ? "token_send" : "token_receive";
        } else if (action.act.account === "atomicassets" && action.act.name === "transfer") {
          transactionType = "nft_transfer";
        } else if (action.act.account === "atomicmarket" && action.act.name === "purchasesale") {
          transactionType = "nft_purchase";
        } else if (action.act.account === "atomicmarket" && action.act.name === "announcesale") {
          transactionType = "nft_listing";
        } else if (action.act.account === "atomicmarket" && action.act.name === "cancelsale") {
          transactionType = "nft_cancel_listing";
        } else {
          transactionType = `${action.act.account}_${action.act.name}`;
        }
        return {
          transaction_id: action.trx_id,
          block_time: action.timestamp,
          action_name: action.act.name,
          contract: action.act.account,
          from: actionData.from,
          to: actionData.to,
          quantity: actionData.quantity,
          memo: actionData.memo,
          asset_ids: actionData.asset_ids,
          collection_name: actionData.collection_name,
          type: transactionType,
          status: "completed"
        };
      });
      logger.debug(` Processed ${transactions.length} Hyperion transactions`, "API");
      return transactions;
    } catch (error) {
      logger.error(" Hyperion API error", "API", error);
      if (this.currentHyperionIndex < this.hyperionEndpoints.length - 1) {
        this.currentHyperionIndex++;
        logger.debug(` Switching to Hyperion endpoint ${this.currentHyperionIndex + 1}`, "API");
        return this.getHyperionTransactionHistory(account, limit, skip);
      } else {
        this.currentHyperionIndex = 0;
        ErrorMessageService.logError("ApiService.getHyperionTransactionHistory", error, { account, limit, skip });
        return [];
      }
    }
  }
  async getAccountTransfers(account, contract, symbol, limit = 50, offset = 0) {
    try {
      const hyperionUrl = `${this.hyperionEndpoints[this.currentHyperionIndex]}/v2/history/get_actions`;
      const params = new URLSearchParams({
        account,
        limit: Math.min(limit, 100).toString(),
        sort: "desc",
        skip: offset.toString(),
        [`transfer.to`]: account
      });
      logger.debug(" Fetching account transfers from Hyperion:", "API", {
        account,
        contract,
        symbol,
        url: `${hyperionUrl}?${params}`
      });
      const response = await this.fetchWithRetry(`${hyperionUrl}?${params}`);
      const data = await response.json();
      if (!data.actions || !Array.isArray(data.actions)) {
        logger.warn("No actions found in Hyperion response for transfers", "API");
        return [];
      }
      logger.debug(` Found ${data.actions.length} Hyperion transfer actions`, "API");
      const transfers = data.actions.filter((action) => {
        const act = action.act;
        return act?.account === contract && act?.name === "transfer" && (act?.data?.to === account || act?.data?.from === account) && (act?.data?.quantity?.includes(symbol) || act?.data?.symbol === symbol);
      }).slice(0, limit).map((action) => {
        const data2 = action.act.data;
        return {
          from: data2.from,
          to: data2.to,
          quantity: data2.quantity,
          memo: data2.memo || "",
          timestamp: action.timestamp,
          transaction_id: action.trx_id,
          block_num: action.block_num
        };
      });
      logger.debug(` Processed ${transfers.length} transfers for account ${account}`, "API");
      return transfers;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAccountTransfers", error, { account, contract, symbol, limit, offset });
      logger.warn("Falling back to legacy WAX chain API", "API");
      return this.fetchTransfersFromWaxChainAPI(account, contract, symbol, limit, offset);
    }
  }
  /**
   * Legacy WAX Chain API fallback method for transfer fetching
   */
  async fetchTransfersFromWaxChainAPI(account, contract, symbol, limit = 50, offset = 0) {
    try {
      const response = await fetch(`${this.waxChainAPI}/v1/history/get_actions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          account_name: account,
          pos: -1,
          offset,
          filter: `${contract}:transfer`
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      const actions = data.actions || [];
      const transfers = actions.filter((action) => {
        const act = action.action_trace?.act;
        return act?.name === "transfer" && act?.account === contract && (act?.data?.to === account || act?.data?.from === account) && act?.data?.quantity?.includes(symbol);
      }).slice(0, limit).map((action) => {
        const act = action.action_trace.act;
        const data2 = act.data;
        return {
          from: data2.from,
          to: data2.to,
          quantity: data2.quantity,
          memo: data2.memo || "",
          timestamp: action.block_time,
          transaction_id: action.action_trace.trx_id,
          block_num: action.block_num
        };
      });
      return transfers;
    } catch (error) {
      ErrorMessageService.logError("ApiService.fetchTransfersFromWaxChainAPI", error, { account, contract, symbol, limit, offset });
      return [];
    }
  }
  /**
   * Get comprehensive user transaction history including marketplace sales and NFT transfers
   */
  async getUserTransactions(account, limit = 500) {
    logger.debug(" getUserTransactions called for account:", "API", { account, limit });
    try {
      const allTransactions = [];
      try {
        logger.debug(" Fetching Hyperion transaction history...", "API");
        const hyperionTransactions = await this.getHyperionTransactionHistory(account, Math.min(limit, 200));
        logger.debug(" Hyperion transactions:", "API", { count: hyperionTransactions.length });
        const formattedHyperionTransactions = hyperionTransactions.map((tx) => ({
          transaction_id: tx.transaction_id,
          block_time: tx.block_time,
          action_name: tx.action_name,
          asset_id: tx.asset_ids?.[0],
          asset_name: tx.asset_ids?.[0] ? `Asset #${tx.asset_ids[0]}` : void 0,
          collection_name: tx.collection_name,
          price: tx.quantity,
          from: tx.from,
          to: tx.to,
          type: tx.type,
          status: tx.status,
          memo: tx.memo
        }));
        allTransactions.push(...formattedHyperionTransactions);
        logger.debug(" Added Hyperion transactions", "API", { count: formattedHyperionTransactions.length });
      } catch (error) {
        logger.warn("Failed to fetch Hyperion transactions", "API", error);
      }
      try {
        const salesUrl = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/sales?account=${account}&state=3&page=1&limit=${Math.min(limit, 200)}&order=desc&sort=updated`;
        logger.debug(" Fetching marketplace transactions from:", "API", { url: salesUrl });
        const salesResponse = await this.fetchWithRetry(salesUrl);
        const salesData = await salesResponse.json();
        logger.debug(" Marketplace response:", "API", { success: salesData.success, dataLength: salesData.data?.length });
        if (salesData.success && salesData.data) {
          const marketplaceTransactions = salesData.data.map((sale) => {
            const priceAmount = parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision || 8);
            const formattedPrice = sale.price.token_symbol === "WAX" ? formatWAXPrice(priceAmount) : `${formatNumber(priceAmount)} ${sale.price.token_symbol}`;
            return {
              transaction_id: sale.sale_id,
              block_time: sale.updated_at_time,
              action_name: sale.buyer === account ? "purchase" : "sale",
              asset_id: sale.assets[0]?.asset_id,
              asset_name: sale.assets[0]?.name || `Asset #${sale.assets[0]?.asset_id}`,
              collection_name: sale.assets[0]?.collection?.collection_name,
              price: formattedPrice,
              from: sale.buyer === account ? sale.seller : account,
              to: sale.buyer === account ? account : sale.buyer,
              type: sale.buyer === account ? "purchase" : "sale",
              status: "completed"
            };
          });
          allTransactions.push(...marketplaceTransactions);
        }
      } catch (error) {
        logger.warn("Failed to fetch marketplace transactions", "API", error);
      }
      try {
        const transfersUrl = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicassets/v1/transfers?account=${account}&page=1&limit=${Math.min(limit, 200)}&order=desc&sort=created`;
        logger.debug(" Fetching NFT transfers from:", "API", { url: transfersUrl });
        const transfersResponse = await this.fetchWithRetry(transfersUrl);
        const transfersData = await transfersResponse.json();
        logger.debug(" NFT transfers response:", "API", { success: transfersData.success, dataLength: transfersData.data?.length });
        if (transfersData.success && transfersData.data) {
          const nftTransfers = transfersData.data.filter((transfer) => transfer.sender !== transfer.recipient).map((transfer) => {
            const asset = transfer.assets?.[0];
            return {
              transaction_id: transfer.tx_id || `transfer_${transfer.transfer_id}`,
              block_time: transfer.created_at_time,
              action_name: "transfer",
              asset_id: asset?.asset_id,
              asset_name: asset?.name || `Asset #${asset?.asset_id}`,
              collection_name: asset?.collection?.collection_name,
              price: void 0,
              from: transfer.sender,
              to: transfer.recipient,
              type: "transfer",
              status: "completed",
              memo: transfer.memo || void 0
            };
          });
          allTransactions.push(...nftTransfers);
        }
      } catch (error) {
        logger.warn("Failed to fetch NFT transfers", "API", error);
      }
      try {
        logger.debug(" Fetching token transfers for account:", "API", { account });
        const tokenTransfers = await this.getAccountTransfers(account, "eosio.token", "WAX", Math.min(limit, 100));
        logger.debug(" Token transfers response:", "API", { count: tokenTransfers.length });
        const formattedTokenTransfers = tokenTransfers.map((transfer) => ({
          transaction_id: transfer.transaction_id,
          block_time: transfer.timestamp,
          action_name: "token_transfer",
          asset_id: void 0,
          asset_name: "WAX Token",
          collection_name: "WAX",
          price: transfer.quantity,
          from: transfer.from,
          to: transfer.to,
          type: transfer.from === account ? "token_send" : "token_receive",
          status: "completed",
          memo: transfer.memo
        }));
        allTransactions.push(...formattedTokenTransfers);
      } catch (error) {
        logger.warn("Failed to fetch token transfers", "API", error);
      }
      logger.debug(" Total transactions found:", "API", { count: allTransactions.length });
      const uniqueTransactions = /* @__PURE__ */ new Map();
      allTransactions.forEach((tx) => {
        const existing = uniqueTransactions.get(tx.transaction_id);
        if (!existing) {
          uniqueTransactions.set(tx.transaction_id, tx);
        } else {
          const merged = {
            ...existing,
            ...tx,
            // Prefer non-undefined values
            asset_id: tx.asset_id || existing.asset_id,
            asset_name: tx.asset_name || existing.asset_name,
            collection_name: tx.collection_name || existing.collection_name,
            price: tx.price || existing.price,
            from: tx.from || existing.from,
            to: tx.to || existing.to,
            memo: tx.memo || existing.memo
          };
          uniqueTransactions.set(tx.transaction_id, merged);
        }
      });
      const sortedTransactions = Array.from(uniqueTransactions.values()).sort((a, b) => new Date(b.block_time).getTime() - new Date(a.block_time).getTime()).slice(0, limit);
      logger.debug(" Returning unique transactions", "API", { unique: sortedTransactions.length, total: allTransactions.length });
      return sortedTransactions;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserTransactions", error, { account, limit });
      return [];
    }
  }
  /**
   * Get user statistics from various sources
   */
  async getUserStats(account) {
    try {
      let joinDate = "2023-01-01";
      try {
        const accountInfo = await this.getWaxAccountInfo(account);
        if (accountInfo?.created) {
          const createdDate = new Date(accountInfo.created);
          joinDate = createdDate.toISOString().split("T")[0];
        }
      } catch (accountError) {
        logger.warn("Failed to fetch account creation date", "API", { account, error: accountError });
      }
      const assetsUrl = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicassets/v1/assets?owner=${account}&page=1&limit=1`;
      const assetsResponse = await this.fetchWithRetry(assetsUrl);
      const assetsData = await assetsResponse.json();
      const nftsOwned = assetsData.success ? assetsData.query_total || assetsData.data?.length || 0 : 0;
      const salesUrl = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/sales?seller=${account}&state=3&page=1&limit=100&order=desc&sort=updated`;
      const salesResponse = await this.fetchWithRetry(salesUrl);
      const salesData = await salesResponse.json();
      let totalSales = 0;
      let totalEarned = 0;
      const collections = /* @__PURE__ */ new Set();
      if (salesData.success && salesData.data) {
        totalSales = salesData.data.length;
        salesData.data.forEach((sale) => {
          totalEarned += parseFloat(sale.price.amount) || 0;
          if (sale.assets[0]?.collection?.collection_name) {
            collections.add(sale.assets[0].collection.collection_name);
          }
        });
      }
      const purchasesUrl = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/sales?buyer=${account}&state=3&page=1&limit=100&order=desc&sort=updated`;
      const purchasesResponse = await this.fetchWithRetry(purchasesUrl);
      const purchasesData = await purchasesResponse.json();
      let totalPurchases = 0;
      let totalSpent = 0;
      if (purchasesData.success && purchasesData.data) {
        totalPurchases = purchasesData.data.length;
        purchasesData.data.forEach((sale) => {
          totalSpent += parseFloat(sale.price.amount) || 0;
          if (sale.assets[0]?.collection?.collection_name) {
            collections.add(sale.assets[0].collection.collection_name);
          }
        });
      }
      return {
        totalAssets: nftsOwned,
        totalPurchases,
        totalSales,
        totalSpent: formatWAXPrice(totalSpent),
        totalEarned: formatWAXPrice(totalEarned),
        collections: Array.from(collections),
        favoriteCollections: Array.from(collections).slice(0, 3),
        joinDate,
        nftsOwned,
        nftsListed: 0
        // Would need active listings count
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUserStats", error, { account });
      return {
        totalAssets: 0,
        totalPurchases: 0,
        totalSales: 0,
        totalSpent: "0.0000 WAX",
        totalEarned: "0.0000 WAX",
        collections: [],
        favoriteCollections: [],
        joinDate: "2023-01-01",
        nftsOwned: 0,
        nftsListed: 0
      };
    }
  }
  async getCollectionPriceHistory(collectionName, timeframe = "7d") {
    try {
      const url = `${this.atomicEndpoints[this.currentEndpointIndex]}/atomicmarket/v1/sales?collection_name=${collectionName}&state=3&limit=100&order=desc&sort=updated`;
      const response = await this.fetchWithRetry(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      const priceHistory = data.data.map((sale) => ({
        timestamp: new Date(sale.updated_at_time).getTime(),
        price: parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision),
        volume: 1
      }));
      return priceHistory;
    } catch (error) {
      ErrorMessageService.logError("ApiService.getCollectionPriceHistory", error, { collectionName, timeframe });
      return this.fetchPriceHistoryFromAlcor(collectionName, timeframe);
    }
  }
  /**
   * Fetch real price history from Alcor Exchange API
   */
  async fetchPriceHistoryFromAlcor(collectionName, timeframe) {
    try {
      const response = await fetch(`${this.alcorAPI}/markets/1/charts?resolution=1D&limit=100`);
      if (response.ok) {
        const data = await response.json();
        if (data && Array.isArray(data)) {
          const days = timeframe === "24h" ? 1 : timeframe === "7d" ? 7 : timeframe === "30d" ? 30 : 90;
          return data.slice(-days).map((item) => ({
            timestamp: item.time * 1e3,
            // Convert to milliseconds
            price: parseFloat(item.close || item.price || "1"),
            volume: parseFloat(item.volume || "0")
          }));
        }
      }
      const collectionStats = await this.getCollectionMarketStats({ collection_name: collectionName });
      if (collectionStats.success && collectionStats.data) {
        const basePrice = parseFloat(collectionStats.data.suggested_average || "1");
        const now = Date.now();
        const days = timeframe === "24h" ? 1 : timeframe === "7d" ? 7 : timeframe === "30d" ? 30 : 90;
        const priceHistory = [];
        for (let i = days; i >= 0; i--) {
          const timestamp = now - i * 24 * 60 * 60 * 1e3;
          const variation = 0.9 + Math.random() * 0.2;
          const price = basePrice * variation;
          const volume = parseFloat(collectionStats.data.volume || "0") / days;
          priceHistory.push({ timestamp, price, volume });
        }
        return priceHistory;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.fetchPriceHistoryFromAlcor", error, { collectionName, timeframe });
      return [];
    }
  }
  async getAuctionBids(auctionId) {
    try {
      return [];
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAuctionBids", error, { auctionId });
      return [];
    }
  }
  async getAuctions(params = {}) {
    const {
      state = 1,
      limit = 36,
      offset = 0,
      sort = "created",
      order = "desc",
      hide_empty_auctions = true,
      search,
      collection_name,
      collection_blacklist = "flinttffunko,onlyfanzgaly,farmerpetsco,fantaspeop",
      seller_blacklist = "dximg.wam,xpvrs.wam,5rrrc.wam,nnmnmnmnn.gm",
      symbol = "WAX"
    } = params;
    try {
      let url = `${this.atomicMarketAPI}/atomicmarket/v1/auctions?limit=${limit}&offset=${offset}&sort=${sort}&order=${order}&symbol=${symbol}`;
      if (state !== void 0) {
        url += `&state=${state}`;
      }
      if (hide_empty_auctions) {
        url += `&hide_empty_auctions=true`;
      }
      if (search) {
        url += `&search=${encodeURIComponent(search)}`;
      }
      if (collection_name) {
        url += `&collection_name=${encodeURIComponent(collection_name)}`;
      }
      if (collection_blacklist) {
        url += `&collection_blacklist=${encodeURIComponent(collection_blacklist)}`;
      }
      if (seller_blacklist) {
        url += `&seller_blacklist=${encodeURIComponent(seller_blacklist)}`;
      }
      const response = await this.fetchWithRetry(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (!data.success || !data.data) {
        throw new Error("Invalid API response structure");
      }
      const formattedData = data.data.map((auction) => {
        const asset = auction.assets?.[0];
        const assetName = asset?.name || asset?.data?.name || asset?.template?.immutable_data?.name || `${asset?.collection?.collection_name || "Unknown"} #${asset?.asset_id}`;
        const priceAmount = auction.price?.amount || "0";
        const tokenSymbol = auction.price?.token_symbol || "WAX";
        const tokenPrecision = auction.price?.token_precision || 8;
        const formattedPrice = priceAmount !== "0" ? `${(parseFloat(priceAmount) / Math.pow(10, tokenPrecision)).toFixed(tokenPrecision)} ${tokenSymbol}` : "0 WAX";
        return {
          auction_id: auction.auction_id,
          asset_id: asset?.asset_id || "",
          seller: auction.seller,
          price: formattedPrice,
          end_time: auction.end_time,
          collection_name: asset?.collection?.collection_name || "Unknown",
          template_id: asset?.template?.template_id || "",
          asset_name: assetName,
          image: asset ? this.getAssetImage(asset) : "https://pixeljourney.xyz/img/toppixals/10.webp",
          video: asset ? this.getAssetVideo(asset) || "" : "",
          current_bid: formattedPrice,
          bidder: auction.buyer || null,
          created_at_time: auction.created_at_time
        };
      });
      return { data: formattedData, success: true };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAuctions", error, { state, limit, offset, sort, order });
      return { data: [], success: false, error };
    }
  }
  /**
   * Get a single auction by ID
   */
  async getAuction(auctionId) {
    try {
      const url = `${this.atomicMarketAPI}/atomicmarket/v1/auctions/${auctionId}`;
      const response = await this.fetchWithRetry(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (!data.success || !data.data) {
        throw new Error("Invalid API response structure");
      }
      const auction = data.data;
      const formattedAuction = {
        auction_id: auction.auction_id,
        asset_id: auction.assets?.[0]?.asset_id || "",
        seller: auction.seller,
        price: auction.price?.amount || "0",
        end_time: auction.end_time,
        collection_name: auction.assets?.[0]?.collection?.collection_name || "Unknown",
        template_id: auction.assets?.[0]?.template?.template_id || "",
        asset_name: auction.assets?.[0]?.name || auction.assets?.[0]?.data?.name || `Asset #${auction.assets?.[0]?.asset_id}`,
        image: auction.assets?.[0] ? this.getAssetImage(auction.assets[0]) : "",
        video: auction.assets?.[0] ? this.getAssetVideo(auction.assets[0]) : "",
        current_bid: auction.price?.amount || "0",
        bidder: auction.buyer || null
      };
      return { data: formattedAuction, success: true };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getAuction", error, { auctionId });
      return { data: null, success: false, error };
    }
  }
  /**
   * Get USD price for a given WAX amount
   */
  async getUSDPrice(waxAmount) {
    try {
      const { priceService: priceService2 } = await __vitePreload(async () => {
        const { priceService: priceService3 } = await Promise.resolve().then(() => priceService$1);
        return { priceService: priceService3 };
      }, true ? void 0 : void 0);
      return await priceService2.convertWaxToUSDAsync(waxAmount.toString());
    } catch (error) {
      ErrorMessageService.logError("ApiService.getUSDPrice", error, { waxAmount });
      return "$0.00";
    }
  }
  /**
   * Generic WAX RPC call with endpoint rotation
   */
  async waxRpcCall(endpoint, body) {
    for (let endpointIndex = 0; endpointIndex < this.waxChainEndpoints.length; endpointIndex++) {
      const baseUrl = this.waxChainEndpoints[endpointIndex];
      const url = `${baseUrl}${endpoint}`;
      try {
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          mode: "cors",
          body: JSON.stringify(body)
        });
        if (response.ok) {
          this.currentWaxChainIndex = endpointIndex;
          return await response.json();
        }
        logger.warn("WAX RPC endpoint returned error status", "API", { endpoint: baseUrl, status: response.status, statusText: response.statusText });
      } catch (error) {
        ErrorMessageService.logError("ApiService.waxRpcCall", error, { endpoint: baseUrl, body });
      }
    }
    throw new Error(`All WAX RPC endpoints failed for ${endpoint}`);
  }
  /**
   * Get powerup state from WAX blockchain
   */
  async getPowerupState() {
    return this.waxRpcCall("/v1/chain/get_table_rows", {
      json: true,
      code: "eosio",
      scope: "eosio",
      table: "powup.state",
      limit: 1
    });
  }
  /**
   * Get chain info from WAX blockchain
   */
  async getChainInfo() {
    return this.waxRpcCall("/v1/chain/get_info", {});
  }
  /**
   * Get RWAX-specific transfers (tokenizations and redemptions)
   * Fetches transfers to/from the 'rwax' account for pixeljourney collection
   */
  async getRWAXTransfers(params = {}) {
    try {
      const {
        limit = 20,
        page = 1,
        order = "desc"
      } = params;
      const [toRwaxResponse, fromRwaxResponse] = await Promise.all([
        // Transfers TO rwax (tokenizations)
        this.getTransfers({
          recipient_name: "rwax",
          collection_name: "pixeljourney",
          limit: Math.ceil(limit / 2),
          page,
          order,
          sort: "created"
        }),
        // Transfers FROM rwax (redemptions)
        this.getTransfers({
          sender: "rwax",
          collection_name: "pixeljourney",
          limit: Math.ceil(limit / 2),
          page,
          order,
          sort: "created"
        })
      ]);
      const allTransfers = [
        ...toRwaxResponse.data.map((transfer) => ({
          ...transfer,
          type: "tokenization"
        })),
        ...fromRwaxResponse.data.map((transfer) => ({
          ...transfer,
          type: "redemption"
        }))
      ];
      const uniqueTransfers = /* @__PURE__ */ new Map();
      allTransfers.forEach((transfer) => {
        const uniqueKey = `${transfer.transfer_id}-${transfer.txid}`;
        if (!uniqueTransfers.has(uniqueKey)) {
          uniqueTransfers.set(uniqueKey, transfer);
        } else {
          const existing = uniqueTransfers.get(uniqueKey);
          const hasMoreAssets = transfer.assets.length > existing.assets.length;
          const hasMoreData = Object.keys(transfer).length > Object.keys(existing).length;
          if (hasMoreAssets || hasMoreData) {
            uniqueTransfers.set(uniqueKey, transfer);
          }
        }
      });
      const deduplicatedTransfers = Array.from(uniqueTransfers.values());
      deduplicatedTransfers.sort((a, b) => {
        const timeA = new Date(a.created_at_time).getTime();
        const timeB = new Date(b.created_at_time).getTime();
        return order === "desc" ? timeB - timeA : timeA - timeB;
      });
      const limitedTransfers = deduplicatedTransfers.slice(0, limit);
      return {
        success: true,
        data: limitedTransfers,
        query_total: (toRwaxResponse.query_total || 0) + (fromRwaxResponse.query_total || 0)
      };
    } catch (error) {
      ErrorMessageService.logError("ApiService.getRWAXTransfers", error, params);
      return { success: false, data: [] };
    }
  }
}
const apiService = new ApiService();
const api = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  apiService
}, Symbol.toStringTag, { value: "Module" }));
class BadgeService {
  constructor() {
    __publicField(this, "badgeCache", /* @__PURE__ */ new Map());
    __publicField(this, "CACHE_DURATION", 5 * 60 * 1e3);
    // 5 minutes
    __publicField(this, "BADGE_DEFINITIONS", {
      "pixal-pfp": {
        id: "pixal-pfp",
        name: "Pixal PFP",
        description: "Owns a Pixal PFP NFT (Template 781515)",
        icon: "",
        color: "#a855f7",
        borderColor: "rgba(168, 85, 247, 0.3)",
        type: "ownership",
        requirements: "Own Template 781515"
      },
      "pixal-collector-5": {
        id: "pixal-collector-5",
        name: "Pixal Collector I",
        description: "Owns 5+ Pixal PFPs",
        icon: "",
        color: "#a855f7",
        borderColor: "rgba(168, 85, 247, 0.3)",
        type: "ownership",
        requirements: "5+ Pixal PFPs",
        tier: 1
      },
      "pixal-collector-25": {
        id: "pixal-collector-25",
        name: "Pixal Collector II",
        description: "Owns 25+ Pixal PFPs",
        icon: "",
        color: "#a855f7",
        borderColor: "rgba(168, 85, 247, 0.3)",
        type: "ownership",
        requirements: "25+ Pixal PFPs",
        tier: 2,
        rarity: "rare"
      },
      "pixal-collector-50": {
        id: "pixal-collector-50",
        name: "Pixal Collector III",
        description: "Owns 50+ Pixal PFPs",
        icon: "",
        color: "#a855f7",
        borderColor: "rgba(168, 85, 247, 0.3)",
        type: "ownership",
        requirements: "50+ Pixal PFPs",
        tier: 3,
        rarity: "epic"
      },
      "pixal-collector-100": {
        id: "pixal-collector-100",
        name: "Pixal Collector IV",
        description: "Owns 100+ Pixal PFPs",
        icon: "",
        color: "#a855f7",
        borderColor: "rgba(168, 85, 247, 0.3)",
        type: "ownership",
        requirements: "100+ Pixal PFPs",
        tier: 4,
        rarity: "epic"
      },
      "pixal-collector-250": {
        id: "pixal-collector-250",
        name: "Pixal Collector V",
        description: "Owns 250+ Pixal PFPs",
        icon: "",
        color: "#a855f7",
        borderColor: "rgba(168, 85, 247, 0.3)",
        type: "ownership",
        requirements: "250+ Pixal PFPs",
        tier: 5,
        rarity: "legendary"
      },
      "waxrock": {
        id: "waxrock",
        name: "WaxRock",
        description: "Owns WaxRock Pixal NFT",
        icon: "",
        color: "#f59e0b",
        borderColor: "rgba(245, 158, 11, 0.3)",
        type: "ownership",
        requirements: "Own WaxRock NFTs"
      },
      "waxrock-collector-3": {
        id: "waxrock-collector-3",
        name: "WaxRock Collector I",
        description: "Owns 3+ WaxRock trait Pixals",
        icon: "",
        color: "#78716c",
        borderColor: "rgba(120, 113, 108, 0.3)",
        type: "ownership",
        requirements: "3+ WaxRock trait Pixals",
        tier: 1
      },
      "waxrock-collector-6": {
        id: "waxrock-collector-6",
        name: "WaxRock Collector II",
        description: "Owns 6+ WaxRock trait Pixals",
        icon: "",
        color: "#78716c",
        borderColor: "rgba(120, 113, 108, 0.3)",
        type: "ownership",
        requirements: "6+ WaxRock trait Pixals",
        tier: 2,
        rarity: "rare"
      },
      "waxrock-collector-10": {
        id: "waxrock-collector-10",
        name: "WaxRock Collector III",
        description: "Owns 10+ WaxRock trait Pixals",
        icon: "",
        color: "#78716c",
        borderColor: "rgba(120, 113, 108, 0.3)",
        type: "ownership",
        requirements: "10+ WaxRock trait Pixals",
        tier: 3,
        rarity: "epic"
      },
      "ingredients": {
        id: "ingredients",
        name: "Ingredients",
        description: "Owns Pixel Journey Ingredients",
        icon: "",
        color: "#22c55e",
        borderColor: "rgba(34, 197, 94, 0.3)",
        type: "ownership",
        requirements: "Own Ingredient NFTs"
      },
      "pxj-whale": {
        id: "pxj-whale",
        name: "PXJ Whale",
        description: "Holds 50,000,000+ PXJ tokens",
        icon: "",
        color: "#3b82f6",
        borderColor: "rgba(59, 130, 246, 0.3)",
        type: "holdings",
        requirements: "50,000,000+ PXJ",
        rarity: "legendary"
      },
      "pxj-holder": {
        id: "pxj-holder",
        name: "PXJ Holder",
        description: "Holds 100,000+ PXJ tokens",
        icon: "",
        color: "#8b5cf6",
        borderColor: "rgba(139, 92, 246, 0.3)",
        type: "holdings",
        requirements: "100,000+ PXJ"
      },
      "pxj-shrimp": {
        id: "pxj-shrimp",
        name: "PXJ Shrimp",
        description: "Holds 10,000+ PXJ tokens",
        icon: "",
        color: "#f97316",
        borderColor: "rgba(249, 115, 22, 0.3)",
        type: "holdings",
        requirements: "10,000+ PXJ"
      },
      "wpixal-holder": {
        id: "wpixal-holder",
        name: "WPIXAL Holder",
        description: "Owns WPIXAL tokens",
        icon: "",
        color: "#a855f7",
        borderColor: "rgba(168, 85, 247, 0.3)",
        type: "holdings",
        requirements: "Own WPIXAL tokens"
      },
      "king-holder": {
        id: "king-holder",
        name: "KING Holder",
        description: "Holds KING tokens",
        icon: "",
        color: "#fbbf24",
        borderColor: "rgba(251, 191, 36, 0.3)",
        type: "holdings",
        requirements: "Hold KING tokens"
      },
      "journey-collector": {
        id: "journey-collector",
        name: "Journey Collector",
        description: "Owns 50+ Journey assets",
        icon: "",
        color: "#ec4899",
        borderColor: "rgba(236, 72, 153, 0.3)",
        type: "ownership",
        requirements: "50+ Journey Assets"
      },
      "journey-enthusiast": {
        id: "journey-enthusiast",
        name: "Journey Enthusiast",
        description: "Owns 10+ Journey assets",
        icon: "",
        color: "#f97316",
        borderColor: "rgba(249, 115, 22, 0.3)",
        type: "ownership",
        requirements: "10+ Journey Assets"
      },
      "early-adopter": {
        id: "early-adopter",
        name: "Early Adopter",
        description: "One of the first Journey participants",
        icon: "",
        color: "#06b6d4",
        borderColor: "rgba(6, 182, 212, 0.3)",
        type: "special",
        requirements: "Early participation",
        rarity: "legendary"
      },
      "active-trader": {
        id: "active-trader",
        name: "Active Trader",
        description: "Completed 100+ transactions",
        icon: "",
        color: "#10b981",
        borderColor: "rgba(16, 185, 129, 0.3)",
        type: "trading",
        requirements: "100+ Transactions",
        rarity: "rare"
      },
      "volume-trader": {
        id: "volume-trader",
        name: "Volume Trader",
        description: "Traded 10,000+ WAX in volume",
        icon: "",
        color: "#f59e0b",
        borderColor: "rgba(245, 158, 11, 0.3)",
        type: "trading",
        requirements: "10,000+ WAX Volume",
        rarity: "epic"
      },
      "community-member": {
        id: "community-member",
        name: "Community Member",
        description: "Active community participant",
        icon: "",
        color: "#8b5cf6",
        borderColor: "rgba(139, 92, 246, 0.3)",
        type: "social",
        requirements: "Community Engagement",
        rarity: "common"
      },
      "diamond-hands": {
        id: "diamond-hands",
        name: "Diamond Hands",
        description: "Held assets for 6+ months",
        icon: "",
        color: "#3b82f6",
        borderColor: "rgba(59, 130, 246, 0.3)",
        type: "achievement",
        requirements: "6+ Months Holding",
        rarity: "epic"
      },
      "master-collector": {
        id: "master-collector",
        name: "Master Collector",
        description: "Owns 500+ Journey assets",
        icon: "",
        color: "#dc2626",
        borderColor: "rgba(220, 38, 38, 0.3)",
        type: "ownership",
        requirements: "500+ Journey Assets",
        rarity: "legendary"
      }
    });
  }
  /**
   * Check all badges for a user account with caching and progress tracking
   */
  async checkUserBadges(userAccount, forceRefresh = false) {
    if (!forceRefresh) {
      const cached = this.badgeCache.get(userAccount);
      if (cached && Date.now() < cached.expiresAt) {
        return cached.result;
      }
    }
    try {
      const [inventory, pxjBalance, tradingStats] = await Promise.all([
        apiService.getUserInventory(userAccount),
        this.getPXJBalance(userAccount),
        this.getTradingStats(userAccount)
      ]);
      const badges = [];
      let journeyAssets = 0;
      let pixalPfpOwned = false;
      let waxrockOwned = false;
      let ingredientsOwned = false;
      const tradingVolume = tradingStats.volume;
      const totalTransactions = tradingStats.transactions;
      const accountAge = tradingStats.accountAge;
      if (inventory && inventory.length > 0) {
        journeyAssets = inventory.filter(
          (asset) => asset.collection === "pixeljourney"
        ).length;
        const pixalPfpAssets = inventory.filter(
          (asset) => asset.template_id === "781515"
        );
        const pixalPfpCount = pixalPfpAssets.length;
        pixalPfpOwned = pixalPfpCount > 0;
        if (pixalPfpOwned) {
          badges.push(this.BADGE_DEFINITIONS["pixal-pfp"]);
        }
        if (pixalPfpCount >= 250) {
          badges.push({
            ...this.BADGE_DEFINITIONS["pixal-collector-250"],
            unlockedAt: /* @__PURE__ */ new Date()
          });
        } else if (pixalPfpCount >= 100) {
          badges.push({
            ...this.BADGE_DEFINITIONS["pixal-collector-100"],
            unlockedAt: /* @__PURE__ */ new Date(),
            progress: {
              current: pixalPfpCount,
              required: 250,
              percentage: Math.round(pixalPfpCount / 250 * 100)
            }
          });
        } else if (pixalPfpCount >= 50) {
          badges.push({
            ...this.BADGE_DEFINITIONS["pixal-collector-50"],
            unlockedAt: /* @__PURE__ */ new Date(),
            progress: {
              current: pixalPfpCount,
              required: 100,
              percentage: Math.round(pixalPfpCount / 100 * 100)
            }
          });
        } else if (pixalPfpCount >= 25) {
          badges.push({
            ...this.BADGE_DEFINITIONS["pixal-collector-25"],
            unlockedAt: /* @__PURE__ */ new Date(),
            progress: {
              current: pixalPfpCount,
              required: 50,
              percentage: Math.round(pixalPfpCount / 50 * 100)
            }
          });
        } else if (pixalPfpCount >= 5) {
          badges.push({
            ...this.BADGE_DEFINITIONS["pixal-collector-5"],
            unlockedAt: /* @__PURE__ */ new Date(),
            progress: {
              current: pixalPfpCount,
              required: 25,
              percentage: Math.round(pixalPfpCount / 25 * 100)
            }
          });
        }
        const waxrockAssets = inventory.filter((asset) => {
          if (asset.template_id === MarketplaceConfigService.getPixalTemplateId()) {
            const waxRock = asset.traits?.WaxRock;
            if (typeof waxRock === "string" && waxRock !== "none") {
              return MarketplaceConfigService.isValidWaxRock(waxRock);
            }
            if (asset.data) {
              const lowerValue = Object.values(asset.traits || {}).find(
                (value) => typeof value === "string" && MarketplaceConfigService.isValidWaxRock(value)
              );
              return lowerValue && lowerValue !== "none";
            }
          }
          return false;
        });
        const waxrockCount = waxrockAssets.length;
        waxrockOwned = waxrockCount > 0;
        if (waxrockOwned) {
          badges.push(this.BADGE_DEFINITIONS["waxrock"]);
        }
        if (waxrockCount >= 10) {
          badges.push({
            ...this.BADGE_DEFINITIONS["waxrock-collector-10"],
            unlockedAt: /* @__PURE__ */ new Date()
          });
        } else if (waxrockCount >= 6) {
          badges.push({
            ...this.BADGE_DEFINITIONS["waxrock-collector-6"],
            unlockedAt: /* @__PURE__ */ new Date(),
            progress: {
              current: waxrockCount,
              required: 10,
              percentage: Math.round(waxrockCount / 10 * 100)
            }
          });
        } else if (waxrockCount >= 3) {
          badges.push({
            ...this.BADGE_DEFINITIONS["waxrock-collector-3"],
            unlockedAt: /* @__PURE__ */ new Date(),
            progress: {
              current: waxrockCount,
              required: 6,
              percentage: Math.round(waxrockCount / 6 * 100)
            }
          });
        }
        ingredientsOwned = inventory.some(
          (asset) => asset.collection === "pixeljourney" && asset.schema === "ingredients"
        );
        if (ingredientsOwned) {
          badges.push(this.BADGE_DEFINITIONS["ingredients"]);
        }
        if (journeyAssets >= 500) {
          badges.push({
            ...this.BADGE_DEFINITIONS["master-collector"],
            unlockedAt: /* @__PURE__ */ new Date()
          });
        } else if (journeyAssets >= 50) {
          badges.push({
            ...this.BADGE_DEFINITIONS["journey-collector"],
            unlockedAt: /* @__PURE__ */ new Date(),
            progress: journeyAssets < 500 ? {
              current: journeyAssets,
              required: 500,
              percentage: Math.round(journeyAssets / 500 * 100)
            } : void 0
          });
        } else if (journeyAssets >= 10) {
          badges.push({
            ...this.BADGE_DEFINITIONS["journey-enthusiast"],
            unlockedAt: /* @__PURE__ */ new Date(),
            progress: {
              current: journeyAssets,
              required: 50,
              percentage: Math.round(journeyAssets / 50 * 100)
            }
          });
        }
      }
      if (pxjBalance >= 5e7) {
        badges.push({
          ...this.BADGE_DEFINITIONS["pxj-whale"],
          unlockedAt: /* @__PURE__ */ new Date()
        });
      } else if (pxjBalance >= 1e5) {
        badges.push({
          ...this.BADGE_DEFINITIONS["pxj-holder"],
          unlockedAt: /* @__PURE__ */ new Date(),
          progress: pxjBalance < 5e7 ? {
            current: pxjBalance,
            required: 5e7,
            percentage: Math.round(pxjBalance / 5e7 * 100)
          } : void 0
        });
      } else if (pxjBalance >= 1e4) {
        badges.push({
          ...this.BADGE_DEFINITIONS["pxj-shrimp"],
          unlockedAt: /* @__PURE__ */ new Date(),
          progress: pxjBalance < 1e5 ? {
            current: pxjBalance,
            required: 1e5,
            percentage: Math.round(pxjBalance / 1e5 * 100)
          } : void 0
        });
      }
      const [wpixalBalance, kingBalance] = await Promise.all([
        this.getTokenBalance(userAccount, "pixeljourney", "WPIXAL"),
        this.getTokenBalance(userAccount, "alpha.waxfun", "KING")
      ]);
      if (wpixalBalance > 0) {
        badges.push({
          ...this.BADGE_DEFINITIONS["wpixal-holder"],
          unlockedAt: /* @__PURE__ */ new Date()
        });
      }
      if (kingBalance > 0) {
        badges.push({
          ...this.BADGE_DEFINITIONS["king-holder"],
          unlockedAt: /* @__PURE__ */ new Date()
        });
      }
      if (totalTransactions >= 100) {
        badges.push({
          ...this.BADGE_DEFINITIONS["active-trader"],
          unlockedAt: /* @__PURE__ */ new Date()
        });
      }
      if (tradingVolume >= 1e4) {
        badges.push({
          ...this.BADGE_DEFINITIONS["volume-trader"],
          unlockedAt: /* @__PURE__ */ new Date()
        });
      }
      if (accountAge >= 180) {
        badges.push({
          ...this.BADGE_DEFINITIONS["diamond-hands"],
          unlockedAt: /* @__PURE__ */ new Date()
        });
      }
      const badgeTypes = new Set(badges.map((b) => b.type));
      if (badgeTypes.size >= 3) {
        badges.push({
          ...this.BADGE_DEFINITIONS["community-member"],
          unlockedAt: /* @__PURE__ */ new Date()
        });
      }
      const isEarlyAdopter = await this.checkEarlyAdopterStatus(userAccount);
      if (isEarlyAdopter) {
        badges.push(this.BADGE_DEFINITIONS["early-adopter"]);
      }
      const result = {
        badges,
        pxjBalance,
        journeyAssets,
        pixalPfpOwned,
        waxrockOwned,
        ingredientsOwned,
        tradingVolume,
        totalTransactions,
        accountAge
      };
      this.badgeCache.set(userAccount, {
        result,
        timestamp: Date.now(),
        expiresAt: Date.now() + this.CACHE_DURATION
      });
      return result;
    } catch (error) {
      ErrorMessageService.logError("BadgeService.checkUserBadges", error, { userAccount });
      return {
        badges: [],
        pxjBalance: 0,
        journeyAssets: 0,
        pixalPfpOwned: false,
        waxrockOwned: false,
        ingredientsOwned: false,
        tradingVolume: 0,
        totalTransactions: 0,
        accountAge: 0
      };
    }
  }
  /**
   * Get user's PXJ token balance
   */
  async getPXJBalance(userAccount) {
    try {
      const response = await apiService.fetchWithRetry(
        `${API_ENDPOINTS.WAX_CHAIN.EOSRIO}/v2/state/get_tokens?account=${userAccount}`
      );
      const data = await response.json();
      if (data.tokens) {
        const pxjToken = data.tokens.find(
          (token) => token.symbol === "PXJ" && token.contract === "pixeljourney"
        );
        return pxjToken ? parseFloat(pxjToken.amount) : 0;
      }
      return 0;
    } catch (error) {
      ErrorMessageService.logError("BadgeService.getPXJBalance", error, { userAccount });
      return 0;
    }
  }
  /**
   * Get trading statistics for a user
   */
  async getTradingStats(userAccount) {
    try {
      const mockStats = {
        volume: Math.random() * 5e4,
        // Random volume for demo
        transactions: Math.floor(Math.random() * 200),
        // Random transaction count
        accountAge: Math.floor(Math.random() * 365)
        // Random account age in days
      };
      return mockStats;
    } catch (error) {
      ErrorMessageService.logError("BadgeService.getTradingStats", error, { userAccount });
      return {
        volume: 0,
        transactions: 0,
        accountAge: 0
      };
    }
  }
  /**
   * Get token balance for a specific token contract and symbol
   */
  async getTokenBalance(userAccount, contract, symbol) {
    try {
      const response = await apiService.fetchWithRetry(
        `${API_ENDPOINTS.WAX_CHAIN.GREYMASS}/get_table_rows`,
        3,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            json: true,
            code: contract,
            scope: userAccount,
            table: "accounts",
            limit: 100
          })
        }
      );
      const data = await response.json();
      if (data.rows && data.rows.length > 0) {
        const tokenRow = data.rows.find(
          (row) => row.balance && row.balance.includes(symbol)
        );
        if (tokenRow) {
          const balanceStr = tokenRow.balance.split(" ")[0];
          return parseFloat(balanceStr) || 0;
        }
      }
      return 0;
    } catch (error) {
      ErrorMessageService.logError("BadgeService.getTokenBalance", error, { userAccount, contract, symbol });
      return 0;
    }
  }
  /**
   * Check if user is an early adopter
   */
  async checkEarlyAdopterStatus(userAccount) {
    try {
      const response = await apiService.fetchWithRetry(
        `${API_ENDPOINTS.WAX_CHAIN.EOSRIO}/v2/history/get_actions?account=${userAccount}&limit=1&sort=asc`
      );
      const data = await response.json();
      if (data.actions && data.actions.length > 0) {
        const firstAction = data.actions[0];
        const actionDate = new Date(firstAction.timestamp);
        const cutoffDate = /* @__PURE__ */ new Date("2023-01-01");
        return actionDate < cutoffDate;
      }
      return false;
    } catch (error) {
      ErrorMessageService.logError("BadgeService.checkEarlyAdopterStatus", error, { userAccount });
      return false;
    }
  }
  /**
   * Get badge definition by ID
   */
  getBadgeDefinition(badgeId) {
    return this.BADGE_DEFINITIONS[badgeId];
  }
  /**
   * Get all available badge definitions
   */
  getAllBadgeDefinitions() {
    return Object.values(this.BADGE_DEFINITIONS);
  }
  /**
   * Check if user has specific badge
   */
  async hasUserBadge(userAccount, badgeId) {
    const result = await this.checkUserBadges(userAccount);
    return result.badges.some((badge) => badge.id === badgeId);
  }
  /**
   * Get user's badge statistics with enhanced information
   */
  async getUserBadgeStats(userAccount) {
    const result = await this.checkUserBadges(userAccount);
    return this.getBadgeStatistics(result.badges);
  }
  /**
   * Get statistics about user's badges
   */
  getBadgeStatistics(badges) {
    const badgesByType = {};
    const badgesByRarity = {};
    const recentBadges = badges.filter((badge) => badge.unlockedAt).sort((a, b) => new Date(b.unlockedAt).getTime() - new Date(a.unlockedAt).getTime()).slice(0, 5);
    const progressBadges = badges.filter((badge) => badge.progress);
    badges.forEach((badge) => {
      badgesByType[badge.type] = (badgesByType[badge.type] || 0) + 1;
      if (badge.rarity) {
        badgesByRarity[badge.rarity] = (badgesByRarity[badge.rarity] || 0) + 1;
      }
    });
    return {
      totalBadges: badges.length,
      badgesByType,
      badgesByRarity,
      recentBadges,
      progressBadges
    };
  }
  /**
   * Clear badge cache for a specific user or all users
   */
  clearBadgeCache(userAccount) {
    if (userAccount) {
      this.badgeCache.delete(userAccount);
    } else {
      this.badgeCache.clear();
    }
  }
  /**
   * Get badge progress for a specific badge type
   */
  getBadgeProgress(userAccount, badgeId) {
    const cached = this.badgeCache.get(userAccount);
    if (!cached) return null;
    const badge = cached.result.badges.find((b) => b.id === badgeId);
    if (badge?.progress) {
      return {
        badgeId,
        current: badge.progress.current,
        required: badge.progress.required,
        percentage: badge.progress.percentage
      };
    }
    return null;
  }
  /**
   * Get all available badge definitions with user progress
   */
  async getAllBadgeDefinitionsWithProgress(userAccount) {
    const userBadges = await this.checkUserBadges(userAccount);
    const earnedBadgeIds = new Set(userBadges.badges.map((b) => b.id));
    return Object.values(this.BADGE_DEFINITIONS).map((badge) => {
      const userBadge = userBadges.badges.find((b) => b.id === badge.id);
      return {
        ...badge,
        earned: earnedBadgeIds.has(badge.id),
        progress: userBadge?.progress,
        unlockedAt: userBadge?.unlockedAt
      };
    });
  }
}
const badgeService = new BadgeService();
class BalanceService {
  constructor() {
    __publicField(this, "balanceCache", /* @__PURE__ */ new Map());
    __publicField(this, "CACHE_DURATION", 3e4);
  }
  // 30 seconds
  /**
   * Get WAX balance for an account with caching
   */
  async getWaxBalance(account, forceRefresh = false) {
    if (!account) return "0.0000 WAX";
    const cacheKey = `wax_${account}`;
    const cached = this.balanceCache.get(cacheKey);
    const now = Date.now();
    if (!forceRefresh && cached && now - cached.lastUpdated < this.CACHE_DURATION) {
      return cached.balance;
    }
    try {
      const lightApiBalances = await apiService.getLightApiBalances(account);
      if (lightApiBalances && lightApiBalances.balances) {
        const waxBalance = lightApiBalances.balances.find(
          (balance) => balance.currency === "WAX" && balance.contract === "eosio.token"
        );
        if (waxBalance) {
          const formattedBalance = `${waxBalance.amount} ${waxBalance.currency}`;
          this.balanceCache.set(cacheKey, {
            balance: formattedBalance,
            lastUpdated: now
          });
          return formattedBalance;
        }
      }
    } catch (error) {
      log.warn("Light API balance fetch failed, falling back to currency balance API", "BalanceService", { error });
    }
    try {
      const balances = await apiService.getWaxCurrencyBalance(account, "eosio.token", "WAX");
      if (balances && balances.length > 0) {
        const balance = balances[0].balance;
        this.balanceCache.set(cacheKey, {
          balance,
          lastUpdated: now
        });
        return balance;
      }
    } catch (error) {
      log.error("Failed to fetch WAX balance", "BalanceService", error);
    }
    return "0.0000 WAX";
  }
  /**
   * Clear balance cache for an account
   */
  clearCache(account) {
    if (account) {
      this.balanceCache.delete(`wax_${account}`);
    } else {
      this.balanceCache.clear();
    }
  }
  /**
   * Check if balance is cached and fresh
   */
  isCached(account) {
    const cached = this.balanceCache.get(`wax_${account}`);
    if (!cached) return false;
    const now = Date.now();
    return now - cached.lastUpdated < this.CACHE_DURATION;
  }
}
const balanceService = new BalanceService();
const NotificationContext = reactExports.createContext(void 0);
const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = reactExports.useState([]);
  const confirmResolveRef = React.useRef(null);
  const [confirmDialog, setConfirmDialog] = reactExports.useState(null);
  const [soundEnabled, setSoundEnabled] = reactExports.useState(() => {
    const saved = localStorage.getItem("notification-sound-enabled");
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [maxNotifications] = reactExports.useState(5);
  reactExports.useEffect(() => {
    localStorage.setItem("notification-sound-enabled", JSON.stringify(soundEnabled));
  }, [soundEnabled]);
  const addNotification = (notification) => {
    const id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    const newNotification = {
      ...notification,
      id,
      duration: notification.duration ?? 5e3
    };
    setNotifications((prev) => {
      const updated = [...prev, newNotification];
      if (updated.length > maxNotifications) {
        return updated.slice(-maxNotifications);
      }
      return updated;
    });
    if (newNotification.duration && newNotification.duration > 0) {
      setTimeout(() => {
        removeNotification(id);
      }, newNotification.duration);
    }
  };
  const removeNotification = (id) => {
    setNotifications((prev) => prev.filter((notification) => notification.id !== id));
  };
  const clearAllNotifications = () => {
    setNotifications([]);
  };
  const toggleSound = () => {
    setSoundEnabled((prev) => !prev);
  };
  const showSuccess = (message, title, duration) => {
    addNotification({ type: "success", message, title, duration });
  };
  const showError = (message, title, duration) => {
    log.warn("User error notification displayed", "NotificationContext.showError", { message, title, duration });
    addNotification({ type: "error", message, title, duration });
  };
  const showWarning = (message, title, duration) => {
    log.info("User warning notification displayed", "NotificationContext.showWarning", { message, title, duration });
    addNotification({ type: "warning", message, title, duration });
  };
  const showInfo = (message, title, duration) => {
    addNotification({ type: "info", message, title, duration });
  };
  const confirm2 = (title, message, confirmText = "Confirm", cancelText = "Cancel") => {
    return new Promise((resolve) => {
      setConfirmDialog({
        title,
        message,
        confirmText,
        cancelText
      });
      confirmResolveRef.current = resolve;
    });
  };
  const resolveConfirm = (result) => {
    if (confirmResolveRef.current) {
      confirmResolveRef.current(result);
      confirmResolveRef.current = null;
    }
    setConfirmDialog(null);
  };
  const value = {
    notifications,
    addNotification,
    removeNotification,
    clearAllNotifications,
    showSuccess,
    showError,
    showWarning,
    showInfo,
    confirm: confirm2,
    confirmDialog,
    resolveConfirm,
    soundEnabled,
    toggleSound
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(NotificationContext.Provider, { value, children: [
    children,
    confirmDialog && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content confirm-dialog", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: confirmDialog.title || "Confirm Action" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: confirmDialog.message }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-secondary",
            onClick: () => resolveConfirm(false),
            children: confirmDialog.cancelText
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary",
            onClick: () => resolveConfirm(true),
            children: confirmDialog.confirmText
          }
        )
      ] })
    ] }) })
  ] });
};
const useNotifications = () => {
  const context = reactExports.useContext(NotificationContext);
  if (context === void 0) {
    throw new Error("useNotifications must be used within a NotificationProvider");
  }
  return context;
};
const ShoppingCart = ({ isOpen, onClose }) => {
  const { isConnected, login, purchaseNFT, batchPurchaseNFTs } = useWallet$1();
  const { showError, showSuccess, showWarning } = useNotifications();
  const [cartItems, setCartItems] = reactExports.useState([]);
  const [totals, setTotals] = reactExports.useState({ totalWAX: "0.0000 WAX", totalUSD: "$0.00", itemCount: 0 });
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [selectedItems, setSelectedItems] = reactExports.useState(/* @__PURE__ */ new Set());
  const [itemsPerTx, setItemsPerTx] = reactExports.useState(20);
  const [useBatchPurchase, setUseBatchPurchase] = reactExports.useState(true);
  const loadCartData = reactExports.useCallback(async () => {
    setIsLoading(true);
    try {
      await cartService.checkAvailability();
      const cart = cartService.getCart();
      setCartItems(cart);
      setSelectedItems(new Set(cart.filter((item) => item.selected).map((item) => item.nft.asset_id)));
      try {
        const newTotals = await cartService.calculateTotals();
        setTotals(newTotals);
      } catch (totalsError) {
        log.error("Failed to calculate totals", "ShoppingCart", totalsError);
        showError("Calculation Error", "Unable to calculate cart totals. Some prices may be outdated.");
      }
    } catch (error) {
      log.error("Failed to load cart data", "ShoppingCart", error);
      showError("Cart Error", "Unable to load cart data. Please try refreshing the page.");
    } finally {
      setIsLoading(false);
    }
  }, [showError]);
  reactExports.useEffect(() => {
    if (isOpen) {
      loadCartData();
    }
    const handleCartChange = (cart) => {
      setCartItems(cart);
      cartService.calculateTotals().then((newTotals) => {
        setTotals(newTotals);
      }).catch((error) => {
        log.error("Failed to calculate totals in cart change handler", "ShoppingCart", error);
      });
    };
    cartService.addListener(handleCartChange);
    return () => cartService.removeListener(handleCartChange);
  }, [isOpen, loadCartData]);
  const handleRemoveItem = (assetId) => {
    cartService.removeFromCart(assetId);
    setSelectedItems((prev) => {
      const newSet = new Set(prev);
      newSet.delete(assetId);
      return newSet;
    });
  };
  const handleToggleSelection = (assetId) => {
    cartService.toggleSelection(assetId);
    const cart = cartService.getCart();
    setCartItems(cart);
    setSelectedItems(new Set(cart.filter((item) => item.selected).map((item) => item.nft.asset_id)));
  };
  const handleSelectAll = () => {
    const availableItems2 = cartItems.filter((item) => item.isAvailable !== false);
    const availableSelectedCount = availableItems2.filter((item) => item.selected).length;
    if (availableSelectedCount === availableItems2.length && availableItems2.length > 0) {
      cartService.deselectAll();
    } else {
      cartService.selectAll();
    }
    const cart = cartService.getCart();
    setCartItems(cart);
    setSelectedItems(new Set(cart.filter((item) => item.selected).map((item) => item.nft.asset_id)));
  };
  const handleCleanupUnavailable = () => {
    cartService.cleanupUnavailableItems();
  };
  const handleClearCart = () => {
    if (confirm("Are you sure you want to clear your entire cart?")) {
      cartService.clearCart();
      setSelectedItems(/* @__PURE__ */ new Set());
    }
  };
  const handleBuySelected = async () => {
    const selectedItemsList = cartService.getSelectedItems().filter(
      (item) => item.isAvailable !== false
    );
    if (selectedItemsList.length === 0) {
      showError("Please select items to purchase", "No Items Selected");
      return;
    }
    if (!isConnected) {
      try {
        await login();
      } catch (error) {
        log.error("Login failed", "ShoppingCart", error);
        showError("Login Failed", "Please connect your wallet to purchase NFTs");
        return;
      }
    }
    let successCount = 0;
    const failedItems = [];
    if (useBatchPurchase && selectedItemsList.length > 1) {
      const batches = [];
      for (let i = 0; i < selectedItemsList.length; i += itemsPerTx) {
        batches.push(selectedItemsList.slice(i, i + itemsPerTx));
      }
      for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
        const batch = batches[batchIndex];
        const batchPurchases = batch.filter((item) => item.nft.sale_id && item.nft.price).map((item) => ({
          saleId: item.nft.sale_id,
          price: item.nft.price.replace(" WAX", "")
        }));
        if (batchPurchases.length === 0) {
          batch.forEach((item) => {
            if (!item.nft.sale_id) {
              failedItems.push(`${item.nft.name} (not for sale)`);
            }
          });
          continue;
        }
        try {
          await batchPurchaseNFTs(batchPurchases);
          batch.forEach((item) => {
            if (item.nft.sale_id) {
              cartService.removeFromCart(item.nft.asset_id);
              setSelectedItems((prev) => {
                const newSet = new Set(prev);
                newSet.delete(item.nft.asset_id);
                return newSet;
              });
              successCount++;
            }
          });
          if (batchIndex < batches.length - 1) {
            await new Promise((resolve) => setTimeout(resolve, 2e3));
          }
        } catch (error) {
          log.error("Batch purchase failed", "ShoppingCart", error);
          showError("Batch Purchase Failed", `Failed to purchase batch of ${batch.length} items`);
          batch.forEach((item) => {
            failedItems.push(`${item.nft.name} (batch failed: ${error instanceof Error ? error.message : "Unknown error"})`);
          });
        }
      }
    } else {
      for (const item of selectedItemsList) {
        try {
          if (!item.nft.sale_id || !item.nft.price) {
            failedItems.push(`${item.nft.name} (not for sale)`);
            continue;
          }
          await purchaseNFT(item.nft.sale_id, item.nft.price.replace(" WAX", ""));
          successCount++;
          cartService.removeFromCart(item.nft.asset_id);
          setSelectedItems((prev) => {
            const newSet = new Set(prev);
            newSet.delete(item.nft.asset_id);
            return newSet;
          });
          if (selectedItemsList.length > 1) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        } catch (error) {
          log.error(`Purchase failed for ${item.nft.name}`, "ShoppingCart", error);
          showError("Purchase Failed", `Failed to purchase ${item.nft.name}`);
          failedItems.push(`${item.nft.name} (${error instanceof Error ? error.message : "Unknown error"})`);
        }
      }
    }
    if (successCount > 0 && failedItems.length === 0) {
      showSuccess(`Successfully purchased ${successCount} item${successCount !== 1 ? "s" : ""}!`, "Purchase Complete");
    } else if (successCount > 0 && failedItems.length > 0) {
      showWarning(
        `Partially completed: ${successCount} successful, ${failedItems.length} failed. Failed items: ${failedItems.join(", ")}`,
        "Purchase Partially Complete",
        8e3
      );
    } else {
      showError(`All purchases failed. Items: ${failedItems.join(", ")}`, "Purchase Failed");
    }
  };
  const availableItems = cartItems.filter((item) => item.isAvailable !== false);
  const unavailableItems = cartItems.filter((item) => item.isAvailable === false);
  if (!isOpen) return null;
  const handleBackdropClick = (e) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "modal-backdrop",
      onClick: handleBackdropClick,
      role: "dialog",
      "aria-modal": "true",
      "aria-labelledby": "cart-title",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content shopping-cart-modal", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "modal-title", id: "cart-title", children: [
            "Shopping Cart (",
            totals.itemCount,
            " ",
            totals.itemCount === 1 ? "item" : "items",
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "modal-close",
              onClick: onClose,
              "aria-label": "Close shopping cart",
              type: "button",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "aria-hidden": "true", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
              ] })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body cart-body", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-loading", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Checking item availability..." })
        ] }) : cartItems.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-empty", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-cart-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "9", cy: "21", r: "1" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "20", cy: "21", r: "1" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m1 1 4 4 2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Your cart is empty" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Add some NFTs from the marketplace to get started!" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-controls", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-actions-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "btn-select-all",
                  onClick: handleSelectAll,
                  "aria-label": selectedItems.size === availableItems.length && availableItems.length > 0 ? `Deselect all ${availableItems.length} items` : `Select all ${availableItems.length} items`,
                  type: "button",
                  children: selectedItems.size === availableItems.length && availableItems.length > 0 ? "Deselect All" : "Select All"
                }
              ),
              unavailableItems.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  className: "btn-cleanup",
                  onClick: handleCleanupUnavailable,
                  "aria-label": `Remove ${unavailableItems.length} unavailable items from cart`,
                  type: "button",
                  children: [
                    "Remove Unavailable (",
                    unavailableItems.length,
                    ")"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn-clear-cart",
                onClick: handleClearCart,
                "aria-label": "Clear all items from cart",
                type: "button",
                children: "Clear Cart"
              }
            )
          ] }),
          availableItems.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "batch-settings", role: "group", "aria-labelledby": "batch-settings-label", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "batch-toggle", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "checkbox",
                    checked: useBatchPurchase,
                    onChange: (e) => setUseBatchPurchase(e.target.checked),
                    "aria-describedby": "batch-purchase-description"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { id: "batch-settings-label", children: "Use batch purchasing" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "batch-purchase-description", className: "sr-only", children: "Batch purchasing allows you to buy multiple items in a single transaction, which is faster and more efficient." })
            ] }),
            useBatchPurchase && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "batch-controls", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "items-per-tx", children: "Items per transaction:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "batch-slider", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    id: "items-per-tx",
                    type: "range",
                    min: "1",
                    max: "50",
                    value: itemsPerTx,
                    onChange: (e) => setItemsPerTx(parseInt(e.target.value))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "batch-value", children: itemsPerTx })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "batch-info", children: selectedItems.size > itemsPerTx && /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                "Will create ",
                Math.ceil(selectedItems.size / itemsPerTx),
                " transaction",
                Math.ceil(selectedItems.size / itemsPerTx) > 1 ? "s" : ""
              ] }) })
            ] })
          ] }),
          availableItems.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "section-title", children: "Available Items" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cart-items", children: availableItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-checkbox", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  checked: selectedItems.has(item.nft.asset_id),
                  onChange: () => handleToggleSelection(item.nft.asset_id),
                  "aria-label": `Select ${item.nft.name} for purchase`,
                  id: `item-${item.nft.asset_id}`
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-image", children: item.nft.video ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "video",
                {
                  src: item.nft.video,
                  className: "cart-item-media",
                  muted: true,
                  onError: (e) => {
                    const img = document.createElement("img");
                    img.src = item.nft.image;
                    img.className = "cart-item-media";
                    img.alt = item.nft.name;
                    e.currentTarget.parentNode?.replaceChild(img, e.currentTarget);
                  }
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: item.nft.image,
                  alt: `${item.nft.name} from ${item.nft.collection}`,
                  className: "cart-item-media"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-details", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "item-name", children: item.nft.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "item-collection", children: item.nft.collection }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-price", "aria-label": `Price: ${item.nft.price}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-wax", children: item.nft.price }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "btn-remove",
                  onClick: () => handleRemoveItem(item.nft.asset_id),
                  title: "Remove from cart",
                  "aria-label": `Remove ${item.nft.name} from cart`,
                  type: "button",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "aria-hidden": "true", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "3,6 5,6 21,6" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2" })
                  ] })
                }
              )
            ] }, item.nft.asset_id)) })
          ] }),
          unavailableItems.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "section-title unavailable-title", children: [
              "Unavailable Items (",
              unavailableItems.length,
              ")"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cart-items unavailable-items", children: unavailableItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-item unavailable", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-image", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: item.nft.image,
                    alt: item.nft.name,
                    className: "cart-item-media"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "unavailable-overlay", children: "Unavailable" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-details", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "item-name", children: item.nft.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "item-collection", children: item.nft.collection }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-price", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-wax", children: item.nft.price }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "btn-remove",
                  onClick: () => handleRemoveItem(item.nft.asset_id),
                  title: "Remove from cart",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "3,6 5,6 21,6" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2" })
                  ] })
                }
              )
            ] }, item.nft.asset_id)) })
          ] })
        ] }) }),
        cartItems.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer cart-footer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cart-totals", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "total-line", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "total-label", children: [
              "Total (",
              selectedItems.size,
              " selected):"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "total-prices", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "total-wax", children: totals.totalWAX }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "total-usd", children: totals.totalUSD })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn-secondary",
                onClick: onClose,
                type: "button",
                "aria-label": "Continue shopping and close cart",
                children: "Continue Shopping"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: "btn-primary",
                onClick: handleBuySelected,
                disabled: selectedItems.size === 0,
                type: "button",
                "aria-label": `Buy ${selectedItems.size} selected items`,
                "aria-describedby": "cart-totals",
                children: [
                  "Buy Selected (",
                  selectedItems.size,
                  ")"
                ]
              }
            )
          ] })
        ] })
      ] })
    }
  );
};
class AccessibilityService {
  constructor() {
    __publicField(this, "preferences");
    __publicField(this, "focusStack", []);
    __publicField(this, "trapFocusElements", []);
    __publicField(this, "isInitialized", false);
    __publicField(this, "mediaQueryListeners", []);
    __publicField(this, "keyboardNavigationActive", false);
    this.preferences = this.getDefaultPreferences();
    this.detectSystemPreferences();
  }
  getDefaultPreferences() {
    return {
      reducedMotion: false,
      highContrast: false,
      largeText: false,
      screenReader: false,
      keyboardNavigation: true
    };
  }
  async initialize() {
    if (this.isInitialized) return;
    try {
      this.loadPreferences();
      this.setupMediaQueryListeners();
      this.setupKeyboardNavigation();
      this.applyAccessibilitySettings();
      this.setupFocusManagement();
      this.isInitialized = true;
      monitoringService.trackEvent("accessibility_service_initialized", {
        preferences: this.preferences,
        systemPreferences: this.detectSystemPreferences()
      });
      logger.info("Accessibility service initialized", "ACCESSIBILITY");
    } catch (error) {
      logger.error("Failed to initialize accessibility service", "ACCESSIBILITY", error);
      monitoringService.reportError(error, "accessibility_init_error");
    }
  }
  detectSystemPreferences() {
    const systemPrefs = {};
    if (window.matchMedia) {
      systemPrefs.reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      systemPrefs.highContrast = window.matchMedia("(prefers-contrast: high)").matches;
    }
    systemPrefs.screenReader = this.detectScreenReader();
    return systemPrefs;
  }
  detectScreenReader() {
    return navigator.userAgent.includes("NVDA") || navigator.userAgent.includes("JAWS") || navigator.userAgent.includes("VoiceOver") || window.speechSynthesis !== void 0;
  }
  setupMediaQueryListeners() {
    if (!window.matchMedia) return;
    const reducedMotionMQ = window.matchMedia("(prefers-reduced-motion: reduce)");
    reducedMotionMQ.addEventListener("change", (e) => {
      this.updatePreference("reducedMotion", e.matches);
    });
    this.mediaQueryListeners.push(reducedMotionMQ);
    const highContrastMQ = window.matchMedia("(prefers-contrast: high)");
    highContrastMQ.addEventListener("change", (e) => {
      this.updatePreference("highContrast", e.matches);
    });
    this.mediaQueryListeners.push(highContrastMQ);
  }
  setupKeyboardNavigation() {
    document.addEventListener("keydown", (e) => {
      if (e.key === "Tab") {
        this.keyboardNavigationActive = true;
        document.body.classList.add("a11y-keyboard-navigation");
      }
    });
    document.addEventListener("mousedown", () => {
      this.keyboardNavigationActive = false;
      document.body.classList.remove("a11y-keyboard-navigation");
    });
  }
  setupFocusManagement() {
    document.addEventListener("focusin", (e) => {
      const target = e.target;
      if (target && this.keyboardNavigationActive) {
        this.announceToScreenReader(`Focused on ${this.getElementDescription(target)}`);
      }
    });
  }
  applyAccessibilitySettings() {
    const root = document.documentElement;
    if (this.preferences.reducedMotion) {
      root.classList.add("a11y-reduce-motion");
    } else {
      root.classList.remove("a11y-reduce-motion");
    }
    if (this.preferences.highContrast) {
      root.classList.add("a11y-high-contrast");
    } else {
      root.classList.remove("a11y-high-contrast");
    }
    if (this.preferences.largeText) {
      root.classList.add("a11y-large-text");
    } else {
      root.classList.remove("a11y-large-text");
    }
    if (this.preferences.screenReader) {
      root.classList.add("a11y-screen-reader-active");
    } else {
      root.classList.remove("a11y-screen-reader-active");
    }
  }
  // Public API methods
  updatePreference(key, value) {
    this.preferences[key] = value;
    this.applyAccessibilitySettings();
    this.savePreferences();
    monitoringService.trackEvent("accessibility_preference_changed", {
      preference: key,
      value,
      allPreferences: this.preferences
    });
  }
  getPreferences() {
    return { ...this.preferences };
  }
  // ARIA label management
  setAriaLabel(element, label) {
    element.setAttribute("aria-label", label);
  }
  setAriaDescribedBy(element, describedById) {
    element.setAttribute("aria-describedby", describedById);
  }
  setAriaExpanded(element, expanded) {
    element.setAttribute("aria-expanded", expanded.toString());
  }
  setAriaSelected(element, selected) {
    element.setAttribute("aria-selected", selected.toString());
  }
  setAriaChecked(element, checked) {
    element.setAttribute("aria-checked", checked.toString());
  }
  setAriaHidden(element, hidden) {
    element.setAttribute("aria-hidden", hidden.toString());
  }
  // Focus management
  focusElement(element, options) {
    try {
      element.focus(options);
      this.focusStack.push(element);
    } catch (error) {
      logger.warn("Failed to focus element", "ACCESSIBILITY", error);
    }
  }
  restoreFocus() {
    const lastFocused = this.focusStack.pop();
    if (lastFocused && document.contains(lastFocused)) {
      this.focusElement(lastFocused);
    }
  }
  // Focus trap for modals and dialogs
  trapFocus(container) {
    const focusableElements = this.getFocusableElements(container);
    focusableElements.forEach((el, index) => {
      this.trapFocusElements.push({
        element: el,
        tabIndex: index,
        originalTabIndex: el.tabIndex
      });
    });
    if (focusableElements.length > 0) {
      this.focusElement(focusableElements[0]);
    }
    const handleKeyDown = (e) => {
      if (e.key === "Tab") {
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        if (e.shiftKey) {
          if (document.activeElement === firstElement) {
            e.preventDefault();
            this.focusElement(lastElement);
          }
        } else {
          if (document.activeElement === lastElement) {
            e.preventDefault();
            this.focusElement(firstElement);
          }
        }
      }
      if (e.key === "Escape") {
        this.releaseFocusTrap();
      }
    };
    container.addEventListener("keydown", handleKeyDown);
    container.setAttribute("data-focus-trap-active", "true");
  }
  releaseFocusTrap() {
    this.trapFocusElements.forEach(({ element, originalTabIndex }) => {
      if (originalTabIndex !== void 0) {
        element.tabIndex = originalTabIndex;
      }
    });
    this.trapFocusElements = [];
    document.querySelectorAll("[data-focus-trap-active]").forEach((el) => {
      el.removeAttribute("data-focus-trap-active");
    });
    this.restoreFocus();
  }
  getFocusableElements(container) {
    const focusableSelectors = [
      "button:not([disabled])",
      "input:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      "a[href]",
      '[tabindex]:not([tabindex="-1"])',
      '[contenteditable="true"]'
    ].join(", ");
    return Array.from(container.querySelectorAll(focusableSelectors)).filter((el) => {
      const element = el;
      return element.offsetParent !== null && !element.hasAttribute("aria-hidden");
    });
  }
  // Screen reader announcements
  announceToScreenReader(message, priority = "polite") {
    const announcement = document.createElement("div");
    announcement.setAttribute("aria-live", priority);
    announcement.setAttribute("aria-atomic", "true");
    announcement.className = "sr-only";
    announcement.textContent = message;
    document.body.appendChild(announcement);
    setTimeout(() => {
      if (document.body.contains(announcement)) {
        document.body.removeChild(announcement);
      }
    }, 1e3);
  }
  // Element description for screen readers
  getElementDescription(element) {
    const ariaLabel = element.getAttribute("aria-label");
    if (ariaLabel) return ariaLabel;
    const textContent = element.textContent?.trim();
    if (textContent) return textContent;
    if (element.tagName === "IMG") {
      const alt = element.alt;
      if (alt) return alt;
    }
    const title = element.getAttribute("title");
    if (title) return title;
    const role = element.getAttribute("role") || element.tagName.toLowerCase();
    return `${role} element`;
  }
  // Keyboard shortcuts management
  registerKeyboardShortcut(key, callback, description) {
    const handleKeyDown = (e) => {
      if (this.matchesShortcut(e, key)) {
        e.preventDefault();
        callback(e);
        monitoringService.trackEvent("keyboard_shortcut_used", {
          shortcut: key,
          description
        });
      }
    };
    document.addEventListener("keydown", handleKeyDown);
  }
  matchesShortcut(event, shortcut) {
    const parts = shortcut.toLowerCase().split("+");
    const key = parts.pop();
    const modifiers = {
      ctrl: event.ctrlKey,
      alt: event.altKey,
      shift: event.shiftKey,
      meta: event.metaKey
    };
    for (const part of parts) {
      if (!modifiers[part]) {
        return false;
      }
    }
    return event.key.toLowerCase() === key;
  }
  // Color contrast utilities
  calculateLuminance(r, g, b) {
    const [rNorm, gNorm, bNorm] = [r, g, b].map((c) => c / 255);
    const [rLinear, gLinear, bLinear] = [rNorm, gNorm, bNorm].map((c) => {
      if (c <= 0.03928) {
        return c / 12.92;
      } else {
        return Math.pow((c + 0.055) / 1.055, 2.4);
      }
    });
    return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
  }
  /**
   * Calculate contrast ratio between two colors
   * @param color1 First color in hex format (#RRGGBB)
   * @param color2 Second color in hex format (#RRGGBB)
   * @returns Contrast ratio (1:1 to 21:1)
   */
  calculateContrastRatio(color1, color2) {
    const rgb1 = this.hexToRgb(color1);
    const rgb2 = this.hexToRgb(color2);
    if (!rgb1 || !rgb2) {
      return 1;
    }
    const lum1 = this.calculateLuminance(rgb1.r, rgb1.g, rgb1.b);
    const lum2 = this.calculateLuminance(rgb2.r, rgb2.g, rgb2.b);
    const lighter = Math.max(lum1, lum2);
    const darker = Math.min(lum1, lum2);
    return (lighter + 0.05) / (darker + 0.05);
  }
  checkColorContrast(foreground, background) {
    return this.calculateContrastRatio(foreground, background);
  }
  /**
   * Convert hex color to RGB values
   * @param hex Hex color string (#RRGGBB or #RGB)
   * @returns RGB object or null if invalid
   */
  hexToRgb(hex) {
    hex = hex.replace("#", "");
    if (hex.length === 3) {
      hex = hex.split("").map((char) => char + char).join("");
    }
    if (hex.length !== 6 || !/^[0-9A-Fa-f]{6}$/.test(hex)) {
      return null;
    }
    return {
      r: parseInt(hex.substr(0, 2), 16),
      g: parseInt(hex.substr(2, 2), 16),
      b: parseInt(hex.substr(4, 2), 16)
    };
  }
  /**
   * Check if color combination meets WCAG contrast requirements
   * @param foreground Foreground color in hex
   * @param background Background color in hex
   * @param level WCAG level ('AA' or 'AAA')
   * @param size Text size ('normal' or 'large')
   * @returns Whether the combination meets requirements
   */
  meetsContrastRequirements(foreground, background, level = "AA", size = "normal") {
    const ratio = this.calculateContrastRatio(foreground, background);
    const requirements = {
      AA: { normal: 4.5, large: 3 },
      AAA: { normal: 7, large: 4.5 }
    };
    return ratio >= requirements[level][size];
  }
  /**
   * Suggest accessible color alternatives
   * @param foreground Current foreground color
   * @param background Current background color
   * @param level Target WCAG level
   * @returns Suggested accessible colors
   */
  suggestAccessibleColors(foreground, background, level = "AA") {
    const suggestions = [];
    const fgRgb = this.hexToRgb(foreground);
    const bgRgb = this.hexToRgb(background);
    if (!fgRgb || !bgRgb) {
      return suggestions;
    }
    const variations = [-60, -40, -20, 20, 40, 60, 80, 100];
    variations.forEach((adjustment) => {
      const newFg = this.adjustBrightness(foreground, adjustment);
      const ratio = this.calculateContrastRatio(newFg, background);
      if (this.meetsContrastRequirements(newFg, background, level)) {
        suggestions.push({
          foreground: newFg,
          background,
          ratio
        });
      }
    });
    return suggestions.sort((a, b) => b.ratio - a.ratio).slice(0, 5);
  }
  /**
   * Adjust color brightness
   * @param hex Original hex color
   * @param adjustment Brightness adjustment (-100 to 100)
   * @returns Adjusted hex color
   */
  adjustBrightness(hex, adjustment) {
    const rgb = this.hexToRgb(hex);
    if (!rgb) return hex;
    const factor = adjustment / 100;
    const adjust = (value) => {
      if (factor > 0) {
        return Math.min(255, value + (255 - value) * factor);
      } else {
        return Math.max(0, value + value * factor);
      }
    };
    const newR = Math.round(adjust(rgb.r));
    const newG = Math.round(adjust(rgb.g));
    const newB = Math.round(adjust(rgb.b));
    return `#${newR.toString(16).padStart(2, "0")}${newG.toString(16).padStart(2, "0")}${newB.toString(16).padStart(2, "0")}`;
  }
  // Persistence
  savePreferences() {
    try {
      localStorage.setItem("accessibility_preferences", JSON.stringify(this.preferences));
    } catch (error) {
      logger.warn("Failed to save accessibility preferences", "ACCESSIBILITY", error);
    }
  }
  loadPreferences() {
    try {
      const saved = localStorage.getItem("accessibility_preferences");
      if (saved) {
        const parsed = JSON.parse(saved);
        this.preferences = { ...this.preferences, ...parsed };
      }
    } catch (error) {
      logger.warn("Failed to load accessibility preferences", "ACCESSIBILITY", error);
    }
  }
  // Cleanup
  destroy() {
    this.mediaQueryListeners.forEach((mq) => {
      mq.removeEventListener("change", () => {
      });
    });
    this.mediaQueryListeners = [];
    this.releaseFocusTrap();
    this.focusStack = [];
  }
}
const accessibilityService = new AccessibilityService();
const AccessibilitySettings = ({ isOpen, onClose }) => {
  const [preferences, setPreferences] = reactExports.useState({
    reducedMotion: false,
    highContrast: false,
    largeText: false,
    screenReader: false,
    keyboardNavigation: true
  });
  const [isLoading, setIsLoading] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isOpen) {
      const currentPrefs = accessibilityService.getPreferences();
      setPreferences(currentPrefs);
      accessibilityService.announceToScreenReader("Accessibility settings dialog opened");
      const firstButton = document.querySelector(".accessibility-modal button");
      if (firstButton) {
        accessibilityService.focusElement(firstButton);
      }
    }
  }, [isOpen]);
  const handlePreferenceChange = async (key, value) => {
    setIsLoading(true);
    try {
      const newPreferences = { ...preferences, [key]: value };
      setPreferences(newPreferences);
      accessibilityService.updatePreference(key, value);
      const preferenceNames = {
        reducedMotion: "Reduced motion",
        highContrast: "High contrast",
        largeText: "Large text",
        screenReader: "Screen reader optimizations",
        keyboardNavigation: "Keyboard navigation"
      };
      accessibilityService.announceToScreenReader(
        `${preferenceNames[key]} ${value ? "enabled" : "disabled"}`,
        "assertive"
      );
      monitoringService.trackEvent("accessibility_preference_changed", {
        preference: key,
        value,
        source: "settings_modal"
      });
    } catch (error) {
      console.error("Failed to update accessibility preference:", error);
      monitoringService.reportError(error, "accessibility_preference_update_error");
      setPreferences((prev) => ({ ...prev, [key]: !value }));
      accessibilityService.announceToScreenReader(
        "Failed to update preference. Please try again.",
        "assertive"
      );
    } finally {
      setIsLoading(false);
    }
  };
  const handleClose = () => {
    accessibilityService.announceToScreenReader("Accessibility settings dialog closed");
    accessibilityService.restoreFocus();
    onClose();
  };
  const handleKeyDown = (e) => {
    if (e.key === "Escape") {
      handleClose();
    }
  };
  const resetToDefaults = () => {
    const defaults = {
      reducedMotion: false,
      highContrast: false,
      largeText: false,
      screenReader: false,
      keyboardNavigation: true
    };
    setPreferences(defaults);
    Object.entries(defaults).forEach(([key, value]) => {
      accessibilityService.updatePreference(key, value);
    });
    accessibilityService.announceToScreenReader("Accessibility settings reset to defaults", "assertive");
    monitoringService.trackEvent("accessibility_settings_reset", {
      source: "settings_modal"
    });
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "accessibility-modal-backdrop",
        onClick: handleClose,
        "aria-hidden": "true"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `accessibility-modal ${isLoading ? "loading" : ""}`,
        role: "dialog",
        "aria-modal": "true",
        "aria-labelledby": "accessibility-settings-title",
        "aria-describedby": "accessibility-settings-description",
        onKeyDown: handleKeyDown,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-modal-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-modal-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h2",
              {
                id: "accessibility-settings-title",
                className: "accessibility-modal-title",
                children: "Accessibility Settings"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleClose,
                className: "accessibility-modal-close",
                "aria-label": "Close accessibility settings",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              id: "accessibility-settings-description",
              className: "accessibility-modal-description",
              children: "Customize your accessibility preferences to improve your experience with the application."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-settings-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "accessibility-setting-label", children: "Reduced Motion" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "accessibility-setting-description", children: "Minimize animations and transitions for a calmer experience." })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handlePreferenceChange("reducedMotion", !preferences.reducedMotion),
                  className: `accessibility-toggle ${preferences.reducedMotion ? "active" : ""}`,
                  role: "switch",
                  "aria-checked": preferences.reducedMotion,
                  disabled: isLoading,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "accessibility-toggle-thumb" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "accessibility-setting-label", children: "High Contrast" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "accessibility-setting-description", children: "Increase color contrast for better visibility" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handlePreferenceChange("highContrast", !preferences.highContrast),
                  className: `accessibility-toggle ${preferences.highContrast ? "active" : ""}`,
                  role: "switch",
                  "aria-checked": preferences.highContrast,
                  disabled: isLoading,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "accessibility-toggle-thumb" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "accessibility-setting-label", children: "Large Text" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "accessibility-setting-description", children: "Increase text size throughout the application" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handlePreferenceChange("largeText", !preferences.largeText),
                  className: `accessibility-toggle ${preferences.largeText ? "active" : ""}`,
                  role: "switch",
                  "aria-checked": preferences.largeText,
                  disabled: isLoading,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "accessibility-toggle-thumb" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "accessibility-setting-label", children: "Screen Reader Optimizations" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "accessibility-setting-description", children: "Optimize interface for screen reader users" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handlePreferenceChange("screenReader", !preferences.screenReader),
                  className: `accessibility-toggle ${preferences.screenReader ? "active" : ""}`,
                  role: "switch",
                  "aria-checked": preferences.screenReader,
                  disabled: isLoading,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "accessibility-toggle-thumb" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-setting-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "accessibility-setting-label", children: "Enhanced Keyboard Navigation" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "accessibility-setting-description", children: "Show focus indicators and enable keyboard shortcuts" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handlePreferenceChange("keyboardNavigation", !preferences.keyboardNavigation),
                  className: `accessibility-toggle ${preferences.keyboardNavigation ? "active" : ""}`,
                  role: "switch",
                  "aria-checked": preferences.keyboardNavigation,
                  disabled: isLoading,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "accessibility-toggle-thumb" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-modal-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: resetToDefaults,
                disabled: isLoading,
                className: "accessibility-modal-reset",
                children: "Reset to Defaults"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-modal-buttons", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleClose,
                  disabled: isLoading,
                  className: "accessibility-modal-cancel",
                  children: "Cancel"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleClose,
                  disabled: isLoading,
                  className: "accessibility-modal-done",
                  children: isLoading ? "Saving..." : "Done"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-shortcuts", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "accessibility-shortcuts-title", children: "Keyboard Shortcuts" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-shortcuts-list", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-shortcut", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Close modal" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("kbd", { className: "accessibility-kbd", children: "Esc" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-shortcut", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Navigate settings" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("kbd", { className: "accessibility-kbd", children: "Tab" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-shortcut", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Toggle setting" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("kbd", { className: "accessibility-kbd", children: "Space" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "accessibility-shortcut", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Activate buttons" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("kbd", { className: "accessibility-kbd", children: "Enter" })
              ] })
            ] })
          ] })
        ] })
      }
    )
  ] });
};
const Navigation = ({ currentPage }) => {
  const { isConnected, isLoading, login, logout, account } = useWallet$1();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = reactExports.useState(false);
  const [isScrolled, setIsScrolled] = reactExports.useState(false);
  const [cartCount, setCartCount] = reactExports.useState(0);
  const [isCartOpen, setIsCartOpen] = reactExports.useState(false);
  const [isWalletDropdownOpen, setIsWalletDropdownOpen] = reactExports.useState(false);
  const [isAccessibilitySettingsOpen, setIsAccessibilitySettingsOpen] = reactExports.useState(false);
  const [isDarkMode, setIsDarkMode] = reactExports.useState(() => {
    if (account) {
      const userSettings = localStorage.getItem(`userSettings_${account}`);
      if (userSettings) {
        const parsed = JSON.parse(userSettings);
        return parsed.darkMode !== void 0 ? parsed.darkMode : true;
      }
    }
    const saved = localStorage.getItem("darkMode");
    return saved ? JSON.parse(saved) : true;
  });
  const { settings, updateSetting } = useDisplaySettings();
  const [waxBalance, setWaxBalance] = reactExports.useState("0.0000");
  const [userBadges, setUserBadges] = reactExports.useState([]);
  const [lastBalanceUpdate, setLastBalanceUpdate] = reactExports.useState(0);
  const [isDisplayOptionsExpanded, setIsDisplayOptionsExpanded] = reactExports.useState(false);
  const [isMoreDropdownOpen, setIsMoreDropdownOpen] = reactExports.useState(false);
  const [isBadgeCategoryExpanded, setIsBadgeCategoryExpanded] = reactExports.useState(false);
  const walletDropdownRef = reactExports.useRef(null);
  const moreDropdownRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 10);
    };
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);
  reactExports.useEffect(() => {
    document.documentElement.setAttribute("data-theme", isDarkMode ? "dark" : "light");
    localStorage.setItem("darkMode", JSON.stringify(isDarkMode));
    if (account) {
      const userSettings = localStorage.getItem(`userSettings_${account}`);
      if (userSettings) {
        const parsed = JSON.parse(userSettings);
        const updated = { ...parsed, darkMode: isDarkMode };
        localStorage.setItem(`userSettings_${account}`, JSON.stringify(updated));
      }
    }
  }, [isDarkMode, account]);
  const toggleDarkMode = () => {
    const newDarkMode = !isDarkMode;
    setIsDarkMode(newDarkMode);
    if (account) {
      const userSettings = localStorage.getItem(`userSettings_${account}`);
      if (userSettings) {
        const parsed = JSON.parse(userSettings);
        const updated = { ...parsed, darkMode: newDarkMode };
        localStorage.setItem(`userSettings_${account}`, JSON.stringify(updated));
      } else {
        const initialSettings = {
          emailNotifications: true,
          priceAlerts: true,
          marketingEmails: false,
          darkMode: newDarkMode,
          language: "en",
          currency: "WAX"
        };
        localStorage.setItem(`userSettings_${account}`, JSON.stringify(initialSettings));
      }
    }
  };
  reactExports.useEffect(() => {
    const updateCartCount = () => {
      setCartCount(cartService.getCartCount());
    };
    updateCartCount();
    cartService.addListener(updateCartCount);
    return () => cartService.removeListener(updateCartCount);
  }, []);
  const toggleMobileMenu = () => {
    setIsMobileMenuOpen(!isMobileMenuOpen);
  };
  const closeMobileMenu = () => {
    setIsMobileMenuOpen(false);
  };
  const toggleWalletDropdown = () => {
    setIsWalletDropdownOpen(!isWalletDropdownOpen);
    if (!isWalletDropdownOpen && isConnected && account) {
      const now = Date.now();
      if (now - lastBalanceUpdate > 3e4) {
        fetchWaxBalance();
      }
    }
  };
  const closeWalletDropdown = () => {
    setIsWalletDropdownOpen(false);
  };
  const fetchWaxBalance = reactExports.useCallback(async (forceRefresh = false) => {
    if (!account || !isConnected) return;
    try {
      const balance = await balanceService.getWaxBalance(account, forceRefresh);
      setWaxBalance(balance);
      setLastBalanceUpdate(Date.now());
    } catch (error) {
      log.error("Failed to fetch WAX balance", "Navigation", error);
    }
  }, [account, isConnected]);
  const checkUserBadges = reactExports.useCallback(async () => {
    if (!account || !isConnected) return;
    try {
      const badgeResult = await badgeService.checkUserBadges(account);
      setUserBadges(badgeResult.badges);
    } catch (error) {
      log.error("Failed to check user badges", "Navigation", error);
    }
  }, [account, isConnected]);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (walletDropdownRef.current && !walletDropdownRef.current.contains(event.target)) {
        closeWalletDropdown();
      }
      if (moreDropdownRef.current && !moreDropdownRef.current.contains(event.target)) {
        setIsMoreDropdownOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);
  reactExports.useEffect(() => {
    if (isConnected && account) {
      fetchWaxBalance();
      checkUserBadges();
    } else {
      setWaxBalance("0.0000");
      setUserBadges([]);
    }
  }, [isConnected, account, fetchWaxBalance, checkUserBadges]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#main-content", className: "a11y-skip-link", children: "Skip to main content" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#navigation", className: "a11y-skip-link", children: "Skip to navigation" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "nav",
      {
        className: `navbar ${isScrolled ? "scrolled" : ""}`,
        role: "navigation",
        "aria-label": "Main navigation",
        id: "navigation",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "navbar-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Link,
            {
              to: "/marketplace",
              className: "navbar-logo",
              "aria-label": "PxMarket - Go to marketplace home",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: "https://pixeljourney.xyz/img/logo.png",
                    alt: "PxMarket logo",
                    className: "logo-image"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "logo-text", children: "PxMarket" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "navbar-nav", role: "menubar", "aria-label": "Main menu", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: "/rwax",
                className: `nav-link ${currentPage === "rwax" ? "active" : ""}`,
                role: "menuitem",
                "aria-current": currentPage === "rwax" ? "page" : void 0,
                children: "RWAX"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: "/collections",
                className: `nav-link ${currentPage === "collections" ? "active" : ""}`,
                role: "menuitem",
                "aria-current": currentPage === "collections" ? "page" : void 0,
                children: "Collections"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nav-dropdown", role: "menuitem", ref: moreDropdownRef, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  className: `nav-link dropdown-toggle ${isMoreDropdownOpen ? "active" : ""}`,
                  onClick: () => setIsMoreDropdownOpen(!isMoreDropdownOpen),
                  "aria-expanded": isMoreDropdownOpen,
                  "aria-haspopup": "true",
                  children: [
                    "More",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "dropdown-arrow", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })
                  ]
                }
              ),
              isMoreDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dropdown-menu", role: "menu", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dropdown-section", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "dropdown-section-title", children: "Marketplace" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Link,
                    {
                      to: "/auctions",
                      className: `dropdown-item ${currentPage === "auctions" ? "active" : ""}`,
                      role: "menuitem",
                      onClick: () => setIsMoreDropdownOpen(false),
                      children: "Auctions"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Link,
                    {
                      to: "/activity",
                      className: `dropdown-item ${currentPage === "activity" ? "active" : ""}`,
                      role: "menuitem",
                      onClick: () => setIsMoreDropdownOpen(false),
                      children: "Activity"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dropdown-section", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "dropdown-section-title", children: "Tools & Features" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Link,
                    {
                      to: "/pxcraft",
                      className: `dropdown-item ${currentPage === "pxcraft" ? "active" : ""}`,
                      role: "menuitem",
                      onClick: () => setIsMoreDropdownOpen(false),
                      children: "PxCraft"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Link,
                    {
                      to: "/pxswap",
                      className: `dropdown-item ${currentPage === "pxswap" ? "active" : ""}`,
                      role: "menuitem",
                      onClick: () => setIsMoreDropdownOpen(false),
                      children: "PxSwap"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Link,
                    {
                      to: "/journeymap",
                      className: `dropdown-item ${currentPage === "journeymap" ? "active" : ""}`,
                      role: "menuitem",
                      onClick: () => setIsMoreDropdownOpen(false),
                      children: "JourneyMap"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Link,
                    {
                      to: "/staking",
                      className: `dropdown-item ${currentPage === "pxstaking" ? "active" : ""}`,
                      role: "menuitem",
                      onClick: () => setIsMoreDropdownOpen(false),
                      children: "PxStaking"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dropdown-section social-section", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "dropdown-section-title", children: "Community" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "a",
                    {
                      href: "http://discord.gg/pixel-journey-1130670500776005734",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      className: "dropdown-item nav-social-link",
                      role: "menuitem",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "social-icon", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028 14.09 14.09 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z" }) }),
                        "Join Discord"
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "a",
                    {
                      href: "https://x.com/PxJourney",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      className: "dropdown-item nav-social-link",
                      role: "menuitem",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "social-icon", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" }) }),
                        "Follow on X"
                      ]
                    }
                  )
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: "/learn",
                className: `nav-link ${currentPage === "learn" ? "active" : ""}`,
                role: "menuitem",
                "aria-current": currentPage === "learn" ? "page" : void 0,
                children: "Learn"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: "/rewards",
                className: `nav-link ${currentPage === "rewards" ? "active" : ""}`,
                role: "menuitem",
                "aria-current": currentPage === "rewards" ? "page" : void 0,
                children: "Rewards"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "navbar-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setIsAccessibilitySettingsOpen(true),
                className: "accessibility-btn",
                "aria-label": "Open accessibility settings",
                title: "Accessibility Settings",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "accessibility-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z" }) })
              }
            ),
            isConnected && cartCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => setIsCartOpen(true),
                className: "cart-btn",
                "aria-label": `Open Shopping Cart (${cartCount} items)`,
                "aria-describedby": "cart-count",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "cart-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "9", cy: "21", r: "1" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "20", cy: "21", r: "1" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m1 1 4 4 2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "cart-badge", id: "cart-count", "aria-label": `${cartCount} items in cart`, children: cartCount }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "cart-text", children: "Cart" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-container", ref: walletDropdownRef, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `wallet-btn ${isConnected ? "connected" : ""}`,
                  onClick: isConnected ? toggleWalletDropdown : login,
                  disabled: isLoading,
                  "aria-label": isConnected ? `Wallet connected: ${account}. Click to open wallet menu` : "Connect wallet",
                  "aria-expanded": isConnected && isWalletDropdownOpen,
                  "aria-haspopup": "menu",
                  children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "loading-spinner", children: "" }) : isConnected ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "wallet-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }),
                    account || "Connected"
                  ] }) : "Connect"
                }
              ),
              isConnected && isWalletDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "wallet-dropdown",
                  role: "menu",
                  "aria-label": "Wallet menu",
                  onKeyDown: (e) => {
                    if (e.key === "Escape") {
                      closeWalletDropdown();
                      accessibilityService.announceToScreenReader("Wallet menu closed");
                    }
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-dropdown-header", role: "group", "aria-label": "Wallet information", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-account", "aria-label": `Wallet account: ${account}`, children: account }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Link,
                      {
                        to: "/inventory",
                        className: "wallet-inventory-btn",
                        "aria-label": "Open Inventory",
                        onClick: () => setIsWalletDropdownOpen(false),
                        role: "menuitem",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "inventory-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2", ry: "2" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 9h6v6H9z" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "My Inventory" })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Link,
                      {
                        to: "/profile",
                        className: "wallet-inventory-btn",
                        "aria-label": "View Profile",
                        onClick: () => setIsWalletDropdownOpen(false),
                        role: "menuitem",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "inventory-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "My Profile" })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Link,
                      {
                        to: "/watchlist",
                        className: "wallet-inventory-btn",
                        "aria-label": "View Watchlist",
                        onClick: () => setIsWalletDropdownOpen(false),
                        role: "menuitem",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "inventory-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" }) }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "My Watchlist" })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-balance", role: "group", "aria-label": "Wallet balance information", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-label", children: "WAX Balance:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nav-balance-amount", "aria-label": `Balance: ${waxBalance} WAX`, children: waxBalance })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-badges", role: "group", "aria-label": "User badges", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "div",
                        {
                          className: "badges-header",
                          onClick: () => setIsBadgeCategoryExpanded(!isBadgeCategoryExpanded),
                          style: { cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "space-between", padding: "8px 0" },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badges-label", children: "PxBadges:" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px", color: "#888" }, children: isBadgeCategoryExpanded ? "" : "" })
                          ]
                        }
                      ),
                      !isBadgeCategoryExpanded ? (
                        // Collapsed view - show earned badge icons only
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "badges-collapsed", style: { display: "flex", gap: "4px", flexWrap: "wrap" }, children: [
                          badgeService.getAllBadgeDefinitions().filter((badgeDef) => userBadges.some((badge) => badge.id === badgeDef.id)).map((badgeDef) => {
                            return /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "span",
                              {
                                className: "badge-icon earned",
                                style: {
                                  fontSize: "16px",
                                  padding: "4px",
                                  borderRadius: "4px",
                                  background: `${badgeDef.color}20`,
                                  color: badgeDef.color,
                                  border: `1px solid ${badgeDef.borderColor}`,
                                  cursor: "pointer"
                                },
                                title: `${badgeDef.name}: ${badgeDef.description}  Earned`,
                                children: badgeDef.icon
                              },
                              badgeDef.id
                            );
                          }),
                          userBadges.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px", color: "#888", fontStyle: "italic" }, children: "No badges earned yet" })
                        ] })
                      ) : (
                        // Expanded view - show full badge details with buy buttons
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "badges-expanded", style: { display: "flex", flexDirection: "column", gap: "8px" }, children: badgeService.getAllBadgeDefinitions().map((badgeDef) => {
                          const isEarned = userBadges.some((badge) => badge.id === badgeDef.id);
                          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "div",
                            {
                              className: `badge-item ${isEarned ? "earned" : "unearned"}`,
                              style: {
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "space-between",
                                padding: "8px",
                                borderRadius: "6px",
                                background: isEarned ? `${badgeDef.color}15` : "rgba(128, 128, 128, 0.05)",
                                border: `1px solid ${isEarned ? badgeDef.borderColor : "rgba(128, 128, 128, 0.1)"}`
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "16px", opacity: isEarned ? 1 : 0.5 }, children: badgeDef.icon }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "12px", fontWeight: "500", color: isEarned ? badgeDef.color : "#666" }, children: [
                                      badgeDef.name,
                                      " ",
                                      isEarned && ""
                                    ] }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "10px", color: "#888" }, children: badgeDef.requirements })
                                  ] })
                                ] }),
                                !isEarned && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  "button",
                                  {
                                    onClick: () => {
                                      if (badgeDef.id === "pxj-whale" || badgeDef.id === "pxj-holder") {
                                        window.open("https://waxonedge.app/swap/WAX_eosio.token/PXJ_pixeljourney", "_blank");
                                      } else if (badgeDef.id === "pixal-pfp") {
                                        window.location.href = "/marketplace?collection=pixeljourney&template=781515";
                                      } else if (badgeDef.id === "waxrock") {
                                        window.location.href = "/marketplace?category=waxrock";
                                      } else if (badgeDef.id === "ingredients") {
                                        window.location.href = "/marketplace?category=ingredients";
                                      } else {
                                        window.location.href = "/marketplace?collection=pixeljourney";
                                      }
                                    },
                                    style: {
                                      fontSize: "10px",
                                      padding: "4px 8px",
                                      background: badgeDef.color,
                                      color: "white",
                                      border: "none",
                                      borderRadius: "4px",
                                      cursor: "pointer",
                                      transition: "opacity 0.2s"
                                    },
                                    onMouseEnter: (e) => e.target.style.opacity = "0.8",
                                    onMouseLeave: (e) => e.target.style.opacity = "1",
                                    children: "Buy"
                                  }
                                )
                              ]
                            },
                            badgeDef.id
                          );
                        }) })
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-settings", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-menu", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "div",
                        {
                          className: "settings-header",
                          onClick: () => setIsDisplayOptionsExpanded(!isDisplayOptionsExpanded),
                          style: { cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "space-between", padding: "8px 0" },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Display Options" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px", color: "#888" }, children: isDisplayOptionsExpanded ? "" : "" })
                          ]
                        }
                      ),
                      !isDisplayOptionsExpanded ? (
                        // Collapsed view - only show dark mode toggle
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "theme-toggle-option", style: { marginTop: "8px" }, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Dark Mode" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "button",
                            {
                              className: `theme-toggle ${isDarkMode ? "active" : ""}`,
                              onClick: toggleDarkMode,
                              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "toggle-slider", children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "sun-icon", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "5" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "1", x2: "12", y2: "3" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "21", x2: "12", y2: "23" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.22", y1: "4.22", x2: "5.64", y2: "5.64" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18.36", y1: "18.36", x2: "19.78", y2: "19.78" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "12", x2: "3", y2: "12" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "12", x2: "23", y2: "12" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.22", y1: "19.78", x2: "5.64", y2: "18.36" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18.36", y1: "5.64", x2: "19.78", y2: "4.22" })
                                ] }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "moon-icon", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" }) })
                              ] })
                            }
                          )
                        ] })
                      ) : (
                        // Expanded view - show all options
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-options", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.showOtherCollections,
                                onChange: (e) => updateSetting("showOtherCollections", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show other collections" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.showWhitelistedOnly,
                                onChange: (e) => updateSetting("showWhitelistedOnly", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Displays only whitelisted collections in overviews" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.enableAnimatedNFTs,
                                onChange: (e) => updateSetting("enableAnimatedNFTs", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Enables animated NFTs to play in overviews" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.showExplicitContent,
                                onChange: (e) => updateSetting("showExplicitContent", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Enables explicit content to be shown in overviews" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.showChatButton,
                                onChange: (e) => updateSetting("showChatButton", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show chat button" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.blockNSFW,
                                onChange: (e) => updateSetting("blockNSFW", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Blocks NSFW collections from the platform" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.blockAI,
                                onChange: (e) => updateSetting("blockAI", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Blocks AI collections from the platform" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "theme-toggle-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Dark Mode" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "button",
                              {
                                className: `theme-toggle ${isDarkMode ? "active" : ""}`,
                                onClick: toggleDarkMode,
                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "toggle-slider", children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "sun-icon", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "5" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "1", x2: "12", y2: "3" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "21", x2: "12", y2: "23" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.22", y1: "4.22", x2: "5.64", y2: "5.64" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18.36", y1: "18.36", x2: "19.78", y2: "19.78" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "12", x2: "3", y2: "12" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "12", x2: "23", y2: "12" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.22", y1: "19.78", x2: "5.64", y2: "18.36" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18.36", y1: "5.64", x2: "19.78", y2: "4.22" })
                                  ] }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "moon-icon", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" }) })
                                ] })
                              }
                            )
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.showPricesInUSD,
                                onChange: (e) => updateSetting("showPricesInUSD", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show Prices in USD" })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "currency-selection", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Currency Comparison:" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(
                              "select",
                              {
                                value: settings.selectedCurrency,
                                onChange: (e) => updateSetting("selectedCurrency", e.target.value),
                                className: "currency-select",
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "USD", children: "USD - US Dollar" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "EUR", children: "EUR - Euro" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "DKK", children: "DKK - Danish Krone" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "AED", children: "AED - UAE Dirham" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "INR", children: "INR - Indian Rupee" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "RUB", children: "RUB - Russian Ruble" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "CNY", children: "CNY - Chinese Yuan" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "JPY", children: "JPY - Japanese Yen" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "BTC", children: "BTC - Bitcoin" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "ETH", children: "ETH - Ethereum" })
                                ]
                              }
                            )
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "filter-option", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "input",
                              {
                                type: "checkbox",
                                checked: settings.showRarityRankings,
                                onChange: (e) => updateSetting("showRarityRankings", e.target.checked)
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show Rarity Rankings" })
                          ] })
                        ] })
                      )
                    ] }) }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "logout-btn", onClick: logout, role: "menuitem", "aria-label": "Logout from wallet", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "logout-icon", "aria-hidden": "true", children: "" }),
                      "Logout"
                    ] })
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: toggleMobileMenu,
                className: `mobile-menu-btn ${isMobileMenuOpen ? "active" : ""}`,
                "aria-label": isMobileMenuOpen ? "Close Menu" : "Open Menu",
                "aria-expanded": isMobileMenuOpen,
                "aria-controls": "mobile-menu",
                onKeyDown: (e) => {
                  if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    toggleMobileMenu();
                    accessibilityService.announceToScreenReader(
                      isMobileMenuOpen ? "Mobile menu closed" : "Mobile menu opened"
                    );
                  }
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hamburger", "aria-hidden": "true", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
                ] })
              }
            )
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `mobile-menu ${isMobileMenuOpen ? "open" : ""}`,
        id: "mobile-menu",
        role: "navigation",
        "aria-expanded": isMobileMenuOpen,
        "aria-label": "Mobile navigation menu",
        onKeyDown: (e) => {
          if (e.key === "Escape") {
            closeMobileMenu();
            accessibilityService.announceToScreenReader("Mobile menu closed");
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "mobile-nav-links", role: "navigation", "aria-label": "Mobile menu links", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mobile-nav-section", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mobile-nav-section-title", children: "Main" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mobile-nav-grid", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "marketplace" || currentPage === "" ? "active" : ""}`,
                    children: "Marketplace"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/rwax",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "rwax" ? "active" : ""}`,
                    children: "RWAX"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/collections",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "collections" ? "active" : ""}`,
                    children: "Collections"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/learn",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "learn" ? "active" : ""}`,
                    children: "Learn"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/rewards",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "rewards" ? "active" : ""}`,
                    children: "Rewards"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mobile-nav-section", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mobile-nav-section-title", children: "Trading & Tools" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mobile-nav-grid", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/auctions",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "auctions" ? "active" : ""}`,
                    children: "Auctions"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/activity",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "activity" ? "active" : ""}`,
                    children: "Activity"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/pxcrafting",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "pxcrafting" ? "active" : ""}`,
                    children: "PxCraft"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/pxswap",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "pxswap" ? "active" : ""}`,
                    children: "PxSwap"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/journeymap",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "journeymap" ? "active" : ""}`,
                    children: "JourneyMap"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/staking",
                    onClick: closeMobileMenu,
                    className: `mobile-nav-link ${currentPage === "pxstaking" ? "active" : ""}`,
                    children: "PxStaking"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mobile-nav-section", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mobile-nav-section-title", children: "Community" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mobile-social-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "a",
                  {
                    href: "http://discord.gg/pixel-journey-1130670500776005734",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "mobile-social-link",
                    onClick: closeMobileMenu,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "social-icon", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028 14.09 14.09 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z" }) }),
                      "Discord"
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "a",
                  {
                    href: "https://x.com/PxJourney",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "mobile-social-link",
                    onClick: closeMobileMenu,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "social-icon", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" }) }),
                      "X (Twitter)"
                    ]
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mobile-menu-actions", children: [
            isConnected && cartCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => {
                  setIsCartOpen(true);
                  closeMobileMenu();
                },
                className: "mobile-cart-btn",
                "aria-label": `Open Shopping Cart (${cartCount} items)`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "cart-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "9", cy: "21", r: "1" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "20", cy: "21", r: "1" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m1 1 4 4 2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6" })
                  ] }),
                  "Shopping Cart (",
                  cartCount,
                  ")"
                ]
              }
            ),
            isConnected && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Link,
                {
                  to: "/inventory",
                  onClick: closeMobileMenu,
                  className: "mobile-inventory-btn",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "inventory-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" }) }),
                    "My Inventory"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Link,
                {
                  to: "/profile",
                  onClick: closeMobileMenu,
                  className: "mobile-inventory-btn",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "inventory-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }),
                    "My Profile"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Link,
                {
                  to: "/watchlist",
                  onClick: closeMobileMenu,
                  className: "mobile-inventory-btn",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "inventory-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" }) }),
                    "My Watchlist"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mobile-auth-section", children: isConnected ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => {
                  logout();
                  closeMobileMenu();
                  accessibilityService.announceToScreenReader("Logged out successfully");
                },
                className: "mobile-auth-btn logout-btn",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "auth-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" }) }),
                  "Logout"
                ]
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => {
                  login();
                  closeMobileMenu();
                  accessibilityService.announceToScreenReader("Login initiated");
                },
                className: "mobile-auth-btn login-btn",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "auth-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1" }) }),
                  "Login"
                ]
              }
            ) })
          ] })
        ]
      }
    ),
    isMobileMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "fixed inset-0 bg-black bg-opacity-50 z-[998]",
        onClick: closeMobileMenu
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ShoppingCart,
      {
        isOpen: isCartOpen,
        onClose: () => setIsCartOpen(false)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AccessibilitySettings,
      {
        isOpen: isAccessibilitySettingsOpen,
        onClose: () => setIsAccessibilitySettingsOpen(false)
      }
    )
  ] });
};
const LandingPage = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "landing-page", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hero-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hero-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "hero-title", children: [
        "Welcome to ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "brand-highlight", children: "PxMarket" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "hero-subtitle", children: "by Pixel Journey" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "hero-description", children: "Discover, trade, and collect unique digital assets in the ultimate NFT marketplace experience." })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cta-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cta-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cta-card marketplace-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cta-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "cta-title", children: "Explore Marketplace" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "cta-description", children: "Browse thousands of unique NFTs, discover rare collectibles, and find your next digital (pixel?!) treasure." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/marketplace", className: "cta-button primary", children: "Enter Marketplace" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cta-card rwax-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cta-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "cta-title", children: "Get Your Pixal PFP via R-WAX" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "cta-description", children: "Pick up your unique pixel-perfect Pixal Profile Picture using WPIXAL on the R-WAX Markets and join the Pixel Journey community!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/rwax", className: "cta-button secondary", children: "Browse RWAX Pixals" })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "features-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "features-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "feature-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Lightning Fast" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Instant transactions on the WAX blockchain" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "feature-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Secure Trading" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Safe and transparent blockchain transactions" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "feature-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Premium Quality" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Curated collection of high-quality digital assets" })
      ] })
    ] }) })
  ] });
};
class PushNotificationService {
  constructor() {
    __publicField(this, "serviceWorkerRegistration", null);
    __publicField(this, "pushSubscription", null);
    __publicField(this, "vapidPublicKey", "");
    // Should be set from environment or config
    __publicField(this, "isInitialized", false);
    __publicField(this, "permissionState", {
      permission: "default",
      supported: false,
      serviceWorkerReady: false,
      subscribed: false
    });
    this.checkSupport();
  }
  checkSupport() {
    this.permissionState.supported = "serviceWorker" in navigator && "PushManager" in window && "Notification" in window;
    if (this.permissionState.supported) {
      this.permissionState.permission = Notification.permission;
    }
  }
  async initialize() {
    if (this.isInitialized) {
      return true;
    }
    try {
      if (!this.permissionState.supported) {
        log.warn("Push notifications not supported in this browser");
        return false;
      }
      await this.registerServiceWorker();
      await this.checkExistingSubscription();
      this.isInitialized = true;
      monitoringService.trackEvent("push_notification_service_initialized", {
        supported: this.permissionState.supported,
        permission: this.permissionState.permission,
        subscribed: this.permissionState.subscribed
      });
      return true;
    } catch (error) {
      log.error("Failed to initialize push notification service", "PushNotificationService.initialize", error);
      monitoringService.reportError(error, "push_notification_init_error");
      return false;
    }
  }
  async registerServiceWorker() {
    try {
      const isDevelopment = location.hostname === "localhost" || location.hostname === "127.0.0.1" || location.protocol === "http:";
      const swFile = isDevelopment ? "/sw-dev.js" : "/sw.js";
      this.serviceWorkerRegistration = await navigator.serviceWorker.register(swFile, {
        scope: "/"
      });
      await navigator.serviceWorker.ready;
      this.permissionState.serviceWorkerReady = true;
      log.info(`Service Worker registered successfully: ${swFile}`);
      navigator.serviceWorker.addEventListener("message", this.handleServiceWorkerMessage.bind(this));
    } catch (error) {
      log.error("Failed to register service worker", "PushNotificationService.registerServiceWorker", error);
      throw error;
    }
  }
  handleServiceWorkerMessage(event) {
    const { type, data } = event.data || {};
    switch (type) {
      case "NOTIFICATION_CLICKED":
        monitoringService.trackEvent("notification_clicked", data);
        break;
      case "NOTIFICATION_CLOSED":
        monitoringService.trackEvent("notification_closed", data);
        break;
      default:
        log.debug("Unknown service worker message:", type);
    }
  }
  async checkExistingSubscription() {
    if (!this.serviceWorkerRegistration) {
      return;
    }
    try {
      this.pushSubscription = await this.serviceWorkerRegistration.pushManager.getSubscription();
      this.permissionState.subscribed = !!this.pushSubscription;
      if (this.pushSubscription) {
        log.info("Existing push subscription found");
        await this.validateSubscription();
      }
    } catch (error) {
      log.error("Failed to check existing subscription", "PushNotificationService.checkExistingSubscription", error);
    }
  }
  async requestPermission() {
    if (!this.permissionState.supported) {
      throw new Error("Push notifications not supported");
    }
    try {
      const permission = await Notification.requestPermission();
      this.permissionState.permission = permission;
      monitoringService.trackEvent("notification_permission_requested", {
        permission,
        previousPermission: this.permissionState.permission
      });
      return permission;
    } catch (error) {
      ErrorMessageService.logError("PushNotificationService.requestPermission", error);
      monitoringService.reportError(error, "notification_permission_error");
      throw error;
    }
  }
  async subscribe(userId) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    if (!this.serviceWorkerRegistration) {
      throw new Error("Service worker not registered");
    }
    if (this.permissionState.permission !== "granted") {
      const permission = await this.requestPermission();
      if (permission !== "granted") {
        throw new Error("Notification permission denied");
      }
    }
    try {
      if (this.pushSubscription) {
        await this.unsubscribe();
      }
      const subscribeOptions = {
        userVisibleOnly: true,
        applicationServerKey: this.vapidPublicKey ? this.urlBase64ToUint8Array(this.vapidPublicKey) : void 0
      };
      this.pushSubscription = await this.serviceWorkerRegistration.pushManager.subscribe(subscribeOptions);
      this.permissionState.subscribed = true;
      const subscriptionData = {
        endpoint: this.pushSubscription.endpoint,
        keys: {
          p256dh: this.arrayBufferToBase64(this.pushSubscription.getKey("p256dh")),
          auth: this.arrayBufferToBase64(this.pushSubscription.getKey("auth"))
        },
        userId,
        subscriptionTime: Date.now()
      };
      localStorage.setItem("push_subscription", JSON.stringify(subscriptionData));
      await this.sendSubscriptionToServer(subscriptionData);
      monitoringService.trackEvent("push_notification_subscribed", {
        userId,
        endpoint: this.pushSubscription.endpoint
      });
      log.info("Push notification subscription successful");
      return this.pushSubscription;
    } catch (error) {
      log.error("Failed to subscribe to push notifications", "PushNotificationService.subscribe", error);
      monitoringService.reportError(error, "push_subscription_error", { userId });
      throw error;
    }
  }
  async unsubscribe() {
    if (!this.pushSubscription) {
      return true;
    }
    try {
      const success = await this.pushSubscription.unsubscribe();
      if (success) {
        this.pushSubscription = null;
        this.permissionState.subscribed = false;
        localStorage.removeItem("push_subscription");
        await this.removeSubscriptionFromServer();
        monitoringService.trackEvent("push_notification_unsubscribed");
        log.info("Push notification unsubscribed successfully");
      }
      return success;
    } catch (error) {
      ErrorMessageService.logError("PushNotificationService.unsubscribe", error);
      monitoringService.reportError(error, "push_unsubscription_error");
      return false;
    }
  }
  async showLocalNotification(payload) {
    if (!this.permissionState.supported || this.permissionState.permission !== "granted") {
      throw new Error("Notifications not available");
    }
    try {
      const options = {
        body: payload.body,
        icon: payload.icon || "/logo.png",
        badge: payload.badge || "/logo.png",
        tag: payload.tag,
        data: payload.data,
        requireInteraction: payload.requireInteraction || false,
        silent: payload.silent || false
      };
      const notification = new Notification(payload.title, options);
      notification.onclick = () => {
        monitoringService.trackEvent("local_notification_clicked", {
          tag: payload.tag,
          title: payload.title
        });
        notification.close();
      };
      notification.onclose = () => {
        monitoringService.trackEvent("local_notification_closed", {
          tag: payload.tag,
          title: payload.title
        });
      };
      monitoringService.trackEvent("local_notification_shown", {
        tag: payload.tag,
        title: payload.title
      });
    } catch (error) {
      log.error("Failed to show local notification", "PushNotificationService.showLocalNotification", error);
      monitoringService.reportError(error, "local_notification_error", { title: payload.title });
      throw error;
    }
  }
  // Utility methods
  urlBase64ToUint8Array(base64String) {
    const padding = "=".repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }
  arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }
  getAuthToken() {
    return localStorage.getItem("auth_token") || sessionStorage.getItem("auth_token") || "";
  }
  getNotificationPreferences() {
    const stored = localStorage.getItem("notification_preferences");
    if (stored) {
      try {
        return JSON.parse(stored);
      } catch (error) {
        log.warn("Failed to parse notification preferences:", "pushNotificationService.getNotificationPreferences", error);
      }
    }
    return {
      priceAlerts: true,
      auctionUpdates: true,
      newListings: false,
      marketTrends: false,
      systemNotifications: true
    };
  }
  async validateSubscription() {
    if (!this.pushSubscription) {
      return false;
    }
    try {
      const subscriptionData = {
        endpoint: this.pushSubscription.endpoint,
        keys: {
          p256dh: this.arrayBufferToBase64(this.pushSubscription.getKey("p256dh")),
          auth: this.arrayBufferToBase64(this.pushSubscription.getKey("auth"))
        }
      };
      const response = await fetch("/api/push/validate-subscription", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.getAuthToken()}`
        },
        body: JSON.stringify({ subscription: subscriptionData })
      });
      if (!response.ok) {
        throw new Error(`Validation failed: ${response.status} ${response.statusText}`);
      }
      const result = await response.json();
      return result.valid === true;
    } catch (error) {
      log.warn("Subscription validation failed:", "pushNotificationService.validateSubscription", error);
      return false;
    }
  }
  async sendSubscriptionToServer(subscriptionData) {
    try {
      const response = await fetch("/api/push/subscribe", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.getAuthToken()}`
        },
        body: JSON.stringify({
          ...subscriptionData,
          userAgent: navigator.userAgent,
          timestamp: Date.now(),
          preferences: this.getNotificationPreferences()
        })
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Failed to save subscription: ${response.status} ${response.statusText} - ${errorData.message || "Unknown error"}`);
      }
      const result = await response.json();
      log.info("Subscription successfully saved to server:", result.subscriptionId);
      localStorage.setItem("push_subscription_id", result.subscriptionId);
    } catch (error) {
      log.error("Failed to send subscription to server:", "pushNotificationService.sendSubscriptionToServer", error, {
        endpoint: subscriptionData.endpoint,
        userId: subscriptionData.userId
      });
      throw error;
    }
  }
  async removeSubscriptionFromServer() {
    try {
      const subscriptionId = localStorage.getItem("push_subscription_id");
      const subscriptionData = localStorage.getItem("push_subscription");
      if (!subscriptionId && !subscriptionData) {
        log.info("No subscription to remove from server");
        return;
      }
      const response = await fetch("/api/push/unsubscribe", {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.getAuthToken()}`
        },
        body: JSON.stringify({
          subscriptionId,
          endpoint: this.pushSubscription?.endpoint,
          timestamp: Date.now()
        })
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Failed to remove subscription: ${response.status} ${response.statusText} - ${errorData.message || "Unknown error"}`);
      }
      localStorage.removeItem("push_subscription_id");
      log.info("Subscription successfully removed from server");
    } catch (error) {
      log.error("Failed to remove subscription from server:", "pushNotificationService.removeSubscriptionFromServer", error);
    }
  }
  // Public API methods
  getPermissionState() {
    return { ...this.permissionState };
  }
  isSubscribed() {
    return this.permissionState.subscribed;
  }
  getSubscription() {
    return this.pushSubscription;
  }
  setVapidKey(key) {
    this.vapidPublicKey = key;
  }
  async testNotification() {
    await this.showLocalNotification({
      title: "PxMarket Test Notification",
      body: "Push notifications are working correctly!",
      tag: "test-notification",
      data: { test: true }
    });
  }
  // Integration with watchlist service for price alerts
  async sendPriceAlert(assetName, currentPrice, targetPrice) {
    await this.showLocalNotification({
      title: "Price Alert",
      body: `${assetName} is now ${currentPrice} (target: ${targetPrice})`,
      tag: "price-alert",
      icon: "/logo.png",
      requireInteraction: true,
      data: {
        type: "price_alert",
        assetName,
        currentPrice,
        targetPrice
      }
    });
  }
  // Integration with cart service for transaction notifications
  async sendTransactionNotification(type, message, transactionId) {
    await this.showLocalNotification({
      title: type === "success" ? "Transaction Successful" : "Transaction Failed",
      body: message,
      tag: `transaction-${type}`,
      icon: "/logo.png",
      data: {
        type: "transaction",
        status: type,
        transactionId
      }
    });
  }
}
const pushNotificationService = new PushNotificationService();
class WatchlistService {
  // 15 minutes
  constructor() {
    __publicField(this, "watchlist", []);
    __publicField(this, "priceAlerts", {});
    __publicField(this, "notifications", {
      browser: true,
      email: false,
      sound: true
    });
    __publicField(this, "listeners", []);
    __publicField(this, "priceCheckInterval", null);
    __publicField(this, "STORAGE_KEY", "pixeljourney_watchlist");
    __publicField(this, "ALERTS_KEY", "pixeljourney_price_alerts");
    __publicField(this, "NOTIFICATIONS_KEY", "pixeljourney_notifications");
    // Price caching to reduce API requests
    __publicField(this, "priceCache", {});
    __publicField(this, "CACHE_DURATION", 2 * 60 * 1e3);
    // 2 minutes cache
    // Endpoint failure tracking
    __publicField(this, "endpointFailures", {});
    __publicField(this, "MAX_FAILURES", 3);
    __publicField(this, "FAILURE_WINDOW", 5 * 60 * 1e3);
    // 5 minutes
    __publicField(this, "DISABLE_DURATION", 15 * 60 * 1e3);
    this.loadFromStorage();
    this.startPriceMonitoring();
    this.requestNotificationPermission();
  }
  // Load data from storage with proper error handling
  loadFromStorage() {
    try {
      this.watchlist = storageService.getJSON(this.STORAGE_KEY, []);
      this.priceAlerts = storageService.getJSON(this.ALERTS_KEY, {});
      this.notifications = storageService.getJSON(this.NOTIFICATIONS_KEY, {
        browser: true,
        email: false,
        sound: true
      });
    } catch (error) {
      ErrorMessageService.logError("WatchlistService.loadFromStorage", error, { storageKeys: [this.STORAGE_KEY, this.ALERTS_KEY, this.NOTIFICATIONS_KEY] });
    }
  }
  // Save data to storage with proper error handling
  saveToStorage() {
    try {
      const success = storageService.setJSON(this.STORAGE_KEY, this.watchlist) && storageService.setJSON(this.ALERTS_KEY, this.priceAlerts) && storageService.setJSON(this.NOTIFICATIONS_KEY, this.notifications);
      if (!success) {
        ErrorMessageService.logError("WatchlistService.saveToStorage", new Error("Failed to save to storage"), {
          watchlistSize: this.watchlist.length,
          alertsCount: Object.keys(this.priceAlerts).length
        });
      }
      this.notifyListeners();
    } catch (error) {
      ErrorMessageService.logError("WatchlistService.saveToStorage", error, { watchlistSize: this.watchlist.length, alertsCount: Object.keys(this.priceAlerts).length });
    }
  }
  // Request browser notification permission
  async requestNotificationPermission() {
    if ("Notification" in window && Notification.permission === "default") {
      await Notification.requestPermission();
    }
  }
  // Add listener for watchlist changes
  addListener(listener) {
    this.listeners.push(listener);
  }
  // Remove listener
  removeListener(listener) {
    this.listeners = this.listeners.filter((l) => l !== listener);
  }
  // Notify all listeners
  notifyListeners() {
    this.listeners.forEach((listener) => listener([...this.watchlist]));
  }
  // Add NFT to watchlist
  async addToWatchlist(nft) {
    const existingIndex = this.watchlist.findIndex((item) => item.nft.asset_id === nft.asset_id);
    if (existingIndex !== -1) {
      return false;
    }
    const watchlistItem = {
      nft,
      alertType: "any",
      addedAt: Date.now(),
      lastPrice: nft.price ? parseFloat(nft.price) : 0
    };
    this.watchlist.push(watchlistItem);
    this.saveToStorage();
    this.notifyListeners();
    return true;
  }
  // Remove NFT from watchlist
  async removeFromWatchlist(assetId) {
    this.watchlist = this.watchlist.filter((item) => item.nft.asset_id !== assetId);
    delete this.priceAlerts[assetId];
    this.saveToStorage();
    this.notifyListeners();
  }
  // Get watchlist
  async getWatchlist() {
    return [...this.watchlist];
  }
  // Check if NFT is in watchlist
  isInWatchlist(assetId) {
    return this.watchlist.some((item) => item.nft.asset_id === assetId);
  }
  // Set price alert for an NFT
  async setPriceAlert(assetId, alert) {
    this.priceAlerts[assetId] = {
      ...alert,
      lastTriggered: void 0
    };
    this.saveToStorage();
  }
  // Remove price alert
  async removePriceAlert(assetId) {
    delete this.priceAlerts[assetId];
    this.saveToStorage();
  }
  // Get price alert for an NFT
  getPriceAlert(assetId) {
    return this.priceAlerts[assetId];
  }
  // Update notification settings
  updateNotificationSettings(settings) {
    this.notifications = { ...this.notifications, ...settings };
    this.saveToStorage();
  }
  // Get notification settings
  getNotificationSettings() {
    return { ...this.notifications };
  }
  // Circuit breaker methods
  isEndpointDisabled(endpoint) {
    const failure = this.endpointFailures[endpoint];
    if (!failure || !failure.disabled) return false;
    if (Date.now() - failure.lastFailure > this.DISABLE_DURATION) {
      failure.disabled = false;
      failure.count = 0;
      return false;
    }
    return true;
  }
  recordEndpointFailure(endpoint) {
    const now = Date.now();
    const failure = this.endpointFailures[endpoint] || { count: 0, lastFailure: 0, disabled: false };
    if (now - failure.lastFailure > this.FAILURE_WINDOW) {
      failure.count = 0;
    }
    failure.count++;
    failure.lastFailure = now;
    if (failure.count >= this.MAX_FAILURES) {
      failure.disabled = true;
      log.warn(`Endpoint ${endpoint} disabled due to ${failure.count} failures`, "WatchlistService.recordEndpointFailure");
    }
    this.endpointFailures[endpoint] = failure;
  }
  recordEndpointSuccess(endpoint) {
    const failure = this.endpointFailures[endpoint];
    if (failure) {
      failure.count = 0;
      failure.disabled = false;
    }
  }
  notifyEndpointsDisabled() {
    const lastNotification = localStorage.getItem("watchlist_endpoints_disabled_notification");
    const now = Date.now();
    if (lastNotification && now - parseInt(lastNotification) < 15 * 60 * 1e3) {
      return;
    }
    localStorage.setItem("watchlist_endpoints_disabled_notification", now.toString());
    window.dispatchEvent(new CustomEvent("watchlistEndpointsDisabled", {
      detail: {
        message: "Price monitoring temporarily disabled due to API issues. Will retry automatically.",
        disabledEndpoints: Object.keys(this.endpointFailures).filter((k) => this.endpointFailures[k].disabled),
        retryTime: Math.max(...Object.values(this.endpointFailures).map((f) => f.lastFailure + this.DISABLE_DURATION))
      }
    }));
  }
  // Get endpoint health status for debugging
  getEndpointStatus() {
    const status = {};
    for (const [endpoint, failure] of Object.entries(this.endpointFailures)) {
      status[endpoint] = {
        healthy: !failure.disabled,
        failures: failure.count,
        disabledUntil: failure.disabled ? failure.lastFailure + this.DISABLE_DURATION : void 0
      };
    }
    return status;
  }
  // Start price monitoring
  startPriceMonitoring() {
    this.priceCheckInterval = setInterval(() => {
      this.checkPriceAlerts();
    }, 3 * 60 * 1e3);
    setTimeout(() => {
      this.checkPriceAlerts();
    }, 6e4);
  }
  // Stop price monitoring
  stopPriceMonitoring() {
    if (this.priceCheckInterval) {
      clearInterval(this.priceCheckInterval);
      this.priceCheckInterval = null;
    }
  }
  // Check price alerts with improved error handling and batching
  async checkPriceAlerts() {
    if (this.watchlist.length === 0) return;
    const allEndpointsDisabled = ["atomichub", "neftyblocks"].every(
      (endpoint) => this.isEndpointDisabled(endpoint)
    );
    if (allEndpointsDisabled) {
      log.warn("All price endpoints are disabled, skipping price check", "WatchlistService.checkPrices");
      this.notifyEndpointsDisabled();
      return;
    }
    try {
      const disabledCount = Object.values(this.endpointFailures).filter((f) => f.disabled).length;
      const batchSize = disabledCount > 0 ? 2 : 3;
      const batches = [];
      for (let i = 0; i < this.watchlist.length; i += batchSize) {
        batches.push(this.watchlist.slice(i, i + batchSize));
      }
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        if (i > 0) {
          await new Promise((resolve) => setTimeout(resolve, 2e3));
        }
        const pricePromises = batch.map(async (item) => {
          try {
            const currentPrice = await this.fetchCurrentPrice(item);
            const priceChange = item.lastPrice > 0 ? (currentPrice - item.lastPrice) / item.lastPrice * 100 : 0;
            item.lastPrice = currentPrice;
            item.priceChange = priceChange;
            const alert = this.priceAlerts[item.nft.asset_id];
            if (alert && alert.enabled && currentPrice > 0) {
              await this.checkAlertCondition(item, alert, currentPrice);
            }
            return item;
          } catch (error) {
            ErrorMessageService.logError("WatchlistService.checkPriceAlerts.priceCheck", error, {
              assetId: item.nft.asset_id,
              nftName: item.nft.name
            });
            return item;
          }
        });
        await Promise.allSettled(pricePromises);
        if (batches.indexOf(batch) < batches.length - 1) {
          const delay = disabledCount > 0 ? 2e3 : 1e3;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
      this.saveToStorage();
    } catch (error) {
      ErrorMessageService.logError("WatchlistService.checkPriceAlerts", error, {
        watchlistSize: this.watchlist.length,
        disabledEndpoints: Object.keys(this.endpointFailures).filter((k) => this.endpointFailures[k].disabled)
      });
    }
  }
  // Fetch current price for a watchlist item with caching
  async fetchCurrentPrice(item) {
    const assetId = item.nft.asset_id;
    const now = Date.now();
    const cached = this.priceCache[assetId];
    if (cached && now - cached.timestamp < this.CACHE_DURATION) {
      return cached.price;
    }
    const price = await this.getCurrentPrice(assetId);
    this.priceCache[assetId] = {
      price,
      timestamp: now
    };
    return price;
  }
  // Get current price for an NFT using single endpoint (sequential, not parallel)
  async getCurrentPrice(assetId) {
    try {
      const endpoints = ["atomichub", "neftyblocks"];
      for (const endpoint of endpoints) {
        if (this.isEndpointDisabled(endpoint)) continue;
        try {
          let price = 0;
          switch (endpoint) {
            case "atomichub":
              price = await this.fetchAtomicHubPrice(assetId);
              break;
            case "neftyblocks":
              price = await this.fetchNeftyBlocksPrice(assetId);
              break;
          }
          if (price > 0) {
            this.recordEndpointSuccess(endpoint);
            return price;
          }
        } catch (error) {
          this.recordEndpointFailure(endpoint);
          log.warn(`Failed to fetch price from ${endpoint}:`, "WatchlistService.getCurrentPrice", { endpoint, error });
        }
      }
      log.warn("All price endpoints failed, using template floor price fallback", "WatchlistService.getCurrentPrice");
      return await this.fetchTemplateFloorPrice(assetId);
    } catch (error) {
      ErrorMessageService.logError("WatchlistService.getCurrentPrice", error, { assetId });
      const item = this.watchlist.find((w) => w.nft.asset_id === assetId);
      return item?.lastPrice || 0;
    }
  }
  // Fetch price from AtomicHub marketplace
  async fetchAtomicHubPrice(assetId) {
    const endpoint = "atomichub";
    try {
      const { apiService: apiService2 } = await __vitePreload(async () => {
        const { apiService: apiService3 } = await Promise.resolve().then(() => api);
        return { apiService: apiService3 };
      }, true ? void 0 : void 0);
      const url = `${apiService2.atomicMarketAPI}/atomicmarket/v1/sales?state=1&asset_id=${assetId}&limit=1`;
      const response = await apiService2.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data && data.data.length > 0) {
        const sale = data.data[0];
        if (sale.price && sale.price.amount) {
          this.recordEndpointSuccess(endpoint);
          return parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision || 8);
        }
      }
      return 0;
    } catch (error) {
      this.recordEndpointFailure(endpoint);
      ErrorMessageService.logError("WatchlistService.fetchAtomicHubPrice", error, {
        assetId,
        endpoint,
        failureCount: this.endpointFailures[endpoint]?.count || 0
      });
      return 0;
    }
  }
  // Fetch price from NeftyBlocks marketplace
  async fetchNeftyBlocksPrice(assetId) {
    const endpoint = "neftyblocks";
    try {
      const { apiService: apiService2 } = await __vitePreload(async () => {
        const { apiService: apiService3 } = await Promise.resolve().then(() => api);
        return { apiService: apiService3 };
      }, true ? void 0 : void 0);
      const url = `https://aa-wax-public1.neftyblocks.com/atomicmarket/v1/sales?state=1&asset_id=${assetId}&limit=1`;
      const response = await apiService2.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data && data.data.length > 0) {
        const sale = data.data[0];
        if (sale.price && sale.price.amount) {
          this.recordEndpointSuccess(endpoint);
          return parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision || 8);
        }
      }
      return 0;
    } catch (error) {
      this.recordEndpointFailure(endpoint);
      ErrorMessageService.logError("WatchlistService.fetchNeftyBlocksPrice", error, {
        assetId,
        endpoint,
        failureCount: this.endpointFailures[endpoint]?.count || 0
      });
      return 0;
    }
  }
  // Fetch template floor price as fallback
  async fetchTemplateFloorPrice(assetId) {
    try {
      const { apiService: apiService2 } = await __vitePreload(async () => {
        const { apiService: apiService3 } = await Promise.resolve().then(() => api);
        return { apiService: apiService3 };
      }, true ? void 0 : void 0);
      const assetUrl = `${apiService2.atomicAssetsAPI}/atomicassets/v1/assets/${assetId}`;
      const assetResponse = await apiService2.fetchWithRetry(assetUrl);
      const assetData = await assetResponse.json();
      if (assetData.success && assetData.data && assetData.data.template) {
        const templateId = assetData.data.template.template_id;
        const floorUrl = `${apiService2.atomicMarketAPI}/atomicmarket/v1/sales?state=1&template_id=${templateId}&sort=price&order=asc&limit=1`;
        const floorResponse = await apiService2.fetchWithRetry(floorUrl);
        const floorData = await floorResponse.json();
        if (floorData.success && floorData.data && floorData.data.length > 0) {
          const sale = floorData.data[0];
          if (sale.price && sale.price.amount) {
            return parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision || 8);
          }
        }
      }
      return 0;
    } catch {
      return 0;
    }
  }
  // Check if alert condition is met
  async checkAlertCondition(item, alert, currentPrice) {
    const now = Date.now();
    const cooldownPeriod = 60 * 60 * 1e3;
    if (alert.lastTriggered && now - alert.lastTriggered < cooldownPeriod) {
      return;
    }
    let shouldTrigger = false;
    let message = "";
    switch (alert.alertType) {
      case "below":
        if (currentPrice <= alert.targetPrice) {
          shouldTrigger = true;
          message = `${item.nft.name} price dropped to ${currentPrice.toFixed(2)} WAX (target: ${alert.targetPrice} WAX)`;
        }
        break;
      case "above":
        if (currentPrice >= alert.targetPrice) {
          shouldTrigger = true;
          message = `${item.nft.name} price rose to ${currentPrice.toFixed(2)} WAX (target: ${alert.targetPrice} WAX)`;
        }
        break;
      case "any": {
        const changePercent = Math.abs(item.priceChange || 0);
        if (changePercent >= 5) {
          shouldTrigger = true;
          const direction = (item.priceChange || 0) > 0 ? "increased" : "decreased";
          message = `${item.nft.name} price ${direction} by ${changePercent.toFixed(1)}% to ${currentPrice.toFixed(2)} WAX`;
        }
        break;
      }
    }
    if (shouldTrigger) {
      await this.triggerAlert(item, message);
      alert.lastTriggered = now;
    }
  }
  // Trigger alert notification
  async triggerAlert(item, message) {
    if (this.notifications.browser && "Notification" in window && Notification.permission === "granted") {
      new Notification("Price Alert - Pixel Journey", {
        body: message,
        icon: item.nft.image || "/logo.png",
        tag: `price-alert-${item.nft.asset_id}`,
        requireInteraction: true
      });
    }
    if (this.notifications.sound) {
      this.playNotificationSound();
    }
    try {
      await pushNotificationService.sendPriceAlert(
        item.nft.name,
        `${item.lastPrice} WAX`,
        message
      );
    } catch (error) {
      log.warn("Failed to send push notification for price alert:", "WatchlistService.sendPriceAlert", { error });
    }
    window.dispatchEvent(new CustomEvent("priceAlert", {
      detail: { item, message }
    }));
  }
  // Play notification sound
  playNotificationSound() {
    try {
      const audio = new Audio("/notification.mp3");
      audio.volume = 0.3;
      audio.play().catch((error) => {
        log.debug("Could not play notification sound:", "WatchlistService.playNotificationSound", { error });
      });
    } catch (error) {
      log.debug("Notification sound not available:", "WatchlistService.playNotificationSound", { error });
    }
  }
  // Get watchlist statistics
  getWatchlistStats() {
    const totalItems = this.watchlist.length;
    const activeAlerts = Object.keys(this.priceAlerts).filter(
      (key) => this.priceAlerts[key].enabled
    ).length;
    const priceChanges = this.watchlist.map((item) => item.priceChange || 0).filter((change) => change !== 0);
    const averagePriceChange = priceChanges.length > 0 ? priceChanges.reduce((sum, change) => sum + change, 0) / priceChanges.length : 0;
    return {
      totalItems,
      activeAlerts,
      averagePriceChange
    };
  }
  // Clear all watchlist data
  clearWatchlist() {
    this.watchlist = [];
    this.priceAlerts = {};
    this.saveToStorage();
  }
  // Subscribe to watchlist changes
  subscribe(callback) {
    this.listeners.push(callback);
    return () => {
      const index = this.listeners.indexOf(callback);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }
  // Export watchlist data
  exportWatchlist() {
    return JSON.stringify({
      watchlist: this.watchlist,
      priceAlerts: this.priceAlerts,
      exportedAt: Date.now()
    }, null, 2);
  }
  // Import watchlist data
  importWatchlist(data) {
    try {
      const parsed = JSON.parse(data);
      if (parsed.watchlist && Array.isArray(parsed.watchlist)) {
        this.watchlist = parsed.watchlist;
        this.priceAlerts = parsed.priceAlerts || {};
        this.saveToStorage();
        return true;
      }
      return false;
    } catch (error) {
      ErrorMessageService.logError("WatchlistService.importWatchlist", error, { dataLength: data.length });
      return false;
    }
  }
}
const watchlistService = new WatchlistService();
function add(number1, number2) {
  var _a;
  if (number2 === void 0) {
    number2 = "0";
  }
  var neg = 0, ind = -1;
  if (number1[0] == "-") {
    number1 = number1.substring(1);
    if (!testZero(number1)) {
      neg++;
      ind = 1;
      number1.length;
    }
  }
  if (number2[0] == "-") {
    number2 = number2.substring(1);
    if (!testZero(number2)) {
      neg++;
      ind = 2;
      number2.length;
    }
  }
  number1 = trim(number1);
  number2 = trim(number2);
  _a = pad(trim(number1), trim(number2)), number1 = _a[0], number2 = _a[1];
  if (neg == 1) {
    if (ind === 1)
      number1 = compliment(number1);
    else if (ind === 2)
      number2 = compliment(number2);
  }
  var res = addCore(number1, number2);
  if (!neg)
    return trim(res);
  else if (neg == 2)
    return "-" + trim(res);
  else {
    if (number1.length < res.length)
      return trim(res.substring(1));
    else
      return "-" + trim(compliment(res));
  }
}
function compliment(number) {
  if (testZero(number)) {
    return number;
  }
  var s = "", l = number.length, dec = number.split(".")[1], ld = dec ? dec.length : 0;
  for (var i = 0; i < l; i++) {
    if (number[i] >= "0" && number[i] <= "9")
      s += 9 - parseInt(number[i]);
    else
      s += number[i];
  }
  var one = ld > 0 ? "0." + new Array(ld).join("0") + "1" : "1";
  return addCore(s, one);
}
function trim(number) {
  var parts = number.split(".");
  if (!parts[0])
    parts[0] = "0";
  while (parts[0][0] == "0" && parts[0].length > 1)
    parts[0] = parts[0].substring(1);
  return parts[0] + (parts[1] ? "." + parts[1] : "");
}
function pad(number1, number2) {
  var parts1 = number1.split("."), parts2 = number2.split(".");
  var length1 = parts1[0].length, length2 = parts2[0].length;
  if (length1 > length2) {
    parts2[0] = new Array(Math.abs(length1 - length2) + 1).join("0") + (parts2[0] ? parts2[0] : "");
  } else {
    parts1[0] = new Array(Math.abs(length1 - length2) + 1).join("0") + (parts1[0] ? parts1[0] : "");
  }
  length1 = parts1[1] ? parts1[1].length : 0, length2 = parts2[1] ? parts2[1].length : 0;
  if (length1 || length2) {
    if (length1 > length2) {
      parts2[1] = (parts2[1] ? parts2[1] : "") + new Array(Math.abs(length1 - length2) + 1).join("0");
    } else {
      parts1[1] = (parts1[1] ? parts1[1] : "") + new Array(Math.abs(length1 - length2) + 1).join("0");
    }
  }
  number1 = parts1[0] + (parts1[1] ? "." + parts1[1] : "");
  number2 = parts2[0] + (parts2[1] ? "." + parts2[1] : "");
  return [number1, number2];
}
function addCore(number1, number2) {
  var _a;
  _a = pad(number1, number2), number1 = _a[0], number2 = _a[1];
  var sum = "", carry = 0;
  for (var i = number1.length - 1; i >= 0; i--) {
    if (number1[i] === ".") {
      sum = "." + sum;
      continue;
    }
    var temp = parseInt(number1[i]) + parseInt(number2[i]) + carry;
    sum = temp % 10 + sum;
    carry = Math.floor(temp / 10);
  }
  return carry ? carry.toString() + sum : sum;
}
function testZero(number) {
  return /^0[0]*[.]{0,1}[0]*$/.test(number);
}
function abs(n) {
  if (typeof n == "number" || typeof n == "bigint")
    n = n.toString();
  if (n[0] == "-")
    return n.substring(1);
  return n;
}
var RoundingModes;
(function(RoundingModes2) {
  RoundingModes2[RoundingModes2["CEILING"] = 0] = "CEILING";
  RoundingModes2[RoundingModes2["DOWN"] = 1] = "DOWN";
  RoundingModes2[RoundingModes2["FLOOR"] = 2] = "FLOOR";
  RoundingModes2[RoundingModes2["HALF_DOWN"] = 3] = "HALF_DOWN";
  RoundingModes2[RoundingModes2["HALF_EVEN"] = 4] = "HALF_EVEN";
  RoundingModes2[RoundingModes2["HALF_UP"] = 5] = "HALF_UP";
  RoundingModes2[RoundingModes2["UNNECESSARY"] = 6] = "UNNECESSARY";
  RoundingModes2[RoundingModes2["UP"] = 7] = "UP";
})(RoundingModes || (RoundingModes = {}));
function roundOff(input, n, mode) {
  if (n === void 0) {
    n = 0;
  }
  if (mode === void 0) {
    mode = RoundingModes.HALF_EVEN;
  }
  if (mode === RoundingModes.UNNECESSARY) {
    throw new Error("UNNECESSARY Rounding Mode has not yet been implemented");
  }
  if (typeof input == "number" || typeof input == "bigint")
    input = input.toString();
  var neg = false;
  if (input[0] === "-") {
    neg = true;
    input = input.substring(1);
  }
  var parts = input.split("."), partInt = parts[0], partDec = parts[1];
  if (n < 0) {
    n = -n;
    if (partInt.length <= n)
      return "0";
    else {
      var prefix = partInt.substr(0, partInt.length - n);
      input = prefix + "." + partInt.substr(partInt.length - n) + partDec;
      prefix = roundOff(input, 0, mode);
      return (neg ? "-" : "") + prefix + new Array(n + 1).join("0");
    }
  }
  if (n == 0) {
    partInt.length;
    if (greaterThanFive(parts[1], partInt, neg, mode)) {
      partInt = increment(partInt);
    }
    return (neg && parseInt(partInt) ? "-" : "") + partInt;
  }
  if (!parts[1]) {
    return (neg ? "-" : "") + partInt + "." + new Array(n + 1).join("0");
  } else if (parts[1].length < n) {
    return (neg ? "-" : "") + partInt + "." + parts[1] + new Array(n - parts[1].length + 1).join("0");
  }
  partDec = parts[1].substring(0, n);
  var rem = parts[1].substring(n);
  if (rem && greaterThanFive(rem, partDec, neg, mode)) {
    partDec = increment(partDec);
    if (partDec.length > n) {
      return (neg ? "-" : "") + increment(partInt, parseInt(partDec[0])) + "." + partDec.substring(1);
    }
  }
  return (neg && (parseInt(partInt) || parseInt(partDec)) ? "-" : "") + partInt + "." + partDec;
}
function greaterThanFive(part, pre, neg, mode) {
  if (!part || part === new Array(part.length + 1).join("0"))
    return false;
  if (mode === RoundingModes.DOWN || !neg && mode === RoundingModes.FLOOR || neg && mode === RoundingModes.CEILING)
    return false;
  if (mode === RoundingModes.UP || neg && mode === RoundingModes.FLOOR || !neg && mode === RoundingModes.CEILING)
    return true;
  var five = "5" + new Array(part.length).join("0");
  if (part > five)
    return true;
  else if (part < five)
    return false;
  switch (mode) {
    case RoundingModes.HALF_DOWN:
      return false;
    case RoundingModes.HALF_UP:
      return true;
    case RoundingModes.HALF_EVEN:
    default:
      return parseInt(pre[pre.length - 1]) % 2 == 1;
  }
}
function increment(part, c) {
  if (c === void 0) {
    c = 0;
  }
  if (!c)
    c = 1;
  if (typeof part == "number")
    part.toString();
  var l = part.length - 1, s = "";
  for (var i = l; i >= 0; i--) {
    var x = parseInt(part[i]) + c;
    if (x == 10) {
      c = 1;
      x = 0;
    } else {
      c = 0;
    }
    s += x;
  }
  if (c)
    s += c;
  return s.split("").reverse().join("");
}
function stripTrailingZero(number) {
  var isNegative = number[0] === "-";
  if (isNegative) {
    number = number.substr(1);
  }
  while (number[0] == "0") {
    number = number.substr(1);
  }
  if (number.indexOf(".") != -1) {
    while (number[number.length - 1] == "0") {
      number = number.substr(0, number.length - 1);
    }
  }
  if (number == "" || number == ".") {
    number = "0";
  } else if (number[number.length - 1] == ".") {
    number = number.substr(0, number.length - 1);
  }
  if (number[0] == ".") {
    number = "0" + number;
  }
  if (isNegative && number != "0") {
    number = "-" + number;
  }
  return number;
}
function multiply(number1, number2) {
  number1 = number1.toString();
  number2 = number2.toString();
  var negative = 0;
  if (number1[0] == "-") {
    negative++;
    number1 = number1.substr(1);
  }
  if (number2[0] == "-") {
    negative++;
    number2 = number2.substr(1);
  }
  number1 = stripTrailingZero(number1);
  number2 = stripTrailingZero(number2);
  var decimalLength1 = 0;
  var decimalLength2 = 0;
  if (number1.indexOf(".") != -1) {
    decimalLength1 = number1.length - number1.indexOf(".") - 1;
  }
  if (number2.indexOf(".") != -1) {
    decimalLength2 = number2.length - number2.indexOf(".") - 1;
  }
  var decimalLength = decimalLength1 + decimalLength2;
  number1 = stripTrailingZero(number1.replace(".", ""));
  number2 = stripTrailingZero(number2.replace(".", ""));
  if (number1.length < number2.length) {
    var temp = number1;
    number1 = number2;
    number2 = temp;
  }
  if (number2 == "0") {
    return "0";
  }
  var length = number2.length;
  var carry = 0;
  var positionVector = [];
  var currentPosition = length - 1;
  var result = "";
  for (var i = 0; i < length; i++) {
    positionVector[i] = number1.length - 1;
  }
  for (var i = 0; i < 2 * number1.length; i++) {
    var sum = 0;
    for (var j = number2.length - 1; j >= currentPosition && j >= 0; j--) {
      if (positionVector[j] > -1 && positionVector[j] < number1.length) {
        sum += parseInt(number1[positionVector[j]--]) * parseInt(number2[j]);
      }
    }
    sum += carry;
    carry = Math.floor(sum / 10);
    result = sum % 10 + result;
    currentPosition--;
  }
  result = stripTrailingZero(adjustDecimal(result, decimalLength));
  if (negative == 1) {
    result = "-" + result;
  }
  return result;
}
function adjustDecimal(number, decimal) {
  if (decimal == 0)
    return number;
  else {
    number = decimal >= number.length ? new Array(decimal - number.length + 1).join("0") + number : number;
    return number.substr(0, number.length - decimal) + "." + number.substr(number.length - decimal, decimal);
  }
}
function divide(dividend, divisor, precission, mode) {
  if (precission === void 0) {
    precission = 8;
  }
  if (mode === void 0) {
    mode = RoundingModes.HALF_EVEN;
  }
  if (divisor == 0) {
    throw new Error("Cannot divide by 0");
  }
  dividend = dividend.toString();
  divisor = divisor.toString();
  dividend = dividend.replace(/(\.\d*?[1-9])0+$/g, "$1").replace(/\.0+$/, "");
  divisor = divisor.replace(/(\.\d*?[1-9])0+$/g, "$1").replace(/\.0+$/, "");
  if (dividend == 0)
    return "0";
  var neg = 0;
  if (divisor[0] == "-") {
    divisor = divisor.substring(1);
    neg++;
  }
  if (dividend[0] == "-") {
    dividend = dividend.substring(1);
    neg++;
  }
  var pt_dvsr = divisor.indexOf(".") > 0 ? divisor.length - divisor.indexOf(".") - 1 : -1;
  divisor = trim(divisor.replace(".", ""));
  if (pt_dvsr >= 0) {
    var pt_dvnd = dividend.indexOf(".") > 0 ? dividend.length - dividend.indexOf(".") - 1 : -1;
    if (pt_dvnd == -1) {
      dividend = trim(dividend + new Array(pt_dvsr + 1).join("0"));
    } else {
      if (pt_dvsr > pt_dvnd) {
        dividend = dividend.replace(".", "");
        dividend = trim(dividend + new Array(pt_dvsr - pt_dvnd + 1).join("0"));
      } else if (pt_dvsr < pt_dvnd) {
        dividend = dividend.replace(".", "");
        var loc = dividend.length - pt_dvnd + pt_dvsr;
        dividend = trim(dividend.substring(0, loc) + "." + dividend.substring(loc));
      } else if (pt_dvsr == pt_dvnd) {
        dividend = trim(dividend.replace(".", ""));
      }
    }
  }
  var prec = 0, dl = divisor.length, quotent = "";
  var dvnd = dividend.indexOf(".") > -1 && dividend.indexOf(".") < dl ? dividend.substring(0, dl + 1) : dividend.substring(0, dl);
  dividend = dividend.indexOf(".") > -1 && dividend.indexOf(".") < dl ? dividend.substring(dl + 1) : dividend.substring(dl);
  if (dvnd.indexOf(".") > -1) {
    var shift = dvnd.length - dvnd.indexOf(".") - 1;
    dvnd = dvnd.replace(".", "");
    if (dl > dvnd.length) {
      shift += dl - dvnd.length;
      dvnd = dvnd + new Array(dl - dvnd.length + 1).join("0");
    }
    prec = shift;
    quotent = "0." + new Array(shift).join("0");
  }
  precission = precission + 2;
  while (prec <= precission) {
    var qt = 0;
    while (parseInt(dvnd) >= parseInt(divisor)) {
      dvnd = add(dvnd, "-" + divisor);
      qt++;
    }
    quotent += qt;
    if (!dividend) {
      if (!prec)
        quotent += ".";
      prec++;
      dvnd = dvnd + "0";
    } else {
      if (dividend[0] == ".") {
        quotent += ".";
        prec++;
        dividend = dividend.substring(1);
      }
      dvnd = dvnd + dividend.substring(0, 1);
      dividend = dividend.substring(1);
    }
  }
  return (neg == 1 ? "-" : "") + trim(roundOff(quotent, precission - 2, mode));
}
function subtract(number1, number2) {
  number1 = number1.toString();
  number2 = number2.toString();
  number2 = negate(number2);
  return add(number1, number2);
}
function negate(number) {
  if (number[0] == "-") {
    number = number.substr(1);
  } else {
    number = "-" + number;
  }
  return number;
}
function modulus(dividend, divisor) {
  if (divisor == 0) {
    throw new Error("Cannot divide by 0");
  }
  dividend = dividend.toString();
  divisor = divisor.toString();
  validate(dividend);
  validate(divisor);
  var sign = "";
  if (dividend[0] == "-") {
    sign = "-";
    dividend = dividend.substr(1);
  }
  if (divisor[0] == "-") {
    divisor = divisor.substr(1);
  }
  var result = subtract(dividend, multiply(divisor, roundOff(divide(dividend, divisor), 0, RoundingModes.FLOOR)));
  return sign + result;
}
function validate(oparand) {
  if (oparand.indexOf(".") != -1) {
    throw new Error("Modulus of non-integers not supported");
  }
}
function compareTo(number1, number2) {
  var _a, _b;
  var negative = false;
  _a = [number1, number2].map(function(n) {
    return stripTrailingZero(n);
  }), number1 = _a[0], number2 = _a[1];
  if (number1[0] == "-" && number2[0] != "-") {
    return -1;
  } else if (number1[0] != "-" && number2[0] == "-") {
    return 1;
  } else if (number1[0] == "-" && number2[0] == "-") {
    number1 = number1.substr(1);
    number2 = number2.substr(1);
    negative = true;
  }
  _b = pad(number1, number2), number1 = _b[0], number2 = _b[1];
  if (number1.localeCompare(number2) == 0) {
    return 0;
  }
  for (var i = 0; i < number1.length; i++) {
    if (number1[i] == number2[i]) {
      continue;
    } else if (number1[i] > number2[i]) {
      if (negative) {
        return -1;
      } else {
        return 1;
      }
    } else {
      if (negative) {
        return 1;
      } else {
        return -1;
      }
    }
  }
  return 0;
}
var bigDecimal = (
  /** @class */
  (function() {
    function bigDecimal2(number) {
      if (number === void 0) {
        number = "0";
      }
      this.value = bigDecimal2.validate(number);
    }
    bigDecimal2.validate = function(number) {
      if (number) {
        number = number.toString();
        if (isNaN(number))
          throw Error("Parameter is not a number: " + number);
        if (number[0] == "+")
          number = number.substring(1);
      } else
        number = "0";
      if (number.startsWith("."))
        number = "0" + number;
      else if (number.startsWith("-."))
        number = "-0" + number.substr(1);
      if (/e/i.test(number)) {
        var _a = number.split(/[eE]/), mantisa = _a[0], exponent = _a[1];
        mantisa = trim(mantisa);
        var sign = "";
        if (mantisa[0] == "-") {
          sign = "-";
          mantisa = mantisa.substring(1);
        }
        if (mantisa.indexOf(".") >= 0) {
          exponent = parseInt(exponent) + mantisa.indexOf(".");
          mantisa = mantisa.replace(".", "");
        } else {
          exponent = parseInt(exponent) + mantisa.length;
        }
        if (mantisa.length < exponent) {
          number = sign + mantisa + new Array(exponent - mantisa.length + 1).join("0");
        } else if (mantisa.length >= exponent && exponent > 0) {
          number = sign + trim(mantisa.substring(0, exponent)) + (mantisa.length > exponent ? "." + mantisa.substring(exponent) : "");
        } else {
          number = sign + "0." + new Array(-exponent + 1).join("0") + mantisa;
        }
      }
      return number;
    };
    bigDecimal2.prototype.getValue = function() {
      return this.value;
    };
    bigDecimal2.prototype.setValue = function(num) {
      this.value = bigDecimal2.validate(num);
    };
    bigDecimal2.getPrettyValue = function(number, digits, separator) {
      if (digits === void 0) {
        digits = 3;
      }
      if (separator === void 0) {
        separator = ",";
      }
      number = bigDecimal2.validate(number);
      var neg = number.charAt(0) == "-";
      if (neg)
        number = number.substring(1);
      var len = number.indexOf(".");
      len = len > 0 ? len : number.length;
      var temp = "";
      for (var i = len; i > 0; ) {
        if (i < digits) {
          digits = i;
          i = 0;
        } else
          i -= digits;
        temp = number.substring(i, i + digits) + (i < len - digits && i >= 0 ? separator : "") + temp;
      }
      return (neg ? "-" : "") + temp + number.substring(len);
    };
    bigDecimal2.prototype.getPrettyValue = function(digits, separator) {
      if (digits === void 0) {
        digits = 3;
      }
      if (separator === void 0) {
        separator = ",";
      }
      return bigDecimal2.getPrettyValue(this.value, digits, separator);
    };
    bigDecimal2.round = function(number, precision, mode) {
      if (precision === void 0) {
        precision = 0;
      }
      if (mode === void 0) {
        mode = RoundingModes.HALF_EVEN;
      }
      number = bigDecimal2.validate(number);
      if (isNaN(precision))
        throw Error("Precision is not a number: " + precision);
      return roundOff(number, precision, mode);
    };
    bigDecimal2.prototype.round = function(precision, mode) {
      if (precision === void 0) {
        precision = 0;
      }
      if (mode === void 0) {
        mode = RoundingModes.HALF_EVEN;
      }
      if (isNaN(precision))
        throw Error("Precision is not a number: " + precision);
      return new bigDecimal2(roundOff(this.value, precision, mode));
    };
    bigDecimal2.abs = function(number) {
      number = bigDecimal2.validate(number);
      return abs(number);
    };
    bigDecimal2.prototype.abs = function() {
      return new bigDecimal2(abs(this.value));
    };
    bigDecimal2.floor = function(number) {
      number = bigDecimal2.validate(number);
      if (number.indexOf(".") === -1)
        return number;
      return bigDecimal2.round(number, 0, RoundingModes.FLOOR);
    };
    bigDecimal2.prototype.floor = function() {
      if (this.value.indexOf(".") === -1)
        return new bigDecimal2(this.value);
      return new bigDecimal2(this.value).round(0, RoundingModes.FLOOR);
    };
    bigDecimal2.ceil = function(number) {
      number = bigDecimal2.validate(number);
      if (number.indexOf(".") === -1)
        return number;
      return bigDecimal2.round(number, 0, RoundingModes.CEILING);
    };
    bigDecimal2.prototype.ceil = function() {
      if (this.value.indexOf(".") === -1)
        return new bigDecimal2(this.value);
      return new bigDecimal2(this.value).round(0, RoundingModes.CEILING);
    };
    bigDecimal2.add = function(number1, number2) {
      number1 = bigDecimal2.validate(number1);
      number2 = bigDecimal2.validate(number2);
      return add(number1, number2);
    };
    bigDecimal2.prototype.add = function(number) {
      return new bigDecimal2(add(this.value, number.getValue()));
    };
    bigDecimal2.subtract = function(number1, number2) {
      number1 = bigDecimal2.validate(number1);
      number2 = bigDecimal2.validate(number2);
      return subtract(number1, number2);
    };
    bigDecimal2.prototype.subtract = function(number) {
      return new bigDecimal2(subtract(this.value, number.getValue()));
    };
    bigDecimal2.multiply = function(number1, number2) {
      number1 = bigDecimal2.validate(number1);
      number2 = bigDecimal2.validate(number2);
      return multiply(number1, number2);
    };
    bigDecimal2.prototype.multiply = function(number) {
      return new bigDecimal2(multiply(this.value, number.getValue()));
    };
    bigDecimal2.divide = function(number1, number2, precision, mode) {
      number1 = bigDecimal2.validate(number1);
      number2 = bigDecimal2.validate(number2);
      return divide(number1, number2, precision, mode);
    };
    bigDecimal2.prototype.divide = function(number, precision, mode) {
      return new bigDecimal2(divide(this.value, number.getValue(), precision, mode));
    };
    bigDecimal2.modulus = function(number1, number2) {
      number1 = bigDecimal2.validate(number1);
      number2 = bigDecimal2.validate(number2);
      return modulus(number1, number2);
    };
    bigDecimal2.prototype.modulus = function(number) {
      return new bigDecimal2(modulus(this.value, number.getValue()));
    };
    bigDecimal2.compareTo = function(number1, number2) {
      number1 = bigDecimal2.validate(number1);
      number2 = bigDecimal2.validate(number2);
      return compareTo(number1, number2);
    };
    bigDecimal2.prototype.compareTo = function(number) {
      return compareTo(this.value, number.getValue());
    };
    bigDecimal2.negate = function(number) {
      number = bigDecimal2.validate(number);
      return negate(number);
    };
    bigDecimal2.prototype.negate = function() {
      return new bigDecimal2(negate(this.value));
    };
    bigDecimal2.stripTrailingZero = function(number) {
      number = bigDecimal2.validate(number);
      return stripTrailingZero(number);
    };
    bigDecimal2.prototype.stripTrailingZero = function() {
      return new bigDecimal2(stripTrailingZero(this.value));
    };
    bigDecimal2.RoundingModes = RoundingModes;
    return bigDecimal2;
  })()
);
/**
 * @wharfkit/resources v1.5.0
 * https://github.com/wharfkit/resources
 *
 * @license
 * Copyright (c) 2021 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
class PowerUpStateResource extends Struct {
  constructor() {
    super(...arguments);
    this.default_block_cpu_limit = UInt64.from(2e5);
    this.default_block_net_limit = UInt64.from(1048576e3);
  }
  // Get the current number of allocated units (shift from REX -> PowerUp)
  get allocated() {
    return 1 - Number(this.weight_ratio.dividing(this.target_weight_ratio)) / 100;
  }
  // Get the current percentage of reserved units
  get reserved() {
    return this.utilization.dividing(this.weight);
  }
  // Get the symbol definition for the token
  get symbol() {
    return this.min_price.symbol;
  }
  // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L358
  utilization_increase(frac) {
    const base = intToBigDecimal(frac);
    const weight = intToBigDecimal(this.weight);
    const multiplier2 = intToBigDecimal(Math.pow(10, 15));
    return UInt128.from(base.multiply(weight).divide(multiplier2, 15).ceil().getValue());
  }
  // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L284-L298
  price_function(utilization) {
    const { weight } = this;
    let price = this.min_price.value;
    const new_exponent = Number(this.exponent) - 1;
    if (new_exponent <= 0) {
      return this.max_price.value;
    } else {
      const util_weight = intToBigDecimal(utilization).divide(intToBigDecimal(weight), 18);
      const difference = this.max_price.value - this.min_price.value;
      price += difference * Math.pow(Number(util_weight.getValue()), new_exponent);
    }
    return price;
  }
  // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L274-L280
  price_integral_delta(start_utilization, end_utilization) {
    const difference = Asset.fromUnits(this.max_price.units.subtracting(this.min_price.units), this.symbol);
    const coefficient = difference.value / this.exponent.value;
    const start_u = Number(start_utilization.dividing(this.weight));
    const end_u = Number(end_utilization.dividing(this.weight));
    const delta = this.min_price.value * end_u - this.min_price.value * start_u + coefficient * Math.pow(end_u, this.exponent.value) - coefficient * Math.pow(start_u, this.exponent.value);
    return delta;
  }
  // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L262-L315
  fee(utilization_increase, adjusted_utilization) {
    const { utilization, weight } = this;
    let start_utilization = Int64.from(utilization);
    const end_utilization = start_utilization.adding(utilization_increase);
    let fee2 = 0;
    if (start_utilization.lt(adjusted_utilization)) {
      const min = Math.min(Number(utilization_increase), Number(adjusted_utilization.subtracting(start_utilization)));
      fee2 += Number(intToBigDecimal(this.price_function(adjusted_utilization) * min).divide(intToBigDecimal(weight)).getValue());
      start_utilization = adjusted_utilization;
    }
    if (start_utilization.lt(end_utilization)) {
      fee2 += this.price_integral_delta(start_utilization, end_utilization);
    }
    return fee2;
  }
  // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L105-L117
  determine_adjusted_utilization(options) {
    const { decay_secs, utilization, utilization_timestamp } = this;
    let { adjusted_utilization } = this;
    if (utilization.lt(adjusted_utilization)) {
      const ts = options && options.timestamp ? options.timestamp : /* @__PURE__ */ new Date();
      const now = TimePointSec.from(ts).toMilliseconds() / 1e3;
      const diff = adjusted_utilization.subtracting(utilization).toNumber();
      let delta = diff * Math.exp(-(now - utilization_timestamp.toMilliseconds()) / Number(decay_secs));
      delta = Math.min(Math.max(delta, 0), diff);
      adjusted_utilization = utilization.adding(delta);
    }
    return adjusted_utilization;
  }
}
__decorate([
  Struct.field("uint8")
], PowerUpStateResource.prototype, "version", void 0);
__decorate([
  Struct.field("int64")
], PowerUpStateResource.prototype, "weight", void 0);
__decorate([
  Struct.field("int64")
], PowerUpStateResource.prototype, "weight_ratio", void 0);
__decorate([
  Struct.field("int64")
], PowerUpStateResource.prototype, "assumed_stake_weight", void 0);
__decorate([
  Struct.field("int64")
], PowerUpStateResource.prototype, "initial_weight_ratio", void 0);
__decorate([
  Struct.field("int64")
], PowerUpStateResource.prototype, "target_weight_ratio", void 0);
__decorate([
  Struct.field("time_point_sec")
], PowerUpStateResource.prototype, "initial_timestamp", void 0);
__decorate([
  Struct.field("time_point_sec")
], PowerUpStateResource.prototype, "target_timestamp", void 0);
__decorate([
  Struct.field("float64")
], PowerUpStateResource.prototype, "exponent", void 0);
__decorate([
  Struct.field("uint32")
], PowerUpStateResource.prototype, "decay_secs", void 0);
__decorate([
  Struct.field("asset")
], PowerUpStateResource.prototype, "min_price", void 0);
__decorate([
  Struct.field("asset")
], PowerUpStateResource.prototype, "max_price", void 0);
__decorate([
  Struct.field("int64")
], PowerUpStateResource.prototype, "utilization", void 0);
__decorate([
  Struct.field("int64")
], PowerUpStateResource.prototype, "adjusted_utilization", void 0);
__decorate([
  Struct.field("time_point_sec")
], PowerUpStateResource.prototype, "utilization_timestamp", void 0);
let PowerUpStateResourceCPU = class PowerUpStateResourceCPU2 extends PowerUpStateResource {
  constructor() {
    super(...arguments);
    this.per_day = (options) => this.us_per_day(options);
    this.frac = (usage, us) => this.frac_by_us(usage, us);
    this.frac_by_ms = (usage, ms) => this.frac_by_us(usage, ms * 1e3);
    this.price_per = (usage, us = 1e3, options) => this.price_per_us(usage, us, options);
    this.price_per_ms = (usage, ms = 1, options) => this.price_per_us(usage, ms * 1e3, options);
  }
  // Return ms (milliseconds) per day
  ms_per_day(options) {
    return this.us_per_day(options) / 1e3;
  }
  // Return s (microseconds) per day
  us_per_day(options) {
    const limit = options && options.virtual_block_cpu_limit ? options.virtual_block_cpu_limit : this.default_block_cpu_limit;
    return Number(limit) * 2 * 60 * 60 * 24;
  }
  // Convert weight to s (microseconds)
  weight_to_us(sample, weight) {
    return UInt128.from(UInt128.from(weight).multiplying(Int64.from(sample)).dividing(BNPrecision, "ceil"));
  }
  // Convert s (microseconds) to weight
  us_to_weight(sample, us) {
    return Int64.from(us).multiplying(BNPrecision).dividing(sample, "floor");
  }
  // Frac generation by s (microseconds)
  frac_by_us(usage, us) {
    const precision = 15;
    const converted = intToBigDecimal(this.us_to_weight(usage.cpu, us));
    const current = intToBigDecimal(this.weight);
    const multiplier2 = intToBigDecimal(Math.pow(10, precision));
    const frac = converted.divide(current, precision).multiply(multiplier2);
    return Int64.from(frac.getValue());
  }
  // Price generation by s (microseconds)
  price_per_us(usage, us = 1e3, options) {
    const frac = UInt128.from(this.frac(usage, us));
    const utilization_increase = this.utilization_increase(frac);
    const adjusted_utilization = this.determine_adjusted_utilization(options);
    const fee2 = this.fee(utilization_increase, adjusted_utilization);
    const precision = Math.pow(10, this.max_price.symbol.precision);
    const price = fee2 * precision;
    const value = Math.ceil(price) / precision;
    const asset = Asset.fromFloat(fee2, this.symbol);
    if (price < 1) {
      throw new Error(`Price (${String(asset)}) for requested CPU amount (${us}us) below required precision, increase requested amount.`);
    }
    if (options && options.min_payment && options.min_payment.units.gt(asset.units)) {
      throw new Error(`Price (${String(asset)}) for requested CPU amount (${us}us) below minimum required payment (${String(options.min_payment)}), increase requested CPU amount.`);
    }
    return value;
  }
};
PowerUpStateResourceCPU = __decorate([
  Struct.type("powerupstateresourcecpu")
], PowerUpStateResourceCPU);
let PowerUpStateResourceNET = class PowerUpStateResourceNET2 extends PowerUpStateResource {
  constructor() {
    super(...arguments);
    this.per_day = (options) => this.bytes_per_day(options);
    this.frac = (usage, bytes) => this.frac_by_bytes(usage, bytes);
    this.frac_by_kb = (usage, kilobytes) => this.frac_by_bytes(usage, kilobytes * 1e3);
    this.price_per = (usage, bytes = 1e3, options) => this.price_per_byte(usage, bytes, options);
    this.price_per_kb = (usage, kilobytes = 1, options) => this.price_per_byte(usage, kilobytes * 1e3, options);
  }
  // Return kb per day
  kb_per_day(options) {
    return this.bytes_per_day(options) / 1e3;
  }
  // Return bytes per day
  bytes_per_day(options) {
    const limit = options && options.virtual_block_net_limit ? options.virtual_block_net_limit : this.default_block_net_limit;
    return Number(limit) * 2 * 60 * 60 * 24;
  }
  // Convert weight to bytes
  weight_to_bytes(sample, weight) {
    return UInt128.from(UInt128.from(weight).multiplying(Int64.from(sample)).dividing(BNPrecision, "ceil"));
  }
  // Convert bytes to weight
  bytes_to_weight(sample, bytes) {
    return Int64.from(bytes).multiplying(BNPrecision).dividing(Int64.from(sample), "floor");
  }
  // Frac generation by bytes
  frac_by_bytes(usage, bytes) {
    const precision = 15;
    const converted = intToBigDecimal(this.bytes_to_weight(usage.net, bytes));
    const current = intToBigDecimal(this.weight);
    const multiplier2 = intToBigDecimal(Math.pow(10, precision));
    const frac = converted.divide(current, precision).multiply(multiplier2);
    return Int64.from(frac.getValue());
  }
  // Price generation by bytes
  price_per_byte(usage, bytes = 1e3, options) {
    const frac = UInt128.from(this.frac(usage, bytes));
    const utilization_increase = this.utilization_increase(frac);
    const adjusted_utilization = this.determine_adjusted_utilization(options);
    const fee2 = this.fee(utilization_increase, adjusted_utilization);
    const precision = Math.pow(10, this.max_price.symbol.precision);
    const value = Math.ceil(fee2 * precision) / precision;
    return value;
  }
};
PowerUpStateResourceNET = __decorate([
  Struct.type("powerupstateresourcenet")
], PowerUpStateResourceNET);
let PowerUpState = class PowerUpState2 extends Struct {
};
__decorate([
  Struct.field("uint8")
], PowerUpState.prototype, "version", void 0);
__decorate([
  Struct.field(PowerUpStateResourceNET)
], PowerUpState.prototype, "net", void 0);
__decorate([
  Struct.field(PowerUpStateResourceCPU)
], PowerUpState.prototype, "cpu", void 0);
__decorate([
  Struct.field("uint32")
], PowerUpState.prototype, "powerup_days", void 0);
__decorate([
  Struct.field("asset")
], PowerUpState.prototype, "min_powerup_fee", void 0);
PowerUpState = __decorate([
  Struct.type("powerupstate")
], PowerUpState);
class PowerUpAPI {
  constructor(parent) {
    this.parent = parent;
  }
  async get_state() {
    const response = await this.parent.api.v1.chain.get_table_rows({
      code: "eosio",
      scope: "",
      table: "powup.state",
      type: PowerUpState
    });
    return response.rows[0];
  }
}
let Connector = class Connector2 extends Struct {
};
__decorate([
  Struct.field("asset")
], Connector.prototype, "balance", void 0);
__decorate([
  Struct.field("float64")
], Connector.prototype, "weight", void 0);
Connector = __decorate([
  Struct.type("connector")
], Connector);
let ExchangeState = class ExchangeState2 extends Struct {
};
__decorate([
  Struct.field("asset")
], ExchangeState.prototype, "supply", void 0);
__decorate([
  Struct.field(Connector)
], ExchangeState.prototype, "base", void 0);
__decorate([
  Struct.field(Connector)
], ExchangeState.prototype, "quote", void 0);
ExchangeState = __decorate([
  Struct.type("exchange_state")
], ExchangeState);
let RAMState = class RAMState2 extends ExchangeState {
  price_per(bytes) {
    const base = this.base.balance.units;
    const quote = this.quote.balance.units;
    return Asset.fromUnits(this.get_input(base, quote, Int64.from(bytes)), this.quote.balance.symbol);
  }
  price_per_kb(kilobytes) {
    return this.price_per(kilobytes * 1e3);
  }
  // Derived from https://github.com/EOSIO/eosio.contracts/blob/f6578c45c83ec60826e6a1eeb9ee71de85abe976/contracts/eosio.system/src/exchange_state.cpp#L96
  get_input(base, quote, value) {
    return quote.multiplying(value).dividing(base.subtracting(value), "ceil");
  }
};
RAMState = __decorate([
  Struct.type("ramstate")
], RAMState);
class RAMAPI {
  constructor(parent) {
    this.parent = parent;
  }
  async get_state() {
    const response = await this.parent.api.v1.chain.get_table_rows({
      code: "eosio",
      scope: "eosio",
      table: "rammarket",
      type: RAMState
    });
    return response.rows[0];
  }
}
let REXState = class REXState2 extends Struct {
  get reserved() {
    return Number(this.total_lent.units) / Number(this.total_lendable.units);
  }
  get symbol() {
    return this.total_lent.symbol;
  }
  get precision() {
    return this.total_lent.symbol.precision;
  }
  get value() {
    const lent = intToBigDecimal(this.total_lent.units);
    const unlent = intToBigDecimal(this.total_unlent.units);
    const rex = intToBigDecimal(this.total_rex.units);
    return Number(lent.add(unlent).divide(rex, 18).getValue());
  }
  exchange(amount) {
    const value = intToBigDecimal(amount.units);
    const lendable = intToBigDecimal(this.total_lendable.units);
    const rex = intToBigDecimal(this.total_rex.units);
    const tokens = value.multiply(lendable).divide(rex, this.precision);
    return Asset.fromUnits(Number(tokens.getValue()), this.symbol);
  }
  cpu_price_per_ms(sample, ms = 1) {
    return this.cpu_price_per_us(sample, ms * 1e3);
  }
  cpu_price_per_us(sample, us = 1e3) {
    return this.price_per(sample, us, sample.cpu);
  }
  net_price_per_kb(sample, kilobytes = 1) {
    return this.net_price_per_byte(sample, kilobytes * 1e3);
  }
  net_price_per_byte(sample, bytes = 1e3) {
    return this.price_per(sample, bytes, sample.net);
  }
  price_per(sample, unit = 1e3, usage = sample.cpu) {
    const tokens = Asset.fromUnits(1e4, this.symbol);
    const bancor = Number(tokens.units) / (this.total_rent.value / this.total_unlent.value);
    const unitPrice = bancor * (Number(usage) / BNPrecision);
    const perunit = Number(tokens.units) / unitPrice;
    const cost = perunit * unit;
    return cost / Math.pow(10, this.precision);
  }
};
__decorate([
  Struct.field("uint8")
], REXState.prototype, "version", void 0);
__decorate([
  Struct.field("asset")
], REXState.prototype, "total_lent", void 0);
__decorate([
  Struct.field("asset")
], REXState.prototype, "total_unlent", void 0);
__decorate([
  Struct.field("asset")
], REXState.prototype, "total_rent", void 0);
__decorate([
  Struct.field("asset")
], REXState.prototype, "total_lendable", void 0);
__decorate([
  Struct.field("asset")
], REXState.prototype, "total_rex", void 0);
__decorate([
  Struct.field("asset")
], REXState.prototype, "namebid_proceeds", void 0);
__decorate([
  Struct.field("uint64")
], REXState.prototype, "loan_num", void 0);
REXState = __decorate([
  Struct.type("rexstate")
], REXState);
class REXAPI {
  constructor(parent) {
    this.parent = parent;
  }
  async get_state() {
    const response = await this.parent.api.v1.chain.get_table_rows({
      code: "eosio",
      scope: "eosio",
      table: "rexpool",
      type: REXState
    });
    return response.rows[0];
  }
}
const BNPrecision = new BN(100 * 1e3 * 1e3);
class Resources {
  constructor(options) {
    this.sampleAccount = "greymassfuel";
    this.symbol = "4,EOS";
    this.v1 = {
      powerup: new PowerUpAPI(this),
      ram: new RAMAPI(this),
      rex: new REXAPI(this)
    };
    if (options.sampleAccount) {
      this.sampleAccount = options.sampleAccount;
    }
    if (options.symbol) {
      this.symbol = options.symbol;
    }
    if (options.api) {
      this.api = options.api;
    } else if (options.url) {
      this.api = new APIClient({ provider: new FetchProvider(options.url, options) });
    } else {
      throw new Error("Missing url or api client");
    }
  }
  async getSampledUsage() {
    const account = await this.api.v1.chain.get_account(this.sampleAccount);
    const us = UInt128.from(account.cpu_limit.max.value.mul(BNPrecision));
    const byte = UInt128.from(account.net_limit.max.value.mul(BNPrecision));
    const cpu_weight = UInt128.from(account.cpu_weight.value);
    const net_weight = UInt128.from(account.net_weight.value);
    return {
      account,
      cpu: divCeil(us.value, cpu_weight.value),
      net: divCeil(byte.value, net_weight.value)
    };
  }
}
Resources.__className = "Resources";
function divCeil(num, den) {
  let v = num.div(den);
  const zero = new BN(0);
  const one = new BN(1);
  if (num.mod(den).gt(zero) && v.gt(one)) {
    v = v.sub(one);
  }
  return UInt128.from(v);
}
function intToBigDecimal(value) {
  return new bigDecimal(String(value));
}
/**
 * @wharfkit/transact-plugin-autocorrect v1.4.0
 * https://github.com/wharfkit/transact-plugin-autocorrect
 *
 * @license
 * Copyright (c) 2021 FFF00 Agents AB & Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
function getException(response) {
  if (response.error) {
    return response.error;
  }
  if (response.processed.except) {
    return response.processed.except;
  }
  return null;
}
let Powerup = class Powerup2 extends Struct {
};
__decorate([
  Struct.field(Name)
], Powerup.prototype, "payer", void 0);
__decorate([
  Struct.field(Name)
], Powerup.prototype, "receiver", void 0);
__decorate([
  Struct.field(UInt32)
], Powerup.prototype, "days", void 0);
__decorate([
  Struct.field(Int64)
], Powerup.prototype, "net_frac", void 0);
__decorate([
  Struct.field(Int64)
], Powerup.prototype, "cpu_frac", void 0);
__decorate([
  Struct.field(Asset)
], Powerup.prototype, "max_payment", void 0);
Powerup = __decorate([
  Struct.type("powerup")
], Powerup);
let Buyrambytes = class Buyrambytes2 extends Struct {
};
__decorate([
  Struct.field(Name)
], Buyrambytes.prototype, "payer", void 0);
__decorate([
  Struct.field(Name)
], Buyrambytes.prototype, "receiver", void 0);
__decorate([
  Struct.field(UInt32)
], Buyrambytes.prototype, "bytes", void 0);
Buyrambytes = __decorate([
  Struct.type("buyrambytes")
], Buyrambytes);
var checking$3 = "Checking transaction";
var fee$3 = {
  title: "Accept Transaction Fee?",
  body: "Additional resources ({{resource}}) are required for your account to perform this transaction. Would you like to automatically purchase these resources from the network and proceed?",
  cost: "Cost of {{resource}}"
};
var resolving$3 = "Resolving transaction";
var en = {
  checking: checking$3,
  fee: fee$3,
  resolving: resolving$3
};
var checking$2 = " ";
var fee$2 = {
  title: "  ?",
  body: "     ({{resource}}) .       ?",
  cost: "{{resource}} "
};
var resolving$2 = " ";
var ko = {
  checking: checking$2,
  fee: fee$2,
  resolving: resolving$2
};
var checking$1 = "";
var fee$1 = {
  title: "",
  body: " {{resource}} ",
  cost: "{{resource}} "
};
var resolving$1 = "";
var zh_hans = {
  checking: checking$1,
  fee: fee$1,
  resolving: resolving$1
};
var checking = "";
var fee = {
  title: "",
  body: " {{resource}} ",
  cost: "{{resource}} "
};
var resolving = "";
var zh_hant = {
  checking,
  fee,
  resolving
};
var defaultTranslations = {
  en,
  ko,
  "zh-Hans": zh_hans,
  "zh-Hant": zh_hant
};
var ChainFeatures;
(function(ChainFeatures2) {
  ChainFeatures2[ChainFeatures2["BuyRAM"] = 0] = "BuyRAM";
  ChainFeatures2[ChainFeatures2["PowerUp"] = 1] = "PowerUp";
})(ChainFeatures || (ChainFeatures = {}));
const chains = {
  // EOS
  aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906: {
    features: [ChainFeatures.BuyRAM, ChainFeatures.PowerUp],
    sampleAccount: "eosio.reserv",
    symbol: Asset.Symbol.from("4,EOS")
  },
  // Jungle 4
  "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d": {
    features: [ChainFeatures.BuyRAM, ChainFeatures.PowerUp],
    sampleAccount: "eosio.reserv",
    symbol: Asset.Symbol.from("4,EOS")
  },
  // WAX
  "1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4": {
    features: [ChainFeatures.BuyRAM, ChainFeatures.PowerUp],
    sampleAccount: "boost.wax",
    symbol: Asset.Symbol.from("8,WAX")
  }
};
const multiplier = 1.5;
class TransactPluginAutoCorrect extends AbstractTransactPlugin {
  constructor() {
    super(...arguments);
    this.id = "transact-plugin-autocorrect";
    this.translations = defaultTranslations;
    this.sample = null;
    this.price = null;
    this.resources = [];
    this.iterations = 0;
  }
  register(context) {
    if (!context.ui) {
      throw new Error("The TransactPluginAutoCorrect plugin requires a UI to be present.");
    }
    context.addHook(TransactHookTypes.beforeSign, async (request, context2) => this.run(request, context2));
  }
  async run(request, context) {
    if (!context.ui) {
      return { request };
    }
    this.price = null;
    this.resources = [];
    this.iterations = 0;
    const t = context.ui.getTranslate(this.id);
    const checkingPromise = context.ui.prompt({
      title: t("checking", { default: "Checking transaction" }),
      body: "",
      elements: []
    }).catch((error) => {
      if (error) {
        throw error;
      }
      return { request };
    });
    const account = await context.client.v1.chain.get_account(context.permissionLevel.actor);
    const correctedPromise = this.correct(request, context, account);
    const modified = await Promise.race([checkingPromise, correctedPromise]);
    if (modified === request && !this.price) {
      return { request };
    }
    const resources = Array.from(new Set(this.resources)).join("/");
    return context.ui.prompt({
      title: t("fee.title", { default: "Accept Transaction Fee?" }),
      body: t("fee.body", {
        default: "Additional resources ({{resource}}) are required for your account to perform this transaction. Would you like to automatically purchase these resources from the network and proceed?",
        resource: resources
      }),
      elements: [
        {
          type: "asset",
          data: {
            label: t("fee.cost", {
              default: "Cost of {{resource}}",
              resource: resources
            }),
            value: this.price
          }
        },
        {
          type: "accept"
        }
      ]
    }).then(() => ({ request: modified })).catch((error) => {
      if (error) {
        throw error;
      }
      return { request };
    });
  }
  async correct(request, context, account) {
    this.iterations++;
    if (this.iterations > 3) {
      throw new Error("Too many iterations. Please report this bug if you see it.");
    }
    const config = chains[String(context.chain.id)];
    if (!config || !context.ui) {
      return request;
    }
    const resources = new Resources({
      api: context.client,
      sampleAccount: config.sampleAccount
    });
    const resolved = await context.resolve(request);
    return context.client.v1.chain.compute_transaction(resolved.transaction).then((response) => {
      const exception = getException(response);
      if (exception && exception.stack && typeof exception.stack[0] === "object") {
        switch (exception.name) {
          case "tx_net_usage_exceeded": {
            const { net_usage } = exception.stack[0].data;
            const needed = net_usage * multiplier;
            if (config.features.includes(ChainFeatures.PowerUp)) {
              return this.powerup(context, resolved, account, resources, 0, needed);
            }
            break;
          }
          case "tx_cpu_usage_exceeded": {
            const { billed, billable } = exception.stack[0].data;
            const needed = (billed - billable) * multiplier;
            if (config.features.includes(ChainFeatures.PowerUp)) {
              return this.powerup(context, resolved, account, resources, needed, 0);
            }
            break;
          }
          case "ram_usage_exceeded": {
            const { available, needs } = exception.stack[0].data;
            const needed = (needs - available) * multiplier;
            if (config.features.includes(ChainFeatures.BuyRAM)) {
              return this.buyram(context, resolved, account, resources, needed);
            }
            break;
          }
        }
      }
      return request;
    }).catch((response) => {
      if (response.error) {
        switch (response.error.name) {
          case "tx_net_usage_exceeded": {
            const [, net_usage] = response.error.details[0].message.match(/transaction net usage is too high: (\d+) > (\d+)/);
            const needed = Number(net_usage) * multiplier;
            if (config.features.includes(ChainFeatures.PowerUp)) {
              return this.powerup(context, resolved, account, resources, 0, needed);
            }
            break;
          }
          case "tx_cpu_usage_exceeded": {
            const [, cpu_usage] = response.error.details[0].message.match(/billed CPU time \((\d+) us\) is greater than the maximum billable CPU time for the transaction/);
            const needed = Number(cpu_usage) * multiplier;
            if (config.features.includes(ChainFeatures.PowerUp)) {
              return this.powerup(context, resolved, account, resources, needed, 0);
            }
            break;
          }
          case "ram_usage_exceeded": {
            const [, , needs, has] = response.error.details[0].message.match(/account (\w.+) has insufficient ram; needs (\d+) bytes has (\d+) bytes/);
            const needed = (Number(needs) - Number(has)) * multiplier + 2;
            if (config.features.includes(ChainFeatures.BuyRAM)) {
              return this.buyram(context, resolved, account, resources, needed);
            }
            break;
          }
          default: {
            console.log("unknown error", response);
            break;
          }
        }
      }
      return request;
    });
  }
  async buyram(context, resolved, account, resources, needed) {
    const config = chains[String(context.chain.id)];
    const ram = await resources.v1.ram.get_state();
    if (!this.sample) {
      this.sample = await resources.getSampledUsage();
    }
    const price = Asset.from(ram.price_per(needed).value, config.symbol);
    if (this.price) {
      this.price.units.add(price.units);
    } else {
      this.price = price;
    }
    this.resources.push("RAM");
    const newAction = Action.from({
      account: "eosio",
      name: "buyrambytes",
      authorization: [resolved.signer],
      data: Buyrambytes.from({
        payer: resolved.signer.actor,
        receiver: resolved.signer.actor,
        bytes: needed
      })
    });
    const newRequest = prependAction(resolved.request, newAction);
    return this.correct(newRequest, context, account);
  }
  async powerup(context, resolved, account, resources, cpu, net) {
    const config = chains[String(context.chain.id)];
    const powerup = await resources.v1.powerup.get_state();
    if (!this.sample) {
      this.sample = await resources.getSampledUsage();
    }
    if (cpu < 2500) {
      cpu = 2500;
    }
    if (net < 1e4) {
      net = 1e4;
    }
    const price = Asset.from(Number(powerup.cpu.price_per(this.sample, cpu)) + Number(powerup.net.price_per(this.sample, net)) * multiplier, config.symbol);
    if (this.price) {
      this.price.units.add(price.units);
    } else {
      this.price = price;
    }
    this.resources.push("CPU", "NET");
    const newAction = Action.from({
      account: "eosio",
      name: "powerup",
      authorization: [resolved.signer],
      data: Powerup.from({
        payer: resolved.signer.actor,
        receiver: resolved.signer.actor,
        days: 1,
        net_frac: powerup.net.frac(this.sample, net),
        cpu_frac: powerup.cpu.frac(this.sample, cpu),
        max_payment: price
      })
    });
    let modifiedRequest = prependAction(resolved.request, newAction);
    const ram_needed = 410;
    if (Number(account.ram_quota) - Number(account.ram_usage) < ram_needed) {
      const config2 = chains[String(context.chain.id)];
      const ram = await resources.v1.ram.get_state();
      if (!this.sample) {
        this.sample = await resources.getSampledUsage();
      }
      const ramAction = Action.from({
        account: "eosio",
        name: "buyrambytes",
        authorization: [resolved.signer],
        data: Buyrambytes.from({
          payer: resolved.signer.actor,
          receiver: resolved.signer.actor,
          bytes: ram_needed
        })
      });
      account.ram_quota.add(ram_needed);
      modifiedRequest = prependAction(modifiedRequest, ramAction);
      const ramPrice = Asset.from(ram.price_per(ram_needed).value, config2.symbol);
      this.price.units.add(ramPrice.units);
      this.resources.push("RAM");
    }
    return this.correct(modifiedRequest, context, account);
  }
}
class TransactionService {
  constructor() {
    __publicField(this, "transactions", /* @__PURE__ */ new Map());
    __publicField(this, "listeners", /* @__PURE__ */ new Set());
    __publicField(this, "retryTimeouts", /* @__PURE__ */ new Map());
  }
  /**
   * Execute a transaction with full state management
   */
  async executeTransaction(type, actions, options = {}) {
    const transactionId = this.generateTransactionId();
    const account = wharfKitService.getAccountName();
    if (!account) {
      throw new Error("Wallet not connected");
    }
    const transaction = {
      id: transactionId,
      type,
      status: "pending",
      timestamp: Date.now(),
      account,
      actions,
      metadata: options.metadata,
      retryCount: 0,
      maxRetries: options.maxRetries ?? 3
    };
    this.transactions.set(transactionId, transaction);
    this.emitEvent("transaction_started", transaction);
    try {
      this.updateTransactionStatus(transactionId, "processing");
      const result = await this.performTransaction(actions, options.timeout);
      transaction.transactionId = result.transactionId;
      transaction.blockNum = result.blockNum;
      transaction.cpuUsage = result.cpuUsage;
      transaction.netUsage = result.netUsage;
      if (result.success) {
        if (!options.skipConfirmation) {
          this.updateTransactionStatus(transactionId, "confirming");
          await this.waitForConfirmation(result.transactionId);
        }
        this.updateTransactionStatus(transactionId, "success");
        log.info("Transaction successful", "TransactionService", {
          transactionId: result.transactionId,
          type,
          account
        });
        return result;
      } else {
        throw new Error(result.error || "Transaction failed");
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      transaction.error = errorMessage;
      log.error("Transaction failed", "TransactionService", error instanceof Error ? error : new Error(errorMessage), {
        transactionId,
        type,
        account
      });
      if (transaction.maxRetries > 0 && transaction.retryCount < transaction.maxRetries) {
        return this.retryTransaction(transactionId, options);
      } else {
        this.updateTransactionStatus(transactionId, "failed");
        return {
          success: false,
          error: errorMessage
        };
      }
    }
  }
  /**
   * Retry a failed transaction
   */
  async retryTransaction(transactionId, options) {
    const transaction = this.transactions.get(transactionId);
    if (!transaction) {
      throw new Error("Transaction not found");
    }
    transaction.retryCount = (transaction.retryCount || 0) + 1;
    this.emitEvent("transaction_retry", transaction);
    const retryDelay = options.retryDelay ?? 2e3 * transaction.retryCount;
    await new Promise((resolve) => {
      const timeout = setTimeout(resolve, retryDelay);
      this.retryTimeouts.set(transactionId, timeout);
    });
    this.retryTimeouts.delete(transactionId);
    const newTransactionId = this.generateTransactionId();
    const newTransaction = {
      ...transaction,
      id: newTransactionId,
      status: "pending",
      timestamp: Date.now(),
      error: void 0,
      transactionId: void 0,
      blockNum: void 0,
      cpuUsage: void 0,
      netUsage: void 0
    };
    this.transactions.set(newTransactionId, newTransaction);
    this.emitEvent("transaction_started", newTransaction);
    try {
      this.updateTransactionStatus(newTransactionId, "processing");
      const result = await this.performTransaction(transaction.actions, options.timeout);
      newTransaction.transactionId = result.transactionId;
      newTransaction.blockNum = result.blockNum;
      newTransaction.cpuUsage = result.cpuUsage;
      newTransaction.netUsage = result.netUsage;
      if (result.success) {
        if (!options.skipConfirmation) {
          this.updateTransactionStatus(newTransactionId, "confirming");
          await this.waitForConfirmation(result.transactionId);
        }
        this.updateTransactionStatus(newTransactionId, "success");
        log.info("Transaction retry successful", "TransactionService", {
          transactionId: result.transactionId,
          type: transaction.type,
          account: transaction.account,
          retryCount: transaction.retryCount
        });
        return result;
      } else {
        throw new Error(result.error || "Transaction failed");
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      newTransaction.error = errorMessage;
      log.error("Transaction retry failed", "TransactionService", error instanceof Error ? error : new Error(errorMessage), {
        transactionId: newTransactionId,
        type: transaction.type,
        account: transaction.account,
        retryCount: transaction.retryCount
      });
      if (transaction.maxRetries > 0 && transaction.retryCount < transaction.maxRetries) {
        return this.retryTransaction(transactionId, options);
      } else {
        this.updateTransactionStatus(newTransactionId, "failed");
        return {
          success: false,
          error: errorMessage
        };
      }
    }
  }
  /**
   * Cancel a pending transaction
   */
  cancelTransaction(transactionId) {
    const transaction = this.transactions.get(transactionId);
    if (!transaction || transaction.status !== "pending") {
      return false;
    }
    const timeout = this.retryTimeouts.get(transactionId);
    if (timeout) {
      clearTimeout(timeout);
      this.retryTimeouts.delete(transactionId);
    }
    this.updateTransactionStatus(transactionId, "cancelled");
    return true;
  }
  /**
   * Get transaction by ID
   */
  getTransaction(transactionId) {
    return this.transactions.get(transactionId);
  }
  /**
   * Get all transactions for an account
   */
  getTransactionsByAccount(account) {
    return Array.from(this.transactions.values()).filter((tx) => tx.account === account).sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Get transactions by type
   */
  getTransactionsByType(type) {
    return Array.from(this.transactions.values()).filter((tx) => tx.type === type).sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Get pending transactions
   */
  getPendingTransactions() {
    return Array.from(this.transactions.values()).filter((tx) => ["pending", "processing", "confirming"].includes(tx.status)).sort((a, b) => b.timestamp - a.timestamp);
  }
  /**
   * Clear old transactions (keep last 100)
   */
  clearOldTransactions() {
    const allTransactions = Array.from(this.transactions.values()).sort((a, b) => b.timestamp - a.timestamp);
    if (allTransactions.length > 100) {
      const toRemove = allTransactions.slice(100);
      toRemove.forEach((tx) => this.transactions.delete(tx.id));
    }
  }
  /**
   * Add transaction event listener
   */
  addListener(listener) {
    this.listeners.add(listener);
  }
  /**
   * Remove transaction event listener
   */
  removeListener(listener) {
    this.listeners.delete(listener);
  }
  /**
   * Clear all listeners
   */
  clearListeners() {
    this.listeners.clear();
  }
  // Private helper methods
  generateTransactionId() {
    return `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  updateTransactionStatus(transactionId, status) {
    const transaction = this.transactions.get(transactionId);
    if (transaction) {
      transaction.status = status;
      this.emitEvent(`transaction_${status}`, transaction);
    }
  }
  emitEvent(type, transaction) {
    const event = {
      type,
      transaction,
      timestamp: Date.now()
    };
    this.listeners.forEach((listener) => {
      try {
        listener(event);
      } catch (error) {
        log.error("Transaction listener error", "TransactionService", error instanceof Error ? error : new Error(String(error)));
      }
    });
  }
  async performTransaction(actions, _timeout) {
    try {
      const result = await wharfKitService.transact(actions);
      if (result && typeof result === "object") {
        const txResult = result;
        return {
          success: true,
          transactionId: txResult.transaction_id || txResult.id,
          blockNum: txResult.block_num,
          cpuUsage: txResult.cpu_usage_us,
          netUsage: txResult.net_usage_words
        };
      }
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Transaction failed"
      };
    }
  }
  async waitForConfirmation(_transactionId) {
    await new Promise((resolve) => setTimeout(resolve, 3e3));
  }
}
const transactionService = new TransactionService();
const buildPurchaseActions = (buyer, saleId, price, currency = "WAX", marketContract = "atomicmarket") => {
  const actions = [];
  const tokenContract = currency === "WAX" ? "eosio.token" : "token.rwax";
  actions.push({
    account: tokenContract,
    name: "transfer",
    authorization: [{ actor: buyer, permission: "active" }],
    data: {
      from: buyer,
      to: marketContract,
      quantity: `${price} ${currency}`,
      memo: "deposit"
    }
  });
  actions.push({
    account: marketContract,
    name: "purchasesale",
    authorization: [{ actor: buyer, permission: "active" }],
    data: {
      buyer,
      sale_id: saleId,
      intended_delphi_median: 0,
      taker_marketplace: "market.pxj"
    }
  });
  return actions;
};
const buildTokenTransferActions = (from, to, amount, currency = "WAX", memo = "") => {
  let tokenContract;
  switch (currency) {
    case "WAX":
      tokenContract = "eosio.token";
      break;
    case "RWAX":
      tokenContract = "token.rwax";
      break;
    case "PXJ":
      tokenContract = "pixeljourney";
      break;
    default:
      tokenContract = "eosio.token";
  }
  return [{
    account: tokenContract,
    name: "transfer",
    authorization: [{ actor: from, permission: "active" }],
    data: {
      from,
      to,
      quantity: `${amount} ${currency}`,
      memo
    }
  }];
};
class WharfKitService {
  constructor() {
    __publicField(this, "sessionKit", null);
    __publicField(this, "currentSession", null);
    __publicField(this, "listeners", []);
    this.initializeSessionKit();
    this.restoreSession();
  }
  initializeSessionKit() {
    try {
      const config = {
        appName: "PxMarket2",
        chains: [{
          id: "1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4",
          url: API_ENDPOINTS.WAX_CHAIN.GREYMASS
        }],
        ui: new WebRenderer(),
        walletPlugins: [
          new WalletPluginAnchor(),
          new WalletPluginCloudWallet(),
          new WalletPluginWombat()
        ]
      };
      const options = {
        transactPlugins: [
          new TransactPluginAutoCorrect()
        ]
      };
      this.sessionKit = new SessionKit(config, options);
    } catch (error) {
      ErrorMessageService.logError("WharfKitService.initialize", error);
    }
  }
  async restoreSession() {
    if (!this.sessionKit) return;
    try {
      const restored = await this.sessionKit.restore();
      if (restored) {
        this.currentSession = restored;
        this.notifyListeners();
      }
    } catch (error) {
      ErrorMessageService.logError("WharfKitService.restoreSession", error);
    }
  }
  async login() {
    if (!this.sessionKit) {
      ErrorMessageService.logError("WharfKitService.login", new Error("SessionKit not initialized"));
      return null;
    }
    try {
      const response = await this.sessionKit.login();
      if (response.session) {
        this.currentSession = response.session;
        this.notifyListeners();
        return this.currentSession;
      }
    } catch (error) {
      ErrorMessageService.logError("WharfKitService.login", error);
      throw error;
    }
    return null;
  }
  async logout() {
    if (!this.sessionKit || !this.currentSession) return;
    try {
      await this.sessionKit.logout(this.currentSession);
      this.currentSession = null;
      this.notifyListeners();
    } catch (error) {
      ErrorMessageService.logError("WharfKitService.logout", error);
      throw error;
    }
  }
  isLoggedIn() {
    return this.currentSession !== null;
  }
  getSession() {
    return this.currentSession;
  }
  getActor() {
    return this.currentSession?.actor?.toString() || null;
  }
  getAccountName() {
    return this.currentSession?.actor?.toString() || null;
  }
  getPermission() {
    return this.currentSession?.permission?.toString() || "active";
  }
  // Safe session property access helpers
  static safeGetActor(session) {
    return session?.actor?.toString() || "";
  }
  static safeGetPermission(session) {
    return session?.permission?.toString() || "active";
  }
  async transact(actions) {
    if (!this.currentSession) {
      throw new Error("No active session. Please login first.");
    }
    try {
      logger.debug("Sending transaction with actions", "WHARFKIT", { actionsCount: actions.length });
      const result = await this.currentSession.transact({
        actions
      }, {
        broadcast: true,
        expireSeconds: 120
      });
      logger.info("Transaction successful", "WHARFKIT", { result });
      return result;
    } catch (error) {
      ErrorMessageService.logError("WharfKitService.transact", error, { actions });
      throw error;
    }
  }
  // Purchase NFT transaction
  async purchaseNFT(saleId, price) {
    if (!this.currentSession) {
      throw new Error("Please login to purchase NFTs");
    }
    const actions = [
      {
        account: "eosio.token",
        name: "transfer",
        authorization: [{
          actor: this.currentSession?.actor?.toString() || "",
          permission: "active"
        }],
        data: {
          from: this.currentSession?.actor?.toString() || "",
          to: "atomicmarket",
          quantity: `${parseFloat(price).toFixed(8)} WAX`,
          memo: `deposit`
        }
      },
      {
        account: "atomicmarket",
        name: "purchasesale",
        authorization: [{
          actor: this.currentSession?.actor?.toString() || "",
          permission: "active"
        }],
        data: {
          buyer: this.currentSession?.actor?.toString() || "",
          sale_id: saleId,
          intended_delphi_median: 0,
          taker_marketplace: "market.pxj"
        }
      }
    ];
    logger.debug("Crafting transaction actions", "WHARFKIT", { actionsCount: actions.length });
    return this.transact(actions);
  }
  // Batch purchase multiple NFTs in a single transaction
  async batchPurchaseNFTs(purchases) {
    if (!this.currentSession) {
      throw new Error("Please login to purchase NFTs");
    }
    if (purchases.length === 0) {
      throw new Error("No items to purchase");
    }
    const actions = [];
    const totalPrice = purchases.reduce((sum, purchase) => {
      return sum + parseFloat(purchase.price);
    }, 0);
    actions.push({
      account: "eosio.token",
      name: "transfer",
      authorization: [{
        actor: this.currentSession.actor.toString(),
        permission: "active"
      }],
      data: {
        from: this.currentSession.actor.toString(),
        to: "atomicmarket",
        quantity: `${totalPrice.toFixed(8)} WAX`,
        memo: `deposit`
      }
    });
    purchases.forEach((purchase) => {
      actions.push({
        account: "atomicmarket",
        name: "purchasesale",
        authorization: [{
          actor: this.currentSession?.actor.toString() || "",
          permission: "active"
        }],
        data: {
          buyer: this.currentSession?.actor.toString() || "",
          sale_id: purchase.saleId,
          intended_delphi_median: 0,
          taker_marketplace: "market.pxj"
        }
      });
    });
    return this.transact(actions);
  }
  // Transfer tokens (PXJ, WAX, etc.)
  async transferTokens(to, amount, currency = "PXJ", memo = "") {
    if (!this.currentSession) {
      throw new Error("Please login to transfer tokens");
    }
    const actions = buildTokenTransferActions(
      this.currentSession?.actor?.toString() || "",
      to,
      amount,
      currency,
      memo
    );
    logger.debug("Token transfer transaction actions", "WHARFKIT", {
      actionsCount: actions.length,
      to,
      amount,
      currency,
      memo
    });
    return this.transact(actions);
  }
  // Bulk transfer multiple NFTs to a single recipient
  async bulkTransferNFT(recipient, assetIds, memo = "") {
    if (!this.currentSession) {
      throw new Error("Please login to transfer NFTs");
    }
    if (!assetIds || assetIds.length === 0) {
      throw new Error("No assets to transfer");
    }
    const actions = assetIds.map((assetId) => ({
      account: "atomicassets",
      name: "transfer",
      authorization: [{
        actor: this.currentSession?.actor?.toString() || "",
        permission: "active"
      }],
      data: {
        from: this.currentSession?.actor?.toString() || "",
        to: recipient,
        asset_ids: [assetId],
        memo
      }
    }));
    logger.debug("Bulk NFT transfer transaction actions", "WHARFKIT", {
      actionsCount: actions.length,
      recipient,
      assetIds: assetIds.length,
      memo
    });
    return this.transact(actions);
  }
  // Execute crafting transaction
  async executeCraftingTransaction(craftingData) {
    if (!this.currentSession) {
      throw new Error("No active session");
    }
    const actions = [];
    const account = this.currentSession?.actor?.toString() || "";
    const recipeToCraftId = {
      "craft_green": 1832,
      "craft_orange": 1833,
      "craft_purple": 1834,
      "craft_amber": 1835,
      "craft_chartreuse": 1836,
      "craft_violet": 1837,
      "craft_teal": 1838,
      "craft_vermillion": 1839,
      "craft_magenta": 1841
    };
    const craftId = recipeToCraftId[craftingData.recipe];
    if (!craftId) {
      throw new Error(`Unknown recipe: ${craftingData.recipe}`);
    }
    const individualPxjCost = craftingData.pxjCost;
    actions.push({
      account: "nft.hive",
      name: "boost",
      authorization: [{
        actor: account,
        permission: "active"
      }],
      data: {
        booster: account
      }
    });
    for (let i = 0; i < craftingData.quantity; i++) {
      const craftAssetIds = [];
      for (const ingredient of craftingData.ingredientAssets) {
        const assetsPerCraft = ingredient.assetIds.length / craftingData.quantity;
        const startIndex = i * assetsPerCraft;
        const endIndex = startIndex + assetsPerCraft;
        craftAssetIds.push(...ingredient.assetIds.slice(startIndex, endIndex));
      }
      if (craftAssetIds.length > 0) {
        actions.push({
          account: "atomicassets",
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "nfthivecraft",
            asset_ids: craftAssetIds,
            memo: "craft"
          }
        });
      }
      if (individualPxjCost > 0) {
        actions.push({
          account: "pixeljourney",
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "nfthivecraft",
            quantity: `${individualPxjCost.toFixed(8)} PXJ`,
            memo: "craft"
          }
        });
      }
      actions.push({
        account: "nfthivecraft",
        name: "craft",
        authorization: [{
          actor: account,
          permission: "active"
        }],
        data: {
          craft_id: craftId,
          user_name: account,
          collection_name: "pixeljourney",
          timestamp: Date.now().toString(),
          asset_ids: craftAssetIds,
          tokens: [`${individualPxjCost.toFixed(8)} PXJ`]
        }
      });
    }
    return this.transact(actions);
  }
  // Subscribe to wallet state changes
  subscribe(callback) {
    this.listeners.push(callback);
    callback(this.getWalletContext());
    return () => {
      const index = this.listeners.indexOf(callback);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }
  notifyListeners() {
    const context = this.getWalletContext();
    this.listeners.forEach((callback) => callback(context));
  }
  getWalletContext() {
    return {
      isConnected: this.isLoggedIn(),
      account: this.getAccountName(),
      session: this.currentSession,
      login: this.login.bind(this),
      logout: this.logout.bind(this),
      transact: this.transact.bind(this),
      purchaseNFT: this.purchaseNFT.bind(this),
      batchPurchaseNFTs: this.batchPurchaseNFTs.bind(this),
      executeCraftingTransaction: this.executeCraftingTransaction.bind(this),
      isLoading: false,
      // WharfKit handles its own loading states
      executeTransaction: this.executeTransaction.bind(this),
      getTransaction: void 0,
      // Optional method not implemented
      cancelTransaction: void 0,
      // Optional method not implemented
      getTransactionHistory: void 0,
      // Optional method not implemented
      transferNFT: void 0,
      // Optional method not implemented
      bulkTransferNFT: this.bulkTransferNFT.bind(this),
      transferTokens: this.transferTokens.bind(this)
    };
  }
  // Execute transaction using the centralized transaction service
  async executeTransaction(type, data) {
    if (!this.currentSession) {
      throw new Error("No active session. Please login first.");
    }
    try {
      let actions = [];
      switch (type) {
        case "nft_purchase":
          if (data.saleId && data.price) {
            actions = buildPurchaseActions(this.currentSession?.actor?.toString() || "", data.saleId, data.price);
          } else {
            throw new Error("Missing saleId or price for NFT purchase");
          }
          break;
        case "crafting": {
          const craftingResult = await this.executeCraftingTransaction(data);
          if (craftingResult && typeof craftingResult === "object" && "transaction_id" in craftingResult) {
            return craftingResult.transaction_id;
          }
          return "crafting_completed";
        }
        default:
          throw new Error(`Transaction type '${type}' not supported yet`);
      }
      const result = await transactionService.executeTransaction(type, actions);
      if (result.success && result.transactionId) {
        return result.transactionId;
      } else {
        throw new Error(result.error || "Transaction failed");
      }
    } catch (error) {
      logger.error("Transaction execution failed", "WharfKitService.executeTransaction", error instanceof Error ? error : new Error(String(error)), { type, data });
      throw error;
    }
  }
  // Get API client for blockchain queries
  getAPIClient() {
    return new APIClient({
      url: API_ENDPOINTS.WAX_CHAIN.GREYMASS
    });
  }
}
const wharfKitService = new WharfKitService();
const wharfkit = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WharfKitService,
  wharfKitService
}, Symbol.toStringTag, { value: "Module" }));
const MediaRenderer = React.memo(({
  imageUrl,
  videoUrl,
  alt,
  className = "",
  controls = true,
  muted = true,
  loop = false,
  autoPlay = false,
  loading = "lazy",
  enableAnimations = true
}) => {
  const processUrl = (url) => {
    if (!url) return null;
    if (typeof url !== "string") return null;
    if (url.startsWith("http")) return url;
    if (url.startsWith("Qm")) return `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${url}`;
    return url;
  };
  const processedVideoUrl = processUrl(videoUrl);
  const processedImageUrl = processUrl(imageUrl);
  const getPlaceholderSrc = () => {
    const svg = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
      <rect width="200" height="200" fill="#f3f4f6"/>
      <text x="100" y="90" text-anchor="middle" font-family="Arial" font-size="14" fill="#6b7280">NFT</text>
      <text x="100" y="110" text-anchor="middle" font-family="Arial" font-size="12" fill="#9ca3af">No Image</text>
      <text x="100" y="130" text-anchor="middle" font-family="Arial" font-size="10" fill="#d1d5db">Available</text>
    </svg>`;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  };
  const finalImageUrl = processedImageUrl || getPlaceholderSrc();
  if (processedVideoUrl && enableAnimations) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "video",
      {
        className,
        controls,
        muted,
        loop,
        autoPlay,
        poster: processedImageUrl ? processedImageUrl : void 0,
        onError: (e) => {
          const target = e.target;
          const img = document.createElement("img");
          img.src = finalImageUrl;
          img.alt = alt;
          img.className = className;
          img.loading = loading;
          target.parentNode?.replaceChild(img, target);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: processedVideoUrl, type: "video/mp4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: processedVideoUrl, type: "video/webm" }),
          "Your browser does not support the video tag."
        ]
      }
    );
  }
  if (processedVideoUrl && !enableAnimations) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: finalImageUrl,
        alt,
        className,
        loading,
        onError: (e) => {
          const target = e.target;
          const placeholder = getPlaceholderSrc();
          if (target.src !== placeholder) {
            target.src = placeholder;
          }
        }
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: finalImageUrl,
      alt,
      className,
      loading,
      onError: (e) => {
        const target = e.target;
        const placeholder = getPlaceholderSrc();
        if (target.src !== placeholder) {
          target.src = placeholder;
        }
      }
    }
  );
});
MediaRenderer.displayName = "MediaRenderer";
function SendOfferModal({ isOpen, onClose, nft }) {
  const { session, isConnected, account } = useWallet$1();
  const { settings } = useDisplaySettings();
  const { showSuccess, showError } = useNotifications();
  const [offerType, setOfferType] = reactExports.useState("wax");
  const [waxAmount, setWaxAmount] = reactExports.useState("");
  const [customMemo, setCustomMemo] = reactExports.useState("");
  const [userNFTs, setUserNFTs] = reactExports.useState([]);
  const [selectedNFTs, setSelectedNFTs] = reactExports.useState([]);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [loadingInventory, setLoadingInventory] = reactExports.useState(false);
  const [isPixalHolder, setIsPixalHolder] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const checkPixalHolder = async () => {
      if (!account) return;
      try {
        const response = await fetch(`https://aa.dapplica.io/atomicassets/v1/assets?owner=${account}&collection_name=pixeljourney&limit=1`);
        const data = await response.json();
        setIsPixalHolder(data.data && data.data.length > 0);
      } catch (error) {
        console.error("Error checking Pixal holder status:", error);
      }
    };
    if (isOpen && isConnected) {
      checkPixalHolder();
    }
  }, [isOpen, isConnected, account]);
  reactExports.useEffect(() => {
    const loadUserNFTs = async () => {
      if (!account || offerType !== "nft") return;
      setLoadingInventory(true);
      try {
        const response = await fetch(`https://aa.dapplica.io/atomicassets/v1/assets?owner=${account}&limit=100`);
        const data = await response.json();
        const formattedNFTs = data.data?.map((asset) => {
          const rawImage = asset.data?.img || asset.data?.image;
          const rawVideo = asset.data?.video;
          let imageUrl = "https://pixeljourney.xyz/img/toppixals/10.webp";
          let videoUrl = null;
          if (rawVideo && typeof rawVideo === "string") {
            if (rawVideo.startsWith("http")) {
              videoUrl = rawVideo;
            } else {
              videoUrl = `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${rawVideo}`;
            }
          }
          if (rawImage && typeof rawImage === "string") {
            if (rawImage.startsWith("http")) {
              imageUrl = rawImage;
            } else {
              imageUrl = `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${rawImage}`;
            }
          }
          return {
            asset_id: asset.asset_id || "",
            name: asset.name || `${asset.collection?.collection_name || "Unknown"} #${asset.asset_id || "N/A"}`,
            image: imageUrl,
            video: videoUrl,
            collection: asset.collection?.collection_name || "Unknown",
            template_mint: void 0,
            max_supply: asset.template?.max_supply || void 0
          };
        }) || [];
        setUserNFTs(formattedNFTs);
      } catch (error) {
        console.error("Error loading user NFTs:", error);
      } finally {
        setLoadingInventory(false);
      }
    };
    if (isOpen && offerType === "nft") {
      loadUserNFTs();
    }
  }, [isOpen, offerType, account]);
  const handleNFTSelection = (assetId) => {
    setSelectedNFTs(
      (prev) => prev.includes(assetId) ? prev.filter((id) => id !== assetId) : [...prev, assetId]
    );
  };
  const handleSendWaxOffer = async () => {
    if (!account || !nft || !waxAmount || !session) return;
    setIsLoading(true);
    try {
      const memo = customMemo || (isPixalHolder ? "Trade Offer sent via PxMarket - market.pixeljourney.xyz" : "Trade Offer sent via PxMarket - market.pixeljourney.xyz");
      const actions = [
        {
          account: "eosio.token",
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "atomicmarket",
            quantity: `${parseFloat(waxAmount).toFixed(8)} WAX`,
            memo: "deposit"
          }
        },
        {
          account: "atomicmarket",
          name: "createbuyo",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            buyer: account,
            recipient: nft.owner || nft.seller,
            price: `${parseFloat(waxAmount).toFixed(8)} WAX`,
            asset_ids: [nft.asset_id],
            memo,
            maker_marketplace: "market.pxj"
          }
        }
      ];
      await session.transact({ actions });
      showSuccess("WAX offer sent successfully!");
      onClose();
    } catch (error) {
      console.error("Error sending WAX offer:", error);
      showError("Failed to send WAX offer. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };
  const handleSendNFTOffer = async () => {
    if (!account || !nft || selectedNFTs.length === 0 || !session) return;
    setIsLoading(true);
    try {
      const memo = customMemo || (isPixalHolder ? "NFT Trade Offer sent via PxMarket - market.pixeljourney.xyz" : "NFT Trade Offer sent via PxMarket - market.pixeljourney.xyz");
      const actions = [{
        account: "atomicassets",
        name: "createoffer",
        authorization: [{
          actor: account,
          permission: "active"
        }],
        data: {
          sender: account,
          recipient: nft.owner || nft.seller,
          sender_asset_ids: selectedNFTs,
          recipient_asset_ids: [nft.asset_id],
          memo
        }
      }];
      await session.transact({ actions });
      showSuccess("NFT trade offer sent successfully!");
      onClose();
    } catch (error) {
      console.error("Error sending NFT offer:", error);
      showError("Failed to send NFT offer. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };
  const handleSubmit = () => {
    if (offerType === "wax") {
      handleSendWaxOffer();
    } else {
      handleSendNFTOffer();
    }
  };
  if (!isOpen || !nft) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-backdrop", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content send-offer-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
        "Send Offer for ",
        nft.name
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "target-nft-preview", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MediaRenderer,
          {
            imageUrl: nft.image,
            alt: nft.name,
            enableAnimations: settings.enableAnimatedNFTs
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: nft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Collection: ",
            typeof nft.collection === "string" ? nft.collection : nft.collection?.collection_name || nft.collection?.name || "Unknown"
          ] }),
          nft.price && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Listed Price: ",
            nft.price,
            " WAX"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offer-type-selection", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Choose Offer Type" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offer-type-buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `offer-type-btn ${offerType === "wax" ? "active" : ""}`,
              onClick: () => setOfferType("wax"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 6v6l4 2" })
                ] }),
                "WAX Offer"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `offer-type-btn ${offerType === "nft" ? "active" : ""}`,
              onClick: () => setOfferType("nft"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2", ry: "2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "8.5", cy: "8.5", r: "1.5" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "21,15 16,10 5,21" })
                ] }),
                "NFT Trade"
              ]
            }
          )
        ] })
      ] }),
      offerType === "wax" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wax-offer-form", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "waxAmount", children: "WAX Amount" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            id: "waxAmount",
            type: "number",
            step: "0.0001",
            min: "0",
            value: waxAmount,
            onChange: (e) => setWaxAmount(e.target.value),
            placeholder: "Enter WAX amount",
            className: "form-input"
          }
        )
      ] }) }),
      offerType === "nft" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-trade-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Select NFTs to Trade" }),
        loadingInventory ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-inventory", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading your NFTs..." })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "user-nfts-grid", children: userNFTs.map((userNft) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `user-nft-item ${selectedNFTs.includes(userNft.asset_id) ? "selected" : ""}`,
            onClick: () => handleNFTSelection(userNft.asset_id),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MediaRenderer,
                {
                  imageUrl: userNft.image,
                  videoUrl: userNft.video,
                  alt: userNft.name,
                  enableAnimations: settings.enableAnimatedNFTs
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-details", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-name", children: userNft.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-collection", children: typeof userNft.collection === "string" ? userNft.collection : userNft.collection?.collection_name || userNft.collection?.name || "Unknown" })
              ] }),
              selectedNFTs.includes(userNft.asset_id) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selection-indicator", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20,6 9,17 4,12" }) }) })
            ]
          },
          userNft.asset_id
        )) })
      ] }),
      isPixalHolder && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-memo-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pixal-holder-badge", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "12,2 15.09,8.26 22,9 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9 8.91,8.26" }) }),
          "Pixal PFP Holder"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "customMemo", children: "Custom Memo (Optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              id: "customMemo",
              value: customMemo,
              onChange: (e) => setCustomMemo(e.target.value),
              placeholder: "Add a custom message to your offer...",
              className: "form-textarea",
              rows: 3
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: onClose, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: handleSubmit,
          disabled: isLoading || !isConnected || offerType === "wax" && !waxAmount || offerType === "nft" && selectedNFTs.length === 0,
          children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-small" }),
            "Sending..."
          ] }) : `Send ${offerType === "wax" ? "WAX" : "NFT"} Offer`
        }
      )
    ] })
  ] }) });
}
class ShareImageGenerator {
  constructor() {
    __publicField(this, "defaultConfig", {
      width: 1200,
      height: 630,
      backgroundColor: "#1a1a2e",
      textColor: "#ffffff",
      accentColor: "#ffd700"
    });
  }
  /**
   * Generate share image for achievements
   */
  generateAchievementShareImage(badges, totalBadges, legendaryCount, username, config = {}) {
    const { width, height, textColor, accentColor } = {
      ...this.defaultConfig,
      ...config
    };
    const topBadges = badges.filter((b) => b.unlockedAt).sort((a, b) => {
      const rarityOrder = { legendary: 4, epic: 3, rare: 2, common: 1 };
      return (rarityOrder[b.rarity || "common"] || 1) - (rarityOrder[a.rarity || "common"] || 1);
    }).slice(0, 3);
    const svg = `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bgGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#1a1a2e;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#16213e;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#0f3460;stop-opacity:1" />
          </linearGradient>
          <linearGradient id="titleGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#ffd700;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#ffed4e;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#ffd700;stop-opacity:1" />
          </linearGradient>
        </defs>
        
        <!-- Background -->
        <rect width="100%" height="100%" fill="url(#bgGradient)"/>
        
        <!-- Header -->
        <text x="${width / 2}" y="80" font-family="system-ui, -apple-system, sans-serif" font-size="48" font-weight="bold" fill="url(#titleGradient)" text-anchor="middle">
          ${username}'s Achievements
        </text>
        
        <!-- Stats Section -->
        <g transform="translate(${width / 2 - 300}, 150)">
          <!-- Total Badges -->
          <rect x="0" y="0" width="180" height="120" rx="15" fill="rgba(255,255,255,0.1)" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
          <text x="90" y="40" font-family="system-ui" font-size="36" font-weight="bold" fill="${accentColor}" text-anchor="middle">${totalBadges}</text>
          <text x="90" y="70" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Total</text>
          <text x="90" y="90" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Badges</text>
          
          <!-- Legendary Badges -->
          <rect x="210" y="0" width="180" height="120" rx="15" fill="rgba(255,140,0,0.2)" stroke="#ff8c00" stroke-width="2"/>
          <text x="300" y="40" font-family="system-ui" font-size="36" font-weight="bold" fill="#ff8c00" text-anchor="middle">${legendaryCount}</text>
          <text x="300" y="70" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Legendary</text>
          <text x="300" y="90" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Badges</text>
          
          <!-- Progress -->
          <rect x="420" y="0" width="180" height="120" rx="15" fill="rgba(255,255,255,0.1)" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
          <text x="510" y="40" font-family="system-ui" font-size="36" font-weight="bold" fill="${accentColor}" text-anchor="middle">${badges.filter((b) => b.progress && !b.unlockedAt).length}</text>
          <text x="510" y="70" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">In</text>
          <text x="510" y="90" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Progress</text>
        </g>
        
        <!-- Top Badges Section -->
        ${topBadges.length > 0 ? `
        <text x="${width / 2}" y="350" font-family="system-ui" font-size="24" font-weight="600" fill="${textColor}" text-anchor="middle">
          Featured Achievements
        </text>
        
        <g transform="translate(${width / 2 - topBadges.length * 150}, 380)">
          ${topBadges.map((badge, index) => {
      const x = index * 300;
      const rarityColor = badge.rarity === "legendary" ? "#ff8c00" : badge.rarity === "epic" ? "#a335ee" : badge.rarity === "rare" ? "#0070dd" : "#ffd700";
      return `
            <g transform="translate(${x}, 0)">
              <rect x="0" y="0" width="280" height="180" rx="15" fill="rgba(255,255,255,0.1)" stroke="${rarityColor}" stroke-width="2"/>
              <text x="140" y="30" font-family="system-ui" font-size="32" text-anchor="middle">${badge.icon}</text>
              <text x="140" y="70" font-family="system-ui" font-size="18" font-weight="600" fill="${rarityColor}" text-anchor="middle">${badge.name}</text>
              <text x="140" y="100" font-family="system-ui" font-size="14" fill="#b0b0b0" text-anchor="middle">${badge.rarity?.toUpperCase() || "COMMON"}</text>
              ${badge.tier ? `<text x="140" y="130" font-family="system-ui" font-size="12" fill="#888" text-anchor="middle">Tier ${badge.tier}</text>` : ""}
              <text x="140" y="160" font-family="system-ui" font-size="10" fill="#666" text-anchor="middle">${badge.unlockedAt ? new Date(badge.unlockedAt).toLocaleDateString() : ""}</text>
            </g>
            `;
    }).join("")}
        </g>
        ` : ""}
        
        <!-- Footer -->
        <text x="${width / 2}" y="${height - 40}" font-family="system-ui" font-size="18" fill="#888" text-anchor="middle">
          Pixel Journey Ecosystem  PxMarket
        </text>
      </svg>
    `;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
  /**
   * Generate share image for inventory selection
   */
  generateInventoryShareImage(selectedItems, totalValue, username, config = {}) {
    const { width, height, textColor, accentColor } = {
      ...this.defaultConfig,
      ...config
    };
    const topItems = selectedItems.sort((a, b) => {
      const rarityOrder = { legendary: 4, epic: 3, rare: 2, common: 1 };
      return (rarityOrder[b.rarity] || 1) - (rarityOrder[a.rarity] || 1);
    }).slice(0, 6);
    const svg = `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bgGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#1a1a2e;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#16213e;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#0f3460;stop-opacity:1" />
          </linearGradient>
          <linearGradient id="titleGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#ffd700;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#ffed4e;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#ffd700;stop-opacity:1" />
          </linearGradient>
        </defs>
        
        <!-- Background -->
        <rect width="100%" height="100%" fill="url(#bgGradient)"/>
        
        <!-- Header -->
        <text x="${width / 2}" y="80" font-family="system-ui, -apple-system, sans-serif" font-size="48" font-weight="bold" fill="url(#titleGradient)" text-anchor="middle">
          ${username}'s Collection
        </text>
        
        <!-- Stats -->
        <g transform="translate(${width / 2 - 200}, 130)">
          <rect x="0" y="0" width="180" height="100" rx="15" fill="rgba(255,255,255,0.1)" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
          <text x="90" y="35" font-family="system-ui" font-size="32" font-weight="bold" fill="${accentColor}" text-anchor="middle">${selectedItems.length}</text>
          <text x="90" y="60" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Selected</text>
          <text x="90" y="80" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Items</text>
          
          <rect x="220" y="0" width="180" height="100" rx="15" fill="rgba(0,212,255,0.2)" stroke="#00d4ff" stroke-width="2"/>
          <text x="310" y="35" font-family="system-ui" font-size="24" font-weight="bold" fill="#00d4ff" text-anchor="middle">${totalValue}</text>
          <text x="310" y="60" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Total</text>
          <text x="310" y="80" font-family="system-ui" font-size="16" fill="#b0b0b0" text-anchor="middle">Value</text>
        </g>
        
        <!-- Items Grid -->
        ${topItems.length > 0 ? `
        <text x="${width / 2}" y="290" font-family="system-ui" font-size="24" font-weight="600" fill="${textColor}" text-anchor="middle">
          Featured Items
        </text>
        
        <g transform="translate(${width / 2 - Math.min(topItems.length, 3) * 120}, 320)">
          ${topItems.slice(0, 3).map((item, index) => {
      const x = index * 240;
      const rarityColor = item.rarity === "legendary" ? "#ff8c00" : item.rarity === "epic" ? "#a335ee" : item.rarity === "rare" ? "#0070dd" : "#ffd700";
      return `
            <g transform="translate(${x}, 0)">
              <rect x="0" y="0" width="220" height="160" rx="15" fill="rgba(255,255,255,0.1)" stroke="${rarityColor}" stroke-width="2"/>
              <rect x="10" y="10" width="60" height="60" rx="8" fill="rgba(0,0,0,0.3)" stroke="${rarityColor}" stroke-width="1"/>
              <text x="40" y="50" font-family="system-ui" font-size="24" text-anchor="middle"></text>
              <text x="90" y="30" font-family="system-ui" font-size="16" font-weight="600" fill="${textColor}">${item.name.length > 15 ? item.name.substring(0, 15) + "..." : item.name}</text>
              <text x="90" y="50" font-family="system-ui" font-size="14" fill="#b0b0b0">${item.collection}</text>
              <text x="90" y="70" font-family="system-ui" font-size="12" fill="${rarityColor}">${item.rarity.toUpperCase()}</text>
              ${item.quantity > 1 ? `<text x="200" y="30" font-family="system-ui" font-size="14" fill="${accentColor}" text-anchor="end">x${item.quantity}</text>` : ""}
            </g>
            `;
    }).join("")}
        </g>
        
        ${topItems.length > 3 ? `
        <g transform="translate(${width / 2 - Math.min(topItems.length - 3, 3) * 120}, 500)">
          ${topItems.slice(3, 6).map((item, index) => {
      const x = index * 240;
      const rarityColor = item.rarity === "legendary" ? "#ff8c00" : item.rarity === "epic" ? "#a335ee" : item.rarity === "rare" ? "#0070dd" : "#ffd700";
      return `
            <g transform="translate(${x}, 0)">
              <rect x="0" y="0" width="220" height="100" rx="15" fill="rgba(255,255,255,0.1)" stroke="${rarityColor}" stroke-width="2"/>
              <rect x="10" y="10" width="40" height="40" rx="6" fill="rgba(0,0,0,0.3)" stroke="${rarityColor}" stroke-width="1"/>
              <text x="30" y="35" font-family="system-ui" font-size="16" text-anchor="middle"></text>
              <text x="65" y="25" font-family="system-ui" font-size="14" font-weight="600" fill="${textColor}">${item.name.length > 12 ? item.name.substring(0, 12) + "..." : item.name}</text>
              <text x="65" y="45" font-family="system-ui" font-size="12" fill="${rarityColor}">${item.rarity.toUpperCase()}</text>
              ${item.quantity > 1 ? `<text x="200" y="25" font-family="system-ui" font-size="12" fill="${accentColor}" text-anchor="end">x${item.quantity}</text>` : ""}
            </g>
            `;
    }).join("")}
        </g>
        ` : ""}
        ` : ""}
        
        <!-- Footer -->
        <text x="${width / 2}" y="${height - 40}" font-family="system-ui" font-size="18" fill="#888" text-anchor="middle">
          Pixel Journey Ecosystem  PxMarket
        </text>
      </svg>
    `;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
  /**
   * Download generated image
   */
  downloadImage(dataUrl, filename) {
    const link = document.createElement("a");
    link.download = filename;
    link.href = dataUrl;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
  /**
   * Convert SVG data URL to PNG (requires canvas)
   */
  async convertToPNG(svgDataUrl, width = 1200, height = 630) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Could not get canvas context"));
          return;
        }
        ctx.drawImage(img, 0, 0, width, height);
        resolve(canvas.toDataURL("image/png"));
      };
      img.onerror = reject;
      img.src = svgDataUrl;
    });
  }
}
const shareImageGenerator = new ShareImageGenerator();
const generateAchievementShareImage = (badges, totalBadges, legendaryCount, username, config) => {
  return shareImageGenerator.generateAchievementShareImage(badges, totalBadges, legendaryCount, username, config);
};
const generateInventoryShareImage = (selectedItems, totalValue, username, config) => {
  return shareImageGenerator.generateInventoryShareImage(selectedItems, totalValue, username, config);
};
const downloadShareImage = (dataUrl, filename) => {
  return shareImageGenerator.downloadImage(dataUrl, filename);
};
const convertShareImageToPNG = (svgDataUrl, width, height) => {
  return shareImageGenerator.convertToPNG(svgDataUrl, width, height);
};
const ShareModal = ({
  isOpen,
  onClose,
  title,
  description,
  imageUrl,
  shareUrl,
  defaultShareText,
  type = "nft",
  badges,
  totalBadges,
  legendaryCount,
  username,
  selectedItems,
  totalValue
}) => {
  const [copied, setCopied] = reactExports.useState(false);
  const [shareText, setShareText] = reactExports.useState("");
  const [generatingImage, setGeneratingImage] = reactExports.useState(false);
  const { showSuccess } = useNotifications();
  const getRandomizedShareText = () => {
    let messages = [];
    switch (type) {
      case "nft":
        messages = [
          ` Check out this amazing NFT: ${title}! `,
          ` Discovered this incredible ${title} NFT! `,
          ` Look at this stunning ${title}! NFT art at its finest `,
          ` Found a gem! ${title} is absolutely beautiful `,
          ` This ${title} NFT caught my eye! Amazing artwork `,
          ` Showcasing ${title} - a true masterpiece! `,
          ` Blown away by this ${title} NFT! `,
          ` Step right up and see ${title}! Fantastic NFT art `
        ];
        break;
      case "collection":
        messages = [
          ` Explore the amazing ${title} collection! `,
          ` This ${title} collection is absolutely fire! `,
          ` Dive into the world of ${title}! Incredible NFT collection `,
          ` Discovered this gem of a collection: ${title}! `,
          ` ${title} collection has some amazing pieces! `,
          ` The ${title} collection is a work of art! `,
          ` Check out the stunning ${title} collection! `,
          ` Welcome to ${title} - an NFT wonderland! `
        ];
        break;
      case "template":
        messages = [
          ` Check out this ${title} template! Perfect for collectors `,
          ` This ${title} template is incredible! `,
          ` Found an amazing ${title} template! `,
          ` ${title} template - a collector's dream! `,
          ` This ${title} template caught my attention! `,
          ` Showcasing the ${title} template! `,
          ` Amazing ${title} template available! `,
          ` Don't miss this ${title} template! `
        ];
        break;
      case "achievement":
        messages = [
          ` Just unlocked some amazing achievements! `,
          ` Check out my gaming achievements! `,
          ` Proud of my latest achievements! `,
          ` Achievement unlocked! Gaming milestones reached `,
          ` Showcasing my gaming achievements! `,
          ` Level up! New achievements earned! `,
          ` Gaming achievements on display! `,
          ` Celebrating my gaming milestones! `
        ];
        break;
      default:
        messages = [defaultShareText];
    }
    const randomIndex = Math.floor(Math.random() * messages.length);
    return messages[randomIndex];
  };
  const [currentRandomText, setCurrentRandomText] = reactExports.useState(
    () => defaultShareText || getRandomizedShareText()
  );
  const finalDefaultText = defaultShareText || currentRandomText;
  const finalShareUrl = shareUrl || window.location.href;
  const regenerateMessage = () => {
    if (!defaultShareText) {
      setCurrentRandomText(getRandomizedShareText());
    }
  };
  if (!isOpen) return null;
  const copyToClipboard = async (text) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
    } catch (error) {
      log.error("Failed to copy to clipboard", "ShareModal", error, { type, shareText });
    }
  };
  const shareToTwitter = () => {
    const text = shareText || finalDefaultText;
    const hashtags = type === "collection" ? "NFTCollection,WAX,PixelJourney" : type === "template" ? "NFTTemplate,WAX,PixelJourney" : type === "achievement" ? "Achievement,Gaming,PixelJourney" : "NFT,WAX,PixelJourney";
    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(finalShareUrl)}&hashtags=${hashtags}`;
    window.open(twitterUrl, "_blank", "width=550,height=420");
  };
  const shareToFacebook = () => {
    const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(finalShareUrl)}`;
    window.open(facebookUrl, "_blank", "width=550,height=420");
  };
  const shareToReddit = () => {
    const text = shareText || finalDefaultText;
    const redditUrl = `https://reddit.com/submit?url=${encodeURIComponent(finalShareUrl)}&title=${encodeURIComponent(text)}`;
    window.open(redditUrl, "_blank", "width=550,height=420");
  };
  const shareToDiscord = () => {
    const text = `${shareText || finalDefaultText}
${finalShareUrl}`;
    copyToClipboard(text);
    showSuccess("Share text copied to clipboard! You can now paste it in Discord.", "Copied to Clipboard");
  };
  const shareToTelegram = () => {
    const text = shareText || finalDefaultText;
    const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(finalShareUrl)}&text=${encodeURIComponent(text)}`;
    window.open(telegramUrl, "_blank", "width=550,height=420");
  };
  const shareViaEmail = () => {
    const subject = `Check out: ${title}`;
    const body = `${shareText || finalDefaultText}

View it here: ${finalShareUrl}`;
    const emailUrl = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    window.location.href = emailUrl;
  };
  const generateAndDownloadShareImage = async () => {
    if (!username) return;
    try {
      setGeneratingImage(true);
      let imageDataUrl;
      let filename;
      if (type === "achievement" && badges && totalBadges !== void 0 && legendaryCount !== void 0) {
        imageDataUrl = generateAchievementShareImage(badges, totalBadges, legendaryCount, username);
        filename = `${username}-achievements-${Date.now()}.svg`;
      } else if (type === "inventory" && selectedItems && totalValue) {
        imageDataUrl = generateInventoryShareImage(selectedItems, totalValue, username);
        filename = `${username}-inventory-${Date.now()}.svg`;
      } else {
        return;
      }
      downloadShareImage(imageDataUrl, filename);
    } catch (error) {
      log.error("Error generating share image", "ShareModal", error, { type, username });
    } finally {
      setGeneratingImage(false);
    }
  };
  const generateAndDownloadPNG = async () => {
    if (!username) return;
    try {
      setGeneratingImage(true);
      let svgDataUrl;
      let filename;
      if (type === "achievement" && badges && totalBadges !== void 0 && legendaryCount !== void 0) {
        svgDataUrl = generateAchievementShareImage(badges, totalBadges, legendaryCount, username);
        filename = `${username}-achievements-${Date.now()}.png`;
      } else if (type === "inventory" && selectedItems && totalValue) {
        svgDataUrl = generateInventoryShareImage(selectedItems, totalValue, username);
        filename = `${username}-inventory-${Date.now()}.png`;
      } else {
        return;
      }
      const pngDataUrl = await convertShareImageToPNG(svgDataUrl);
      downloadShareImage(pngDataUrl, filename);
    } catch (error) {
      log.error("Error generating PNG share image", "ShareModal", error, { type, username });
    } finally {
      setGeneratingImage(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-share-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-share-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
        "Share ",
        type === "collection" ? "Collection" : type === "template" ? "Template" : type === "achievement" ? "Achievement" : "NFT"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-content", children: [
      imageUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview share-modal-preview", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: imageUrl, alt: title, className: "nft-image" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: title }),
          description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: description })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-text-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-text-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "share-text", children: "Customize your message:" }),
          !defaultShareText && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "refresh-message-btn",
              onClick: regenerateMessage,
              title: "Generate new random message",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" }) })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            id: "share-text",
            value: shareText,
            onChange: (e) => setShareText(e.target.value),
            placeholder: finalDefaultText,
            className: "share-textarea",
            rows: 3
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-url-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Share URL:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "url-input-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: finalShareUrl,
              readOnly: true,
              className: "url-input"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `copy-btn ${copied ? "copied" : ""}`,
              onClick: () => copyToClipboard(finalShareUrl),
              children: [
                copied ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" })
                ] }),
                copied ? "Copied!" : "Copy"
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn twitter", onClick: shareToTwitter, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z" }) }),
          "Twitter"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn facebook", onClick: shareToFacebook, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z" }) }),
          "Facebook"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn reddit", onClick: shareToReddit, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z" }) }),
          "Reddit"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn discord", onClick: shareToDiscord, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419-.0190 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1568 2.4189Z" }) }),
          "Discord"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn telegram", onClick: shareToTelegram, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z" }) }),
          "Telegram"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn email", onClick: shareViaEmail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" }) }),
          "Email"
        ] })
      ] }),
      (type === "achievement" || type === "inventory") && username && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-image-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Generate Share Image" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "image-buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "generate-btn svg",
              onClick: generateAndDownloadShareImage,
              disabled: generatingImage,
              children: generatingImage ? "Generating..." : "Download SVG"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "generate-btn png",
              onClick: generateAndDownloadPNG,
              disabled: generatingImage,
              children: generatingImage ? "Generating..." : "Download PNG"
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
class ChatService {
  constructor() {
    __publicField(this, "CHAT_ACCOUNT", "chat.pxj");
    __publicField(this, "PXJ_CONTRACT", "pixeljourney");
    __publicField(this, "PXJ_SYMBOL", "PXJ");
    // Pricing constants
    __publicField(this, "BASE_COST_PIXAL_HOLDER", 100);
    // 100 PXJ for Pixal holders
    __publicField(this, "BASE_COST_NON_HOLDER", 1e4);
    // 10,000 PXJ for non-holders
    __publicField(this, "SPONSORED_COST_PIXAL_HOLDER", 1e4);
    // 1000 PXJ for Pixal holders (10k PXJ)
    __publicField(this, "SPONSORED_COST_NON_HOLDER", 25e3);
    // 25000 PXJ for non-holders (25k PXJ)
    // Spam prevention
    __publicField(this, "MIN_MESSAGE_COST", 100);
    // 100 PXJ minimum (aligned with holder base cost)
    __publicField(this, "messageCache", /* @__PURE__ */ new Map());
    __publicField(this, "userRateLimit", /* @__PURE__ */ new Map());
    __publicField(this, "blacklistedAccounts", /* @__PURE__ */ new Set());
    // Removed duplicate bannedWords - now using moderationSettings
    __publicField(this, "moderationSettings", {
      blacklistedAccounts: [],
      bannedWords: ["spam", "scam", "hack", "phishing"],
      trustedDomains: ["wax.io", "atomichub.io", "wax.bloks.io", "pixeljourney.io"],
      maxMessageLength: 240,
      minTimeBetweenMessages: 5
    });
    __publicField(this, "userLastMessageTime", /* @__PURE__ */ new Map());
  }
  /**
   * Calculate the cost to send a message based on length and user privileges
   */
  async calculateMessageCost(message, userAccount, isSponsored = false) {
    const characterCount = message.length;
    const hasPixalPFP = await this.checkPixalPFPOwnership(userAccount);
    if (isSponsored) {
      const sponsoredCost = hasPixalPFP ? this.SPONSORED_COST_PIXAL_HOLDER : this.SPONSORED_COST_NON_HOLDER;
      const discount2 = hasPixalPFP ? 60 : 0;
      return {
        baseCost: sponsoredCost,
        characterCost: 0,
        totalCost: sponsoredCost,
        hasPixalPFP,
        discount: discount2,
        isSponsored: true
      };
    }
    const baseCost = hasPixalPFP ? this.BASE_COST_PIXAL_HOLDER : this.BASE_COST_NON_HOLDER;
    let characterMultiplier = 1;
    if (characterCount > 50) {
      characterMultiplier = 1 + (characterCount - 50) / 50;
    }
    const characterCost = Math.floor(baseCost * (characterMultiplier - 1));
    const totalCost = Math.max(this.MIN_MESSAGE_COST, baseCost + characterCost);
    const maxCostForHolders = hasPixalPFP ? 5e4 : totalCost;
    const finalCost = hasPixalPFP ? Math.min(totalCost, maxCostForHolders) : totalCost;
    const discount = hasPixalPFP ? 99 : 0;
    return {
      baseCost,
      characterCost,
      totalCost: finalCost,
      hasPixalPFP,
      discount,
      isSponsored: false
    };
  }
  /**
   * Check if user owns a Pixal PFP NFT (template 781515)
   */
  async checkPixalPFPOwnership(userAccount) {
    try {
      const assets = await apiService.getUserInventory(userAccount);
      if (!assets || assets.length === 0) {
        return false;
      }
      const hasPixalPFP = assets.some(
        (asset) => asset.template_id === "781515"
      );
      return hasPixalPFP;
    } catch (error) {
      ErrorMessageService.logError("ChatService.checkPixalPFPOwnership", error, { userAccount });
      return false;
    }
  }
  /**
   * Send a chat message by transferring PXJ with memo
   */
  async sendMessage(message, userAccount, collectionTag, isSponsored = false) {
    this.validateMessageForSending(message, userAccount);
    const costInfo = await this.calculateMessageCost(message, userAccount);
    let finalCost = costInfo.totalCost;
    let memo = message;
    if (isSponsored) {
      const hasPixalPFP = await this.checkPixalPFPOwnership(userAccount);
      finalCost = hasPixalPFP ? this.SPONSORED_COST_PIXAL_HOLDER : this.SPONSORED_COST_NON_HOLDER;
      memo = `::sponsored:: ${message}`;
    }
    if (collectionTag) {
      memo = `::col:${collectionTag}:: ${memo}`;
    }
    this.userLastMessageTime.set(userAccount, Date.now());
    const transferAction = {
      account: this.PXJ_CONTRACT,
      name: "transfer",
      authorization: [{
        actor: userAccount,
        permission: "active"
      }],
      data: {
        from: userAccount,
        to: this.CHAT_ACCOUNT,
        quantity: `${finalCost.toFixed(8)} ${this.PXJ_SYMBOL}`,
        memo
      }
    };
    try {
      const result = await wharfKitService.transact([transferAction]);
      let transactionId = null;
      if (result) {
        transactionId = result.transaction_id || result.id || result.processed?.id || result.processed?.transaction_id || result.response && result.response.transaction_id || result.transaction && result.transaction.id;
      }
      if (transactionId) {
        this.updateRateLimit(userAccount);
        this.messageCache.clear();
        return transactionId;
      } else {
        log.warn("Unexpected transaction result format", "ChatService.sendMessage", { result });
        throw new Error("Transaction completed but transaction ID not found in response");
      }
    } catch (error) {
      if (error instanceof Error && error.message.includes("transaction ID not found")) {
        log.warn("Transaction may have succeeded but response format was unexpected", "ChatService.sendMessage", { error });
      }
      ErrorMessageService.logError("ChatService.sendMessage", error, { messageLength: message.length });
      throw new Error(`Failed to send message: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Fetch chat messages from blockchain
   */
  async getMessages(filters = {}, limit = 50, offset = 0) {
    const cacheKey = JSON.stringify({ filters, limit, offset });
    if (this.messageCache.has(cacheKey)) {
      return this.messageCache.get(cacheKey);
    }
    try {
      const transfers = await apiService.getAccountTransfers(
        this.CHAT_ACCOUNT,
        this.PXJ_CONTRACT,
        this.PXJ_SYMBOL,
        limit,
        offset
      );
      if (!transfers || transfers.length === 0) {
        return [];
      }
      const messages = [];
      for (const transfer of transfers) {
        const message = this.parseTransferToMessage(transfer);
        if (message && this.applyFilters(message, filters) && !this.isMessageBlockedByModeration(message)) {
          messages.push(message);
        }
      }
      messages.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
      this.messageCache.set(cacheKey, messages);
      return messages;
    } catch (error) {
      ErrorMessageService.logError("ChatService.loadMessages", error);
      return [];
    }
  }
  /**
   * Parse a blockchain transfer into a chat message
   */
  parseTransferToMessage(transfer) {
    try {
      const memo = String(transfer.memo || "");
      const sender = transfer.from;
      const amount = transfer.quantity;
      const timestamp = transfer.timestamp;
      const transactionId = transfer.transaction_id;
      if (this.blacklistedAccounts.has(sender)) {
        return null;
      }
      let message = memo;
      let isSponsored = false;
      let collectionTag;
      let messageType = "normal";
      if (memo.startsWith("::sponsored::")) {
        const pxjAmount2 = parseFloat(amount.split(" ")[0]);
        const minSponsoredAmount = 1e3;
        if (pxjAmount2 >= minSponsoredAmount) {
          isSponsored = true;
          messageType = "sponsored";
          message = memo.replace("::sponsored::", "").trim();
        } else {
          message = memo.replace("::sponsored::", "").trim();
        }
      }
      const collectionMatch = memo.match(/::col:([^:]+)::/);
      if (collectionMatch) {
        collectionTag = collectionMatch[1];
        message = message.replace(collectionMatch[0], "").trim();
      }
      const pxjAmount = parseFloat(amount.split(" ")[0]);
      if (pxjAmount >= 10) {
        messageType = "premium";
      }
      return {
        id: `${transactionId}_${sender}`,
        sender,
        message,
        timestamp,
        pxjAmount: amount,
        transactionId,
        isSponsored,
        collectionTag,
        messageType,
        characterCount: message.length
      };
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error("Failed to parse transfer to message");
      ErrorMessageService.logError("ChatService.parseTransferToMessage", errorObj, {
        transfer: transfer?.transaction_id || "unknown"
      });
      return null;
    }
  }
  /**
   * Apply filters to messages
   */
  applyFilters(message, filters) {
    if (filters.collection && message.collectionTag !== filters.collection) {
      return false;
    }
    if (filters.minPxjAmount) {
      const amount = parseFloat(message.pxjAmount.split(" ")[0]);
      if (amount < filters.minPxjAmount) {
        return false;
      }
    }
    if (filters.maxPxjAmount) {
      const amount = parseFloat(message.pxjAmount.split(" ")[0]);
      if (amount > filters.maxPxjAmount) {
        return false;
      }
    }
    if (filters.hideSpam && this.isSpamMessage(message)) {
      return false;
    }
    if (filters.showOnlySponsored && !message.isSponsored) {
      return false;
    }
    return true;
  }
  /**
   * Check if message is spam
   */
  isSpamMessage(message) {
    const text = message.message.toLowerCase();
    return this.moderationSettings.bannedWords.some((word) => text.includes(word));
  }
  /**
   * Update rate limit for user
   */
  updateRateLimit(userAccount) {
    const now = Date.now();
    const userMessages = this.userRateLimit.get(userAccount) || [];
    userMessages.push(now);
    this.userRateLimit.set(userAccount, userMessages);
  }
  /**
   * Add account to blacklist
   */
  blacklistAccount(account) {
    this.blacklistedAccounts.add(account);
  }
  /**
   * Remove account from blacklist
   */
  unblacklistAccount(account) {
    this.blacklistedAccounts.delete(account);
  }
  /**
   * Clear message cache
   */
  clearCache() {
    this.messageCache.clear();
  }
  /**
   * Get user's avatar URL (Wax profile or Pixal PFP)
   */
  async getUserAvatar(userAccount) {
    try {
      const inventory = await apiService.getUserInventory(userAccount);
      const pixalAssets = inventory.filter((asset) => asset.collection === "pixeljourney" && asset.schema === "Pixal");
      if (pixalAssets && pixalAssets.length > 0) {
        const asset = pixalAssets[0];
        if (asset.traits && asset.traits.img && typeof asset.traits.img === "string") {
          return `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${asset.traits.img.startsWith("Qm") ? asset.traits.img : asset.traits.img}`;
        }
      }
      return `${API_ENDPOINTS.AVATAR.DICEBEAR}?seed=${userAccount}`;
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error("Failed to get user avatar");
      ErrorMessageService.logError("ChatService.getUserAvatar", errorObj, {
        userAccount
      });
      return `${API_ENDPOINTS.AVATAR.DICEBEAR}?seed=${userAccount}`;
    }
  }
  /**
   * Enhanced message validation for sending
   */
  validateMessageForSending(message, userAccount) {
    if (this.moderationSettings.blacklistedAccounts.includes(userAccount)) {
      throw new Error("Account is blacklisted from sending messages.");
    }
    if (message.length > this.moderationSettings.maxMessageLength) {
      throw new Error(`Message too long. Maximum ${this.moderationSettings.maxMessageLength} characters allowed.`);
    }
    const lowerMessage = message.toLowerCase();
    for (const bannedWord of this.moderationSettings.bannedWords) {
      if (lowerMessage.includes(bannedWord.toLowerCase())) {
        throw new Error("Message contains prohibited content.");
      }
    }
    const lastMessageTime = this.userLastMessageTime.get(userAccount);
    if (lastMessageTime) {
      const timeDiff = (Date.now() - lastMessageTime) / 1e3;
      if (timeDiff < this.moderationSettings.minTimeBetweenMessages) {
        throw new Error(`Please wait ${this.moderationSettings.minTimeBetweenMessages - Math.floor(timeDiff)} more seconds before sending another message.`);
      }
    }
    this.verifyLinksInMessage(message);
  }
  /**
   * Check if message is blocked by moderation settings
   */
  isMessageBlockedByModeration(message) {
    if (this.moderationSettings.blacklistedAccounts.includes(message.sender)) {
      return true;
    }
    const lowerMessage = message.message.toLowerCase();
    for (const bannedWord of this.moderationSettings.bannedWords) {
      if (lowerMessage.includes(bannedWord.toLowerCase())) {
        return true;
      }
    }
    return false;
  }
  /**
   * Verify links in message against trusted domains
   */
  verifyLinksInMessage(message) {
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    const urls = message.match(urlRegex);
    if (urls) {
      for (const url of urls) {
        try {
          const urlObj = new URL(url);
          const domain = urlObj.hostname.toLowerCase();
          const isTrusted = this.moderationSettings.trustedDomains.some(
            (trustedDomain) => domain === trustedDomain.toLowerCase() || domain.endsWith("." + trustedDomain.toLowerCase())
          );
          if (!isTrusted) {
            throw new Error(`Links to ${domain} are not allowed. Only trusted domains are permitted.`);
          }
        } catch (error) {
          if (error instanceof Error && error.message.includes("not allowed")) {
            throw error;
          }
          throw new Error("Invalid URL detected in message.");
        }
      }
    }
  }
  /**
   * Update moderation settings
   */
  updateModerationSettings(settings) {
    this.moderationSettings = { ...this.moderationSettings, ...settings };
  }
  /**
   * Get current moderation settings
   */
  getModerationSettings() {
    return { ...this.moderationSettings };
  }
}
const chatService = new ChatService();
const ALLOWED_TAGS = ["strong", "em", "b", "i", "u", "br", "p", "span"];
const ALLOWED_ATTRIBUTES = {
  "span": ["class"],
  "p": ["class"]
};
function sanitizeHtml(html) {
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = html;
  sanitizeElement(tempDiv);
  return tempDiv.innerHTML;
}
function sanitizeElement(element) {
  const children = Array.from(element.children);
  for (const child of children) {
    const tagName = child.tagName.toLowerCase();
    if (!ALLOWED_TAGS.includes(tagName)) {
      const textNode = document.createTextNode(child.textContent || "");
      child.parentNode?.replaceChild(textNode, child);
      continue;
    }
    const allowedAttrs = ALLOWED_ATTRIBUTES[tagName] || [];
    const attributes = Array.from(child.attributes);
    for (const attr of attributes) {
      if (!allowedAttrs.includes(attr.name)) {
        child.removeAttribute(attr.name);
      }
    }
    sanitizeElement(child);
  }
}
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}
function formatSafeMarkdown(content) {
  const escaped = escapeHtml(content);
  const formatted = escaped.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>").replace(/\n/g, "<br>");
  return sanitizeHtml(formatted);
}
const ListingChatModal = ({ isOpen, onClose, nft }) => {
  const { account, session } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  const messagesEndRef = reactExports.useRef(null);
  const [messages, setMessages] = reactExports.useState([]);
  const [newMessage, setNewMessage] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [isSending, setIsSending] = reactExports.useState(false);
  const [costInfo, setCostInfo] = reactExports.useState(null);
  const [showPriceInfo, setShowPriceInfo] = reactExports.useState(false);
  const listingTag = `listing:${nft.sale_id || nft.asset_id}`;
  const scrollToBottom = reactExports.useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, []);
  const loadMessages = reactExports.useCallback(async (refresh = false) => {
    if (!refresh && messages.length > 0) return;
    setIsLoading(true);
    try {
      const listingMessages = await chatService.getMessages({
        collection: listingTag,
        hideSpam: true
      }, 50);
      setMessages(listingMessages);
    } catch (error) {
      console.error("Error loading listing messages:", error);
      showError("Failed to load messages");
    } finally {
      setIsLoading(false);
    }
  }, [listingTag, messages.length, showError]);
  const updateCostInfo = reactExports.useCallback(async () => {
    if (!account || !newMessage.trim()) {
      setCostInfo(null);
      return;
    }
    try {
      const cost = await chatService.calculateMessageCost(newMessage, account);
      setCostInfo(cost);
    } catch (error) {
      console.error("Error calculating cost:", error);
    }
  }, [account, newMessage]);
  const sendMessage = async () => {
    if (!account || !newMessage.trim() || !session) {
      showError("Please connect your wallet to send messages");
      return;
    }
    if (!nft.seller) {
      showError("Seller information not available");
      return;
    }
    if (nft.seller === WharfKitService.safeGetActor(session)) {
      showError("You cannot message yourself");
      return;
    }
    setIsSending(true);
    try {
      const messageWithTags = `${listingTag} :${nft.seller}: ${newMessage.trim()}`;
      const txId = await chatService.sendMessage(
        messageWithTags,
        account
      );
      showSuccess("Message sent!", `Transaction: ${txId.substring(0, 8)}...`);
      setNewMessage("");
      setCostInfo(null);
      setTimeout(() => {
        loadMessages(true);
      }, 2e3);
    } catch (error) {
      console.error("Error sending message:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (errorMessage.includes("transaction ID not found")) {
        showError(
          "Message Status Unclear",
          "Your message may have been sent successfully. Please check your transaction history or refresh the chat to confirm."
        );
      } else {
        showError("Failed to send message", errorMessage);
      }
    } finally {
      setIsSending(false);
    }
  };
  reactExports.useEffect(() => {
    if (isOpen) {
      loadMessages();
    }
  }, [isOpen, loadMessages]);
  reactExports.useEffect(() => {
    const debounceTimer = setTimeout(updateCostInfo, 300);
    return () => clearTimeout(debounceTimer);
  }, [updateCostInfo]);
  reactExports.useEffect(() => {
    scrollToBottom();
  }, [messages, scrollToBottom]);
  reactExports.useEffect(() => {
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener("keydown", handleEscape);
      return () => document.removeEventListener("keydown", handleEscape);
    }
  }, [isOpen, onClose]);
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-chat-modal-backdrop", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-chat-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-chat-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-chat-header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: nft.image || "/placeholder-nft.png",
            alt: nft.name,
            className: "listing-nft-image"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "listing-title", children: nft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "listing-seller", children: [
            "Seller: ",
            nft.seller
          ] }),
          nft.price && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "listing-price", children: nft.price })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-chat-header-right", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "chat_btn chat_btn--icon",
            onClick: () => loadMessages(true),
            disabled: isLoading,
            title: "Refresh messages",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `chat_refresh-icon ${isLoading ? "chat_refresh-icon--spinning" : ""}`, children: "" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "chat_btn chat_btn--icon",
            onClick: onClose,
            title: "Close chat",
            children: ""
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-chat-messages", children: [
      isLoading && messages.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_loading", children: "Loading messages..." }) : messages.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_empty", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No messages yet for this listing." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Be the first to start the conversation!" })
      ] }) : messages.map((message) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `chat_message chat_message--${message.messageType || "normal"}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_message-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_message-avatar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: `https://wax.atomichub.io/v1/accounts/${message.sender}/avatar`,
              alt: message.sender,
              className: "chat_avatar",
              onError: (e) => {
                const target = e.target;
                target.src = "/default-avatar.png";
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_message-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_sender", children: message.sender }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_timestamp", children: new Date(message.timestamp).toLocaleString() }),
            message.pxjAmount && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_amount", children: message.pxjAmount })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_message-actions", children: message.transactionId && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: `https://waxblock.io/transaction/${message.transactionId}`,
              target: "_blank",
              rel: "noopener noreferrer",
              className: "chat_tx-link",
              title: "View transaction",
              children: ""
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "chat_message-content",
            dangerouslySetInnerHTML: { __html: formatSafeMarkdown(message.message) }
          }
        )
      ] }, message.id)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: messagesEndRef })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-chat-input-section", children: [
      costInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_cost-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_cost-display", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "Message Cost: ",
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "chat_cost-amount", children: [
              (costInfo.totalCost / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "chat_info-btn",
              onClick: () => setShowPriceInfo(!showPriceInfo),
              title: "View price breakdown",
              children: ""
            }
          )
        ] }),
        costInfo.hasPixalPFP && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "chat_discount", children: [
          "Pixal PFP Discount: ",
          costInfo.discount,
          "%"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "chat_char-count", children: [
          newMessage.length,
          "/240 chars"
        ] }),
        showPriceInfo && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_price-tooltip", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_price-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Price Breakdown" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-factor", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Base Cost:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              (costInfo.baseCost / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-factor", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Character Cost (",
              newMessage.length,
              " chars):"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              ((costInfo.totalCost - costInfo.baseCost) / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] }),
          costInfo.hasPixalPFP && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-factor discount", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Pixal PFP Discount (",
              costInfo.discount,
              "%):"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "-",
              ((costInfo.baseCost + (costInfo.totalCost - costInfo.baseCost)) * (costInfo.discount / 100) / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-factor total", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Total:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              (costInfo.totalCost / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-chat-input-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: "listing-chat-input",
            value: newMessage,
            onChange: (e) => setNewMessage(e.target.value),
            placeholder: `Send a message about ${nft.name}...`,
            maxLength: 240,
            rows: 3,
            onKeyDown: (e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "listing-chat-send-btn",
            onClick: sendMessage,
            disabled: !newMessage.trim() || isSending || !account,
            children: isSending ? "" : ""
          }
        )
      ] }),
      !account && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-chat-connect-notice", children: "Please connect your wallet to send messages" })
    ] })
  ] }) });
};
const getIPFSUrl = (hash) => {
  const gateways = API_ENDPOINTS.IPFS.GATEWAYS;
  const randomGateway = gateways[Math.floor(Math.random() * gateways.length)];
  return `${randomGateway}${hash}`;
};
const getAssetImageUrl = (asset) => {
  if (!asset) return void 0;
  if (asset.image && typeof asset.image === "string") {
    return asset.image;
  }
  let imgData;
  if (asset.data && typeof asset.data === "object" && "img" in asset.data) {
    imgData = asset.data.img;
  }
  if (!imgData) {
    imgData = asset.template?.immutable_data?.img || asset.img;
  }
  if (!imgData) return void 0;
  if (typeof imgData === "string") {
    if (imgData.startsWith("http")) return imgData;
    if (imgData.startsWith("Qm")) return getIPFSUrl(imgData);
    return imgData;
  }
  return void 0;
};
const getAssetVideoUrl = (asset) => {
  if (!asset) return null;
  if (asset.video && typeof asset.video === "string") {
    return asset.video;
  }
  let videoData;
  if (asset.data && typeof asset.data === "object" && "video" in asset.data) {
    videoData = asset.data.video;
  }
  if (!videoData) {
    videoData = asset.template?.immutable_data?.video || asset.video;
  }
  if (!videoData) return null;
  if (typeof videoData === "string") {
    if (videoData.startsWith("http")) return videoData;
    if (videoData.startsWith("Qm")) return getIPFSUrl(videoData);
    return videoData;
  }
  return null;
};
const getTemplateImageUrl = (template) => {
  if (!template) return void 0;
  const imgData = template.immutable_data?.img || template.data?.img || template.img || template.template?.immutable_data?.img;
  if (!imgData) return void 0;
  if (typeof imgData === "string") {
    if (imgData.startsWith("http")) return imgData;
    if (imgData.startsWith("Qm")) return getIPFSUrl(imgData);
    return imgData;
  }
  return void 0;
};
const getTemplateVideoUrl = (template) => {
  if (!template) return null;
  const videoData = template.immutable_data?.video || template.data?.video || template.video || template.template?.immutable_data?.video;
  if (!videoData) return null;
  if (typeof videoData === "string") {
    if (videoData.startsWith("http")) return videoData;
    if (videoData.startsWith("Qm")) return getIPFSUrl(videoData);
    return videoData;
  }
  return null;
};
const getSaleAssetImageUrl = (sale) => {
  const asset = sale?.assets?.[0];
  return getAssetImageUrl(asset);
};
const getSaleAssetVideoUrl = (sale) => {
  const asset = sale?.assets?.[0];
  return getAssetVideoUrl(asset);
};
const createIPFSUrl = (hash) => {
  if (!hash) return "";
  if (hash.startsWith("http")) return hash;
  return getIPFSUrl(hash);
};
const NFTDetailsModal = ({ nft, isOpen, onClose, usdPrice }) => {
  const navigate = useNavigate();
  const { settings } = useDisplaySettings();
  const [localUsdPrice, setLocalUsdPrice] = reactExports.useState("$0.00");
  const [isInCart, setIsInCart] = reactExports.useState(false);
  const [isInWatchlist, setIsInWatchlist] = reactExports.useState(false);
  const [showShareModal, setShowShareModal] = reactExports.useState(false);
  const [showSendOfferModal, setShowSendOfferModal] = reactExports.useState(false);
  const [showChatModal, setShowChatModal] = reactExports.useState(false);
  const [session, setSession] = reactExports.useState(null);
  const { isConnected, purchaseNFT, login } = useWallet$1();
  const { showSuccess, showError, showWarning } = useNotifications();
  const [collectionStats, setCollectionStats] = reactExports.useState(null);
  const [recentActivity, setRecentActivity] = reactExports.useState([]);
  const [priceHistory, setPriceHistory] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const initSession = async () => {
      try {
        const currentSession = wharfKitService.getSession();
        if (currentSession) {
          setSession({
            ...currentSession,
            actor: WharfKitService.safeGetActor(currentSession)
          });
        } else {
          setSession(null);
        }
      } catch (error) {
        log.info("No active session", "NFTDetailsModal", error);
      }
    };
    initSession();
  }, []);
  reactExports.useEffect(() => {
    if (isOpen && nft) {
      fetchCollectionStats();
      fetchRecentActivity();
      fetchPriceHistory();
    }
  }, [isOpen, nft]);
  const fetchCollectionStats = async () => {
    if (!nft?.collection) return;
    try {
      const stats = await apiService.getCollectionStats(nft.collection);
      if (stats) {
        setCollectionStats({
          floorPrice: stats.floor_price || "0",
          volume24h: stats.volume_24h || "0",
          totalSales: stats.sales || "0",
          avgPrice: stats.averagePrice || "0"
        });
      }
    } catch (error) {
      log.error("Error fetching collection stats", "NFTDetailsModal", error);
    }
  };
  const fetchRecentActivity = async () => {
    if (!nft?.collection) return;
    try {
      const recentSales = await apiService.getSales({
        collection_name: nft.collection,
        state: "3",
        // completed sales
        limit: 5,
        sort: "updated",
        order: "desc"
      });
      if (recentSales.success && recentSales.data) {
        const activities = recentSales.data.map((sale) => ({
          type: "sale",
          price: `${(parseFloat(sale.price?.amount || "0") / Math.pow(10, sale.price?.token_precision || 8)).toFixed(4)} ${sale.price?.token_symbol || "WAX"}`,
          time: new Date(parseInt(sale.updated_at_time) * 1e3).toLocaleString()
        }));
        setRecentActivity(activities);
      }
    } catch (error) {
      log.error("Error fetching recent activity", "NFTDetailsModal", error);
    }
  };
  const fetchPriceHistory = async () => {
    if (!nft?.collection) return;
    try {
      const history = await apiService.getCollectionPriceHistory(nft.collection, "7d");
      setPriceHistory(history);
    } catch (error) {
      log.error("Error fetching price history", "NFTDetailsModal", error);
      setPriceHistory([]);
    }
  };
  const handleMessageSeller = () => {
    setShowChatModal(true);
  };
  reactExports.useEffect(() => {
    if (nft && !usdPrice && nft.price) {
      priceService.convertWaxToUSDAsync(nft.price).then(setLocalUsdPrice);
    }
  }, [nft, usdPrice]);
  reactExports.useEffect(() => {
    const checkStatus = async () => {
      if (nft) {
        const cart = cartService.getCart();
        setIsInCart(cart.some((item) => item.nft.asset_id === nft.asset_id));
        const watchlist = await watchlistService.getWatchlist();
        setIsInWatchlist(watchlist.some((item) => item.nft.asset_id === nft.asset_id));
      }
    };
    checkStatus();
  }, [nft]);
  reactExports.useEffect(() => {
    const updateCartStatus = () => {
      if (nft) {
        const cart = cartService.getCart();
        setIsInCart(cart.some((item) => item.nft.asset_id === nft.asset_id));
      }
    };
    const updateWatchlistStatus = async () => {
      if (nft) {
        const watchlist = await watchlistService.getWatchlist();
        setIsInWatchlist(watchlist.some((item) => item.nft.asset_id === nft.asset_id));
      }
    };
    cartService.addListener(updateCartStatus);
    const unsubscribeWatchlist = watchlistService.subscribe(updateWatchlistStatus);
    return () => {
      cartService.removeListener(updateCartStatus);
      unsubscribeWatchlist();
    };
  }, [nft]);
  const handleCollectionClick = () => {
    if (!nft) return;
    onClose();
    navigate(`/collections/${nft.collection}`);
  };
  const handleSchemaClick = () => {
    if (!nft) return;
    window.open(`https://wax.atomichub.io/explorer/schema/wax-mainnet/${nft.collection}/${nft.schema}`, "_blank");
  };
  const handleAssetClick = () => {
    if (!nft) return;
    onClose();
    navigate(`/assets/${nft.asset_id}`);
  };
  const handleSellerClick = () => {
    if (!nft || !nft.seller) return;
    onClose();
    navigate(`/user-profile-lookup?user=${encodeURIComponent(nft.seller)}`);
  };
  if (!isOpen || !nft) return null;
  const handleBackdropClick = (e) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };
  const formatTraits = (traits) => {
    return Object.entries(traits).filter(
      ([key, value]) => key !== "img" && key !== "video" && key !== "name" && value !== null && value !== void 0
    );
  };
  const handleBuyNow = async () => {
    if (!isConnected) {
      try {
        await login();
      } catch (error) {
        log.error("Login failed", "NFTDetailsModal", error);
        return;
      }
    }
    if (!nft.sale_id) {
      showWarning("This NFT is not for sale");
      return;
    }
    if (!nft.sale_id || !nft.price) {
      showError("NFT is not available for purchase");
      return;
    }
    try {
      const priceValue = nft.price.replace(" WAX", "");
      await purchaseNFT(nft.sale_id, priceValue);
      showSuccess("Purchase successful!");
      onClose();
    } catch (error) {
      log.error("Purchase failed", "NFTDetailsModal", error);
      showError("Purchase failed. Please try again.");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-backdrop", onClick: handleBackdropClick, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content nft-details-modal", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "modal-title", children: nft.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-details-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-details-top", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-media-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-media-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: getAssetImageUrl(nft),
              videoUrl: getAssetVideoUrl(nft),
              alt: nft.name,
              className: "nft-media",
              controls: true,
              loop: true,
              muted: true,
              enableAnimations: settings.enableAnimatedNFTs
            }
          ),
          (nft.template_mint || nft.max_supply) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mint-info", children: [
            "Mint: ",
            nft.template_mint !== void 0 && nft.template_mint !== null ? nft.template_mint : "?",
            " / ",
            nft.max_supply === "0" || nft.max_supply === void 0 || nft.max_supply === null ? "" : nft.max_supply
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "info-title", children: "Basic Information" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-label", children: "Collection:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-value info-link", onClick: handleCollectionClick, title: "View collection on AtomicHub", children: nft.collection })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-label", children: "Schema:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-value info-link", onClick: handleSchemaClick, title: "View schema on AtomicHub", children: nft.schema })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-label", children: "Asset ID:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-value info-link", onClick: handleAssetClick, title: "View asset on AtomicHub", children: nft.asset_id })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-label", children: "Seller:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-value info-link", onClick: handleSellerClick, title: "View seller profile", children: nft.seller })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "info-title", children: "Price Information" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-display", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-main", children: nft.price }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-usd", children: usdPrice || localUsdPrice })
            ] })
          ] }),
          nft.traits && Object.keys(nft.traits).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "info-title", children: "Attributes" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attributes-grid", children: formatTraits(nft.traits).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attribute-label", children: key }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attribute-value", children: String(value) })
            ] }, key)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "info-title", children: "Statistics" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-statistics", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-grid", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Floor Price" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: collectionStats ? `${parseFloat(collectionStats.floorPrice).toFixed(4)} WAX` : "Loading..." })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "24h Volume" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: collectionStats ? `${parseFloat(collectionStats.volume24h).toFixed(2)} WAX` : "Loading..." })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Total Sales" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: collectionStats ? collectionStats.totalSales : "Loading..." })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Avg Sale Price" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: collectionStats ? `${parseFloat(collectionStats.avgPrice).toFixed(4)} WAX` : "Loading..." })
              ] })
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-details-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "info-title", children: "Price History & Activity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-statistics", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-history-section", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "price-history-title", children: "Recent Price History" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-history-chart", children: priceHistory.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chart-placeholder", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 400 120", className: "price-chart", children: [
                  [0, 1, 2, 3, 4].map((i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "line",
                    {
                      x1: "20",
                      y1: 20 + i * 20,
                      x2: "380",
                      y2: 20 + i * 20,
                      stroke: "var(--border-color)",
                      strokeWidth: "1",
                      opacity: "0.3"
                    },
                    `grid-${i}`
                  )),
                  priceHistory.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "polyline",
                    {
                      fill: "none",
                      stroke: "var(--accent-color)",
                      strokeWidth: "2",
                      points: priceHistory.map((point, index) => {
                        const x = 20 + index / (priceHistory.length - 1) * 360;
                        const maxPrice = Math.max(...priceHistory.map((p) => p.price));
                        const minPrice = Math.min(...priceHistory.map((p) => p.price));
                        const priceRange = maxPrice - minPrice || 1;
                        const y = 100 - (point.price - minPrice) / priceRange * 60;
                        return `${x},${y}`;
                      }).join(" ")
                    }
                  ),
                  priceHistory.map((point, index) => {
                    const x = 20 + index / (priceHistory.length - 1) * 360;
                    const maxPrice = Math.max(...priceHistory.map((p) => p.price));
                    const minPrice = Math.min(...priceHistory.map((p) => p.price));
                    const priceRange = maxPrice - minPrice || 1;
                    const y = 100 - (point.price - minPrice) / priceRange * 60;
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "circle",
                      {
                        cx: x,
                        cy: y,
                        r: "3",
                        fill: "var(--accent-color)"
                      },
                      index
                    );
                  })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chart-labels", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: priceHistory.length > 0 ? new Date(priceHistory[0].timestamp).toLocaleDateString() : "7d ago" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: priceHistory.length > 0 ? new Date(priceHistory[priceHistory.length - 1].timestamp).toLocaleDateString() : "Now" })
                ] })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chart-placeholder", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-chart", children: "Loading price history..." }) }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "trading-activity", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "activity-title", children: "Recent Activity" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "activity-list", children: recentActivity.length > 0 ? recentActivity.map((activity, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `activity-type ${activity.type}`, children: activity.type === "sale" ? "Sale" : "Listed" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "activity-price", children: activity.price }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "activity-time", children: activity.time })
              ] }, index)) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "activity-type", children: "Loading..." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "activity-price", children: "-" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "activity-time", children: "-" })
              ] }) })
            ] })
          ] })
        ] }) })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-actions-left", children: nft.sale_id ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "listing-btn-buy-now",
              onClick: handleBuyNow,
              title: `Buy now for ${nft.price} WAX`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
                "Buy Now"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "btn-secondary",
              onClick: () => setShowSendOfferModal(true),
              title: "Make Offer",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 -8 72 72", fill: "currentColor", style: { width: "24px", height: "24px", marginRight: "8px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M64,12.78v17s-3.63.71-4.38.81-3.08.85-4.78-.78C52.22,27.25,42.93,18,42.93,18a3.54,3.54,0,0,0-4.18-.21c-2.36,1.24-5.87,3.07-7.33,3.78a3.37,3.37,0,0,1-5.06-2.64,3.44,3.44,0,0,1,2.1-3c3.33-2,10.36-6,13.29-7.52,1.78-1,3.06-1,5.51,1C50.27,12,53,14.27,53,14.27a2.75,2.75,0,0,0,2.26.43C58.63,14,64,12.78,64,12.78ZM27,41.5a3,3,0,0,0-3.55-4.09,3.07,3.07,0,0,0-.64-3,3.13,3.13,0,0,0-3-.75,3.07,3.07,0,0,0-.65-3,3.38,3.38,0,0,0-4.72.13c-1.38,1.32-2.27,3.72-1,5.14s2.64.55,3.72.3c-.3,1.07-1.2,2.07-.09,3.47s2.64.55,3.72.3c-.3,1.07-1.16,2.16-.1,3.46s2.84.61,4,.25c-.45,1.15-1.41,2.39-.18,3.79s4.08.75,5.47-.58a3.32,3.32,0,0,0,.3-4.68A3.18,3.18,0,0,0,27,41.5Zm25.35-8.82L41.62,22a3.53,3.53,0,0,0-3.77-.68c-1.5.66-3.43,1.56-4.89,2.24a8.15,8.15,0,0,1-3.29,1.1,5.59,5.59,0,0,1-3-10.34C29,12.73,34.09,10,34.09,10a6.46,6.46,0,0,0-5-2C25.67,8,18.51,12.7,18.51,12.7a5.61,5.61,0,0,1-4.93.13L8,10.89v19.4s1.59.46,3,1a6.33,6.33,0,0,1,1.56-2.47,6.17,6.17,0,0,1,8.48-.06,5.4,5.4,0,0,1,1.34,2.37,5.49,5.49,0,0,1,2.29,1.4A5.4,5.4,0,0,1,26,34.94a5.47,5.47,0,0,1,3.71,4,5.38,5.38,0,0,1,2.39,1.43,5.65,5.65,0,0,1,1.48,4.89a0,0,0,0,1,0,0s.8.9,1.29,1.39a2.46,2.46,0,0,0,3.48-3.48s2,2.48,4.28,1c2-1.4,1.69-3.06.74-4a3.19,3.19,0,0,0,4.77.13,2.45,2.45,0,0,0,.13-3.3s1.33,1.81,4,.12c1.89-1.6,1-3.43,0-4.39Z" }) }),
                "Make Offer"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `btn-secondary ${isInCart ? "in-cart" : ""}`,
              onClick: () => {
                if (isInCart) {
                  cartService.removeFromCart(nft.asset_id);
                } else {
                  const added = cartService.addToCart(nft);
                  if (!added) {
                    showWarning("Item is already in your cart!");
                  }
                }
              },
              title: isInCart ? "Remove from cart" : "Add to cart",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cart-icon-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", className: "cart-icon", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "9", cy: "21", r: "1" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "20", cy: "21", r: "1" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m1 1 4 4 2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", className: "cart-action-icon", children: isInCart ? /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" })
                ] }) })
              ] })
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn-disabled", disabled: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "4.93", x2: "19.07", y2: "19.07" })
          ] }),
          "Not Available"
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions-right", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-icon btn-external",
              onClick: handleAssetClick,
              title: "View full asset details page",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
              ] })
            }
          ),
          nft?.seller && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-icon btn-message",
              onClick: () => handleMessageSeller(),
              title: "Send Direct Message (1000 PXJ)",
              disabled: !session || nft.seller === session?.actor,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `btn-icon ${isInWatchlist ? "in-watchlist" : ""}`,
              onClick: async () => {
                if (isInWatchlist) {
                  await watchlistService.removeFromWatchlist(nft.asset_id);
                } else {
                  const added = await watchlistService.addToWatchlist(nft);
                  if (!added) {
                    showWarning("Item is already in your watchlist!");
                  }
                }
              },
              title: isInWatchlist ? "Remove from watchlist" : "Add to watchlist",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: isInWatchlist ? /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z", fill: "currentColor" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-icon",
              onClick: () => setShowShareModal(true),
              title: "Share",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "16,6 12,2 8,6" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "2", x2: "12", y2: "15" })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-icon",
              onClick: onClose,
              title: "Close",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
              ] })
            }
          )
        ] })
      ] })
    ] }),
    showShareModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ShareModal,
      {
        isOpen: showShareModal,
        onClose: () => setShowShareModal(false),
        title: nft?.name || "NFT",
        description: `Check out this amazing NFT: ${nft?.name || "Unnamed NFT"}`,
        imageUrl: getAssetImageUrl(nft),
        shareUrl: `${window.location.origin}/assets/${nft?.asset_id}`,
        defaultShareText: `Check out this NFT: ${nft?.name || "Unnamed NFT"} on PxMarket!  View it at market.pixeljourney.xyz`,
        type: "nft"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SendOfferModal,
      {
        isOpen: showSendOfferModal,
        onClose: () => setShowSendOfferModal(false),
        nft
      }
    ),
    nft && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListingChatModal,
      {
        isOpen: showChatModal,
        onClose: () => setShowChatModal(false),
        nft
      }
    )
  ] });
};
const NFTComparison = ({ isOpen, onClose, initialNFTs = [] }) => {
  const [selectedNFTs, setSelectedNFTs] = reactExports.useState(initialNFTs);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [searchResults, setSearchResults] = reactExports.useState([]);
  const [isSearching, setIsSearching] = reactExports.useState(false);
  const { showWarning } = useNotifications();
  const [comparisonMetrics, setComparisonMetrics] = reactExports.useState({
    showPrice: true,
    showRarity: true,
    showAttributes: true,
    showCollection: true,
    showSeller: true
  });
  reactExports.useEffect(() => {
    if (initialNFTs.length > 0) {
      setSelectedNFTs(initialNFTs);
    }
  }, [initialNFTs]);
  const searchNFTs = async (query) => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }
    setIsSearching(true);
    try {
      const [pixelJourney, friedFactory, cryptoMuffins] = await Promise.all([
        apiService.getWaxRockPixals(20),
        apiService.getFriedFactoryNFTs(20),
        apiService.getCryptoMuffinsNFTs(20)
      ]);
      const allNFTs = [...pixelJourney, ...friedFactory, ...cryptoMuffins];
      const filtered = allNFTs.filter(
        (nft) => nft.name.toLowerCase().includes(query.toLowerCase()) || nft.collection.toLowerCase().includes(query.toLowerCase())
      );
      setSearchResults(filtered.slice(0, 10));
    } catch (error) {
      console.error("Error searching NFTs:", error);
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  };
  const addNFTToComparison = (nft) => {
    if (selectedNFTs.length >= 4) {
      showWarning("You can compare up to 4 NFTs at once", "Comparison Limit");
      return;
    }
    if (selectedNFTs.find((n) => n.asset_id === nft.asset_id)) {
      showWarning("This NFT is already in the comparison", "Duplicate NFT");
      return;
    }
    setSelectedNFTs([...selectedNFTs, nft]);
    setSearchTerm("");
    setSearchResults([]);
  };
  const removeNFTFromComparison = (assetId) => {
    setSelectedNFTs(selectedNFTs.filter((nft) => nft.asset_id !== assetId));
  };
  const toggleMetric = (metric) => {
    setComparisonMetrics((prev) => ({
      ...prev,
      [metric]: !prev[metric]
    }));
  };
  const getRarityColor = (rarity) => {
    if (!rarity) return "#666";
    switch (rarity.toLowerCase()) {
      case "common":
        return "#9CA3AF";
      case "rare":
        return "#3B82F6";
      case "epic":
        return "#8B5CF6";
      case "legendary":
        return "#F59E0B";
      case "mythic":
        return "#EF4444";
      default:
        return "#666";
    }
  };
  const getAttributeValue = (nft, attributeName) => {
    if (!nft.traits) return "N/A";
    const attr = nft.traits[attributeName];
    return attr || "N/A";
  };
  const getAllAttributes = () => {
    const allAttributes = /* @__PURE__ */ new Set();
    selectedNFTs.forEach((nft) => {
      if (nft.traits) {
        Object.keys(nft.traits).forEach((key) => {
          if (key !== "rarity") {
            allAttributes.add(key);
          }
        });
      }
    });
    return Array.from(allAttributes);
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-comparison-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-comparison-modal", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "NFT Comparison Tool" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-input-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Search NFTs to add to comparison...",
              value: searchTerm,
              onChange: (e) => {
                setSearchTerm(e.target.value);
                searchNFTs(e.target.value);
              },
              className: "search-input"
            }
          ),
          isSearching && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-loading", children: "Searching..." })
        ] }),
        searchResults.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-results", children: searchResults.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-result-item", onClick: () => addNFTToComparison(nft), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: nft.image, alt: nft.name, className: "result-image" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "result-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "result-name", children: nft.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "result-collection", children: nft.collection }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "result-price", children: nft.price })
          ] })
        ] }, nft.asset_id)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metrics-toggle", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Show Comparison Metrics:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "toggle-buttons", children: Object.entries(comparisonMetrics).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `toggle-btn ${value ? "active" : ""}`,
            onClick: () => toggleMetric(key),
            children: key.replace("show", "").replace(/([A-Z])/g, " $1").trim()
          },
          key
        )) })
      ] }),
      selectedNFTs.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "comparison-table", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-grid", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-row header-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-label", children: "NFT" }),
          selectedNFTs.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-column", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: nft.image, alt: nft.name, className: "nft-image" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-name", children: nft.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-id", children: [
                "#",
                nft.asset_id
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "remove-nft-btn",
                onClick: () => removeNFTFromComparison(nft.asset_id),
                title: "Remove from comparison",
                children: ""
              }
            )
          ] }) }, nft.asset_id))
        ] }),
        comparisonMetrics.showPrice && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-label", children: "Price" }),
          selectedNFTs.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-value price", children: nft.price }, nft.asset_id))
        ] }),
        comparisonMetrics.showRarity && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-label", children: "Rarity" }),
          selectedNFTs.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-value rarity", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "rarity-badge",
              style: { backgroundColor: getRarityColor(String(nft.traits?.rarity || "Unknown")) },
              children: nft.traits?.rarity || "Unknown"
            }
          ) }, nft.asset_id))
        ] }),
        comparisonMetrics.showCollection && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-label", children: "Collection" }),
          selectedNFTs.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-value", children: nft.collection }, nft.asset_id))
        ] }),
        comparisonMetrics.showSeller && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-label", children: "Seller" }),
          selectedNFTs.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-value", children: nft.seller }, nft.asset_id))
        ] }),
        comparisonMetrics.showAttributes && getAllAttributes().map((attributeName) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-label", children: attributeName }),
          selectedNFTs.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-value", children: getAttributeValue(nft, attributeName) }, nft.asset_id))
        ] }, attributeName))
      ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-comparison", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No NFTs to Compare" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Search and add NFTs above to start comparing their attributes, prices, and more." })
      ] })
    ] })
  ] }) });
};
const SocialShare = ({ nft, isOpen, onClose }) => {
  const [copied, setCopied] = reactExports.useState(false);
  const [shareText, setShareText] = reactExports.useState("");
  const { showSuccess } = useNotifications();
  const shareMessages = [
    ` Check out this amazing NFT: ${nft.name} from ${nft.collection}! `,
    ` Discovered this incredible ${nft.name} NFT! Part of the ${nft.collection} collection `,
    ` Look at this stunning ${nft.name} from ${nft.collection}! NFT art at its finest `,
    ` Found a gem! ${nft.name} from the ${nft.collection} collection is absolutely beautiful `,
    ` This ${nft.name} NFT caught my eye! Amazing work from ${nft.collection} `,
    ` Showcasing ${nft.name} - a masterpiece from ${nft.collection}! `,
    ` Blown away by this ${nft.name} NFT! ${nft.collection} never disappoints `,
    ` Step right up and see ${nft.name}! Another fantastic piece from ${nft.collection} `
  ];
  const getRandomShareText = () => {
    const randomIndex = Math.floor(Math.random() * shareMessages.length);
    return shareMessages[randomIndex];
  };
  const [defaultShareText, setDefaultShareText] = reactExports.useState(() => getRandomShareText());
  if (!isOpen) return null;
  const currentPath = window.location.pathname;
  let shareUrl = `${window.location.origin}/assets/${nft.asset_id}`;
  if (currentPath.includes("/listings/")) {
    shareUrl = window.location.href;
  }
  const regenerateMessage = () => {
    setDefaultShareText(getRandomShareText());
  };
  const copyToClipboard = async (text) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
    } catch (error) {
      log.error("Failed to copy to clipboard", "SocialShare.copyToClipboard", error);
    }
  };
  const shareToTwitter = () => {
    const text = shareText || defaultShareText;
    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(shareUrl)}&hashtags=NFT,WAX,PixelJourney`;
    window.open(twitterUrl, "_blank", "width=550,height=420");
  };
  const shareToFacebook = () => {
    const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}`;
    window.open(facebookUrl, "_blank", "width=550,height=420");
  };
  const shareToReddit = () => {
    const text = shareText || defaultShareText;
    const redditUrl = `https://reddit.com/submit?url=${encodeURIComponent(shareUrl)}&title=${encodeURIComponent(text)}`;
    window.open(redditUrl, "_blank", "width=550,height=420");
  };
  const shareToDiscord = () => {
    const text = `${shareText || defaultShareText}
${shareUrl}`;
    copyToClipboard(text);
    showSuccess("Share text copied to clipboard! You can now paste it in Discord.", "Copied to Clipboard");
  };
  const shareToTelegram = () => {
    const text = shareText || defaultShareText;
    const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(text)}`;
    window.open(telegramUrl, "_blank", "width=550,height=420");
  };
  const shareViaEmail = () => {
    const subject = `Check out this NFT: ${nft.name}`;
    const body = `${shareText || defaultShareText}

View it here: ${shareUrl}`;
    const emailUrl = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    window.location.href = emailUrl;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-share-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-share-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Share NFT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: nft.image, alt: nft.name, className: "nft-image" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: nft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: typeof nft.collection === "string" ? nft.collection : nft.collection?.collection_name || nft.collection?.name || "Unknown" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-price", children: nft.price })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-text-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-text-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "share-text", children: "Customize your message:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "refresh-message-btn",
              onClick: regenerateMessage,
              title: "Generate new random message",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" }) })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            id: "share-text",
            value: shareText,
            onChange: (e) => setShareText(e.target.value),
            placeholder: defaultShareText,
            className: "share-textarea",
            rows: 3
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-url-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Share URL:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "url-input-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: shareUrl,
              readOnly: true,
              className: "url-input"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `copy-btn ${copied ? "copied" : ""}`,
              onClick: () => copyToClipboard(shareUrl),
              children: [
                copied ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" })
                ] }),
                copied ? "Copied!" : "Copy"
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn twitter", onClick: shareToTwitter, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z" }) }),
          "Twitter"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn facebook", onClick: shareToFacebook, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z" }) }),
          "Facebook"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn reddit", onClick: shareToReddit, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z" }) }),
          "Reddit"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn discord", onClick: shareToDiscord, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419-.0190 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1568 2.4189Z" }) }),
          "Discord"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn telegram", onClick: shareToTelegram, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z" }) }),
          "Telegram"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "social-btn email", onClick: shareViaEmail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" }) }),
          "Email"
        ] })
      ] })
    ] })
  ] }) });
};
const ErrorMessage = ({
  title,
  message,
  onRetry,
  showRetry = true,
  error,
  errorConfig,
  errorType,
  isRetrying = false,
  retryCount = 0,
  maxRetries = 3
}) => {
  let finalConfig;
  if (errorConfig) {
    finalConfig = errorConfig;
  } else if (errorType) {
    finalConfig = ErrorMessageService.getMessage(errorType);
  } else if (error) {
    finalConfig = ErrorMessageService.formatError(error);
  } else {
    finalConfig = {
      title: title || "Oh no! Something went wrong",
      message: message || "We're having trouble loading the data right now. Please try again in a moment.",
      action: "Try Again"
    };
  }
  const displayTitle = title || finalConfig.title;
  const displayMessage = message || finalConfig.message;
  const actionText = isRetrying ? "Retrying..." : finalConfig.action || "Try Again";
  const getErrorIcon = () => {
    if (isRetrying) return "";
    switch (errorType) {
      case "NETWORK_ERROR":
        return "";
      case "TIMEOUT_ERROR":
        return "";
      case "API_ERROR":
        return "";
      case "LOAD_FAILED":
        return "";
      default:
        return "";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `error-message ${isRetrying ? "retrying" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-content", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `error-icon ${isRetrying ? "spinning" : ""}`, children: getErrorIcon() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "error-title", children: displayTitle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-text", children: displayMessage }),
    retryCount > 0 && !isRetrying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "retry-status", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "retry-count", children: [
      "Attempt ",
      retryCount,
      " of ",
      maxRetries
    ] }) }),
    showRetry && onRetry && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        className: `error-retry-btn ${isRetrying ? "retrying" : ""}`,
        onClick: onRetry,
        disabled: isRetrying || retryCount >= maxRetries,
        children: [
          isRetrying && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "retry-spinner" }),
          actionText
        ]
      }
    ),
    retryCount >= maxRetries && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-retries-reached", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Maximum retry attempts reached. Please refresh the page or try again later." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "error-refresh-btn",
          onClick: () => window.location.reload(),
          children: "Refresh Page"
        }
      )
    ] })
  ] }) });
};
const SEARCH_HISTORY_KEY = "pixeljourney_search_history";
const MAX_HISTORY_ITEMS = 10;
const AdvancedSearch = ({
  searchTerm,
  onSearchChange,
  suggestions = [],
  placeholder = "Search NFTs, collections, schemas...",
  showFilters = false,
  onFilterChange,
  className = ""
}) => {
  const [showSuggestions, setShowSuggestions] = reactExports.useState(false);
  const [searchHistory, setSearchHistory] = reactExports.useState([]);
  const [filters, setFilters] = reactExports.useState({
    priceRange: { min: "", max: "" },
    rarities: [],
    collections: [],
    schemas: [],
    sortBy: "relevance"
  });
  const [showAdvancedFilters, setShowAdvancedFilters] = reactExports.useState(false);
  const searchInputRef = reactExports.useRef(null);
  const suggestionsRef = reactExports.useRef(null);
  const [selectedSuggestionIndex, setSelectedSuggestionIndex] = reactExports.useState(-1);
  reactExports.useEffect(() => {
    const savedHistory = localStorage.getItem(SEARCH_HISTORY_KEY);
    if (savedHistory) {
      try {
        setSearchHistory(JSON.parse(savedHistory));
      } catch (error) {
        console.error("Failed to parse search history:", error);
      }
    }
  }, []);
  const saveToHistory = reactExports.useCallback((term) => {
    if (!term.trim() || term.length < 2) return;
    const newHistory = [term, ...searchHistory.filter((item) => item !== term)].slice(0, MAX_HISTORY_ITEMS);
    setSearchHistory(newHistory);
    localStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(newHistory));
  }, [searchHistory]);
  const clearHistory = reactExports.useCallback(() => {
    setSearchHistory([]);
    localStorage.removeItem(SEARCH_HISTORY_KEY);
  }, []);
  const handleSearchChange = reactExports.useCallback((value) => {
    onSearchChange(value);
    setSelectedSuggestionIndex(-1);
    if (value.length >= 2) {
      setShowSuggestions(true);
    } else {
      setShowSuggestions(false);
    }
  }, [onSearchChange]);
  const handleSearchSubmit = reactExports.useCallback(() => {
    if (searchTerm.trim()) {
      saveToHistory(searchTerm.trim());
      setShowSuggestions(false);
      searchInputRef.current?.blur();
    }
  }, [searchTerm, saveToHistory]);
  const handleSuggestionClick = reactExports.useCallback((suggestion) => {
    handleSearchChange(suggestion.text);
    saveToHistory(suggestion.text);
    setShowSuggestions(false);
  }, [handleSearchChange, saveToHistory]);
  const handleKeyDown = reactExports.useCallback((e) => {
    if (!showSuggestions) return;
    const allSuggestions2 = [
      ...searchHistory.map((item) => ({ text: item, type: "history" })),
      ...suggestions
    ];
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setSelectedSuggestionIndex(
          (prev) => prev < allSuggestions2.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setSelectedSuggestionIndex((prev) => prev > -1 ? prev - 1 : -1);
        break;
      case "Enter":
        e.preventDefault();
        if (selectedSuggestionIndex >= 0 && allSuggestions2[selectedSuggestionIndex]) {
          handleSuggestionClick(allSuggestions2[selectedSuggestionIndex]);
        } else {
          handleSearchSubmit();
        }
        break;
      case "Escape":
        setShowSuggestions(false);
        setSelectedSuggestionIndex(-1);
        searchInputRef.current?.blur();
        break;
    }
  }, [showSuggestions, searchHistory, suggestions, selectedSuggestionIndex, handleSuggestionClick, handleSearchSubmit]);
  const handleFilterChange = reactExports.useCallback((newFilters) => {
    const updatedFilters = { ...filters, ...newFilters };
    setFilters(updatedFilters);
    onFilterChange?.(updatedFilters);
  }, [filters, onFilterChange]);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (suggestionsRef.current && !suggestionsRef.current.contains(event.target) && searchInputRef.current && !searchInputRef.current.contains(event.target)) {
        setShowSuggestions(false);
        setSelectedSuggestionIndex(-1);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const allSuggestions = [
    ...searchHistory.map((item) => ({ text: item, type: "history" })),
    ...suggestions
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `advanced-search ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-input-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "search-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            ref: searchInputRef,
            type: "text",
            value: searchTerm,
            onChange: (e) => handleSearchChange(e.target.value),
            onKeyDown: handleKeyDown,
            onFocus: () => {
              if (searchTerm.length >= 2 || searchHistory.length > 0) {
                setShowSuggestions(true);
              }
            },
            placeholder,
            className: "search-input",
            "aria-label": "Search for NFTs, collections, or schemas",
            "aria-describedby": showSuggestions ? "search-suggestions" : void 0,
            "aria-expanded": showSuggestions,
            "aria-autocomplete": "list",
            role: "combobox"
          }
        ),
        searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "clear-search",
            onClick: () => {
              handleSearchChange("");
              setShowSuggestions(false);
            },
            title: "Clear search",
            "aria-label": "Clear search input",
            type: "button",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "aria-hidden": "true", children: "" })
          }
        ),
        showFilters && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `filter-toggle ${showAdvancedFilters ? "active" : ""}`,
            onClick: () => setShowAdvancedFilters(!showAdvancedFilters),
            title: "Advanced filters",
            "aria-label": showAdvancedFilters ? "Hide advanced filters" : "Show advanced filters",
            "aria-expanded": showAdvancedFilters,
            type: "button",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" }) })
          }
        )
      ] }),
      showSuggestions && allSuggestions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          ref: suggestionsRef,
          className: "search-suggestions",
          id: "search-suggestions",
          role: "listbox",
          "aria-label": "Search suggestions",
          children: [
            searchHistory.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "suggestions-section", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "suggestions-header", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { id: "recent-searches-label", children: "Recent searches" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: clearHistory,
                    className: "clear-history",
                    "aria-label": "Clear search history",
                    type: "button",
                    children: "Clear"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { role: "group", "aria-labelledby": "recent-searches-label", children: searchHistory.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `suggestion-item history ${selectedSuggestionIndex === index ? "selected" : ""}`,
                  onClick: () => handleSuggestionClick({ text: item, type: "history" }),
                  role: "option",
                  "aria-selected": selectedSuggestionIndex === index,
                  tabIndex: -1,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "suggestion-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item })
                  ]
                },
                `history-${index}`
              )) })
            ] }),
            suggestions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "suggestions-section", children: [
              searchHistory.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "suggestions-divider" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "suggestions-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Suggestions" }) }),
              suggestions.map((suggestion, index) => {
                const actualIndex = searchHistory.length + index;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: `suggestion-item ${suggestion.type} ${selectedSuggestionIndex === actualIndex ? "selected" : ""}`,
                    onClick: () => handleSuggestionClick(suggestion),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "suggestion-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: [
                        suggestion.type === "name" && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" }),
                        suggestion.type === "collection" && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" }),
                        suggestion.type === "schema" && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: suggestion.text }),
                      suggestion.count && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "suggestion-count", children: suggestion.count })
                    ]
                  },
                  `suggestion-${index}`
                );
              })
            ] })
          ]
        }
      )
    ] }),
    showFilters && showAdvancedFilters && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "advanced-filters", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filters-grid", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "filter-label", children: "Price Range (WAX)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-range", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Min",
                value: filters.priceRange.min,
                onChange: (e) => handleFilterChange({
                  priceRange: { ...filters.priceRange, min: e.target.value }
                }),
                className: "price-input"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-separator", children: "to" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Max",
                value: filters.priceRange.max,
                onChange: (e) => handleFilterChange({
                  priceRange: { ...filters.priceRange, max: e.target.value }
                }),
                className: "price-input"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "filter-label", children: "Sort By" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: filters.sortBy,
              onChange: (e) => handleFilterChange({ sortBy: e.target.value }),
              className: "filter-select",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "relevance", children: "Relevance" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_asc", children: "Price: Low to High" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_desc", children: "Price: High to Low" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name: A to Z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name: Z to A" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "newest", children: "Newest First" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "oldest", children: "Oldest First" })
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "filter-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => {
            const resetFilters = {
              priceRange: { min: "", max: "" },
              rarities: [],
              collections: [],
              schemas: [],
              sortBy: "relevance"
            };
            setFilters(resetFilters);
            onFilterChange?.(resetFilters);
          },
          className: "filter-reset",
          children: "Reset Filters"
        }
      ) })
    ] })
  ] });
};
const Marketplace = React.memo(() => {
  const navigate = useNavigate();
  const { settings } = useDisplaySettings();
  const { showSuccess, showError, showWarning } = useNotifications();
  const [filteredNfts, setFilteredNfts] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState("idle");
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [activeCategory, setActiveCategory] = reactExports.useState("pixals");
  const [usdPrices, setUsdPrices] = reactExports.useState({});
  const [selectedNft, setSelectedNft] = reactExports.useState(null);
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [cartItems, setCartItems] = reactExports.useState(/* @__PURE__ */ new Set());
  const [selectedItems, setSelectedItems] = reactExports.useState(/* @__PURE__ */ new Set());
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [totalPages, setTotalPages] = reactExports.useState(1);
  const [allNfts, setAllNfts] = reactExports.useState([]);
  const [isFilterSidebarOpen, setIsFilterSidebarOpen] = reactExports.useState(false);
  const [priceRange, setPriceRange] = reactExports.useState({ min: "", max: "" });
  const [selectedSchemas, setSelectedSchemas] = reactExports.useState(/* @__PURE__ */ new Set());
  const [sortBy, setSortBy] = reactExports.useState("price_asc");
  const [dateRange, setDateRange] = reactExports.useState({ start: "", end: "" });
  const [searchSuggestions, setSearchSuggestions] = reactExports.useState([]);
  const [availableCollections, setAvailableCollections] = reactExports.useState([]);
  const [availableSchemas, setAvailableSchemas] = reactExports.useState([]);
  const [selectedCollections, setSelectedCollections] = reactExports.useState(/* @__PURE__ */ new Set());
  const [selectedAttributes, setSelectedAttributes] = reactExports.useState(/* @__PURE__ */ new Map());
  const [availableAttributes, setAvailableAttributes] = reactExports.useState(/* @__PURE__ */ new Map());
  const [collapsedSections, setCollapsedSections] = reactExports.useState(/* @__PURE__ */ new Set());
  const [watchlistItems, setWatchlistItems] = reactExports.useState(/* @__PURE__ */ new Set());
  const [loadMoreLoading, setLoadMoreLoading] = reactExports.useState(false);
  const [isComparisonOpen, setIsComparisonOpen] = reactExports.useState(false);
  const [shareNft, setShareNft] = reactExports.useState(null);
  const [isShareModalOpen, setIsShareModalOpen] = reactExports.useState(false);
  const [offerNft, setOfferNft] = reactExports.useState(null);
  const [isOfferModalOpen, setIsOfferModalOpen] = reactExports.useState(false);
  const [chatNft, setChatNft] = reactExports.useState(null);
  const [isChatModalOpen, setIsChatModalOpen] = reactExports.useState(false);
  const [openDropdowns, setOpenDropdowns] = reactExports.useState(/* @__PURE__ */ new Set());
  const [zoomedImage, setZoomedImage] = reactExports.useState(null);
  const [showImageZoom, setShowImageZoom] = reactExports.useState(false);
  const handleMessageSeller = (asset) => {
    setChatNft(asset);
    setIsChatModalOpen(true);
  };
  const toggleDropdown = reactExports.useCallback((assetId) => {
    setOpenDropdowns((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(assetId)) {
        newSet.delete(assetId);
      } else {
        newSet.clear();
        newSet.add(assetId);
      }
      return newSet;
    });
  }, []);
  const closeAllDropdowns = reactExports.useCallback(() => {
    setOpenDropdowns(/* @__PURE__ */ new Set());
  }, []);
  const handleMediaZoom = reactExports.useCallback((imageUrl, videoUrl, name) => {
    const mediaUrl = videoUrl || imageUrl;
    const mediaType = videoUrl ? "video" : "image";
    let processedUrl = mediaUrl;
    if (mediaUrl.startsWith("Qm") || mediaUrl.startsWith("baf")) {
      processedUrl = `https://ipfs.io/ipfs/${mediaUrl}`;
    } else if (mediaUrl.startsWith("/ipfs/")) {
      processedUrl = `https://ipfs.io${mediaUrl}`;
    } else if (mediaUrl.startsWith("ipfs://")) {
      processedUrl = mediaUrl.replace("ipfs://", "https://ipfs.io/ipfs/");
    }
    setZoomedImage({ url: processedUrl, name, type: mediaType });
    setShowImageZoom(true);
  }, []);
  reactExports.useEffect(() => {
    const handleClickOutside = () => {
      closeAllDropdowns();
    };
    document.addEventListener("click", handleClickOutside);
    return () => document.removeEventListener("click", handleClickOutside);
  }, [closeAllDropdowns]);
  const loadMarketplaceData = async (category, page = 1) => {
    if (page === 1) {
      setLoading("loading");
      setCurrentPage(1);
      setAllNfts([]);
    } else {
      setLoadMoreLoading(true);
    }
    try {
      let data = [];
      const limit = 50;
      switch (category) {
        case "pixals":
          data = await apiService.getCheapestPixals(limit, page);
          break;
        case "waxrocks":
          data = await apiService.getWaxRockPixals(limit, page);
          break;
        case "ingredients":
          data = await apiService.getPixelIngredients(limit, page);
          break;
        case "bundles":
          data = await apiService.getBundleListings(limit, page);
          break;
        case "friedfactory":
          data = await apiService.getFriedFactoryNFTs(limit, page);
          break;
        case "cryptomuffins":
          data = await apiService.getCryptoMuffinsNFTs(limit, page);
          break;
        case "akufishheads":
          data = await apiService.getPartnerListings(limit, page);
          break;
        case "partners":
          data = await apiService.getPartnerListings(limit, page);
          break;
        case "pxapproved":
          data = await apiService.getPxApprovedListings(limit, page);
          break;
        case "ah_verified":
          data = await apiService.getAHVerifiedListings(limit, page);
          break;
        case "all_wax":
          data = await apiService.getAllWaxListings(limit, page);
          break;
        default:
          data = await apiService.getCheapestPixals(limit, page);
      }
      if (page === 1) {
        setAllNfts(data);
      } else {
        setAllNfts((prev) => [...prev, ...data]);
        setCurrentPage(page);
      }
      if (data.length < limit) {
        setTotalPages(page);
      } else {
        setTotalPages(page + 1);
      }
      setLoading("success");
      setLoadMoreLoading(false);
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error("Failed to load marketplace data");
      ErrorMessageService.logError("Marketplace.loadMarketplaceData", errorObj, {
        category: activeCategory,
        page,
        limit: 50
      });
      setLoading("error");
      setLoadMoreLoading(false);
    }
  };
  const loadAvailableSchemas = reactExports.useCallback(async () => {
    try {
      const schemas = await apiService.getCollectionSchemas("pixeljourney");
      const schemaNames = schemas.map((schema) => schema.schema_name);
      setAvailableSchemas(schemaNames);
    } catch (error) {
      log.error("Failed to load available schemas", "Marketplace", error);
      setAvailableSchemas([]);
    }
  }, []);
  reactExports.useEffect(() => {
    loadMarketplaceData(activeCategory);
    loadAvailableSchemas();
  }, [activeCategory, loadAvailableSchemas]);
  const loadUsdPrices = reactExports.useCallback(async (nfts) => {
    const prices = {};
    const nftsNeedingPrices = nfts.filter((nft) => nft.price && !usdPrices[nft.asset_id]);
    if (nftsNeedingPrices.length === 0) return;
    const batchSize = 10;
    for (let i = 0; i < nftsNeedingPrices.length; i += batchSize) {
      const batch = nftsNeedingPrices.slice(i, i + batchSize);
      const batchResults = await Promise.allSettled(batch.map(async (nft) => {
        const usdPrice = await priceService.convertWaxToUSDAsync(nft.price);
        return { assetId: nft.asset_id, price: usdPrice };
      }));
      batchResults.forEach((result) => {
        if (result.status === "fulfilled" && result.value) {
          prices[result.value.assetId] = result.value.price;
        }
      });
      if (i + batchSize < nftsNeedingPrices.length) {
        await new Promise((resolve) => setTimeout(resolve, 50));
      }
    }
    setUsdPrices((prev) => ({ ...prev, ...prices }));
  }, []);
  reactExports.useEffect(() => {
    if (filteredNfts.length > 0) {
      loadUsdPrices(filteredNfts);
    }
  }, [filteredNfts, loadUsdPrices]);
  const generateSearchSuggestions = reactExports.useCallback((query) => {
    if (!query || query.length < 2) {
      setSearchSuggestions([]);
      return;
    }
    const suggestions = /* @__PURE__ */ new Map();
    const queryLower = query.toLowerCase();
    allNfts.forEach((nft) => {
      if (nft.name.toLowerCase().includes(queryLower)) {
        const key = `name:${nft.name}`;
        if (!suggestions.has(key)) {
          suggestions.set(key, {
            text: nft.name,
            type: "name",
            count: 1
          });
        } else {
          const existing = suggestions.get(key);
          existing.count = (existing.count || 0) + 1;
        }
      }
      if (nft.collection.toLowerCase().includes(queryLower)) {
        const key = `collection:${nft.collection}`;
        if (!suggestions.has(key)) {
          suggestions.set(key, {
            text: nft.collection,
            type: "collection",
            count: 1
          });
        } else {
          const existing = suggestions.get(key);
          existing.count = (existing.count || 0) + 1;
        }
      }
    });
    const suggestionList = Array.from(suggestions.values()).sort((a, b) => (b.count || 0) - (a.count || 0)).slice(0, 8);
    setSearchSuggestions(suggestionList);
  }, [allNfts]);
  const handleAdvancedFilterChange = reactExports.useCallback((filters) => {
    setPriceRange(filters.priceRange);
    setSortBy(filters.sortBy);
  }, []);
  reactExports.useEffect(() => {
    generateSearchSuggestions(searchTerm);
  }, [searchTerm, generateSearchSuggestions]);
  reactExports.useEffect(() => {
    const updateCartItems = () => {
      const cart = cartService.getCart();
      setCartItems(new Set(cart.map((item) => item.nft.asset_id)));
    };
    updateCartItems();
    cartService.addListener(updateCartItems);
    return () => cartService.removeListener(updateCartItems);
  }, []);
  reactExports.useEffect(() => {
    const updateWatchlistItems = async () => {
      const watchlist = await watchlistService.getWatchlist();
      setWatchlistItems(new Set(watchlist.map((item) => item.nft.asset_id)));
    };
    updateWatchlistItems();
    watchlistService.addListener((watchlist) => {
      setWatchlistItems(new Set(watchlist.map((item) => item.nft.asset_id)));
    });
  }, []);
  const handleLoadMore = reactExports.useCallback(() => {
    if (currentPage < totalPages && !loadMoreLoading) {
      loadMarketplaceData(activeCategory, currentPage + 1);
    }
  }, [activeCategory, currentPage, totalPages, loadMoreLoading]);
  const toggleFilterSidebar = () => {
    setIsFilterSidebarOpen(!isFilterSidebarOpen);
  };
  const closeFilterSidebar = () => {
    setIsFilterSidebarOpen(false);
  };
  const handleSchemaToggle = reactExports.useCallback((schema) => {
    const newSchemas = new Set(selectedSchemas);
    if (newSchemas.has(schema)) {
      newSchemas.delete(schema);
    } else {
      newSchemas.add(schema);
      const newCollapsed = new Set(collapsedSections);
      newCollapsed.add("schemas");
      setCollapsedSections(newCollapsed);
    }
    setSelectedSchemas(newSchemas);
  }, [selectedSchemas, collapsedSections]);
  const handleCollectionToggle = reactExports.useCallback((collection) => {
    const newSelected = new Set(selectedCollections);
    if (newSelected.has(collection)) {
      newSelected.delete(collection);
    } else {
      newSelected.add(collection);
      const newCollapsed = new Set(collapsedSections);
      newCollapsed.add("collections");
      setCollapsedSections(newCollapsed);
    }
    setSelectedCollections(newSelected);
  }, [selectedCollections, collapsedSections]);
  const handleAttributeToggle = reactExports.useCallback((attributeType, attributeValue) => {
    const newSelected = new Map(selectedAttributes);
    const currentValues = newSelected.get(attributeType) || /* @__PURE__ */ new Set();
    const newValues = new Set(currentValues);
    if (newValues.has(attributeValue)) {
      newValues.delete(attributeValue);
    } else {
      newValues.add(attributeValue);
    }
    if (newValues.size > 0) {
      newSelected.set(attributeType, newValues);
      const newCollapsed = new Set(collapsedSections);
      newCollapsed.add("attributes");
      setCollapsedSections(newCollapsed);
    } else {
      newSelected.delete(attributeType);
    }
    setSelectedAttributes(newSelected);
  }, [selectedAttributes, collapsedSections]);
  const toggleSectionCollapse = reactExports.useCallback((sectionName) => {
    const newCollapsed = new Set(collapsedSections);
    if (newCollapsed.has(sectionName)) {
      newCollapsed.delete(sectionName);
    } else {
      newCollapsed.add(sectionName);
    }
    setCollapsedSections(newCollapsed);
  }, [collapsedSections]);
  const clearAllFilters = () => {
    setPriceRange({ min: "", max: "" });
    setSelectedSchemas(/* @__PURE__ */ new Set());
    setSelectedCollections(/* @__PURE__ */ new Set());
    setSelectedAttributes(/* @__PURE__ */ new Map());
    setDateRange({ start: "", end: "" });
    setSortBy("price_asc");
  };
  const filteredAndSortedNfts = reactExports.useMemo(() => {
    let filtered = [...allNfts];
    if (searchTerm) {
      const searchLower = searchTerm.toLowerCase();
      filtered = filtered.filter(
        (nft) => nft.name.toLowerCase().includes(searchLower) || nft.collection.toLowerCase().includes(searchLower) || nft.schema && nft.schema.toLowerCase().includes(searchLower)
      );
    }
    if (priceRange.min || priceRange.max) {
      filtered = filtered.filter((nft) => {
        if (!nft.price) return false;
        const price = parseFloat(nft.price);
        const min = priceRange.min ? parseFloat(priceRange.min) : 0;
        const max = priceRange.max ? parseFloat(priceRange.max) : Infinity;
        return price >= min && price <= max;
      });
    }
    if (selectedSchemas.size > 0) {
      filtered = filtered.filter(
        (nft) => nft.schema && selectedSchemas.has(nft.schema)
      );
    }
    if (selectedCollections.size > 0) {
      filtered = filtered.filter(
        (nft) => selectedCollections.has(nft.collection)
      );
    }
    if (selectedAttributes.size > 0) {
      filtered = filtered.filter((nft) => {
        if (!nft.data || !nft.data.attributes || !Array.isArray(nft.data.attributes)) return false;
        for (const [attributeType, selectedValues] of selectedAttributes) {
          const nftAttribute = nft.data.attributes.find((attr) => attr.key === attributeType);
          if (!nftAttribute || !selectedValues.has(nftAttribute.value)) {
            return false;
          }
        }
        return true;
      });
    }
    filtered.sort((a, b) => {
      switch (sortBy) {
        case "price_asc":
          return parseFloat(a.price || "0") - parseFloat(b.price || "0");
        case "price_desc":
          return parseFloat(b.price || "0") - parseFloat(a.price || "0");
        case "name_asc":
          return a.name.localeCompare(b.name);
        case "name_desc":
          return b.name.localeCompare(a.name);
        case "newest":
          return new Date(b.created_at_time || 0).getTime() - new Date(a.created_at_time || 0).getTime();
        case "oldest":
          return new Date(a.created_at_time || 0).getTime() - new Date(b.created_at_time || 0).getTime();
        default:
          return 0;
      }
    });
    return filtered;
  }, [allNfts, searchTerm, priceRange, selectedSchemas, selectedCollections, selectedAttributes, sortBy]);
  reactExports.useEffect(() => {
    setFilteredNfts(filteredAndSortedNfts);
  }, [filteredAndSortedNfts]);
  reactExports.useEffect(() => {
    const attributeMap = /* @__PURE__ */ new Map();
    let filteredNfts2 = allNfts;
    if (selectedCollections.size > 0) {
      filteredNfts2 = filteredNfts2.filter((nft) => selectedCollections.has(nft.collection));
    }
    if (selectedSchemas.size > 0) {
      filteredNfts2 = filteredNfts2.filter((nft) => nft.schema && selectedSchemas.has(nft.schema));
    }
    filteredNfts2.forEach((nft) => {
      if (nft.data && nft.data.attributes && Array.isArray(nft.data.attributes)) {
        nft.data.attributes.forEach((attr) => {
          if (!attributeMap.has(attr.key)) {
            attributeMap.set(attr.key, []);
          }
          const values = attributeMap.get(attr.key);
          if (!values.includes(attr.value)) {
            values.push(attr.value);
          }
        });
      }
    });
    attributeMap.forEach((values, _key) => {
      values.sort();
    });
    setAvailableAttributes(attributeMap);
    setSelectedAttributes((prev) => {
      const newSelected = /* @__PURE__ */ new Map();
      prev.forEach((values, key) => {
        if (attributeMap.has(key)) {
          const availableValues = attributeMap.get(key);
          const filteredValues = /* @__PURE__ */ new Set();
          values.forEach((value) => {
            if (availableValues.includes(value)) {
              filteredValues.add(value);
            }
          });
          if (filteredValues.size > 0) {
            newSelected.set(key, filteredValues);
          }
        }
      });
      return newSelected;
    });
  }, [allNfts, selectedCollections, selectedSchemas]);
  reactExports.useEffect(() => {
    if (selectedCollections.size > 0) {
      const filteredSchemas = [...new Set(
        allNfts.filter((nft) => selectedCollections.has(nft.collection)).map((nft) => nft.schema).filter((schema) => schema)
      )].sort();
      setAvailableSchemas(filteredSchemas);
      setSelectedSchemas((prev) => {
        const newSelected = /* @__PURE__ */ new Set();
        prev.forEach((schema) => {
          if (filteredSchemas.includes(schema)) {
            newSelected.add(schema);
          }
        });
        return newSelected;
      });
    } else {
      const allSchemas = [...new Set(
        allNfts.map((nft) => nft.schema).filter((schema) => schema)
      )].sort();
      setAvailableSchemas(allSchemas);
    }
  }, [allNfts, selectedCollections]);
  const applyAdvancedFilters = reactExports.useCallback((nfts) => {
    let filtered = [...nfts];
    if (priceRange.min || priceRange.max) {
      filtered = filtered.filter((nft) => {
        if (!nft.price) return false;
        const price = parseFloat(nft.price.replace(" WAX", ""));
        const min = priceRange.min ? parseFloat(priceRange.min) : 0;
        const max = priceRange.max ? parseFloat(priceRange.max) : Infinity;
        return price >= min && price <= max;
      });
    }
    if (selectedSchemas.size > 0) {
      filtered = filtered.filter((nft) => selectedSchemas.has(nft.schema));
    }
    if (selectedCollections.size > 0) {
      filtered = filtered.filter((nft) => {
        return selectedCollections.has(nft.collection);
      });
    }
    if (dateRange.start || dateRange.end) ;
    filtered.sort((a, b) => {
      const priceA = a.price ? parseFloat(a.price.replace(" WAX", "")) : 0;
      const priceB = b.price ? parseFloat(b.price.replace(" WAX", "")) : 0;
      switch (sortBy) {
        case "price_asc":
          return priceA - priceB;
        case "price_desc":
          return priceB - priceA;
        case "name_asc":
          return a.name.localeCompare(b.name);
        case "name_desc":
          return b.name.localeCompare(a.name);
        // Rarity sorting removed - Pixal PFPs don't have rarity attributes
        // WaxRock gems could be sorted by rarity if needed in the future
        case "date_newest": {
          const timeA = 0;
          const timeB = 0;
          return timeB - timeA;
        }
        case "date_oldest": {
          const timeA = 0;
          const timeB = 0;
          return timeA - timeB;
        }
        default:
          return 0;
      }
    });
    return filtered;
  }, [priceRange, selectedSchemas, selectedCollections, sortBy]);
  reactExports.useEffect(() => {
    const collections = Array.from(new Set(allNfts.map((nft) => nft.collection)));
    setAvailableCollections(collections);
  }, [allNfts]);
  reactExports.useEffect(() => {
    let filtered = allNfts.filter((nft) => {
      const matchesSearch = nft.name.toLowerCase().includes(searchTerm.toLowerCase()) || (typeof nft.collection === "string" ? nft.collection.toLowerCase() : "").includes(searchTerm.toLowerCase());
      return matchesSearch;
    });
    filtered = applyAdvancedFilters(filtered);
    setFilteredNfts(filtered);
  }, [allNfts, searchTerm, priceRange, selectedSchemas, selectedCollections, dateRange, sortBy, applyAdvancedFilters]);
  const { purchaseNFT } = useWallet$1();
  const handlePurchase = reactExports.useCallback(async (nft) => {
    try {
      if (!wharfKitService.isLoggedIn()) {
        showWarning("Please connect your wallet to purchase NFTs");
        return;
      }
      log.debug("Purchasing NFT", "Marketplace", { nft });
      if (!nft.sale_id || !nft.price) {
        showError("Purchase Error", "NFT is not available for purchase");
        return;
      }
      await purchaseNFT(nft.sale_id, nft.price.replace(" WAX", ""));
      showSuccess(`Successfully purchased ${nft.name}!`);
      loadMarketplaceData(activeCategory);
    } catch (error) {
      log.error("Purchase failed", "Marketplace", error instanceof Error ? error : new Error(String(error)));
      showError(`Purchase failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }, [activeCategory, showWarning, showSuccess, showError, loadMarketplaceData]);
  const handleSellerClick = reactExports.useCallback((seller) => {
    navigate(`/user-profile-lookup?user=${encodeURIComponent(seller)}`);
  }, [navigate]);
  const handleCollectionClick = reactExports.useCallback((collection) => {
    navigate(`/collections/${encodeURIComponent(collection)}`);
  }, [navigate]);
  const handleAssetClick = reactExports.useCallback((nft) => {
    if (selectedItems.size > 0) {
      handleSelectItem(nft.asset_id);
      return;
    }
    if (nft.sale_id) {
      navigate(`/listings/${nft.sale_id}`);
    } else {
      navigate(`/assets/${nft.asset_id}`);
    }
  }, [navigate, selectedItems.size]);
  const handleSelectItem = reactExports.useCallback((assetId) => {
    const newSelected = new Set(selectedItems);
    if (newSelected.has(assetId)) {
      newSelected.delete(assetId);
    } else {
      newSelected.add(assetId);
    }
    setSelectedItems(newSelected);
  }, [selectedItems]);
  const handleSelectAll = reactExports.useCallback(() => {
    if (selectedItems.size === filteredNfts.length) {
      setSelectedItems(/* @__PURE__ */ new Set());
    } else {
      setSelectedItems(new Set(filteredNfts.map((nft) => nft.asset_id)));
    }
  }, [selectedItems, filteredNfts]);
  const handleBulkAddToCart = reactExports.useCallback(() => {
    const selectedNfts = filteredNfts.filter((nft) => selectedItems.has(nft.asset_id));
    selectedNfts.forEach((nft) => {
      if (!cartItems.has(nft.asset_id)) {
        cartService.addToCart(nft);
      }
    });
    setSelectedItems(/* @__PURE__ */ new Set());
  }, [filteredNfts, selectedItems, cartItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "marketplace", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "marketplace-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "marketplace-header-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "marketplace-header-text", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "marketplace-title", children: "Pixel Journey Marketplace" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "marketplace-subtitle", children: "Discover, collect, and trade unique digital assets from the Pixel Journey ecosystem. This marketplace serves all WAX users, with full market access unlocked for Pixal PFP holders." })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "marketplace-filters", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdvancedSearch,
          {
            searchTerm,
            onSearchChange: setSearchTerm,
            suggestions: searchSuggestions,
            placeholder: "Search items, collections...",
            showFilters: true,
            onFilterChange: handleAdvancedFilterChange,
            className: "marketplace-search"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "marketplace-controls", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "category-tabs-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "category-section-title", children: "Listings" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "category-tabs-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "category-tabs", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `category-tab ${activeCategory === "pixals" ? "active" : ""}`,
                  onClick: () => setActiveCategory("pixals"),
                  "aria-label": "Filter by Pixals category",
                  "aria-pressed": activeCategory === "pixals",
                  children: "Pixals"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `category-tab ${activeCategory === "waxrocks" ? "active" : ""}`,
                  onClick: () => setActiveCategory("waxrocks"),
                  "aria-label": "Filter by WaxRocks category",
                  "aria-pressed": activeCategory === "waxrocks",
                  children: "WaxRocks"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `category-tab ${activeCategory === "ingredients" ? "active" : ""}`,
                  onClick: () => setActiveCategory("ingredients"),
                  "aria-label": "Filter by Ingredients category",
                  "aria-pressed": activeCategory === "ingredients",
                  children: "Ingredients"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `category-tab ${activeCategory === "bundles" ? "active" : ""}`,
                  onClick: () => setActiveCategory("bundles"),
                  "aria-label": "Filter by Bundles category",
                  "aria-pressed": activeCategory === "bundles",
                  children: " Bundles"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  className: "others-select",
                  value: ["friedfactory", "cryptomuffins", "akufishheads", "partners", "pxapproved", "ah_verified", "all_wax"].includes(activeCategory) ? activeCategory : "others",
                  onChange: (e) => {
                    const value = e.target.value;
                    if (value !== "others") {
                      setActiveCategory(value);
                    }
                  },
                  "aria-label": "Select additional marketplace categories",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "others", children: "Others" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("optgroup", { label: "Marketplace", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "pxapproved", children: "PxApproved" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "ah_verified", children: "All AH Verified (Pixals holders+ only)" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all_wax", children: "All Wax Listings (Pixals holders+ only)" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("optgroup", { label: "Partners", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "friedfactory", children: "Fried Factory" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "cryptomuffins", children: "CryptoMuffins" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "akufishheads", children: "Aku Fish Heads" })
                    ] })
                  ]
                }
              )
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-sort-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "filter-sort-title", children: "Filter & Sort" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-sort-controls", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  className: "sort-dropdown",
                  value: sortBy,
                  onChange: (e) => setSortBy(e.target.value),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_asc", children: "Price: Low to High" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_desc", children: "Price: High to Low" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name: A to Z" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name: Z to A" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "date_newest", children: "Newest Listings" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "date_oldest", children: "Oldest Listings" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "filter-toggle-btn",
                  onClick: toggleFilterSidebar,
                  title: "Advanced Filters",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" }) })
                }
              )
            ] })
          ] })
        ] })
      ] }),
      loading === "loading" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-grid", children: Array.from({ length: 8 }).map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-card loading", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-image-placeholder" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-text" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-text short" })
        ] })
      ] }, index)) }),
      loading === "error" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ErrorMessage,
        {
          errorType: "LOAD_FAILED",
          onRetry: () => loadMarketplaceData(activeCategory),
          showRetry: true
        }
      ),
      selectedItems.size > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-actions-bar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bulk-actions-info", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          selectedItems.size,
          " item",
          selectedItems.size !== 1 ? "s" : "",
          " selected"
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-actions-buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "bulk-btn bulk-cart",
              onClick: handleBulkAddToCart,
              "aria-label": `Add ${selectedItems.size} selected items to cart`,
              children: "Add Selected to Cart"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "bulk-btn bulk-compare",
              onClick: () => setIsComparisonOpen(true),
              disabled: selectedItems.size < 2 || selectedItems.size > 4,
              title: selectedItems.size < 2 ? "Select 2-4 items to compare" : selectedItems.size > 4 ? "Maximum 4 items can be compared" : "Compare selected items",
              "aria-label": `Compare ${selectedItems.size} selected items`,
              children: [
                "Compare (",
                selectedItems.size,
                ")"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "bulk-btn bulk-clear",
              onClick: () => setSelectedItems(/* @__PURE__ */ new Set()),
              "aria-label": "Clear all selected items",
              children: "Clear Selection"
            }
          )
        ] })
      ] }),
      loading === "success" && filteredNfts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "select-all-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "select-all-btn",
            onClick: handleSelectAll,
            "aria-label": selectedItems.size === filteredNfts.length ? `Deselect all ${filteredNfts.length} items` : `Select all ${filteredNfts.length} items`,
            children: selectedItems.size === filteredNfts.length ? "Deselect All" : "Select All"
          }
        ),
        currentPage < totalPages && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "load-more-btn load-more-top",
            onClick: handleLoadMore,
            disabled: loadMoreLoading,
            "aria-label": loadMoreLoading ? "Loading more items" : "Load more marketplace items",
            children: loadMoreLoading ? "Loading..." : "Load More"
          }
        )
      ] }),
      loading === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-grid", children: filteredNfts.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `nft-card ${selectedItems.has(nft.asset_id) ? "selected" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-select-checkbox", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: selectedItems.has(nft.asset_id),
            onChange: () => handleSelectItem(nft.asset_id),
            className: "select-checkbox"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-image-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: getAssetImageUrl(nft),
              videoUrl: getAssetVideoUrl(nft),
              className: "nft-image",
              alt: nft.name,
              autoPlay: true,
              loop: true,
              enableAnimations: settings.enableAnimatedNFTs
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "zoom-overlay",
              onClick: () => handleMediaZoom(getAssetImageUrl(nft) || "", getAssetVideoUrl(nft) || "", nft.name || `Asset #${nft.asset_id}`),
              title: "Click to zoom",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "zoom-icon", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21 21-4.35-4.35" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11 8v6M8 11h6" })
              ] })
            }
          ),
          (nft.template_mint || nft.max_supply !== void 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mint-badge", children: [
            nft.template_mint !== void 0 && nft.template_mint !== null ? nft.template_mint : "?",
            "/",
            nft.max_supply === "0" || nft.max_supply === void 0 || nft.max_supply === null ? "" : nft.max_supply
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "nft-name", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "asset-link", onClick: () => handleAssetClick(nft), children: nft.name }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-collection", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "collection-link", onClick: () => handleCollectionClick(nft.collection), children: nft.collection }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-price-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-prices-div", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-price", children: nft.price }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-price-usd", children: usdPrices[nft.asset_id] || "$0.00" })
            ] }),
            nft.seller && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "nft-seller", children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seller-link", onClick: () => handleSellerClick(nft.seller), children: nft.seller })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-actions-row nft-actions-main", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  className: "btn-buy-now",
                  onClick: () => handlePurchase(nft),
                  title: "Buy now",
                  "aria-label": `Buy ${nft.name} for ${nft.price}`,
                  type: "button",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
                    "Buy Now"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  className: "details-btn",
                  onClick: () => {
                    setSelectedNft(nft);
                    setIsModalOpen(true);
                  },
                  title: "View Details",
                  "aria-label": `View details for ${nft.name}`,
                  type: "button",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "aria-hidden": "true", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21 21-4.35-4.35" })
                    ] }),
                    "Info"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-actions-row nft-actions-icons", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `btn-cart ${cartItems.has(nft.asset_id) ? "in-cart" : ""}`,
                  onClick: () => {
                    if (cartItems.has(nft.asset_id)) {
                      cartService.removeFromCart(nft.asset_id);
                    } else {
                      const added = cartService.addToCart(nft);
                      if (!added) {
                        showWarning("Item is already in your cart!");
                      }
                    }
                  },
                  title: cartItems.has(nft.asset_id) ? "Remove from cart" : "Add to cart",
                  "aria-label": cartItems.has(nft.asset_id) ? `Remove ${nft.name} from cart` : `Add ${nft.name} to cart`,
                  type: "button",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "aria-hidden": "true", children: cartItems.has(nft.asset_id) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "3,6 5,6 21,6" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2" })
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "9", cy: "21", r: "1" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "20", cy: "21", r: "1" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m1 1 4 4 2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6" })
                  ] }) })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "btn-make-offer",
                  onClick: (e) => {
                    e.stopPropagation();
                    setOfferNft(nft);
                    setIsOfferModalOpen(true);
                  },
                  title: "Offer",
                  type: "button",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 -8 72 72", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M64,12.78v17s-3.63.71-4.38.81-3.08.85-4.78-.78C52.22,27.25,42.93,18,42.93,18a3.54,3.54,0,0,0-4.18-.21c-2.36,1.24-5.87,3.07-7.33,3.78a3.37,3.37,0,0,1-5.06-2.64,3.44,3.44,0,0,1,2.1-3c3.33-2,10.36-6,13.29-7.52,1.78-1,3.06-1,5.51,1C50.27,12,53,14.27,53,14.27a2.75,2.75,0,0,0,2.26.43C58.63,14,64,12.78,64,12.78ZM27,41.5a3,3,0,0,0-3.55-4.09,3.07,3.07,0,0,0-.64-3,3.13,3.13,0,0,0-3-.75,3.07,3.07,0,0,0-.65-3,3.38,3.38,0,0,0-4.72.13c-1.38,1.32-2.27,3.72-1,5.14s2.64.55,3.72.3c-.3,1.07-1.2,2.07-.09,3.47s2.64.55,3.72.3c-.3,1.07-1.16,2.16-.1,3.46s2.84.61,4,.25c-.45,1.15-1.41,2.39-.18,3.79s4.08.75,5.47-.58a3.32,3.32,0,0,0,.3-4.68A3.18,3.18,0,0,0,27,41.5Zm25.35-8.82L41.62,22a3.53,3.53,0,0,0-3.77-.68c-1.5.66-3.43,1.56-4.89,2.24a8.15,8.15,0,0,1-3.29,1.1,5.59,5.59,0,0,1-3-10.34C29,12.73,34.09,10,34.09,10a6.46,6.46,0,0,0-5-2C25.67,8,18.51,12.7,18.51,12.7a5.61,5.61,0,0,1-4.93.13L8,10.89v19.4s1.59.46,3,1a6.33,6.33,0,0,1,1.56-2.47,6.17,6.17,0,0,1,8.48-.06,5.4,5.4,0,0,1,1.34,2.37,5.49,5.49,0,0,1,2.29,1.4A5.4,5.4,0,0,1,26,34.94a5.47,5.47,0,0,1,3.71,4,5.38,5.38,0,0,1,2.39,1.43,5.65,5.65,0,0,1,1.48,4.89a0,0,0,0,1,0,0s.8.9,1.29,1.39a2.46,2.46,0,0,0,3.48-3.48s2,2.48,4.28,1c2-1.4,1.69-3.06.74-4a3.19,3.19,0,0,0,4.77.13,2.45,2.45,0,0,0,.13-3.3s1.33,1.81,4,.12c1.89-1.6,1-3.43,0-4.39Z" }) })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "btn-message",
                  onClick: () => handleMessageSeller(nft),
                  title: "Send Direct Message (1000 PXJ)",
                  disabled: !nft.seller,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }) })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "other-actions-dropdown", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "btn-other-actions",
                    onClick: (e) => {
                      e.stopPropagation();
                      toggleDropdown(nft.asset_id);
                    },
                    title: "More Actions",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "1" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "19", cy: "12", r: "1" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "5", cy: "12", r: "1" })
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `other-actions-menu ${openDropdowns.has(nft.asset_id) ? "open" : ""}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      className: "other-actions-item",
                      onClick: (e) => {
                        e.stopPropagation();
                        handleAssetClick(nft);
                        closeAllDropdowns();
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                        ] }),
                        "View Full Listing"
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      className: "other-actions-item",
                      onClick: (e) => {
                        e.stopPropagation();
                        setShareNft(nft);
                        setIsShareModalOpen(true);
                        closeAllDropdowns();
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "16,6 12,2 8,6" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "2", x2: "12", y2: "15" })
                        ] }),
                        "Share NFT"
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      className: `other-actions-item ${watchlistItems.has(nft.asset_id) ? "in-watchlist" : ""}`,
                      onClick: async (e) => {
                        e.stopPropagation();
                        if (watchlistItems.has(nft.asset_id)) {
                          await watchlistService.removeFromWatchlist(nft.asset_id);
                        } else {
                          const added = await watchlistService.addToWatchlist(nft);
                          if (!added) {
                            showWarning("Item is already in your watchlist!");
                          }
                        }
                        closeAllDropdowns();
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: watchlistItems.has(nft.asset_id) ? /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z", fill: "currentColor" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" }) }),
                        watchlistItems.has(nft.asset_id) ? "Remove from Watchlist" : "Add to Watchlist"
                      ]
                    }
                  )
                ] })
              ] })
            ] })
          ] })
        ] })
      ] }, nft.asset_id)) }),
      loading === "success" && filteredNfts.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "marketplace-empty", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "empty-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No items found" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Try adjusting your search or filter criteria" })
      ] }),
      loading === "success" && currentPage < totalPages && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "load-more-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "load-more-btn",
            onClick: () => loadMarketplaceData(activeCategory, currentPage + 1),
            disabled: loadMoreLoading,
            children: loadMoreLoading ? "Loading..." : "Load More"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-info", children: [
          "Showing ",
          filteredNfts.length,
          " items  Loaded ",
          currentPage,
          " of ",
          totalPages > currentPage ? totalPages + "+" : totalPages,
          " pages"
        ] })
      ] }),
      loading === "success" && currentPage >= totalPages && filteredNfts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-info", children: [
        "Showing all ",
        filteredNfts.length,
        " items"
      ] }) })
    ] }),
    isFilterSidebarOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "filter-sidebar-overlay", onClick: closeFilterSidebar }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-sidebar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-sidebar-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Advanced Filters" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-sidebar-btn", onClick: closeFilterSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section-header", onClick: () => toggleSectionCollapse("collections"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Collections" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "collapse-toggle", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                className: collapsedSections.has("collections") ? "collapsed" : "",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
              }
            ) })
          ] }),
          !collapsedSections.has("collections") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-checkboxes", children: availableCollections.slice(0, 8).map((collection) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "collection-checkbox", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  checked: selectedCollections.has(collection),
                  onChange: () => handleCollectionToggle(collection)
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "checkmark" }),
              collection
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: `/analytics/${encodeURIComponent(collection)}`,
                className: "analytics-link",
                title: `View ${collection} analytics`,
                onClick: (e) => e.stopPropagation(),
                children: ""
              }
            )
          ] }, collection)) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section-header", onClick: () => toggleSectionCollapse("schemas"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Schema Type" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "collapse-toggle", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                className: collapsedSections.has("schemas") ? "collapsed" : "",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
              }
            ) })
          ] }),
          !collapsedSections.has("schemas") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "schema-checkboxes", children: availableSchemas.length > 0 ? availableSchemas.map((schema) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "schema-checkbox", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                checked: selectedSchemas.has(schema),
                onChange: () => handleSchemaToggle(schema)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "checkmark" }),
            schema.charAt(0).toUpperCase() + schema.slice(1)
          ] }, schema)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-schemas", children: "Loading schemas..." }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section-header", onClick: () => toggleSectionCollapse("price"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Price Range (WAX)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "collapse-toggle", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                className: collapsedSections.has("price") ? "collapsed" : "",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
              }
            ) })
          ] }),
          !collapsedSections.has("price") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-range-inputs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Min",
                value: priceRange.min,
                onChange: (e) => setPriceRange((prev) => ({ ...prev, min: e.target.value })),
                className: "price-input"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "to" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Max",
                value: priceRange.max,
                onChange: (e) => setPriceRange((prev) => ({ ...prev, max: e.target.value })),
                className: "price-input"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section-header", onClick: () => toggleSectionCollapse("attributes"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Attribute Filters" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "collapse-toggle", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                className: collapsedSections.has("attributes") ? "collapsed" : "",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
              }
            ) })
          ] }),
          !collapsedSections.has("attributes") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute-filters", children: [
            Array.from(availableAttributes.entries()).map(([attributeType, values]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute-group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "attribute-type", children: attributeType }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attribute-values", children: values.map((value) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "attribute-checkbox", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "checkbox",
                    checked: selectedAttributes.get(attributeType)?.has(value) || false,
                    onChange: () => handleAttributeToggle(attributeType, value)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "checkmark" }),
                value
              ] }, value)) })
            ] }, attributeType)),
            availableAttributes.size === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-attributes", children: "No attributes available" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Date Range" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "date-range-inputs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "date",
                value: dateRange.start,
                onChange: (e) => setDateRange((prev) => ({ ...prev, start: e.target.value })),
                className: "date-input",
                placeholder: "Start Date"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "to" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "date",
                value: dateRange.end,
                onChange: (e) => setDateRange((prev) => ({ ...prev, end: e.target.value })),
                className: "date-input",
                placeholder: "End Date"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Sort By" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: sortBy,
              onChange: (e) => setSortBy(e.target.value),
              className: "sort-select",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_asc", children: "Price: Low to High" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_desc", children: "Price: High to Low" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name: A to Z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name: Z to A" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "date_newest", children: "Newest Listings" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "date_oldest", children: "Oldest Listings" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "clear-filters-btn", onClick: clearAllFilters, children: "Clear All" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "apply-filters-btn", onClick: closeFilterSidebar, children: "Apply Filters" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NFTDetailsModal,
      {
        nft: selectedNft,
        isOpen: isModalOpen,
        onClose: () => {
          setIsModalOpen(false);
          setSelectedNft(null);
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NFTComparison,
      {
        initialNFTs: filteredNfts.filter((nft) => selectedItems.has(nft.asset_id)),
        isOpen: isComparisonOpen,
        onClose: () => setIsComparisonOpen(false)
      }
    ),
    shareNft && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SocialShare,
      {
        nft: shareNft,
        isOpen: isShareModalOpen,
        onClose: () => {
          setIsShareModalOpen(false);
          setShareNft(null);
        }
      }
    ),
    offerNft && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SendOfferModal,
      {
        nft: offerNft,
        isOpen: isOfferModalOpen,
        onClose: () => {
          setIsOfferModalOpen(false);
          setOfferNft(null);
        }
      }
    ),
    chatNft && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListingChatModal,
      {
        nft: chatNft,
        isOpen: isChatModalOpen,
        onClose: () => {
          setIsChatModalOpen(false);
          setChatNft(null);
        }
      }
    ),
    showImageZoom && zoomedImage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "image-zoom-modal", onClick: () => setShowImageZoom(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "zoom-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "zoom-modal-close",
          onClick: () => setShowImageZoom(false),
          "aria-label": "Close zoom modal",
          children: ""
        }
      ),
      zoomedImage.type === "video" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "video",
        {
          src: zoomedImage.url,
          className: "zoom-modal-video",
          controls: true,
          autoPlay: true,
          loop: true,
          muted: true
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: zoomedImage.url,
          alt: zoomedImage.name,
          className: "zoom-modal-image"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "zoom-modal-title", children: zoomedImage.name })
    ] }) })
  ] });
});
const Rewards = ({ onPageChange }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rewards-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rewards-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "rewards-title", children: "Trading Rewards" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "rewards-subtitle", children: "Earn PXJ tokens and Pixel Ingredients for every trade you make on Pixel Market" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rewards-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reward-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "reward-icon pxj-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 6v6l4 2" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "reward-title", children: "PXJ Token Rewards" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "reward-description", children: "Earn PXJ tokens based on your trading volume. The more you trade, the more you earn!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "reward-benefits", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "0.1% of trade value in PXJ tokens" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Bonus multipliers for high-volume traders" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Weekly bonus distributions" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Governance voting rights" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reward-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "reward-icon ingredient-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "reward-title", children: "Pixel Ingredients" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "reward-description", children: [
          "Collect rare Pixel Ingredients that can be used for crafting and enhancing your NFTs. ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Available to Pixal PFP holders and Fried Factory trait holders only." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "reward-benefits", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Random ingredient drops with each trade" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Rare ingredients for large transactions" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Craft unique items and upgrades" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Trade ingredients with other players" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reward-card full-width", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "reward-icon volume-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 3v18h18" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 12l4-4 4 4 6-6" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "reward-title", children: "Volume-Based Bonuses" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "reward-description", children: "Unlock additional rewards and benefits as your trading volume increases." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "volume-tiers", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Bronze Trader" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "1+ WAX volume" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-bonus", children: "1x rewards" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Silver Trader" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "100+ WAX volume" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-bonus", children: "1.5x rewards" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Gold Trader" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "1,000+ WAX volume" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-bonus", children: "2x rewards" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Diamond Trader" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "10,000+ WAX volume" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-bonus", children: "3x rewards" })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rewards-cta", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Start Trading Today!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your wallet and start earning rewards with every transaction." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "cta-button",
          onClick: () => onPageChange?.("marketplace"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 7l5 5m0 0l-5 5m5-5H6" }) }),
            "Go to Marketplace"
          ]
        }
      )
    ] })
  ] });
};
const ListingModal = ({ nft, isOpen, onClose, onSuccess, bundleNfts = [] }) => {
  const [price, setPrice] = reactExports.useState("");
  const [isBundle, setIsBundle] = reactExports.useState(false);
  const [bundleName, setBundleName] = reactExports.useState("");
  const [isListing, setIsListing] = reactExports.useState(false);
  const { session } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  const waxCurrency = { symbol: "WAX", contract: "eosio.token", precision: 8 };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!nft || !session || !price) {
      showError("Please fill in all required fields");
      return;
    }
    if (isBundle && !bundleName.trim()) {
      showError("Please enter a bundle name");
      return;
    }
    const priceFloat = parseFloat(price);
    if (isNaN(priceFloat) || priceFloat <= 0) {
      showError("Please enter a valid price");
      return;
    }
    setIsListing(true);
    try {
      const selectedCurrency = waxCurrency;
      const formattedPrice = priceFloat.toFixed(selectedCurrency.precision);
      const priceString = `${formattedPrice} ${selectedCurrency.symbol}`;
      const assetIds = isBundle && bundleNfts.length > 0 ? [nft.asset_id, ...bundleNfts.map((bundleNft) => bundleNft.asset_id)] : [nft.asset_id];
      const action = {
        account: "atomicmarket",
        name: "announcesale",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          seller: WharfKitService.safeGetActor(session),
          asset_ids: assetIds,
          listing_price: priceString,
          settlement_symbol: `${selectedCurrency.precision},${selectedCurrency.symbol}`,
          maker_marketplace: "market.pxj"
        }
      };
      const result = await session.transact({ actions: [action] });
      if (result) {
        const listingType = isBundle ? "Bundle" : "NFT";
        showSuccess(`${listingType} listed successfully!`);
        onSuccess?.();
        onClose();
        setPrice("");
      }
    } catch (error) {
      log.error("Listing failed", "ListingModal", error instanceof Error ? error : new Error(String(error)));
      showError(`Listing failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    } finally {
      setIsListing(false);
    }
  };
  const handleClose = () => {
    if (!isListing) {
      setPrice("");
      setIsBundle(false);
      setBundleName("");
      onClose();
    }
  };
  if (!isOpen || !nft) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content listing-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "List NFT for Sale" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "modal-close",
          onClick: handleClose,
          disabled: isListing,
          children: ""
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview enhanced-preview", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-image", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          MediaRenderer,
          {
            imageUrl: getAssetImageUrl(nft),
            videoUrl: getAssetVideoUrl(nft),
            alt: nft.name || `Asset #${nft.asset_id}`,
            className: "nft-media"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: nft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-collection", children: typeof nft.collection === "string" ? nft.collection : nft.collection?.name || nft.collection?.collection_name || "Unknown" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-schema", children: nft.schema.schema_name }),
          nft.mint_number && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "nft-mint", children: [
            "Mint #",
            nft.mint_number
          ] }),
          isBundle && bundleNfts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "bundle-info", children: [
            "+ ",
            bundleNfts.length,
            " additional NFT",
            bundleNfts.length > 1 ? "s" : ""
          ] })
        ] })
      ] }),
      bundleNfts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bundle-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bundle-toggle", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "checkbox-label", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: isBundle,
              onChange: (e) => setIsBundle(e.target.checked),
              disabled: isListing
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "checkmark" }),
          "Create Bundle with ",
          bundleNfts.length,
          " additional NFT",
          bundleNfts.length > 1 ? "s" : ""
        ] }) }),
        isBundle && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bundle-details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "bundleName", children: "Bundle Name *" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                id: "bundleName",
                value: bundleName,
                onChange: (e) => setBundleName(e.target.value),
                placeholder: "Enter bundle name",
                disabled: isListing,
                className: "bundle-name-input"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bundle-preview", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Bundle Contents:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bundle-nfts", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bundle-nft-item main-nft", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MediaRenderer, { imageUrl: getAssetImageUrl(nft), videoUrl: getAssetVideoUrl(nft), alt: nft.name || `Asset #${nft.asset_id}`, className: "bundle-nft-image" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: nft.name })
              ] }),
              bundleNfts.slice(0, 3).map((bundleNft) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bundle-nft-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MediaRenderer, { imageUrl: getAssetImageUrl(bundleNft), videoUrl: getAssetVideoUrl(bundleNft), alt: bundleNft.name || `Asset #${bundleNft.asset_id}`, className: "bundle-nft-image" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: bundleNft.name })
              ] }, bundleNft.asset_id)),
              bundleNfts.length > 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bundle-more", children: [
                "+",
                bundleNfts.length - 3,
                " more"
              ] })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "modal-form listing-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "price", children: "Price *" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-input-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                id: "price",
                value: price,
                onChange: (e) => setPrice(e.target.value),
                placeholder: "0.00",
                step: "0.0001",
                min: "0",
                required: true,
                disabled: isListing,
                className: "price-input"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "currency-display", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "currency-symbol", children: waxCurrency.symbol }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "currency-note", children: "(AtomicMarket only supports WAX)" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "info-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Marketplace:" }),
            " AtomicMarket"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "info-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Marketplace Fee:" }),
            " 2%"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "info-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Collection Fee:" }),
            " Varies by collection"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: handleClose,
              disabled: isListing,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary",
              disabled: isListing || !price,
              children: isListing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
                "Listing..."
              ] }) : "List for Sale"
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const TransferModal = ({ nft, isOpen, onClose, onSuccess }) => {
  const [recipient, setRecipient] = reactExports.useState("");
  const [memo, setMemo] = reactExports.useState("");
  const [isTransferring, setIsTransferring] = reactExports.useState(false);
  const { session, transferNFT } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  const validateWaxAccount = (account) => {
    const waxAccountRegex = /^[a-z1-5]{12}$/;
    return waxAccountRegex.test(account);
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!nft || !session || !recipient.trim()) {
      showError("Validation Error", "Please fill in all required fields");
      return;
    }
    if (!validateWaxAccount(recipient.trim())) {
      showError(
        "Invalid Account Name",
        "Please enter a valid WAX account name (12 characters, lowercase letters and numbers 1-5)"
      );
      return;
    }
    setIsTransferring(true);
    try {
      if (!transferNFT) {
        throw new Error("NFT transfer service is not available");
      }
      const result = await transferNFT(
        nft.asset_id,
        recipient.trim()
      );
      if (result) {
        showSuccess("Transfer Successful", "NFT transferred successfully!");
        onSuccess?.();
        onClose();
        setRecipient("");
        setMemo("");
      }
    } catch (error) {
      log.error("Transfer failed", "TransferModal", error);
      showError(
        "Transfer Failed",
        error instanceof Error ? error.message : "Unknown error occurred"
      );
    } finally {
      setIsTransferring(false);
    }
  };
  const handleClose = () => {
    if (!isTransferring) {
      setRecipient("");
      setMemo("");
      onClose();
    }
  };
  if (!isOpen || !nft) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content transfer-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Transfer NFT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "modal-close",
          onClick: handleClose,
          disabled: isTransferring,
          children: ""
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-image", children: nft.video ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "video",
          {
            src: nft.video.startsWith("http") ? nft.video : `https://ipfs.io/ipfs/${nft.video}`,
            muted: true,
            loop: true,
            autoPlay: true
          }
        ) : nft.img ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: nft.img.startsWith("http") ? nft.img : `https://ipfs.io/ipfs/${nft.img}`,
            alt: nft.name
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-image", children: "No Image" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: nft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-collection", children: typeof nft.collection === "string" ? nft.collection : nft.collection?.name || nft.collection?.collection_name || "Unknown" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-schema", children: nft.schema.schema_name }),
          nft.mint_number && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "nft-mint", children: [
            "Mint #",
            nft.mint_number
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "modal-form transfer-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "recipient", children: "Recipient WAX Account *" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "recipient",
              value: recipient,
              onChange: (e) => setRecipient(e.target.value.toLowerCase()),
              placeholder: "e.g. pixeljourney",
              maxLength: 12,
              required: true,
              disabled: isTransferring,
              className: "recipient-input"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "input-help", children: "Enter a valid WAX account name (12 characters, lowercase letters and numbers 1-5)" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "memo", children: "Memo (Optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "memo",
              value: memo,
              onChange: (e) => setMemo(e.target.value),
              placeholder: "Optional transfer message",
              maxLength: 256,
              disabled: isTransferring,
              className: "memo-input"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transfer-warning", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "warning-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Warning:" }),
            " This action cannot be undone. Make sure you trust the recipient and have entered the correct account name."
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: handleClose,
              disabled: isTransferring,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary transfer-btn",
              disabled: isTransferring || !recipient.trim() || !validateWaxAccount(recipient.trim()),
              children: isTransferring ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
                "Transferring..."
              ] }) : "Transfer NFT"
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const BurnModal = ({ nft, isOpen, onClose, onSuccess }) => {
  const [confirmText, setConfirmText] = reactExports.useState("");
  const [isBurning, setIsBurning] = reactExports.useState(false);
  const [step, setStep] = reactExports.useState("warning");
  const { session } = useWallet$1();
  const { showError, showSuccess } = useNotifications();
  const requiredConfirmText = "BURN";
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!nft || !session) {
      showError("Session error. Please try again.", "Connection Error");
      return;
    }
    if (MarketplaceConfigService.isPixalPFP(nft.template.template_id)) {
      const waxRock = nft.data?.WaxRock;
      if (waxRock && MarketplaceConfigService.isValidWaxRock(waxRock)) {
        showError(
          `This is a rare WaxRock Pixal PFP (${waxRock}) and cannot be burned. WaxRock Pixals are protected from burning and recycling on our platform.`,
          "Protected NFT",
          8e3
        );
        return;
      }
    }
    if (confirmText.toUpperCase() !== requiredConfirmText) {
      showError(`Please type "${requiredConfirmText}" to confirm`, "Confirmation Required");
      return;
    }
    setIsBurning(true);
    try {
      const action = {
        account: "atomicassets",
        name: "burnasset",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          asset_owner: WharfKitService.safeGetActor(session),
          asset_id: nft.asset_id
        }
      };
      const result = await session.transact({ actions: [action] });
      if (result) {
        showSuccess("NFT burned successfully!", "Burn Complete");
        onSuccess?.();
        onClose();
        resetModal();
      }
    } catch (error) {
      log.error("Burn failed", "BurnModal", error);
      showError(`Burn failed: ${error instanceof Error ? error.message : "Unknown error"}`, "Burn Failed");
    } finally {
      setIsBurning(false);
    }
  };
  const resetModal = () => {
    setConfirmText("");
    setStep("warning");
  };
  const handleClose = () => {
    if (!isBurning) {
      resetModal();
      onClose();
    }
  };
  const handleProceed = () => {
    setStep("confirm");
  };
  if (!isOpen || !nft) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content burn-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: " Burn NFT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "modal-close",
          onClick: handleClose,
          disabled: isBurning,
          children: ""
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-image", children: nft.video ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "video",
          {
            src: nft.video.startsWith("http") ? nft.video : `https://ipfs.io/ipfs/${nft.video}`,
            muted: true,
            loop: true,
            autoPlay: true
          }
        ) : nft.img ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: nft.img.startsWith("http") ? nft.img : `https://ipfs.io/ipfs/${nft.img}`,
            alt: nft.name
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-image", children: "No Image" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: nft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-collection", children: typeof nft.collection === "string" ? nft.collection : nft.collection?.name || nft.collection?.collection_name || "Unknown" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-schema", children: nft.schema.schema_name }),
          nft.mint_number && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "nft-mint", children: [
            "Mint #",
            nft.mint_number
          ] })
        ] })
      ] }),
      step === "warning" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "burn-warning-step", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "danger-warning", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "warning-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "PERMANENT ACTION WARNING" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "warning-list", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                "This action will ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "permanently destroy" }),
                " your NFT"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                "The NFT will be ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "completely removed" }),
                " from the blockchain"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                "This action ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "cannot be undone or reversed" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                "You will ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "not receive any compensation" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                "The NFT will ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "disappear forever" })
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "burn-reasons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Common reasons for burning NFTs:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Reducing supply to increase rarity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Participating in burn-to-earn mechanics" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Collection cleanup or rebranding" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Accidental duplicate mints" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: handleClose,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-danger",
              onClick: handleProceed,
              children: "I Understand, Proceed"
            }
          )
        ] })
      ] }),
      step === "confirm" && /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "modal-form burn-confirm-step", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "final-warning", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "warning-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "FINAL WARNING:" }),
            " You are about to permanently destroy this NFT. This action cannot be undone."
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: "confirmText", children: [
            "Type ",
            /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              '"',
              requiredConfirmText,
              '"'
            ] }),
            " to confirm:"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "confirmText",
              value: confirmText,
              onChange: (e) => setConfirmText(e.target.value),
              placeholder: `Type "${requiredConfirmText}" here`,
              required: true,
              disabled: isBurning,
              className: "confirm-input",
              autoComplete: "off"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: () => setStep("warning"),
              disabled: isBurning,
              children: "Back"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-danger burn-btn",
              disabled: isBurning || confirmText.toUpperCase() !== requiredConfirmText,
              children: isBurning ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
                "Burning..."
              ] }) : " Burn NFT Forever"
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const BulkListingModal = ({ nfts, isOpen, onClose, onSuccess }) => {
  const [listingPrices, setListingPrices] = reactExports.useState({});
  const [bulkPrice, setBulkPrice] = reactExports.useState("");
  const [isListing, setIsListing] = reactExports.useState(false);
  const [listingProgress, setListingProgress] = reactExports.useState(0);
  const [priceSuggestions, setPriceSuggestions] = reactExports.useState({});
  const [loadingSuggestions, setLoadingSuggestions] = reactExports.useState(false);
  const [showSuggestions, setShowSuggestions] = reactExports.useState(true);
  const [sortBy, setSortBy] = reactExports.useState("name_asc");
  const { session } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  const waxCurrency = {
    symbol: "WAX",
    precision: 8
  };
  const handlePriceChange = (assetId, price) => {
    setListingPrices((prev) => ({
      ...prev,
      [assetId]: price
    }));
  };
  const fetchPriceSuggestions = reactExports.useCallback(async () => {
    if (!nfts.length || !isOpen) return;
    setLoadingSuggestions(true);
    const suggestions = {};
    const maxRetries = 3;
    const fetchWithRetry = async (url, retries = maxRetries) => {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 1e4);
        const response = await fetch(url, {
          signal: controller.signal,
          headers: {
            "Accept": "application/json",
            "Content-Type": "application/json"
          }
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
      } catch (error) {
        if (retries > 0 && error instanceof Error && !error.name.includes("AbortError")) {
          log.warn(`Retrying API call (${maxRetries - retries + 1}/${maxRetries})`, "BulkListingModal.fetchWithRetry", { error: error.message, url });
          await new Promise((resolve) => setTimeout(resolve, 1e3 * (maxRetries - retries + 1)));
          return fetchWithRetry(url, retries - 1);
        }
        throw error;
      }
    };
    try {
      const collectionGroups = nfts.reduce((groups, nft) => {
        const collection = nft.collection.collection_name;
        if (!groups[collection]) groups[collection] = [];
        groups[collection].push(nft);
        return groups;
      }, {});
      const collectionEntries = Object.entries(collectionGroups);
      let successfulCollections = 0;
      for (const [collection, collectionNFTs] of collectionEntries) {
        try {
          const salesUrl = `${apiService.atomicMarketAPI}/atomicmarket/v1/sales?state=3&collection_name=${collection}&limit=100&order=desc&sort=updated`;
          let salesData = null;
          try {
            salesData = await fetchWithRetry(salesUrl);
          } catch (primaryError) {
            log.error(`Primary API failed for ${collection}, trying fallback:`, "BulkListingModal.fetchPriceSuggestions", primaryError);
            try {
              const fallbackUrl = `${apiService.atomicMarketAPI}/atomicmarket/v1/sales?collection_name=${collection}&state=3&limit=50&order=desc`;
              salesData = await fetchWithRetry(fallbackUrl, 1);
            } catch (fallbackError) {
              log.error(`Fallback API also failed for ${collection}:`, "BulkListingModal.fetchPriceSuggestions", fallbackError);
              applyDefaultPricing(collectionNFTs, suggestions);
              continue;
            }
          }
          const isValidApiResponse = (data) => {
            return typeof data === "object" && data !== null && "success" in data && "data" in data && Array.isArray(data.data);
          };
          if (isValidApiResponse(salesData) && salesData.success && salesData.data.length > 0) {
            const sales = salesData.data;
            const prices = sales.filter((sale) => sale.price?.amount).map((sale) => {
              const amount = parseFloat(sale.price.amount);
              const precision = sale.price.token_precision || 8;
              return amount / Math.pow(10, precision);
            }).filter((price) => price > 0 && price < 1e4);
            if (prices.length > 0) {
              const sortedPrices = prices.sort((a, b) => a - b);
              const q1Index = Math.floor(sortedPrices.length * 0.25);
              const q3Index = Math.floor(sortedPrices.length * 0.75);
              const iqr = sortedPrices[q3Index] - sortedPrices[q1Index];
              const lowerBound = sortedPrices[q1Index] - 1.5 * iqr;
              const upperBound = sortedPrices[q3Index] + 1.5 * iqr;
              const filteredPrices = sortedPrices.filter((price) => price >= lowerBound && price <= upperBound);
              if (filteredPrices.length > 0) {
                const floorPrice = Math.min(...filteredPrices);
                const averagePrice = filteredPrices.reduce((sum, price) => sum + price, 0) / filteredPrices.length;
                const medianPrice = filteredPrices[Math.floor(filteredPrices.length / 2)];
                let suggestedPrice;
                if (filteredPrices.length >= 10) {
                  suggestedPrice = Math.max(floorPrice * 1.03, medianPrice * 0.98);
                } else {
                  suggestedPrice = Math.max(floorPrice * 1.05, averagePrice * 0.95);
                }
                let confidence;
                if (filteredPrices.length >= 20) {
                  confidence = "high";
                } else if (filteredPrices.length >= 10) {
                  confidence = "medium";
                } else {
                  confidence = "low";
                }
                collectionNFTs.forEach((nft) => {
                  suggestions[nft.asset_id] = {
                    floorPrice,
                    averagePrice,
                    suggestedPrice,
                    confidence,
                    sampleSize: filteredPrices.length
                  };
                });
                successfulCollections++;
              } else {
                applyDefaultPricing(collectionNFTs, suggestions);
              }
            } else {
              applyDefaultPricing(collectionNFTs, suggestions);
            }
          } else {
            applyDefaultPricing(collectionNFTs, suggestions);
          }
        } catch (error) {
          log.error(`Failed to process collection ${collection}:`, "BulkListingModal.fetchPriceSuggestions", error);
          applyDefaultPricing(collectionNFTs, suggestions);
        }
        if (collectionEntries.indexOf([collection, collectionNFTs]) < collectionEntries.length - 1) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }
      if (successfulCollections === 0) {
        showError("Price Analysis", "Unable to fetch current market data. Using default pricing suggestions.");
      } else if (successfulCollections < collectionEntries.length) {
        log.warn(`Price data available for ${successfulCollections}/${collectionEntries.length} collections`);
      }
      setPriceSuggestions(suggestions);
    } catch (error) {
      log.error("Error fetching price suggestions:", "BulkListingModal.fetchPriceSuggestions", error);
      showError("Price Analysis Failed", "Unable to analyze market prices. Please set prices manually.");
      nfts.forEach((nft) => {
        suggestions[nft.asset_id] = {
          floorPrice: 1,
          averagePrice: 2,
          suggestedPrice: 1.5,
          confidence: "low",
          sampleSize: 0
        };
      });
      setPriceSuggestions(suggestions);
    } finally {
      setLoadingSuggestions(false);
    }
  }, [nfts, isOpen, showError]);
  const applyDefaultPricing = (collectionNFTs, suggestions) => {
    const defaultFloor = 1;
    const defaultAverage = 2;
    const defaultSuggested = 1.5;
    collectionNFTs.forEach((nft) => {
      suggestions[nft.asset_id] = {
        floorPrice: defaultFloor,
        averagePrice: defaultAverage,
        suggestedPrice: defaultSuggested,
        confidence: "low",
        sampleSize: 0
      };
    });
  };
  reactExports.useEffect(() => {
    if (isOpen && nfts.length > 0) {
      fetchPriceSuggestions();
    }
  }, [isOpen, nfts, fetchPriceSuggestions]);
  const sortedNfts = reactExports.useMemo(() => {
    const sorted = [...nfts];
    switch (sortBy) {
      case "name_asc":
        return sorted.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      case "name_desc":
        return sorted.sort((a, b) => (b.name || "").localeCompare(a.name || ""));
      case "collection_asc":
        return sorted.sort((a, b) => a.collection.collection_name.localeCompare(b.collection.collection_name));
      case "collection_desc":
        return sorted.sort((a, b) => b.collection.collection_name.localeCompare(a.collection.collection_name));
      case "mint_asc":
        return sorted.sort((a, b) => (a.mint_number || 0) - (b.mint_number || 0));
      case "mint_desc":
        return sorted.sort((a, b) => (b.mint_number || 0) - (a.mint_number || 0));
      case "price_asc":
        return sorted.sort((a, b) => {
          const priceA = parseFloat(listingPrices[a.asset_id] || "0");
          const priceB = parseFloat(listingPrices[b.asset_id] || "0");
          return priceA - priceB;
        });
      case "price_desc":
        return sorted.sort((a, b) => {
          const priceA = parseFloat(listingPrices[a.asset_id] || "0");
          const priceB = parseFloat(listingPrices[b.asset_id] || "0");
          return priceB - priceA;
        });
      default:
        return sorted;
    }
  }, [nfts, sortBy, listingPrices]);
  const applyBulkPrice = () => {
    if (!bulkPrice) return;
    const newPrices = {};
    nfts.forEach((nft) => {
      newPrices[nft.asset_id] = bulkPrice;
    });
    setListingPrices(newPrices);
  };
  const applySuggestedPrices = () => {
    const newPrices = {};
    nfts.forEach((nft) => {
      const suggestion = priceSuggestions[nft.asset_id];
      if (suggestion) {
        newPrices[nft.asset_id] = formatNumber(suggestion.suggestedPrice, 4);
      }
    });
    setListingPrices(newPrices);
  };
  const applyFloorPrices = () => {
    const newPrices = {};
    nfts.forEach((nft) => {
      const suggestion = priceSuggestions[nft.asset_id];
      if (suggestion) {
        newPrices[nft.asset_id] = formatNumber(suggestion.floorPrice * 0.99, 4);
      }
    });
    setListingPrices(newPrices);
  };
  reactExports.useEffect(() => {
    if (showSuggestions && nfts.length > 0) {
      fetchPriceSuggestions();
    }
  }, [showSuggestions, nfts, fetchPriceSuggestions]);
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!session || nfts.length === 0) {
      showError("Validation Error", "Please connect your wallet and select NFTs to list");
      return;
    }
    const invalidPrices = nfts.filter((nft) => {
      const price = listingPrices[nft.asset_id];
      return !price || isNaN(parseFloat(price)) || parseFloat(price) <= 0;
    });
    if (invalidPrices.length > 0) {
      showError(
        "Invalid Prices",
        `Please set valid prices for all NFTs. ${invalidPrices.length} NFT(s) have invalid prices.`
      );
      return;
    }
    setIsListing(true);
    setListingProgress(0);
    try {
      const actions = nfts.map((nft) => {
        const priceFloat = parseFloat(listingPrices[nft.asset_id]);
        const formattedPrice = priceFloat.toFixed(waxCurrency.precision);
        const priceString = `${formattedPrice} ${waxCurrency.symbol}`;
        return {
          account: "atomicmarket",
          name: "announcesale",
          authorization: [{
            actor: WharfKitService.safeGetActor(session),
            permission: WharfKitService.safeGetPermission(session)
          }],
          data: {
            seller: WharfKitService.safeGetActor(session),
            asset_ids: [nft.asset_id],
            listing_price: priceString,
            settlement_symbol: `${waxCurrency.precision},${waxCurrency.symbol}`,
            maker_marketplace: "market.pxj"
          }
        };
      });
      const batchSize = 5;
      const batches = [];
      for (let i = 0; i < actions.length; i += batchSize) {
        batches.push(actions.slice(i, i + batchSize));
      }
      let completedBatches = 0;
      for (const batch of batches) {
        const result = await session.transact({ actions: batch });
        if (result) {
          completedBatches++;
          setListingProgress(completedBatches / batches.length * 100);
        }
      }
      showSuccess(
        "Listing Successful",
        `Successfully listed ${nfts.length} NFT(s) on the marketplace!`
      );
      onSuccess?.();
      onClose();
      setListingPrices({});
      setBulkPrice("");
    } catch (error) {
      log.error("Bulk listing failed:", "BulkListingModal.handleSubmit", error);
      showError(
        "Listing Failed",
        error instanceof Error ? error.message : "Unknown error occurred"
      );
    } finally {
      setIsListing(false);
      setListingProgress(0);
    }
  };
  const getTotalValue = () => {
    return nfts.reduce((total, nft) => {
      const price = parseFloat(listingPrices[nft.asset_id] || "0");
      return total + (isNaN(price) ? 0 : price);
    }, 0);
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content bulk-listing-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Bulk List NFTs" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-summary", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Listing Summary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "You are about to list ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
            nfts.length,
            " NFT",
            nfts.length !== 1 ? "s" : ""
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "total-value", children: [
          "Total Value: ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: formatWAXPrice(getTotalValue()) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "listing-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "smart-pricing-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pricing-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Smart Pricing Tools" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "toggle-suggestions",
                onClick: () => setShowSuggestions(!showSuggestions),
                children: showSuggestions ? " Hide Analysis" : " Show Analysis"
              }
            )
          ] }),
          showSuggestions && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-analysis", children: loadingSuggestions ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-suggestions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Analyzing market data..." })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "suggestion-controls", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "btn-suggestion suggested",
                onClick: applySuggestedPrices,
                disabled: isListing || Object.keys(priceSuggestions).length === 0,
                title: "Apply AI-recommended prices based on market analysis",
                children: " Apply Suggested Prices"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "btn-suggestion floor",
                onClick: applyFloorPrices,
                disabled: isListing || Object.keys(priceSuggestions).length === 0,
                title: "Price 1% below current floor prices for quick sales",
                children: " Quick Sale (Floor -1%)"
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-price-controls", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Manual Bulk Pricing" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-input-group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  value: bulkPrice,
                  onChange: (e) => setBulkPrice(e.target.value),
                  placeholder: "Set same price for all",
                  step: "0.0001",
                  min: "0",
                  disabled: isListing
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "btn-secondary",
                  onClick: applyBulkPrice,
                  disabled: !bulkPrice || isListing,
                  children: "Apply to All"
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-pricing-list", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pricing-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Individual Pricing" }),
            nfts.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sort-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "nft-sort", children: "Sort by:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  id: "nft-sort",
                  className: "sort-select",
                  value: sortBy,
                  onChange: (e) => setSortBy(e.target.value),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name (A-Z)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name (Z-A)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_asc", children: "Collection (A-Z)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_desc", children: "Collection (Z-A)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_asc", children: "Mint # (Low-High)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_desc", children: "Mint # (High-Low)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_asc", children: "Price (Low-High)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_desc", children: "Price (High-Low)" })
                  ]
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bulk-listing-pricing-list-container", children: sortedNfts.map((nft) => {
            const suggestion = priceSuggestions[nft.asset_id];
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-nft-pricing-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-nft-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bulk-listing-nft-image", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: nft.img?.startsWith("http") ? nft.img : `https://ipfs.io/ipfs/${nft.img}`,
                    alt: nft.name,
                    onError: (e) => {
                      const target = e.target;
                      target.src = "https://pixeljourney.xyz/img/toppixals/10.webp";
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-nft-details", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bulk-listing-nft-name", children: nft.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bulk-listing-nft-collection", children: typeof nft.collection === "string" ? nft.collection : nft.collection?.collection_name || nft.collection?.name || "Unknown" }),
                  nft.mint_number && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bulk-listing-nft-mint", children: [
                    "#",
                    nft.mint_number
                  ] }),
                  suggestion && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-price-suggestions", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-suggestion-row", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bulk-listing-suggestion-label", children: "Floor:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bulk-listing-suggestion-value", children: formatWAXPrice(suggestion.floorPrice) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-suggestion-row", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bulk-listing-suggestion-label", children: "Avg:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bulk-listing-suggestion-value", children: formatWAXPrice(suggestion.averagePrice) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-suggestion-row", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bulk-listing-suggestion-label", children: "Suggested:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `bulk-listing-suggestion-value confidence-${suggestion.confidence}`, children: formatWAXPrice(suggestion.suggestedPrice) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bulk-listing-confidence-badge", children: suggestion.confidence })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-sample-size", children: [
                      "Based on ",
                      suggestion.sampleSize,
                      " recent sales"
                    ] })
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-price-input-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-price-input", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      value: listingPrices[nft.asset_id] || "",
                      onChange: (e) => handlePriceChange(nft.asset_id, e.target.value),
                      placeholder: "Price in WAX",
                      step: "0.0001",
                      min: "0",
                      required: true,
                      disabled: isListing
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "currency-label", children: "WAX" })
                ] }),
                suggestion && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-listing-quick-price-buttons", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      className: "bulk-listing-quick-price-btn suggested",
                      onClick: () => handlePriceChange(nft.asset_id, formatNumber(suggestion.suggestedPrice, 4)),
                      disabled: isListing,
                      title: "Use suggested price",
                      children: ""
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      className: "bulk-listing-quick-price-btn floor",
                      onClick: () => handlePriceChange(nft.asset_id, formatNumber(suggestion.floorPrice * 0.99, 4)),
                      disabled: isListing,
                      title: "Use floor price -1%",
                      children: ""
                    }
                  )
                ] })
              ] })
            ] }, nft.asset_id);
          }) })
        ] }),
        isListing && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-progress", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "progress-fill",
              style: { width: `${listingProgress}%` }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Listing NFTs... ",
            Math.round(listingProgress),
            "% complete"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: onClose,
              disabled: isListing,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary",
              disabled: isListing || getTotalValue() === 0,
              children: isListing ? "Listing..." : `List ${nfts.length} NFT${nfts.length !== 1 ? "s" : ""}`
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const BulkTransferModal = ({ nfts, isOpen, onClose, onSuccess }) => {
  const [recipient, setRecipient] = reactExports.useState("");
  const [memo, setMemo] = reactExports.useState("");
  const [isTransferring, setIsTransferring] = reactExports.useState(false);
  const [transferProgress, setTransferProgress] = reactExports.useState(0);
  const [sortBy, setSortBy] = reactExports.useState("name_asc");
  const { session, bulkTransferNFT } = useWallet$1();
  const { showError, showSuccess } = useNotifications();
  const sortedNfts = reactExports.useMemo(() => {
    const sorted = [...nfts];
    switch (sortBy) {
      case "name_asc":
        return sorted.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      case "name_desc":
        return sorted.sort((a, b) => (b.name || "").localeCompare(a.name || ""));
      case "collection_asc":
        return sorted.sort((a, b) => a.collection.collection_name.localeCompare(b.collection.collection_name));
      case "collection_desc":
        return sorted.sort((a, b) => b.collection.collection_name.localeCompare(a.collection.collection_name));
      case "mint_asc":
        return sorted.sort((a, b) => (a.mint_number || 0) - (b.mint_number || 0));
      case "mint_desc":
        return sorted.sort((a, b) => (b.mint_number || 0) - (a.mint_number || 0));
      default:
        return sorted;
    }
  }, [nfts, sortBy]);
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!session || !recipient.trim() || nfts.length === 0) {
      showError("Please fill in all required fields", "Validation Error");
      return;
    }
    const recipientTrimmed = recipient.trim().toLowerCase();
    if (recipientTrimmed.length < 1 || recipientTrimmed.length > 12) {
      showError("Account name must be between 1 and 12 characters", "Validation Error");
      return;
    }
    if (!/^[a-z1-5.]+$/.test(recipientTrimmed)) {
      showError("Account name can only contain lowercase letters, numbers 1-5, and dots", "Validation Error");
      return;
    }
    setIsTransferring(true);
    setTransferProgress(0);
    try {
      if (!bulkTransferNFT) {
        log.error("bulkTransferNFT service not available", "BulkTransferModal");
        throw new Error("Bulk transfer service not available");
      }
      const assetIds = nfts.map((nft) => nft.asset_id);
      await bulkTransferNFT(
        recipientTrimmed,
        assetIds,
        memo || "Bulk transfer from PxMarket"
      );
      setTransferProgress(100);
      showSuccess(`Successfully transferred ${nfts.length} NFT(s) to ${recipientTrimmed}!`, "Transfer Complete");
      onSuccess?.();
      onClose();
      setRecipient("");
      setMemo("");
    } catch (error) {
      log.error("Bulk transfer failed", "BulkTransferModal.handleSubmit", error, { nftCount: nfts.length, recipient });
      showError(`Transfer failed: ${error instanceof Error ? error.message : "Unknown error"}`, "Transfer Failed");
    } finally {
      setIsTransferring(false);
      setTransferProgress(0);
    }
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content bulk-transfer-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Bulk Transfer NFTs" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transfer-summary", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Transfer Summary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "You are about to transfer ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
            nfts.length,
            " NFT",
            nfts.length !== 1 ? "s" : ""
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-breakdown", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Collection Breakdown" }),
          Object.entries(
            nfts.reduce((acc, nft) => {
              const collectionName = nft.collection.collection_name;
              acc[collectionName] = (acc[collectionName] || 0) + 1;
              return acc;
            }, {})
          ).map(([collection, count]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "collection-name", children: collection }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "collection-count", children: [
              count,
              " NFT",
              count !== 1 ? "s" : ""
            ] })
          ] }, collection))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rarity-breakdown", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Rarity Distribution" }),
          Object.entries(
            nfts.reduce((acc, nft) => {
              const rarity = nft.template?.immutable_data?.rarity || nft.data?.rarity || "Unknown";
              acc[rarity.toString()] = (acc[rarity.toString()] || 0) + 1;
              return acc;
            }, {})
          ).map(([rarity, count]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rarity-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rarity-name", children: rarity }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rarity-count", children: count })
          ] }, rarity))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "preview-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "NFT Preview" }),
            nfts.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sort-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "transfer-sort", children: "Sort by:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  id: "transfer-sort",
                  className: "sort-select",
                  value: sortBy,
                  onChange: (e) => setSortBy(e.target.value),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name (A-Z)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name (Z-A)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_asc", children: "Collection (A-Z)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_desc", children: "Collection (Z-A)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_asc", children: "Mint # (Low-High)" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_desc", children: "Mint # (High-Low)" })
                  ]
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview-list", children: [
            sortedNfts.slice(0, 5).map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: nft.img?.startsWith("http") ? nft.img : `https://ipfs.io/ipfs/${nft.img}`,
                  alt: nft.name,
                  onError: (e) => {
                    const target = e.target;
                    target.src = "https://pixeljourney.xyz/img/toppixals/10.webp";
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-info-bulk", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-details", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-name", children: nft.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-collection", children: typeof nft.collection === "string" ? nft.collection : nft.collection?.collection_name || nft.collection?.name || "Unknown" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-mint", children: [
                  "#",
                  nft.mint_number || "N/A"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-id", children: [
                  "ID: ",
                  nft.asset_id
                ] })
              ] }) })
            ] }, nft.asset_id)),
            nfts.length > 5 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview-more", children: [
              "+",
              nfts.length - 5,
              " more NFTs"
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "transfer-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "recipient", children: "Recipient Account *" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "recipient",
              value: recipient,
              onChange: (e) => setRecipient(e.target.value),
              placeholder: "Enter WAX account name",
              required: true,
              disabled: isTransferring,
              maxLength: 12
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "form-help", children: "Enter a valid WAX account name (1-12 characters, lowercase letters, numbers 1-5, dots)" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "memo", children: "Memo (Optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "memo",
              value: memo,
              onChange: (e) => setMemo(e.target.value),
              placeholder: "Optional transfer memo",
              disabled: isTransferring,
              maxLength: 256
            }
          )
        ] }),
        isTransferring && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transfer-progress", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "progress-fill",
              style: { width: `${transferProgress}%` }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Transferring... ",
            Math.round(transferProgress),
            "% complete"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: onClose,
              disabled: isTransferring,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary",
              disabled: isTransferring || !recipient.trim(),
              children: isTransferring ? "Transferring..." : `Transfer ${nfts.length} NFT${nfts.length !== 1 ? "s" : ""}`
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const DistributeModal = ({ nfts, isOpen, onClose, onSuccess }) => {
  const [distributions, setDistributions] = reactExports.useState(
    () => nfts.map((nft) => ({ nft, recipient: "" }))
  );
  const [bulkAddresses, setBulkAddresses] = reactExports.useState("");
  const [memo, setMemo] = reactExports.useState("");
  const [isDistributing, setIsDistributing] = reactExports.useState(false);
  const [distributeProgress, setDistributeProgress] = reactExports.useState(0);
  const [batchSize, setBatchSize] = reactExports.useState(10);
  const [sortBy, setSortBy] = reactExports.useState("name_asc");
  const { session } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  const sortedDistributions = reactExports.useMemo(() => {
    const sorted = [...distributions];
    switch (sortBy) {
      case "name_asc":
        return sorted.sort((a, b) => (a.nft.name || "").localeCompare(b.nft.name || ""));
      case "name_desc":
        return sorted.sort((a, b) => (b.nft.name || "").localeCompare(a.nft.name || ""));
      case "collection_asc":
        return sorted.sort((a, b) => a.nft.collection.collection_name.localeCompare(b.nft.collection.collection_name));
      case "collection_desc":
        return sorted.sort((a, b) => b.nft.collection.collection_name.localeCompare(a.nft.collection.collection_name));
      case "mint_asc":
        return sorted.sort((a, b) => (a.nft.mint_number || 0) - (b.nft.mint_number || 0));
      case "mint_desc":
        return sorted.sort((a, b) => (b.nft.mint_number || 0) - (a.nft.mint_number || 0));
      default:
        return sorted;
    }
  }, [distributions, sortBy]);
  React.useEffect(() => {
    setDistributions(nfts.map((nft) => ({ nft, recipient: "" })));
  }, [nfts]);
  const handleRecipientChange = (assetId, recipient) => {
    setDistributions(
      (prev) => prev.map(
        (dist) => dist.nft.asset_id === assetId ? { ...dist, recipient } : dist
      )
    );
  };
  const handleBulkAddressesChange = (addresses) => {
    setBulkAddresses(addresses);
    if (addresses.trim()) {
      const addressList = addresses.split(",").map((addr) => addr.trim()).filter((addr) => addr);
      if (addressList.length > 0) {
        setDistributions(
          (prev) => prev.map((dist, index) => ({
            ...dist,
            recipient: addressList[index % addressList.length] || ""
          }))
        );
      }
    }
  };
  const randomizeDistribution = () => {
    if (!bulkAddresses.trim()) {
      showError("No addresses provided", "Please enter comma-separated addresses first");
      return;
    }
    const addressList = bulkAddresses.split(",").map((addr) => addr.trim()).filter((addr) => addr);
    if (addressList.length === 0) {
      showError("Invalid addresses", "Please provide valid comma-separated addresses");
      return;
    }
    setDistributions(
      (prev) => prev.map((dist) => ({
        ...dist,
        recipient: addressList[Math.floor(Math.random() * addressList.length)]
      }))
    );
  };
  const clearAllRecipients = () => {
    setDistributions((prev) => prev.map((dist) => ({ ...dist, recipient: "" })));
    setBulkAddresses("");
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!session) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    const invalidDistributions = distributions.filter((dist) => !dist.recipient.trim());
    if (invalidDistributions.length > 0) {
      showError("Missing Recipients", `Please specify recipients for all ${invalidDistributions.length} NFT(s)`);
      return;
    }
    setIsDistributing(true);
    setDistributeProgress(0);
    try {
      const totalTransfers = distributions.length;
      let completedTransfers = 0;
      for (let i = 0; i < distributions.length; i += batchSize) {
        const batch = distributions.slice(i, i + batchSize);
        const actions = batch.map(({ nft, recipient }) => ({
          account: "atomicassets",
          name: "transfer",
          authorization: [{
            actor: session.actor.toString(),
            permission: "active"
          }],
          data: {
            from: session.actor.toString(),
            to: recipient.trim(),
            asset_ids: [nft.asset_id],
            memo: memo || `Distributed via PxMarket`
          }
        }));
        const result = await session.transact({
          actions
        }, {
          expireSeconds: 30
        });
        completedTransfers += batch.length;
        setDistributeProgress(completedTransfers / totalTransfers * 100);
        log.info("Batch distribution completed", "DistributeModal", {
          batchSize: batch.length,
          completed: completedTransfers,
          total: totalTransfers,
          transactionId: result.transaction
        });
      }
      showSuccess("Distribution Complete", `Successfully distributed ${totalTransfers} NFT${totalTransfers !== 1 ? "s" : ""}`);
      onSuccess?.();
      onClose();
    } catch (error) {
      log.error("Distribution failed", "DistributeModal", error);
      showError(
        "Distribution Failed",
        error instanceof Error ? error.message : "Unknown error occurred"
      );
    } finally {
      setIsDistributing(false);
      setDistributeProgress(0);
    }
  };
  if (!isOpen) return null;
  const validDistributions = distributions.filter((dist) => dist.recipient.trim());
  const readyToDistribute = validDistributions.length === distributions.length;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content distribute-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Distribute NFTs" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "distribute-summary", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Distribution Summary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "You are about to distribute ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
            nfts.length,
            " NFT",
            nfts.length !== 1 ? "s" : ""
          ] }),
          " to individual recipients"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-addresses-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Bulk Address Input" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "bulk-addresses", children: "Comma-separated addresses (optional)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                id: "bulk-addresses",
                className: "form-control",
                value: bulkAddresses,
                onChange: (e) => handleBulkAddressesChange(e.target.value),
                placeholder: "pixeljourney,market.pxj,council.pxj",
                rows: 3
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "btn btn-secondary",
                  onClick: randomizeDistribution,
                  disabled: !bulkAddresses.trim(),
                  children: " Randomize Distribution"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "btn btn-secondary",
                  onClick: clearAllRecipients,
                  children: " Clear All"
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "batch-config", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Transaction Settings" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "batch-size", children: "NFTs per transaction (5-200)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                id: "batch-size",
                className: "form-control",
                value: batchSize,
                onChange: (e) => setBatchSize(Math.max(5, Math.min(200, parseInt(e.target.value) || 10))),
                min: 5,
                max: 200
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: "Larger batches are more efficient but may fail if too large" })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "distribution-list", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "distribution-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { children: [
            "Individual Recipients (",
            validDistributions.length,
            "/",
            distributions.length,
            " configured)"
          ] }),
          nfts.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sort-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "distribute-sort", children: "Sort by:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                id: "distribute-sort",
                className: "sort-select",
                value: sortBy,
                onChange: (e) => setSortBy(e.target.value),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name (A-Z)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name (Z-A)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_asc", children: "Collection (A-Z)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_desc", children: "Collection (Z-A)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_asc", children: "Mint # (Low-High)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_desc", children: "Mint # (High-Low)" })
                ]
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "distribution-items", children: sortedDistributions.map(({ nft, recipient }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "distribution-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-preview", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: nft.img?.startsWith("http") ? nft.img : `https://ipfs.io/ipfs/${nft.img}`,
                alt: nft.name,
                onError: (e) => {
                  const target = e.target;
                  target.src = "https://pixeljourney.xyz/img/toppixals/10.webp";
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-name", children: nft.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-collection", children: nft.collection.collection_name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-mint", children: [
                "#",
                nft.mint_number || "N/A"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "recipient-input", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "form-control",
              value: recipient,
              onChange: (e) => handleRecipientChange(nft.asset_id, e.target.value),
              placeholder: "Recipient account name"
            }
          ) })
        ] }, nft.asset_id)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "distribute-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "memo", children: "Memo (optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "memo",
              className: "form-control",
              value: memo,
              onChange: (e) => setMemo(e.target.value),
              placeholder: "Optional transfer memo",
              maxLength: 256
            }
          )
        ] }),
        isDistributing && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "progress-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "progress-fill",
              style: { width: `${distributeProgress}%` }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Distributing NFTs... ",
            Math.round(distributeProgress),
            "%"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn btn-secondary",
              onClick: onClose,
              disabled: isDistributing,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn btn-primary",
              disabled: isDistributing || !readyToDistribute,
              children: isDistributing ? "Distributing..." : `Distribute ${nfts.length} NFT${nfts.length !== 1 ? "s" : ""}`
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const BulkBurnModal = ({ nfts, isOpen, onClose, onSuccess }) => {
  const [isBurning, setIsBurning] = reactExports.useState(false);
  const [burnProgress, setBurnProgress] = reactExports.useState(0);
  const [confirmText, setConfirmText] = reactExports.useState("");
  const { session } = useWallet$1();
  const { showError, showSuccess, showWarning } = useNotifications();
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!session || nfts.length === 0) {
      showError("Please connect your wallet and select NFTs to burn", "Wallet Required");
      return;
    }
    const waxrockPixals = [];
    const burnableNfts = nfts.filter((nft) => {
      if (MarketplaceConfigService.isPixalPFP(nft.template.template_id)) {
        const waxRock = nft.data?.WaxRock;
        if (waxRock && MarketplaceConfigService.isValidWaxRock(waxRock)) {
          waxrockPixals.push(nft);
          return false;
        }
      }
      return true;
    });
    if (waxrockPixals.length > 0) {
      const waxrockNames = waxrockPixals.map((nft) => `${nft.name} (${nft.data?.WaxRock})`).join(", ");
      showWarning(
        `${waxrockPixals.length} WaxRock Pixal PFP(s) were excluded from burning for protection: ${waxrockNames}. WaxRock Pixals are protected from burning and recycling on our platform.`,
        "Protected NFTs Excluded",
        8e3
      );
      if (burnableNfts.length === 0) {
        showError("No NFTs remaining to burn after excluding WaxRock Pixals.", "No Burnable NFTs");
        return;
      }
    }
    if (confirmText !== "BURN") {
      showError('Please type "BURN" to confirm this action', "Confirmation Required");
      return;
    }
    setIsBurning(true);
    setBurnProgress(0);
    try {
      const actions = burnableNfts.map((nft) => ({
        account: "atomicassets",
        name: "burnasset",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          asset_owner: WharfKitService.safeGetActor(session),
          asset_id: nft.asset_id
        }
      }));
      const batchSize = 10;
      const batches = [];
      for (let i = 0; i < actions.length; i += batchSize) {
        batches.push(actions.slice(i, i + batchSize));
      }
      let completedBatches = 0;
      for (const batch of batches) {
        const result = await session.transact({ actions: batch });
        if (result) {
          completedBatches++;
          setBurnProgress(completedBatches / batches.length * 100);
        }
      }
      showSuccess(`Successfully burned ${burnableNfts.length} NFT(s)!`, "Burn Complete");
      onSuccess?.();
      onClose();
      setConfirmText("");
    } catch (error) {
      log.error("Bulk burn failed", "BulkBurnModal.handleSubmit", error, { nftCount: burnableNfts.length });
      showError(`Burn failed: ${error instanceof Error ? error.message : "Unknown error"}`, "Burn Failed");
    } finally {
      setIsBurning(false);
      setBurnProgress(0);
    }
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content bulk-burn-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Bulk Burn NFTs" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "burn-warning", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "warning-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "9", x2: "12", y2: "13" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Warning: This action cannot be undone!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "You are about to permanently burn ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
            nfts.length,
            " NFT",
            nfts.length !== 1 ? "s" : ""
          ] }),
          ". This will completely destroy these assets and they cannot be recovered."
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nfts-to-burn", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "NFTs to be burned:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "burn-list-container", children: nfts.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "burn-nft-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: nft.img?.startsWith("http") ? nft.img : `https://ipfs.io/ipfs/${nft.img}`,
              alt: nft.name,
              onError: (e) => {
                const target = e.target;
                target.src = "https://pixeljourney.xyz/img/toppixals/10.webp";
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-name", children: nft.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-collection", children: typeof nft.collection === "string" ? nft.collection : nft.collection?.collection_name || nft.collection?.name || "Unknown" }),
            nft.mint_number && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-mint", children: [
              "#",
              nft.mint_number
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-id", children: [
              "ID: ",
              nft.asset_id
            ] })
          ] })
        ] }, nft.asset_id)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "burn-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "confirmation-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: "confirmText", children: [
            "Type ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: '"BURN"' }),
            " to confirm this action:"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              id: "confirmText",
              type: "text",
              value: confirmText,
              onChange: (e) => setConfirmText(e.target.value.toUpperCase()),
              placeholder: "Type BURN to confirm",
              disabled: isBurning,
              required: true
            }
          )
        ] }),
        isBurning && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "burn-progress", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "progress-fill",
              style: { width: `${burnProgress}%` }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Burning NFTs... ",
            Math.round(burnProgress),
            "% complete"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: onClose,
              disabled: isBurning,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-danger",
              disabled: isBurning || confirmText !== "BURN",
              children: isBurning ? "Burning..." : ` Burn ${nfts.length} NFT${nfts.length !== 1 ? "s" : ""}`
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const INGREDIENT_TEMPLATES = [
  { id: 781515, pxj: 1, wuf: 22, pxjUpgrade: 0, name: "Pixal PFP", type: "pixals" },
  { id: 820134, pxj: 2.22, wuf: 5, pxjUpgrade: 0, name: "Pixel Ingredient Pack", type: "pixelpack" },
  { id: 858568, pxj: 142, wuf: 142, pxjUpgrade: 0, name: "Black (Primary)", type: "primary" },
  { id: 858569, pxj: 0.42, wuf: 1, pxjUpgrade: 0, name: "Blue (Primary)", type: "primary" },
  { id: 858570, pxj: 0.42, wuf: 1, pxjUpgrade: 0, name: "Red (Primary)", type: "primary" },
  { id: 858571, pxj: 0.42, wuf: 1, pxjUpgrade: 0, name: "Yellow (Primary)", type: "primary" },
  { id: 858572, pxj: 2.22, wuf: 1, pxjUpgrade: 25e3, name: "Green (Secondary)", type: "secondary" },
  { id: 858573, pxj: 2.22, wuf: 1, pxjUpgrade: 25e3, name: "Orange (Secondary)", type: "secondary" },
  { id: 858574, pxj: 2.22, wuf: 1, pxjUpgrade: 25e3, name: "Purple (Secondary)", type: "secondary" },
  { id: 858575, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Amber (Tertiary)", type: "tertiary" },
  { id: 858576, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Chartreuse (Tertiary)", type: "tertiary" },
  { id: 858577, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Violet (Tertiary)", type: "tertiary" },
  { id: 858578, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Teal (Tertiary)", type: "tertiary" },
  { id: 858580, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Vermillion (Tertiary)", type: "tertiary" },
  { id: 859273, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Magenta (Tertiary)", type: "tertiary" }
];
const CRAFTING_RECIPES = [
  {
    id: "craft_green",
    name: "Green (Secondary)",
    description: "Craft Green from Yellow + Blue + 25,000 PXJ",
    resultTemplateId: 858572,
    ingredients: [
      { templateId: 858571, quantity: 1, name: "Yellow (Primary)" },
      { templateId: 858569, quantity: 1, name: "Blue (Primary)" }
    ],
    pxjCost: 25e3,
    tier: "secondary"
  },
  {
    id: "craft_orange",
    name: "Orange (Secondary)",
    description: "Craft Orange from Red + Yellow + 25,000 PXJ",
    resultTemplateId: 858573,
    ingredients: [
      { templateId: 858570, quantity: 1, name: "Red (Primary)" },
      { templateId: 858571, quantity: 1, name: "Yellow (Primary)" }
    ],
    pxjCost: 25e3,
    tier: "secondary"
  },
  {
    id: "craft_purple",
    name: "Purple (Secondary)",
    description: "Craft Purple from Red + Blue + 25,000 PXJ",
    resultTemplateId: 858574,
    ingredients: [
      { templateId: 858570, quantity: 1, name: "Red (Primary)" },
      { templateId: 858569, quantity: 1, name: "Blue (Primary)" }
    ],
    pxjCost: 25e3,
    tier: "secondary"
  },
  {
    id: "craft_amber",
    name: "Amber (Tertiary)",
    description: "Craft Amber from Orange + Green + 150,000 PXJ",
    resultTemplateId: 858575,
    ingredients: [
      { templateId: 858573, quantity: 1, name: "Orange (Secondary)" },
      { templateId: 858572, quantity: 1, name: "Green (Secondary)" }
    ],
    pxjCost: 15e4,
    tier: "tertiary"
  },
  {
    id: "craft_chartreuse",
    name: "Chartreuse (Tertiary)",
    description: "Craft Chartreuse from Green + Purple + 150,000 PXJ",
    resultTemplateId: 858576,
    ingredients: [
      { templateId: 858572, quantity: 1, name: "Green (Secondary)" },
      { templateId: 858574, quantity: 1, name: "Purple (Secondary)" }
    ],
    pxjCost: 15e4,
    tier: "tertiary"
  },
  {
    id: "craft_violet",
    name: "Violet (Tertiary)",
    description: "Craft Violet from Purple + Orange + 150,000 PXJ",
    resultTemplateId: 858577,
    ingredients: [
      { templateId: 858574, quantity: 1, name: "Purple (Secondary)" },
      { templateId: 858573, quantity: 1, name: "Orange (Secondary)" }
    ],
    pxjCost: 15e4,
    tier: "tertiary"
  },
  {
    id: "craft_teal",
    name: "Teal (Tertiary)",
    description: "Craft Teal from Green + Purple + 150,000 PXJ",
    resultTemplateId: 858578,
    ingredients: [
      { templateId: 858572, quantity: 1, name: "Green (Secondary)" },
      { templateId: 858574, quantity: 1, name: "Purple (Secondary)" }
    ],
    pxjCost: 15e4,
    tier: "tertiary"
  },
  {
    id: "craft_vermillion",
    name: "Vermillion (Tertiary)",
    description: "Craft Vermillion from Orange + Purple + 150,000 PXJ",
    resultTemplateId: 858580,
    ingredients: [
      { templateId: 858573, quantity: 1, name: "Orange (Secondary)" },
      { templateId: 858574, quantity: 1, name: "Purple (Secondary)" }
    ],
    pxjCost: 15e4,
    tier: "tertiary"
  },
  {
    id: "craft_magenta",
    name: "Magenta (Tertiary)",
    description: "Craft Magenta from Purple + Orange + 150,000 PXJ",
    resultTemplateId: 859273,
    ingredients: [
      { templateId: 858574, quantity: 1, name: "Purple (Secondary)" },
      { templateId: 858573, quantity: 1, name: "Orange (Secondary)" }
    ],
    pxjCost: 15e4,
    tier: "tertiary"
  }
];
const getTemplateById = (id) => {
  return INGREDIENT_TEMPLATES.find((template) => template.id === id);
};
class InventoryService {
  constructor() {
    __publicField(this, "cache", []);
    __publicField(this, "balanceCache", { pxj: 0, wuf: 0 });
    __publicField(this, "lastFetch", 0);
    __publicField(this, "CACHE_DURATION", 3e4);
    // 30 seconds
    // Virtual library for background loading
    __publicField(this, "virtualLibrary", /* @__PURE__ */ new Map());
    // account -> full NFT data
    __publicField(this, "virtualLibraryTimestamp", /* @__PURE__ */ new Map());
    __publicField(this, "VIRTUAL_LIBRARY_CACHE_DURATION", 3e5);
    // 5 minutes
    __publicField(this, "backgroundLoadingPromises", /* @__PURE__ */ new Map());
    __publicField(this, "isBackgroundLoading", /* @__PURE__ */ new Set());
  }
  /**
   * Fetch user's ingredient inventory from the blockchain
   */
  async fetchInventory(account) {
    const now = Date.now();
    if (this.cache.length > 0 && now - this.lastFetch < this.CACHE_DURATION) {
      return this.cache;
    }
    try {
      const response = await fetch(
        `${apiService.getCurrentAtomicEndpoint()}/atomicassets/v1/assets?owner=${account}&collection_name=pixeljourney&burned=false&limit=1000&page=1&order=desc&sort=asset_id`
      );
      if (!response.ok) {
        throw new Error(`Failed to fetch inventory: ${response.statusText}`);
      }
      const data = await response.json();
      const assets = data.data || [];
      const inventoryMap = /* @__PURE__ */ new Map();
      for (const asset of assets) {
        const templateId = parseInt(asset.template.template_id);
        const template = INGREDIENT_TEMPLATES.find((t) => t.id === templateId);
        if (!template || !["primary", "secondary", "tertiary"].includes(template.type)) {
          continue;
        }
        if (!inventoryMap.has(templateId)) {
          inventoryMap.set(templateId, {
            templateId,
            name: template.name,
            assetIds: [],
            tier: template.type
          });
        }
        inventoryMap.get(templateId).assetIds.push(asset.asset_id);
      }
      this.cache = Array.from(inventoryMap.values()).map((item) => ({
        ...item,
        quantity: item.assetIds.length
      }));
      this.lastFetch = now;
      return this.cache;
    } catch (error) {
      ErrorMessageService.logError("InventoryService.fetchInventory", error, { account });
      this.cache = [];
      return [];
    }
  }
  /**
   * Fetch user's token balances (PXJ, WUF)
   */
  async fetchBalances(account) {
    try {
      let pxjBalance = 0;
      let wufBalance = 0;
      try {
        const pxjBalances = await apiService.getWaxCurrencyBalance(account, "pixeljourney", "PXJ");
        if (pxjBalances && pxjBalances.length > 0) {
          pxjBalance = parseFloat(pxjBalances[0].balance.split(" ")[0]);
        }
      } catch (error) {
        ErrorMessageService.logError("InventoryService.getPXJBalance", error, { account });
      }
      try {
        const wufBalances = await apiService.getWaxCurrencyBalance(account, "wuffi", "WUF");
        if (wufBalances && wufBalances.length > 0) {
          wufBalance = parseFloat(wufBalances[0].balance.split(" ")[0]);
        }
      } catch (error) {
        ErrorMessageService.logError("InventoryService.getWUFBalance", error, { account });
      }
      this.balanceCache = { pxj: pxjBalance, wuf: wufBalance };
      return this.balanceCache;
    } catch (error) {
      ErrorMessageService.logError("InventoryService.fetchBalances", error, { account });
      const emptyBalances = { pxj: 0, wuf: 0 };
      this.balanceCache = emptyBalances;
      return emptyBalances;
    }
  }
  /**
   * Get quantity of a specific ingredient from inventory
   */
  getIngredientQuantity(templateId) {
    const item = this.cache.find((inv) => inv.templateId === templateId);
    return item ? item.quantity : 0;
  }
  /**
   * Get asset IDs for a specific ingredient (needed for crafting transactions)
   */
  getIngredientAssetIds(templateId, quantity) {
    const item = this.cache.find((inv) => inv.templateId === templateId);
    if (!item || item.quantity < quantity) {
      return [];
    }
    return item.assetIds.slice(0, quantity);
  }
  /**
   * Check if user has enough ingredients for a recipe
   */
  canCraftRecipe(ingredients, pxjCost) {
    for (const ingredient of ingredients) {
      const available = this.getIngredientQuantity(ingredient.templateId);
      if (available < ingredient.quantity) {
        return false;
      }
    }
    if (this.balanceCache.pxj < pxjCost) {
      return false;
    }
    return true;
  }
  /**
   * Calculate maximum craftable quantity for a recipe
   */
  getMaxCraftableQuantity(ingredients, pxjCost) {
    let maxFromIngredients = Infinity;
    for (const ingredient of ingredients) {
      const available = this.getIngredientQuantity(ingredient.templateId);
      const needed = ingredient.quantity;
      const possibleFromThisIngredient = Math.floor(available / needed);
      maxFromIngredients = Math.min(maxFromIngredients, possibleFromThisIngredient);
    }
    const maxFromPxj = Math.floor(this.balanceCache.pxj / pxjCost);
    return Math.min(maxFromIngredients, maxFromPxj);
  }
  /**
   * Update inventory after successful crafting (optimistic update)
   */
  updateInventoryAfterCraft(usedIngredients, pxjSpent) {
    for (const used of usedIngredients) {
      const item = this.cache.find((inv) => inv.templateId === used.templateId);
      if (item) {
        item.quantity = Math.max(0, item.quantity - used.quantity);
        item.assetIds = item.assetIds.slice(used.quantity);
      }
    }
    this.balanceCache.pxj = Math.max(0, this.balanceCache.pxj - pxjSpent);
  }
  /**
   * Start background loading of user's full inventory for virtual library
   */
  async startBackgroundInventoryLoad(account) {
    if (!account || this.isBackgroundLoading.has(account)) {
      return;
    }
    const lastUpdate = this.virtualLibraryTimestamp.get(account) || 0;
    const now = Date.now();
    if (now - lastUpdate < this.VIRTUAL_LIBRARY_CACHE_DURATION) {
      return;
    }
    this.isBackgroundLoading.add(account);
    try {
      log.debug(`Starting background inventory load for ${account}`, "InventoryService.startBackgroundInventoryLoad");
      const promise = this.loadFullInventoryInBackground(account);
      this.backgroundLoadingPromises.set(account, promise);
      await promise;
      log.info(`Background inventory load completed for ${account}`, "InventoryService.startBackgroundInventoryLoad");
    } catch (error) {
      ErrorMessageService.logError("InventoryService.startBackgroundInventoryLoad", error, { account });
    } finally {
      this.isBackgroundLoading.delete(account);
      this.backgroundLoadingPromises.delete(account);
    }
  }
  /**
   * Convert NFTAsset to InventoryNFT format
   */
  convertNFTAssetToInventoryNFT(asset) {
    return {
      asset_id: asset.asset_id,
      name: asset.name,
      img: asset.image,
      video: asset.video,
      collection: {
        name: asset.collection,
        collection_name: asset.collection
      },
      schema: {
        schema_name: asset.schema
      },
      template: {
        template_id: asset.template_id?.toString() || "0",
        max_supply: asset.max_supply || "0",
        immutable_data: {
          img: asset.image,
          video: asset.video
        }
      },
      data: {
        ...asset.traits,
        rarity: asset.rarity
      },
      mint_number: asset.template_mint
    };
  }
  /**
   * Load full inventory in background with pagination
   */
  async loadFullInventoryInBackground(account) {
    const allNFTs = [];
    let page = 1;
    const limit = 100;
    let hasMore = true;
    while (hasMore) {
      try {
        const response = await apiService.getUserInventoryWithFilter(
          account,
          page,
          limit,
          "all"
        );
        if (response && response.assets && response.assets.length > 0) {
          const convertedAssets = response.assets.map((asset) => this.convertNFTAssetToInventoryNFT(asset));
          allNFTs.push(...convertedAssets);
          hasMore = response.hasMore;
          page++;
          await new Promise((resolve) => setTimeout(resolve, 100));
        } else {
          hasMore = false;
        }
      } catch (error) {
        ErrorMessageService.logError("InventoryService.loadFullInventoryInBackground", error, { account, page });
        hasMore = false;
      }
    }
    this.virtualLibrary.set(account, allNFTs);
    this.virtualLibraryTimestamp.set(account, Date.now());
    log.info(`Loaded ${allNFTs.length} NFTs into virtual library for ${account}`, "InventoryService.loadFullInventoryInBackground");
  }
  /**
   * Get inventory page from virtual library (if available) or fetch from API
   */
  async getInventoryPage(account, page, limit = 50) {
    const virtualData = this.virtualLibrary.get(account);
    const lastUpdate = this.virtualLibraryTimestamp.get(account) || 0;
    const now = Date.now();
    if (virtualData && now - lastUpdate < this.VIRTUAL_LIBRARY_CACHE_DURATION) {
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;
      const pageData = virtualData.slice(startIndex, endIndex);
      return {
        data: pageData,
        hasMore: endIndex < virtualData.length,
        totalCount: virtualData.length
      };
    }
    try {
      const response = await apiService.getUserInventoryWithFilter(account, page, limit, "all");
      const convertedAssets = response?.assets ? response.assets.map((asset) => this.convertNFTAssetToInventoryNFT(asset)) : [];
      return {
        data: convertedAssets,
        hasMore: response?.hasMore || false,
        totalCount: response?.total || 0
      };
    } catch (error) {
      ErrorMessageService.logError("InventoryService.getInventoryPage", error, { account, page, limit });
      return { data: [], hasMore: false, totalCount: 0 };
    }
  }
  /**
   * Check if background loading is in progress
   */
  isBackgroundLoadingInProgress(account) {
    return this.isBackgroundLoading.has(account);
  }
  /**
   * Get virtual library stats
   */
  getVirtualLibraryStats(account) {
    const itemCount = this.virtualLibrary.get(account)?.length || 0;
    const lastUpdate = this.virtualLibraryTimestamp.get(account) || null;
    const isLoading = this.isBackgroundLoading.has(account);
    return { itemCount, lastUpdate, isLoading };
  }
  /**
   * Clear cache to force refresh on next fetch
   */
  clearCache() {
    this.cache = [];
    this.balanceCache = { pxj: 0, wuf: 0 };
    this.lastFetch = 0;
  }
  /**
   * Clear virtual library cache
   */
  clearVirtualLibrary(account) {
    if (account) {
      this.virtualLibrary.delete(account);
      this.virtualLibraryTimestamp.delete(account);
      this.isBackgroundLoading.delete(account);
      this.backgroundLoadingPromises.delete(account);
    } else {
      this.virtualLibrary.clear();
      this.virtualLibraryTimestamp.clear();
      this.isBackgroundLoading.clear();
      this.backgroundLoadingPromises.clear();
    }
  }
  /**
   * Get cached inventory without fetching
   */
  getCachedInventory() {
    return this.cache;
  }
  /**
   * Get cached balances without fetching
   */
  getCachedBalances() {
    return this.balanceCache;
  }
}
const inventoryService = new InventoryService();
const CraftingModal = ({ isOpen, onClose, ingredient }) => {
  const { account, session, transferTokens, executeCraftingTransaction } = useWallet$1();
  useDisplaySettings();
  const { showError, showSuccess, showWarning } = useNotifications();
  const [activeTab, setActiveTab] = reactExports.useState("craft");
  const [selectedRecipe, setSelectedRecipe] = reactExports.useState(null);
  const [craftingQueue, setCraftingQueue] = reactExports.useState([]);
  const [isProcessing, setIsProcessing] = reactExports.useState(false);
  const [inventory, setInventory] = reactExports.useState([]);
  const [balances, setBalances] = reactExports.useState({ pxj: 0, wuf: 0 });
  const [loadingInventory, setLoadingInventory] = reactExports.useState(false);
  const [craftQuantity, setCraftQuantity] = reactExports.useState(1);
  const [maxCraftable, setMaxCraftable] = reactExports.useState(0);
  const [sortBy, setSortBy] = reactExports.useState("name_asc");
  const loadInventoryData = reactExports.useCallback(async () => {
    if (!account) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    setLoadingInventory(true);
    try {
      const [inventoryData, balanceData] = await Promise.all([
        inventoryService.fetchInventory(account),
        inventoryService.fetchBalances(account)
      ]);
      setInventory(inventoryData);
      setBalances(balanceData);
    } catch (error) {
      console.error("Failed to load inventory:", error);
      showError("Failed to load inventory data", error instanceof Error ? error.message : "Unknown error");
    } finally {
      setLoadingInventory(false);
    }
  }, [account, showError]);
  reactExports.useEffect(() => {
    if (isOpen && account) {
      loadInventoryData();
    }
  }, [isOpen, account, loadInventoryData]);
  const getInventoryQuantity = (templateId) => {
    const item = inventory.find((inv) => inv.templateId === templateId);
    return item ? item.quantity : 0;
  };
  const calculateMaxCraftable = (recipe) => {
    if (!recipe) return 0;
    let maxFromIngredients = Infinity;
    for (const ingredient2 of recipe.ingredients) {
      const available = getInventoryQuantity(ingredient2.templateId);
      const needed = ingredient2.quantity;
      const possibleFromThisIngredient = Math.floor(available / needed);
      maxFromIngredients = Math.min(maxFromIngredients, possibleFromThisIngredient);
    }
    const maxFromPxj = Math.floor(balances.pxj / recipe.pxjCost);
    return Math.min(maxFromIngredients, maxFromPxj);
  };
  reactExports.useEffect(() => {
    if (selectedRecipe) {
      const max = calculateMaxCraftable(selectedRecipe);
      setMaxCraftable(max);
      setCraftQuantity(Math.min(craftQuantity, max));
    }
  }, [selectedRecipe, inventory, balances.pxj, calculateMaxCraftable, craftQuantity]);
  const sortedInventory = reactExports.useMemo(() => {
    const sorted = [...inventory];
    switch (sortBy) {
      case "name_asc":
        return sorted.sort((a, b) => a.name.localeCompare(b.name));
      case "name_desc":
        return sorted.sort((a, b) => b.name.localeCompare(a.name));
      case "quantity_asc":
        return sorted.sort((a, b) => a.quantity - b.quantity);
      case "quantity_desc":
        return sorted.sort((a, b) => b.quantity - a.quantity);
      case "type_asc":
        return sorted.sort((a, b) => {
          const templateA = getTemplateById(a.templateId);
          const templateB = getTemplateById(b.templateId);
          const typeA = templateA?.type || "Unknown";
          const typeB = templateB?.type || "Unknown";
          return typeA.localeCompare(typeB);
        });
      case "type_desc":
        return sorted.sort((a, b) => {
          const templateA = getTemplateById(a.templateId);
          const templateB = getTemplateById(b.templateId);
          const typeA = templateA?.type || "Unknown";
          const typeB = templateB?.type || "Unknown";
          return typeB.localeCompare(typeA);
        });
      default:
        return sorted;
    }
  }, [inventory, sortBy]);
  const canCraft = (recipe, quantity = 1) => {
    for (const ingredient2 of recipe.ingredients) {
      const available = getInventoryQuantity(ingredient2.templateId);
      const needed = ingredient2.quantity * quantity;
      if (available < needed) return false;
    }
    const pxjNeeded = recipe.pxjCost * quantity;
    if (balances.pxj < pxjNeeded) return false;
    return true;
  };
  const addToQueue = () => {
    if (!selectedRecipe || craftQuantity <= 0) return;
    if (!canCraft(selectedRecipe, craftQuantity)) {
      showWarning("Insufficient Resources", "You don't have enough ingredients or PXJ for this craft.");
      return;
    }
    const existingIndex = craftingQueue.findIndex((item) => item.recipe.id === selectedRecipe.id);
    if (existingIndex >= 0) {
      const newQueue = [...craftingQueue];
      newQueue[existingIndex].quantity += craftQuantity;
      setCraftingQueue(newQueue);
    } else {
      setCraftingQueue([...craftingQueue, { recipe: selectedRecipe, quantity: craftQuantity }]);
    }
    showSuccess("Added to Queue", `Added ${craftQuantity}x ${selectedRecipe.name} to crafting queue`);
    setCraftQuantity(1);
  };
  const removeFromQueue = (recipeId) => {
    setCraftingQueue(craftingQueue.filter((item) => item.recipe.id !== recipeId));
  };
  const clearQueue = () => {
    setCraftingQueue([]);
  };
  const executeCraftingQueue = async () => {
    if (craftingQueue.length === 0) {
      showWarning("Empty Queue", "No items in crafting queue");
      return;
    }
    if (!account || !session) {
      showError("Wallet Required", "Please connect your wallet to craft ingredients");
      return;
    }
    if (isProcessing) {
      return;
    }
    setIsProcessing(true);
    let successCount = 0;
    try {
      for (const queueItem of craftingQueue) {
        const { recipe, quantity } = queueItem;
        const ingredientAssets = [];
        let canProceed = true;
        for (const ingredient2 of recipe.ingredients) {
          const neededQuantity = ingredient2.quantity * quantity;
          const assetIds = inventoryService.getIngredientAssetIds(ingredient2.templateId, neededQuantity);
          if (assetIds.length < neededQuantity) {
            showError("Insufficient Ingredients", `Not enough ${ingredient2.name} available`);
            canProceed = false;
            break;
          }
          ingredientAssets.push({
            templateId: ingredient2.templateId,
            assetIds
          });
        }
        if (!canProceed) continue;
        try {
          if (!executeCraftingTransaction) {
            showError("Crafting Error", "Crafting service not available");
            continue;
          }
          const craftingData = {
            recipe: recipe.id,
            quantity,
            ingredientAssets,
            pxjCost: recipe.pxjCost
          };
          const result = await executeCraftingTransaction(craftingData);
          if (result) {
            successCount++;
            const usedIngredients = recipe.ingredients.map((ing) => ({
              templateId: ing.templateId,
              quantity: ing.quantity * quantity
            }));
            inventoryService.updateInventoryAfterCraft(usedIngredients, recipe.pxjCost * quantity);
            showSuccess("Craft Successful!", `Successfully crafted ${quantity}x ${recipe.name}`);
          } else {
            showError("Craft Failed", `Failed to craft ${recipe.name}`);
          }
        } catch (craftError) {
          console.error("Craft error:", craftError);
          showError("Craft Failed", craftError instanceof Error ? craftError.message : "Unknown crafting error");
        }
      }
      if (successCount > 0) {
        showSuccess("Crafting Complete!", `Successfully crafted ${successCount} recipe(s)`);
        setCraftingQueue([]);
        loadInventoryData();
        onClose();
      }
    } catch (error) {
      console.error("Crafting failed:", error);
      showError("Crafting Failed", error instanceof Error ? error.message : "Unknown error occurred");
    } finally {
      setIsProcessing(false);
    }
  };
  const handleUpgrade = async () => {
    if (!ingredient || !account || !session) {
      showError("Missing Requirements", "Ingredient and wallet connection required for upgrading");
      return;
    }
    const templateId = "template" in ingredient ? ingredient.template?.template_id : ingredient.id;
    const template = getTemplateById(typeof templateId === "string" ? parseInt(templateId) : templateId);
    if (!template || template.pxjUpgrade === 0) {
      showError("Cannot Upgrade", "This ingredient cannot be upgraded");
      return;
    }
    if (balances.pxj < template.pxjUpgrade) {
      showError("Insufficient PXJ", `You need ${template.pxjUpgrade.toLocaleString()} PXJ to upgrade this ingredient`);
      return;
    }
    setIsProcessing(true);
    try {
      if (!transferTokens) {
        showError("Upgrade Error", "Transfer service not available");
        return;
      }
      const result = await transferTokens(
        "upgradepool",
        template.pxjUpgrade.toString(),
        "PXJ",
        `Upgrade ${template.name}`
      );
      if (result) {
        showSuccess("Upgrade Complete!", `Successfully upgraded ${template.name}`);
        loadInventoryData();
        onClose();
      }
    } catch (error) {
      console.error("Upgrade failed:", error);
      showError("Upgrade Failed", error instanceof Error ? error.message : "Unknown error occurred");
    } finally {
      setIsProcessing(false);
    }
  };
  if (!isOpen) return null;
  return reactDomExports.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crafting-modal", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Pixel Ingredient Crafting" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: onClose, children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-tabs", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `tab-btn ${activeTab === "craft" ? "active" : ""}`,
            onClick: () => setActiveTab("craft"),
            children: "Craft New"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `tab-btn ${activeTab === "upgrade" ? "active" : ""}`,
            onClick: () => setActiveTab("upgrade"),
            disabled: !ingredient,
            children: "Upgrade Existing"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-content", children: activeTab === "craft" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "craft-tab", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "craft-layout", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-selection", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Select Recipe" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-categories", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-category", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Secondary Ingredients" }),
                CRAFTING_RECIPES.filter((r) => r.tier === "secondary").map((recipe) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: `recipe-item ${selectedRecipe?.id === recipe.id ? "selected" : ""} ${!canCraft(recipe) ? "disabled" : ""}`,
                    onClick: () => setSelectedRecipe(recipe),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "recipe-name", children: recipe.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-cost", children: [
                        recipe.pxjCost.toLocaleString(),
                        " PXJ"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "recipe-ingredients", children: recipe.ingredients.map((ing, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: getInventoryQuantity(ing.templateId) >= ing.quantity ? "available" : "unavailable", children: [
                        ing.name,
                        " (",
                        getInventoryQuantity(ing.templateId),
                        "/",
                        ing.quantity,
                        ")"
                      ] }, idx)) })
                    ]
                  },
                  recipe.id
                ))
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-category", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Tertiary Ingredients" }),
                CRAFTING_RECIPES.filter((r) => r.tier === "tertiary").map((recipe) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: `recipe-item ${selectedRecipe?.id === recipe.id ? "selected" : ""} ${!canCraft(recipe) ? "disabled" : ""}`,
                    onClick: () => setSelectedRecipe(recipe),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "recipe-name", children: recipe.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-cost", children: [
                        recipe.pxjCost.toLocaleString(),
                        " PXJ"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "recipe-ingredients", children: recipe.ingredients.map((ing, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: getInventoryQuantity(ing.templateId) >= ing.quantity ? "available" : "unavailable", children: [
                        ing.name,
                        " (",
                        getInventoryQuantity(ing.templateId),
                        "/",
                        ing.quantity,
                        ")"
                      ] }, idx)) })
                    ]
                  },
                  recipe.id
                ))
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "craft-controls", children: [
            selectedRecipe && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-recipe", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: selectedRecipe.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: selectedRecipe.description }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quantity-controls", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Quantity:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quantity-input", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => setCraftQuantity(Math.max(1, craftQuantity - 1)),
                      disabled: craftQuantity <= 1,
                      children: "-"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      value: craftQuantity,
                      onChange: (e) => setCraftQuantity(Math.min(maxCraftable, Math.max(1, parseInt(e.target.value) || 1))),
                      min: "1",
                      max: maxCraftable
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => setCraftQuantity(Math.min(maxCraftable, craftQuantity + 1)),
                      disabled: craftQuantity >= maxCraftable,
                      children: "+"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "max-craftable", children: [
                  "Max: ",
                  maxCraftable
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "total-cost", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                "Total Cost: ",
                (selectedRecipe.pxjCost * craftQuantity).toLocaleString(),
                " PXJ"
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "add-to-queue-btn",
                  onClick: addToQueue,
                  disabled: !canCraft(selectedRecipe, craftQuantity) || craftQuantity <= 0,
                  children: "Add to Queue"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-section", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-header", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Your Inventory" }),
                !loadingInventory && inventory.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sort-container", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "inventory-sort", children: "Sort by:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      id: "inventory-sort",
                      className: "sort-select",
                      value: sortBy,
                      onChange: (e) => setSortBy(e.target.value),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name (A-Z)" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name (Z-A)" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "quantity_asc", children: "Quantity (Low-High)" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "quantity_desc", children: "Quantity (High-Low)" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "type_asc", children: "Type (A-Z)" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "type_desc", children: "Type (Z-A)" })
                      ]
                    }
                  )
                ] })
              ] }),
              loadingInventory ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-inventory", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading inventory..." })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inventory-grid", children: sortedInventory.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-inventory", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "No ingredients found" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "refresh-btn",
                    onClick: loadInventoryData,
                    disabled: loadingInventory,
                    children: "Refresh Inventory"
                  }
                )
              ] }) }) : sortedInventory.map((item) => {
                const template = getTemplateById(item.templateId);
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-name", children: item.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-quantity", children: [
                    "Qty: ",
                    item.quantity
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item-tier", children: template?.type || "Unknown" })
                ] }, item.templateId);
              }) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crafting-queue", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "queue-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
              "Crafting Queue (",
              craftingQueue.length,
              ")"
            ] }),
            craftingQueue.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "clear-queue-btn", onClick: clearQueue, children: "Clear All" })
          ] }),
          craftingQueue.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "queue-items", children: [
            craftingQueue.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "queue-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "queue-item-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "item-name", children: item.recipe.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "item-quantity", children: [
                  "x",
                  item.quantity
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "item-cost", children: [
                  (item.recipe.pxjCost * item.quantity).toLocaleString(),
                  " PXJ"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "remove-item-btn",
                  onClick: () => removeFromQueue(item.recipe.id),
                  children: "Remove"
                }
              )
            ] }, index)),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "queue-total", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              "Total: ",
              craftingQueue.reduce((sum, item) => sum + item.recipe.pxjCost * item.quantity, 0).toLocaleString(),
              " PXJ"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "execute-queue-btn",
                onClick: executeCraftingQueue,
                disabled: isProcessing,
                children: isProcessing ? "Crafting..." : "Craft All"
              }
            )
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-queue", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No items in queue. Select a recipe and add it to start crafting." }) })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "upgrade-tab", children: ingredient ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "upgrade-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
          "Upgrade: ",
          ingredient.name
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "Template ID: ",
          "template" in ingredient ? ingredient.template?.template_id : ingredient.id
        ] }),
        (() => {
          const templateId = "template" in ingredient ? ingredient.template?.template_id : ingredient.id;
          const template = getTemplateById(typeof templateId === "string" ? parseInt(templateId) : templateId);
          if (!template) return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Template not found" });
          if (template.pxjUpgrade === 0) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "no-upgrade", children: "This ingredient cannot be upgraded." });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "upgrade-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "upgrade-cost", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              "Upgrade Cost: ",
              template.pxjUpgrade.toLocaleString(),
              " PXJ"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-info", children: [
              "Your PXJ Balance: ",
              balances.pxj.toLocaleString()
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "upgrade-btn",
                onClick: handleUpgrade,
                disabled: isProcessing || balances.pxj < template.pxjUpgrade,
                children: isProcessing ? "Upgrading..." : "Upgrade Ingredient"
              }
            )
          ] });
        })()
      ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-ingredient", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No ingredient selected for upgrade. Please select an ingredient from your inventory." }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-display", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pxj-balance", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
        "PXJ Balance: ",
        balances.pxj.toLocaleString()
      ] }) }) }) })
    ] }) }),
    document.body
  );
};
class OfferService {
  constructor() {
    __publicField(this, "atomicMarketContract", "atomicmarket");
  }
  get atomicMarketAPI() {
    return apiService.getCurrentAtomicEndpoint();
  }
  // Place a buy offer on an NFT
  async placeBuyOffer(session, assetId, offerAmount, memo = "") {
    if (!session) {
      throw new Error("Please connect your wallet first");
    }
    const offerFloat = parseFloat(offerAmount);
    if (isNaN(offerFloat) || offerFloat <= 0) {
      throw new Error("Please enter a valid offer amount");
    }
    try {
      const formattedPrice = offerFloat.toFixed(8);
      const priceString = `${formattedPrice} WAX`;
      const assetResponse = await fetch(
        `${this.atomicMarketAPI}/atomicassets/v1/assets/${assetId}`
      );
      if (!assetResponse.ok) {
        throw new Error("Failed to fetch asset details");
      }
      const assetData = await assetResponse.json();
      if (!assetData.success || !assetData.data) {
        throw new Error("Asset not found");
      }
      const asset = assetData.data;
      const seller = asset.owner;
      const action = {
        account: this.atomicMarketContract,
        name: "announceoffer",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          buyer: WharfKitService.safeGetActor(session),
          recipient: seller,
          asset_ids: [assetId],
          price: priceString,
          memo: memo || `Buy offer from PxMarket - market.pixeljourney.xyz`,
          maker_marketplace: "market.pxj"
        }
      };
      const result = await session.transact({ actions: [action] });
      const transactionResult = result;
      return {
        success: true,
        transaction_id: transactionResult?.transaction_id || transactionResult?.id || "",
        message: `Buy offer of ${offerAmount} WAX placed successfully!`
      };
    } catch (error) {
      ErrorMessageService.logError("OfferService.placeBuyOffer", error, { assetId, offerAmount, actor: session.actor });
      throw new Error(`Failed to place buy offer: ${error instanceof Error ? error.message : "Transaction failed or was rejected"}`);
    }
  }
  // Get buy offers for a specific asset
  async getBuyOffersForAsset(assetId) {
    try {
      const response = await fetch(
        `${this.atomicMarketAPI}/atomicmarket/v1/buyoffers?asset_id=${assetId}&state=0&sort=price&order=desc&limit=50`
      );
      if (!response.ok) {
        throw new Error("Failed to fetch buy offers");
      }
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("OfferService.getBuyOffersForAsset", error, { assetId });
      return [];
    }
  }
  // Get buy offers made by a user
  async getUserBuyOffers(account, state) {
    try {
      let url = `${this.atomicMarketAPI}/atomicmarket/v1/buyoffers?buyer=${account}&sort=created&order=desc&limit=100`;
      if (state !== void 0) {
        url += `&state=${state}`;
      }
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error("Failed to fetch user buy offers");
      }
      const data = await response.json();
      if (data.success && data.data) {
        return data.data;
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("OfferService.getUserBuyOffers", error, { account, state });
      return [];
    }
  }
  // Cancel a buy offer
  async cancelBuyOffer(session, offerId) {
    if (!session) {
      throw new Error("Please connect your wallet first");
    }
    try {
      const action = {
        account: this.atomicMarketContract,
        name: "canceloffer",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          offer_id: offerId
        }
      };
      const result = await session.transact({ actions: [action] });
      const transactionResult = result;
      return {
        success: true,
        transaction_id: transactionResult?.transaction_id || transactionResult?.id || "",
        message: "Buy offer cancelled successfully!"
      };
    } catch (error) {
      ErrorMessageService.logError("OfferService.cancelBuyOffer", error, { offerId, actor: session.actor });
      throw new Error(`Failed to cancel buy offer: ${error instanceof Error ? error.message : "Transaction failed or was rejected"}`);
    }
  }
  // Accept a buy offer (for sellers)
  async acceptBuyOffer(session, offerId) {
    if (!session) {
      throw new Error("Please connect your wallet first");
    }
    try {
      const action = {
        account: this.atomicMarketContract,
        name: "acceptoffer",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          offer_id: offerId
        }
      };
      const result = await session.transact({ actions: [action] });
      const transactionResult = result;
      return {
        success: true,
        transaction_id: transactionResult?.transaction_id || transactionResult?.id || "",
        message: "Buy offer accepted successfully!"
      };
    } catch (error) {
      ErrorMessageService.logError("OfferService.acceptBuyOffer", error, { offerId, actor: session.actor });
      throw new Error(`Failed to accept buy offer: ${error instanceof Error ? error.message : "Transaction failed or was rejected"}`);
    }
  }
  // Decline a buy offer (for sellers)
  async declineBuyOffer(session, offerId) {
    if (!session) {
      throw new Error("Please connect your wallet first");
    }
    try {
      const action = {
        account: this.atomicMarketContract,
        name: "declineoffer",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          offer_id: offerId
        }
      };
      const result = await session.transact({ actions: [action] });
      const transactionResult = result;
      return {
        success: true,
        transaction_id: transactionResult?.transaction_id || transactionResult?.id || "",
        message: "Buy offer declined successfully!"
      };
    } catch (error) {
      ErrorMessageService.logError("OfferService.declineBuyOffer", error, { offerId, actor: session.actor });
      throw new Error(`Failed to decline buy offer: ${error instanceof Error ? error.message : "Transaction failed or was rejected"}`);
    }
  }
  // Format price for display
  formatPrice(price) {
    const amount = parseFloat(price.amount) / Math.pow(10, price.token_precision);
    return `${amount.toFixed(Math.min(4, price.token_precision))} ${price.token_symbol}`;
  }
  // Get offer state as readable string
  getOfferStateText(state) {
    switch (state) {
      case 0:
        return "Pending";
      case 1:
        return "Invalid";
      case 2:
        return "Accepted";
      case 3:
        return "Declined";
      case 4:
        return "Cancelled";
      default:
        return "Unknown";
    }
  }
}
const offerService = new OfferService();
const ViewOffersModal = ({ isOpen, onClose, nft }) => {
  const { account, session } = useWallet$1();
  const { settings } = useDisplaySettings();
  const { showSuccess, showError } = useNotifications();
  const [offers, setOffers] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [acceptingOffer, setAcceptingOffer] = reactExports.useState(null);
  const loadOffers = reactExports.useCallback(async () => {
    if (!nft) return;
    setLoading(true);
    try {
      const offersData = await apiService.getAssetOffers(nft.asset_id);
      if (offersData && offersData.length > 0) {
        const formattedOffers = offersData.map((offer) => ({
          id: offer.id,
          buyer: offer.buyer,
          price: (parseFloat(offer.price) / 1e8).toFixed(8),
          // Convert from atomic units
          symbol: offer.token,
          timestamp: offer.created,
          memo: offer.memo
        }));
        const sortedOffers = formattedOffers.sort((a, b) => parseFloat(b.price) - parseFloat(a.price));
        setOffers(sortedOffers);
      } else {
        setOffers([]);
      }
    } catch (error) {
      console.error("Failed to load offers:", error);
      setOffers([]);
    } finally {
      setLoading(false);
    }
  }, [nft]);
  reactExports.useEffect(() => {
    if (isOpen && nft) {
      loadOffers();
    }
  }, [isOpen, nft, loadOffers]);
  const handleAcceptOffer = async (offer) => {
    if (!account || !session || !nft) {
      showError("Please connect your wallet first", "Wallet Required");
      return;
    }
    const confirmed = window.confirm(
      `Accept offer of ${offer.price} ${offer.symbol} from ${offer.buyer}?

This action cannot be undone.`
    );
    if (!confirmed) return;
    setAcceptingOffer(offer.id);
    try {
      if (!session) {
        showError("Wallet Not Connected", "Please connect your wallet to accept offers.");
        return;
      }
      await offerService.acceptBuyOffer(session, offer.id);
      showSuccess(
        "Offer Accepted!",
        `${offer.price} ${offer.symbol} will be transferred to your account.`
      );
      onClose();
    } catch (error) {
      showError(
        "Failed to Accept Offer",
        error instanceof Error ? error.message : "Failed to accept the offer. Please try again."
      );
    } finally {
      setAcceptingOffer(null);
    }
  };
  const formatTimeAgo = (timestamp) => {
    const now = /* @__PURE__ */ new Date();
    const offerTime = new Date(timestamp);
    const diffMs = now.getTime() - offerTime.getTime();
    const diffHours = Math.floor(diffMs / (1e3 * 60 * 60));
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays > 0) {
      return `${diffDays} day${diffDays > 1 ? "s" : ""} ago`;
    } else if (diffHours > 0) {
      return `${diffHours} hour${diffHours > 1 ? "s" : ""} ago`;
    } else {
      const diffMinutes = Math.floor(diffMs / (1e3 * 60));
      return `${diffMinutes} minute${diffMinutes > 1 ? "s" : ""} ago`;
    }
  };
  if (!isOpen || !nft) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content view-offers-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "View Offers" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offers-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "view-offers-nft-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-image", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          MediaRenderer,
          {
            imageUrl: nft.img,
            alt: nft.name,
            enableAnimations: settings.enableAnimatedNFTs
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: nft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-id", children: [
            "#",
            nft.asset_id
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-info", children: [
            typeof nft.collection === "string" ? nft.collection : nft.collection?.name || nft.collection?.collection_name || "Unknown",
            "  ",
            nft.schema.schema_name
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offers-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offers-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
            "Active Offers (",
            offers.length,
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "refresh-btn", onClick: loadOffers, disabled: loading, children: [
            loading ? "" : "",
            " Refresh"
          ] })
        ] }),
        loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading offers..." })
        ] }) : offers.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-offers", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "No Offers Yet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "This NFT hasn't received any offers yet. List it on the marketplace to attract buyers!" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "offers-list", children: offers.map((offer, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `offer-card ${index === 0 ? "highest-offer" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offer-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buyer-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: offer.buyer }),
              index === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "highest-badge", children: " Highest" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "offer-time", children: formatTimeAgo(offer.timestamp) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offer-price", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-amount", children: parseFloat(offer.price).toFixed(2) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-symbol", children: offer.symbol })
          ] }),
          offer.memo && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "offer-memo", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("em", { children: [
            '"',
            offer.memo,
            '"'
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "offer-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "accept-btn",
              onClick: () => handleAcceptOffer(offer),
              disabled: acceptingOffer !== null,
              children: acceptingOffer === offer.id ? "Accepting..." : "Accept Offer"
            }
          ) })
        ] }, offer.id)) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: onClose, children: "Close" }) })
  ] }) });
};
class NeftyBlendService {
  // Generic pack blend ID
  static async recyclePixal(assetId, userAccount) {
    const blockInfo = await this.getBlockInfo();
    const transaction = {
      expiration: this.getExpirationTime(),
      ref_block_num: blockInfo.ref_block_num,
      ref_block_prefix: blockInfo.ref_block_prefix,
      max_net_usage_words: 0,
      max_cpu_usage_ms: 0,
      delay_sec: 0,
      context_free_actions: [],
      actions: [
        // Skip CPU pay action as mentioned in requirements
        {
          account: this.BLEND_CONTRACT,
          name: "openbal",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            owner: userAccount,
            token_symbol: "8,PXJ"
          }
        },
        {
          account: this.PXJ_CONTRACT,
          name: "transfer",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            from: userAccount,
            to: this.BLEND_CONTRACT,
            quantity: this.RECYCLE_COST,
            memo: "deposit"
          }
        },
        {
          account: this.BLEND_CONTRACT,
          name: "announcedepo",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            owner: userAccount,
            count: 1
          }
        },
        {
          account: this.ATOMIC_ASSETS_CONTRACT,
          name: "transfer",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            from: userAccount,
            to: this.BLEND_CONTRACT,
            asset_ids: [assetId],
            memo: "deposit"
          }
        },
        {
          account: this.BLEND_CONTRACT,
          name: "nosecfuse",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            claimer: userAccount,
            blend_id: this.RECYCLE_BLEND_ID,
            transferred_assets: [assetId],
            own_assets: []
          }
        }
      ],
      transaction_extensions: []
    };
    return transaction;
  }
  static async unpackPixelIngredientPack(assetId, userAccount) {
    const blockInfo = await this.getBlockInfo();
    const transaction = {
      expiration: this.getExpirationTime(),
      ref_block_num: blockInfo.ref_block_num,
      ref_block_prefix: blockInfo.ref_block_prefix,
      max_net_usage_words: 0,
      max_cpu_usage_ms: 0,
      delay_sec: 0,
      context_free_actions: [],
      actions: [
        {
          account: this.ATOMIC_ASSETS_CONTRACT,
          name: "transfer",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            from: userAccount,
            to: this.BLEND_CONTRACT,
            asset_ids: [assetId],
            memo: "unpack"
          }
        },
        {
          account: this.BLEND_CONTRACT,
          name: "nosecfuse",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            claimer: userAccount,
            blend_id: this.PACK_RECIPE_ID,
            transferred_assets: [assetId],
            own_assets: []
          }
        }
      ],
      transaction_extensions: []
    };
    return transaction;
  }
  static async unpackGenericPack(assetId, userAccount) {
    const blockInfo = await this.getBlockInfo();
    const transaction = {
      expiration: this.getExpirationTime(),
      ref_block_num: blockInfo.ref_block_num,
      ref_block_prefix: blockInfo.ref_block_prefix,
      max_net_usage_words: 0,
      max_cpu_usage_ms: 0,
      delay_sec: 0,
      context_free_actions: [],
      actions: [
        {
          account: this.ATOMIC_ASSETS_CONTRACT,
          name: "transfer",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            from: userAccount,
            to: this.BLEND_CONTRACT,
            asset_ids: [assetId],
            memo: "unpack"
          }
        },
        {
          account: this.BLEND_CONTRACT,
          name: "nosecfuse",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            claimer: userAccount,
            blend_id: this.GENERIC_PACK_BLEND_ID,
            transferred_assets: [assetId],
            own_assets: []
          }
        }
      ],
      transaction_extensions: []
    };
    return transaction;
  }
  static async getBlockInfo() {
    try {
      const waxEndpoints = [
        API_ENDPOINTS.WAX_CHAIN.EOSRIO,
        API_ENDPOINTS.WAX_CHAIN.WAXSWEDEN,
        API_ENDPOINTS.WAX_CHAIN.GREYMASS
      ];
      for (const endpoint of waxEndpoints) {
        try {
          const response = await fetch(`${endpoint}/v1/chain/get_info`, {
            method: "GET",
            headers: {
              "Accept": "application/json"
            }
          });
          if (!response.ok) continue;
          const chainInfo = await response.json();
          const headBlockId = chainInfo.head_block_id;
          const refBlockNum = chainInfo.last_irreversible_block_num & 65535;
          const blockIdBytes = headBlockId.match(/.{2}/g)?.slice(4, 8) || ["00", "00", "00", "00"];
          const refBlockPrefix = parseInt(blockIdBytes.reverse().join(""), 16);
          return {
            ref_block_num: refBlockNum,
            ref_block_prefix: refBlockPrefix
          };
        } catch (endpointError) {
          logger.warn("Failed to fetch block info from endpoint", "NEFTY_BLEND", { endpoint, error: endpointError });
          continue;
        }
      }
      throw new Error("All WAX endpoints failed");
    } catch (error) {
      ErrorMessageService.logError("NeftyBlendService.getBlockInfo", error);
      const now = Date.now();
      return {
        ref_block_num: now / 500 & 65535,
        // Approximate block number
        ref_block_prefix: now & 4294967295
        // Use timestamp as prefix
      };
    }
  }
  static getExpirationTime() {
    const now = /* @__PURE__ */ new Date();
    const expiration = new Date(now.getTime() + 30 * 60 * 1e3);
    return expiration.toISOString().slice(0, -5);
  }
  static async executeRecycle(transaction, wallet) {
    try {
      if (!wallet || !wallet.transact) {
        throw new Error("Wallet not connected or does not support transactions");
      }
      const result = await wallet.transact({
        actions: transaction.actions
      });
      logger.info("Recycle transaction successful", "NEFTY_BLEND", { result });
      return true;
    } catch (error) {
      ErrorMessageService.logError("NeftyBlendService.executeRecycle", error, {
        blendId: this.RECYCLE_BLEND_ID,
        recycleCost: this.RECYCLE_COST,
        actionsCount: transaction.actions.length,
        walletActor: wallet.actor
      });
      throw error;
    }
  }
  static async executeUnpack(transaction, wallet) {
    try {
      if (!wallet || !wallet.transact) {
        throw new Error("Wallet not connected or does not support transactions");
      }
      const result = await wallet.transact({
        actions: transaction.actions
      });
      logger.info("Unpack transaction successful", "NEFTY_BLEND", { result });
      return result;
    } catch (error) {
      ErrorMessageService.logError("NeftyBlendService.executeUnpack", error, {
        actionsCount: transaction.actions.length,
        walletActor: wallet.actor
      });
      throw error;
    }
  }
  static isPackNFT(nft) {
    if (!nft || !nft.template) return false;
    const packKeywords = ["pack", "container", "box", "chest"];
    const templateName = (nft.template.name || "").toLowerCase();
    const hasPackKeyword = packKeywords.some((keyword) => templateName.includes(keyword));
    const isNeftyBlocksPack = nft.template?.template_id === this.PACK_TEMPLATE_ID;
    return hasPackKeyword || isNeftyBlocksPack;
  }
  static getPackType(nft) {
    if (!this.isPackNFT(nft)) return null;
    if (nft.template?.template_id === this.PACK_TEMPLATE_ID) {
      return "pixel_ingredient";
    }
    return "generic";
  }
  static async unpackPixelPack(assetId, userAccount) {
    const blockInfo = await this.getBlockInfo();
    const transaction = {
      expiration: this.getExpirationTime(),
      ref_block_num: blockInfo.ref_block_num,
      ref_block_prefix: blockInfo.ref_block_prefix,
      max_net_usage_words: 0,
      max_cpu_usage_ms: 0,
      delay_sec: 0,
      context_free_actions: [],
      actions: [
        {
          account: this.ATOMIC_ASSETS_CONTRACT,
          name: "transfer",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            from: userAccount,
            to: "neftyblocksp",
            asset_ids: [assetId],
            memo: "unbox"
          }
        }
      ],
      transaction_extensions: []
    };
    return transaction;
  }
  static async unpackPixelPacksBulk(assetIds, userAccount) {
    const transactions = [];
    for (let i = 0; i < assetIds.length; i += 20) {
      const batch = assetIds.slice(i, i + 20);
      const blockInfo = await this.getBlockInfo();
      const transaction = {
        expiration: this.getExpirationTime(),
        ref_block_num: blockInfo.ref_block_num,
        ref_block_prefix: blockInfo.ref_block_prefix,
        max_net_usage_words: 0,
        max_cpu_usage_ms: 0,
        delay_sec: 0,
        context_free_actions: [],
        actions: batch.map((assetId) => ({
          account: this.ATOMIC_ASSETS_CONTRACT,
          name: "transfer",
          authorization: [{
            actor: userAccount,
            permission: "active"
          }],
          data: {
            from: userAccount,
            to: "neftyblocksp",
            asset_ids: [assetId],
            memo: "unbox"
          }
        })),
        transaction_extensions: []
      };
      transactions.push(transaction);
    }
    return transactions;
  }
  static isPixelPack(nft) {
    return nft.template?.template_id === this.PACK_TEMPLATE_ID;
  }
}
__publicField(NeftyBlendService, "BLEND_CONTRACT", "blend.nefty");
__publicField(NeftyBlendService, "ATOMIC_ASSETS_CONTRACT", "atomicassets");
__publicField(NeftyBlendService, "PXJ_CONTRACT", "pixeljourney");
__publicField(NeftyBlendService, "RECYCLE_BLEND_ID", 37700);
__publicField(NeftyBlendService, "RECYCLE_COST", "12000.00000000 PXJ");
// Pack unpack blend IDs - Updated with correct values
__publicField(NeftyBlendService, "PACK_TEMPLATE_ID", "820134");
// NeftyBlocks pack template ID
__publicField(NeftyBlendService, "PACK_RECIPE_ID", 37701);
// Recipe ID for unpacking
__publicField(NeftyBlendService, "GENERIC_PACK_BLEND_ID", 37702);
const UnpackModal = ({
  isOpen,
  onClose,
  selectedNFTs,
  userAccount,
  walletSession,
  onUnpackComplete
}) => {
  const [isUnpacking, setIsUnpacking] = reactExports.useState(false);
  const { showError, showSuccess } = useNotifications();
  const packNFTs = selectedNFTs.filter((nft) => NeftyBlendService.isPackNFT(nft));
  const handleUnpack = async () => {
    if (!userAccount || !walletSession) {
      showError("Wallet not connected", "Connection Required");
      return;
    }
    if (packNFTs.length === 0) {
      showError("No pack NFTs selected", "No Packs Selected");
      return;
    }
    setIsUnpacking(true);
    const results = [];
    try {
      for (const nft of packNFTs) {
        const packType = NeftyBlendService.getPackType(nft);
        let transaction;
        if (packType === "pixel_ingredient") {
          transaction = await NeftyBlendService.unpackPixelIngredientPack(nft.asset_id, userAccount);
        } else {
          transaction = await NeftyBlendService.unpackGenericPack(nft.asset_id, userAccount);
        }
        const result = await NeftyBlendService.executeUnpack(transaction, walletSession);
        results.push({ nft, transaction: result, success: true });
      }
      showSuccess("Packs unpacked successfully!", "Unpack Complete");
      onUnpackComplete();
    } catch (error) {
      console.error("Error unpacking NFTs:", error);
      showError("Failed to unpack NFTs. Please try again.", "Unpack Failed");
    } finally {
      setIsUnpacking(false);
    }
  };
  if (!isOpen) return null;
  const canUnpack = packNFTs.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content unpack-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Unpack NFT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "unpack-nft-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
          "Selected Pack NFTs (",
          packNFTs.length,
          ")"
        ] }),
        packNFTs.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-image", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: nft.img, alt: nft.name }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: nft.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "collection-name", children: typeof nft.collection === "string" ? nft.collection : nft.collection?.collection_name || nft.collection?.name || "Unknown" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "schema-name", children: nft.schema.schema_name }),
            nft.mint_number && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mint-number", children: [
              "Mint #",
              nft.mint_number
            ] })
          ] })
        ] }, nft.asset_id))
      ] }),
      canUnpack ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "unpack-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Pack Contents" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pack-contents", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "These packs contain random rewards that will be revealed upon unpacking." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "warning", children: " Unpacking will burn these packs permanently!" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "unpack-btn",
            onClick: handleUnpack,
            disabled: isUnpacking || !walletSession,
            children: isUnpacking ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner small" }),
              "Unpacking..."
            ] }) : ` Unpack ${packNFTs.length} Pack${packNFTs.length > 1 ? "s" : ""}`
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cannot-unpack", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box error", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Cannot Unpack" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No pack NFTs selected for unpacking." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Only packs, chests, boxes, and containers can be unpacked." })
      ] }) })
    ] })
  ] }) });
};
const WalletProvider = ({ children }) => {
  const [walletState, setWalletState] = reactExports.useState({
    isConnected: false,
    account: null,
    session: null,
    login: async () => null,
    logout: async () => {
    },
    transact: async () => null,
    purchaseNFT: async () => null,
    batchPurchaseNFTs: async () => null,
    executeCraftingTransaction: async () => null,
    executeTransaction: async () => {
      throw new Error("Wallet not connected");
    },
    isLoading: true
  });
  reactExports.useEffect(() => {
    const unsubscribe = wharfKitService.subscribe((context) => {
      setWalletState(context);
    });
    return unsubscribe;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WalletContext.Provider, { value: walletState, children });
};
const useWallet = () => {
  const context = reactExports.useContext(WalletContext);
  if (context === void 0) {
    throw new Error("useWallet must be used within a WalletProvider");
  }
  return context;
};
const BulkAuctionModal = ({
  nfts,
  isOpen,
  onClose,
  onSuccess
}) => {
  const { showSuccess, showError } = useNotifications();
  const walletContext = useWallet();
  const [startingPrice, setStartingPrice] = reactExports.useState("");
  const [durationWeeks, setDurationWeeks] = reactExports.useState(0);
  const [durationDays, setDurationDays] = reactExports.useState(1);
  const [durationHours, setDurationHours] = reactExports.useState(0);
  const [durationMinutes, setDurationMinutes] = reactExports.useState(0);
  const [auctionMemo, setAuctionMemo] = reactExports.useState("");
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  const [sortBy, setSortBy] = reactExports.useState("name_asc");
  reactExports.useEffect(() => {
    if (isOpen) {
      setStartingPrice("");
      setDurationWeeks(0);
      setDurationDays(1);
      setDurationHours(0);
      setDurationMinutes(0);
      setAuctionMemo("");
      setIsSubmitting(false);
    }
  }, [isOpen]);
  const sortedNfts = reactExports.useMemo(() => {
    const sorted = [...nfts];
    switch (sortBy) {
      case "name_asc":
        return sorted.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      case "name_desc":
        return sorted.sort((a, b) => (b.name || "").localeCompare(a.name || ""));
      case "collection_asc":
        return sorted.sort((a, b) => a.collection.collection_name.localeCompare(b.collection.collection_name));
      case "collection_desc":
        return sorted.sort((a, b) => b.collection.collection_name.localeCompare(a.collection.collection_name));
      case "mint_asc":
        return sorted.sort((a, b) => (a.mint_number || 0) - (b.mint_number || 0));
      case "mint_desc":
        return sorted.sort((a, b) => (b.mint_number || 0) - (a.mint_number || 0));
      default:
        return sorted;
    }
  }, [nfts, sortBy]);
  const calculateTotalDuration = () => {
    return durationWeeks * 7 * 24 * 3600 + durationDays * 24 * 3600 + durationHours * 3600 + durationMinutes * 60;
  };
  const updateDurationComponent = (component, value) => {
    const clampedValue = Math.max(0, Math.min(value, getMaxValue(component)));
    switch (component) {
      case "weeks":
        setDurationWeeks(clampedValue);
        break;
      case "days":
        setDurationDays(clampedValue);
        break;
      case "hours":
        setDurationHours(clampedValue);
        break;
      case "minutes":
        setDurationMinutes(clampedValue);
        break;
    }
  };
  const getMaxValue = (component) => {
    switch (component) {
      case "weeks":
        return 4;
      // Max 4 weeks
      case "days":
        return 30;
      // Max 30 days
      case "hours":
        return 23;
      // Max 23 hours
      case "minutes":
        return 59;
      // Max 59 minutes
      default:
        return 0;
    }
  };
  const formatDurationDisplay = () => {
    const parts = [];
    if (durationWeeks > 0) parts.push(`${durationWeeks}w`);
    if (durationDays > 0) parts.push(`${durationDays}d`);
    if (durationHours > 0) parts.push(`${durationHours}h`);
    if (durationMinutes > 0) parts.push(`${durationMinutes}m`);
    return parts.length > 0 ? parts.join(" ") : "0m";
  };
  const handleSubmit = async () => {
    if (!startingPrice || parseFloat(startingPrice) <= 0) {
      showError("Invalid Price", "Please enter a valid starting price");
      return;
    }
    const totalDurationSeconds = calculateTotalDuration();
    if (totalDurationSeconds < 3600) {
      showError("Invalid Duration", "Auction duration must be at least 1 hour");
      return;
    }
    if (totalDurationSeconds > 2592e3) {
      showError("Invalid Duration", "Auction duration cannot exceed 30 days");
      return;
    }
    setIsSubmitting(true);
    try {
      const startingBidAmount = `${parseFloat(startingPrice).toFixed(8)} WAX`;
      const actions = nfts.map((nft) => ({
        account: "atomicmarket",
        name: "announceauct",
        authorization: [{
          actor: walletContext.account || "",
          permission: "active"
        }],
        data: {
          seller: walletContext.account || "",
          asset_ids: [parseInt(nft.asset_id)],
          starting_bid: startingBidAmount,
          duration: totalDurationSeconds,
          maker_marketplace: "market.pxj"
        }
      }));
      await walletContext.transact(actions);
      const durationDisplay = formatDurationDisplay();
      showSuccess(
        "Bulk Auction Created",
        `Successfully created auctions for ${nfts.length} NFT${nfts.length !== 1 ? "s" : ""} with starting price ${startingPrice} WAX and duration ${durationDisplay}. Remember to transfer your assets to the atomicmarket contract to activate the auctions.`
      );
      onSuccess();
      onClose();
    } catch (error) {
      console.error("Bulk auction creation failed:", error);
      showError("Auction Creation Failed", error instanceof Error ? error.message : "Failed to create bulk auctions. Please try again.");
    } finally {
      setIsSubmitting(false);
    }
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content bulk-auction-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Create Bulk Auction" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-nfts-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-nfts-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
            "Selected NFTs (",
            nfts.length,
            ")"
          ] }),
          nfts.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sort-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "auction-sort", children: "Sort by:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                id: "auction-sort",
                className: "sort-select",
                value: sortBy,
                onChange: (e) => setSortBy(e.target.value),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name (A-Z)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name (Z-A)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_asc", children: "Collection (A-Z)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_desc", children: "Collection (Z-A)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_asc", children: "Mint # (Low-High)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_desc", children: "Mint # (High-Low)" })
                ]
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-nfts-grid", children: [
          sortedNfts.slice(0, 6).map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-nft-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-image-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              MediaRenderer,
              {
                imageUrl: getAssetImageUrl(nft),
                videoUrl: getAssetVideoUrl(nft),
                alt: nft.name || `Asset #${nft.asset_id}`,
                className: "nft-image"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-name", children: nft.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-collection", children: typeof nft.collection === "string" ? nft.collection : nft.collection?.name || nft.collection?.collection_name || "Unknown" })
            ] })
          ] }, nft.asset_id)),
          nfts.length > 6 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "more-nfts-indicator", children: [
            "+",
            nfts.length - 6,
            " more"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-settings", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "startingPrice", children: "Starting Price (WAX)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              id: "startingPrice",
              value: startingPrice,
              onChange: (e) => setStartingPrice(e.target.value),
              placeholder: "Enter starting price",
              min: "0",
              step: "0.01",
              disabled: isSubmitting
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Auction Duration" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-inputs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-field", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "duration-label", children: "Weeks" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  className: "duration-input",
                  value: durationWeeks,
                  onChange: (e) => updateDurationComponent("weeks", parseInt(e.target.value) || 0),
                  min: "0",
                  max: getMaxValue("weeks"),
                  disabled: isSubmitting
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-field", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "duration-label", children: "Days" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  className: "duration-input",
                  value: durationDays,
                  onChange: (e) => updateDurationComponent("days", parseInt(e.target.value) || 0),
                  min: "0",
                  max: getMaxValue("days"),
                  disabled: isSubmitting
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-field", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "duration-label", children: "Hours" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  className: "duration-input",
                  value: durationHours,
                  onChange: (e) => updateDurationComponent("hours", parseInt(e.target.value) || 0),
                  min: "0",
                  max: getMaxValue("hours"),
                  disabled: isSubmitting
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-field", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "duration-label", children: "Minutes" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  className: "duration-input",
                  value: durationMinutes,
                  onChange: (e) => updateDurationComponent("minutes", parseInt(e.target.value) || 0),
                  min: "0",
                  max: getMaxValue("minutes"),
                  disabled: isSubmitting
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-summary", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "duration-display", children: formatDurationDisplay() }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "duration-total", children: [
              "(",
              calculateTotalDuration().toLocaleString(),
              "s)"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "auctionMemo", children: "Memo (Optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              id: "auctionMemo",
              value: auctionMemo,
              onChange: (e) => setAuctionMemo(e.target.value),
              placeholder: "Add a note about this auction batch...",
              rows: 3,
              maxLength: 256,
              disabled: isSubmitting
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "cancel-btn",
          onClick: onClose,
          disabled: isSubmitting,
          children: "Cancel"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "create-btn",
          onClick: handleSubmit,
          disabled: isSubmitting || !startingPrice || parseFloat(startingPrice) <= 0 || calculateTotalDuration() < 3600,
          children: isSubmitting ? "Creating..." : `Create ${nfts.length} Auction${nfts.length !== 1 ? "s" : ""}`
        }
      )
    ] })
  ] }) });
};
class RWaxService {
  constructor() {
    __publicField(this, "WAX_API_BASE", "https://wax.eosrio.io/v1/chain");
    __publicField(this, "ATOMIC_API_BASE", "https://wax-api.hivebp.io/api");
  }
  /**
   * Fetch fee tokens from RWAX contract table with live WAX value conversion
   */
  async getFeeTokens() {
    const maxRetries = 3;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 1e4);
        const response = await fetch(`${this.WAX_API_BASE}/get_table_rows`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            code: "rwax",
            scope: "rwax",
            table: "feetokens",
            json: true,
            limit: 100
          }),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        if (!data.rows || !Array.isArray(data.rows)) {
          log.error("Invalid fee tokens response structure:", data);
          return [];
        }
        const alcorTokenIds = ["honey-honeyhiveio", "lswax-liquidstaked"];
        const alcorRates = await this.fetchAlcorTokenRates(alcorTokenIds);
        const feeTokens = await Promise.all(data.rows.map(async (row) => {
          const feeMatch = row.fee.match(/([0-9.]+)\s+([A-Z]+)/);
          const symbol = feeMatch ? feeMatch[2] : "UNKNOWN";
          const amount = feeMatch ? feeMatch[1] : "0";
          let waxValue;
          if (symbol !== "WAX") {
            try {
              waxValue = await this.calculateLiveWaxValue(symbol, amount, alcorRates);
            } catch (error) {
              log.warn(`Failed to get live WAX value for ${symbol}, using exchange rate fallback`, "RWaxService.getFeeTokens");
              if (row.exchange_rate) {
                const exchangeRate = parseFloat(row.exchange_rate);
                const feeAmount = parseFloat(amount);
                if (!isNaN(exchangeRate) && !isNaN(feeAmount)) {
                  waxValue = (feeAmount / exchangeRate).toFixed(8);
                }
              }
            }
          }
          return {
            fee: row.fee,
            contract: row.contract,
            exchange_rate: row.exchange_rate,
            symbol,
            amount,
            wax_value: waxValue
          };
        }));
        log.info(`Successfully fetched ${feeTokens.length} fee tokens with live WAX conversions`);
        return feeTokens;
      } catch (error) {
        log.error(`Attempt ${attempt} failed to fetch fee tokens:`, error instanceof Error ? error.message : String(error));
        if (attempt === maxRetries) {
          throw new Error(`Failed to fetch fee tokens after ${maxRetries} attempts: ${error}`);
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
    return [];
  }
  /**
   * Fetch Alcor V2 token rates in batch
   * @param tokenIds Array of token IDs (e.g., ['honey-honeyhiveio', 'lswax-liquidstaked'])
   * @returns Map of token ID to WAX rate
   */
  async fetchAlcorTokenRates(tokenIds) {
    try {
      const url = `https://wax.alcor.exchange/api/v2/tokens/${tokenIds.join(",")}`;
      const response = await fetch(url);
      const tokens = await response.json();
      const rates = /* @__PURE__ */ new Map();
      tokens.forEach((t) => {
        const id = `${t.symbol.toLowerCase()}-${t.contract}`;
        rates.set(id, parseFloat(t.system_price) || 0);
      });
      return rates;
    } catch (error) {
      log.error("Failed to fetch Alcor V2 rates:", "RWaxService.fetchAlcorTokenRates", error);
      return /* @__PURE__ */ new Map();
    }
  }
  /**
    * Calculate live WAX value for different fee tokens
    * @param symbol Token symbol (e.g., 'WPIXAL', 'PXJ', 'HONEY', 'LSWAX')
    * @param amount Token amount as string
    * @param alcorRates Pre-fetched Map from fetchAlcorTokenRates (for efficiency)
    * @returns WAX value as string
    */
  async calculateLiveWaxValue(symbol, amount, alcorRates) {
    const feeAmount = parseFloat(amount);
    if (isNaN(feeAmount)) {
      throw new Error(`Invalid amount: ${amount}`);
    }
    try {
      switch (symbol.toUpperCase()) {
        case "WPIXAL": {
          const wpixalPriceWAX = await priceService.getWpixalPriceWAX();
          const waxValue = feeAmount * wpixalPriceWAX;
          return waxValue.toFixed(8);
        }
        case "PXJ": {
          const pxjPriceUSD = await priceService.getPxjPriceUSD();
          const waxPriceUSD = await priceService.getWaxPriceUSD();
          if (waxPriceUSD > 0) {
            const waxValue = feeAmount * pxjPriceUSD / waxPriceUSD;
            return waxValue.toFixed(8);
          }
          throw new Error("WAX price is zero");
        }
        case "HONEY": {
          const rate = alcorRates?.get("honey-honeyhiveio") || 0;
          if (rate > 0) {
            const waxValue = feeAmount * rate;
            return waxValue.toFixed(8);
          }
          throw new Error("HONEY/WAX rate not available");
        }
        case "LSWAX": {
          const rate = alcorRates?.get("lswax-liquidstaked") || 0;
          if (rate > 0) {
            const waxValue2 = feeAmount * rate;
            return waxValue2.toFixed(8);
          }
          const waxValue = feeAmount * 1.1616;
          return waxValue.toFixed(8);
        }
        default: {
          log.warn(`Unknown token symbol for live conversion: ${symbol}`, "RWaxService.calculateLiveWaxValue");
          throw new Error(`Unsupported token: ${symbol}`);
        }
      }
    } catch (error) {
      log.error(`Failed to calculate live WAX value for ${symbol}:`, "RWaxService.calculateLiveWaxValue", error);
      throw error;
    }
  }
  /**
   * Get WPIXAL amount for a specific asset from assetpools table
   */
  async getAssetPoolInfo(assetId) {
    const maxRetries = 3;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 1e4);
        const response = await fetch(`${this.WAX_API_BASE}/get_table_rows`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            code: "rwax",
            scope: "WPIXAL",
            table: "assetpools",
            json: true,
            limit: 1,
            lower_bound: assetId,
            upper_bound: assetId,
            key_type: "i64"
          }),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        if (!data.rows || !Array.isArray(data.rows) || data.rows.length === 0) {
          return null;
        }
        const row = data.rows[0];
        return {
          assetId: row.asset_id,
          issuedTokens: row.issued_tokens
        };
      } catch (error) {
        log.error(`Attempt ${attempt} failed to fetch asset pool info for ${assetId}:`, error instanceof Error ? error.message : String(error));
        if (attempt === maxRetries) {
          log.error(`Failed to fetch asset pool info after ${maxRetries} attempts: ${error}`);
          return null;
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
    return null;
  }
  /**
   * Fetch tokenized WPIXAL assets from API with fallback to test data
   */
  async getTokenizedAssets(limit = 36, offset = 0, sortBy = "rarity_score_desc", attributeFilters = "") {
    const maxRetries = 3;
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const params = new URLSearchParams({
          term: "",
          owner: "rwax",
          collection: "pixeljourney",
          schema: "pixals",
          category: "",
          recent: "",
          order_by: sortBy,
          limit: limit.toString(),
          search_type: "inventory",
          offer_type: "sales",
          min_price: "0",
          max_price: "0",
          offset: offset.toString(),
          verified: "all",
          favorites: "false",
          user: "pixeljourney",
          contract: "",
          attributes: attributeFilters,
          only: "rwax",
          rwax_contract: "pixeljourney",
          rwax_symbol: "WPIXAL"
        });
        const url = `${this.ATOMIC_API_BASE}/assets?${params.toString()}`;
        log.info(`Fetching tokenized assets from: ${url}`, "RWaxService");
        const response = await fetch(url, {
          method: "GET",
          headers: {
            "Accept": "application/json",
            "Content-Type": "application/json"
          }
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        log.debug("RWAX API Response received", "RWaxService.getTokenizedAssets", { dataLength: Array.isArray(data) ? data.length : "not array" });
        return Array.isArray(data) ? data : [];
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        log.error(`Attempt ${attempt}/${maxRetries} failed:`, "RWaxService.getTokenizedAssets", lastError);
        if (attempt === maxRetries) {
          log.warn("API failed, returning test data with original structure", "RWaxService.getTokenizedAssets");
          const testAssets = [
            {
              assetId: 1099932947523,
              name: "Pixal 09106",
              schema: "pixals",
              owner: "rwax",
              burned: false,
              mint: 9106,
              contract: "atomicassets",
              collection: {
                collectionName: "pixeljourney",
                displayName: "Pixel Journey",
                collectionImage: "QmVnrLdB1xQ9EMzgw5srW6u8WKQpTjmYz6fBi2g7ic8iob",
                verification: true,
                blacklisted: false
              },
              transferable: true,
              burnable: true,
              mutableData: [],
              immutableData: [
                { key: "Background", value: ["string", "Nefty Spot"] },
                { key: "Body", value: ["string", "Pink-Blue Overalls"] },
                { key: "Eyes", value: ["string", "Kawaii Green"] },
                { key: "Head", value: ["string", "Grey"] },
                { key: "img", value: ["string", "Qma9rcg1NHxhvG5CMDecS3bo14gpQSr6QFieUXsFPrG14T"] },
                { key: "name", value: ["string", "Pixal 09106"] }
              ],
              rarityScore: 419.80619503583694,
              attributesFloor: 501,
              rwax: {
                symbol: "WPIXAL",
                contract: "pixeljourney",
                decimals: 8,
                tokenName: "Wrapped Pixal",
                redeemAmount: 1.09997216
              },
              image: "Qma9rcg1NHxhvG5CMDecS3bo14gpQSr6QFieUXsFPrG14T",
              template: {
                templateId: 781515
              }
            },
            {
              assetId: 1099931322703,
              name: "Pixal 06238",
              schema: "pixals",
              owner: "rwax",
              burned: false,
              mint: 6238,
              contract: "atomicassets",
              collection: {
                collectionName: "pixeljourney",
                displayName: "Pixel Journey",
                verification: true,
                blacklisted: false
              },
              transferable: true,
              burnable: true,
              mutableData: [],
              immutableData: [
                { key: "Background", value: ["string", "Blue Sky"] },
                { key: "Body", value: ["string", "Red Shirt"] },
                { key: "Eyes", value: ["string", "Brown"] },
                { key: "Head", value: ["string", "Black Hair"] },
                { key: "img", value: ["string", "QmTestImage2"] },
                { key: "name", value: ["string", "Pixal 06238"] }
              ],
              rarityScore: 350.5,
              attributesFloor: 400,
              rwax: {
                symbol: "WPIXAL",
                contract: "pixeljourney",
                decimals: 8,
                tokenName: "Wrapped Pixal",
                redeemAmount: 1.25
              },
              image: "QmTestImage2",
              template: {
                templateId: 781516
              }
            }
          ];
          const startIndex = offset;
          const endIndex = startIndex + limit;
          return testAssets.slice(startIndex, endIndex);
        }
      }
    }
    throw lastError || new Error("Failed to fetch tokenized assets");
  }
  /**
   * Get WPIXAL amount for a specific asset
   */
  async getAssetWPIXALAmount(assetId) {
    try {
      const url = `${this.WAX_API_BASE}/get_table_rows`;
      const requestBody = {
        code: "pixeljourney",
        index_position: "primary",
        json: true,
        key_type: "i64",
        limit: 1,
        reverse: false,
        lower_bound: assetId,
        upper_bound: assetId,
        scope: "pixeljourney",
        show_payer: false,
        table: "assetpools",
        table_key: ""
      };
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) {
        throw new Error(`Failed to fetch WPIXAL amount: ${response.statusText}`);
      }
      const data = await response.json();
      if (data.rows && data.rows.length > 0) {
        return data.rows[0].issued_tokens;
      }
      return "0.00000000 WPIXAL";
    } catch (error) {
      log.error("Error fetching WPIXAL amount:", "RWaxService.getAssetWPIXALAmount", error instanceof Error ? error : new Error(String(error)));
      return "0.00000000 WPIXAL";
    }
  }
  /**
   * Fetch user's Pixal assets for tokenization
   */
  async getUserPixalAssets(account, limit = 36, offset = 0) {
    const maxRetries = 3;
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const page = Math.floor(offset / limit) + 1;
        const url = `https://wax.api.atomicassets.io/atomicassets/v1/assets?owner=${account}&collection_name=pixeljourney&schema_name=pixals&limit=${limit}&page=${page}&order=desc&sort=asset_id`;
        log.info(`Fetching user assets from: ${url}`, "RWaxService");
        const response = await fetch(url, {
          method: "GET",
          headers: {
            "Accept": "application/json",
            "Content-Type": "application/json"
          }
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        if (!data || !data.data || !Array.isArray(data.data)) {
          log.error("Invalid user assets API response structure:", data);
          return [];
        }
        return data.data.map((asset) => {
          let imageUrl = "";
          const imageSources = [
            asset.data?.img,
            asset.data?.image,
            asset.immutable_data?.img,
            asset.immutable_data?.image,
            asset.template?.immutable_data?.img,
            asset.template?.immutable_data?.image
          ];
          for (const source of imageSources) {
            if (source && typeof source === "string") {
              imageUrl = source;
              break;
            }
          }
          if (imageUrl && !imageUrl.startsWith("http")) {
            if (imageUrl.startsWith("Qm") || imageUrl.startsWith("/ipfs/")) {
              imageUrl = `https://ipfs.io/ipfs/${imageUrl.replace("/ipfs/", "")}`;
            } else if (imageUrl.startsWith("ipfs://")) {
              imageUrl = imageUrl.replace("ipfs://", "https://ipfs.io/ipfs/");
            }
          }
          return {
            assetId: parseInt(asset.asset_id) || 0,
            name: asset.name || asset.data?.name || asset.immutable_data?.name || `Pixal #${asset.asset_id}`,
            image: imageUrl,
            schema: asset.schema?.schema_name || asset.schema_name || "pixals",
            owner: asset.owner || "",
            burned: asset.burned || false,
            mint: asset.template_mint || 0,
            contract: asset.contract || "atomicassets",
            collection: {
              collectionName: asset.collection?.collection_name || asset.collection_name || "pixeljourney",
              displayName: asset.collection?.name || asset.collection?.collection_name || "Pixel Journey",
              verification: asset.collection?.authorized_accounts?.length > 0 || true,
              blacklisted: false
            },
            transferable: asset.transferable !== false,
            burnable: asset.burnable !== false,
            mutableData: Array.isArray(asset.mutable_data) ? asset.mutable_data : [],
            immutableData: Array.isArray(asset.immutable_data) ? asset.immutable_data : [],
            template: {
              templateId: parseInt(asset.template?.template_id || asset.template_id || "0")
            }
          };
        });
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        log.error(`Attempt ${attempt}/${maxRetries} failed:`, "RWaxService.getUserPixalAssets", lastError);
        if (attempt === maxRetries) {
          log.error("All attempts failed, returning empty array", "RWaxService.getUserPixalAssets");
          return [];
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3 * attempt));
      }
    }
    return [];
  }
  /**
   * Execute tokenization transaction
   */
  async executeTokenization(assetIds, feeToken) {
    try {
      const { wharfKitService: wharfKitService2 } = await __vitePreload(async () => {
        const { wharfKitService: wharfKitService3 } = await Promise.resolve().then(() => wharfkit);
        return { wharfKitService: wharfKitService3 };
      }, true ? void 0 : void 0);
      if (!wharfKitService2.isLoggedIn()) {
        throw new Error("Wallet not connected");
      }
      const account = wharfKitService2.getAccountName();
      if (!account) {
        throw new Error("No account found");
      }
      const actions = [
        {
          account: "nft.hive",
          name: "boost",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            booster: account
          }
        },
        {
          account: feeToken.contract,
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "rwax",
            quantity: feeToken.fee,
            memo: "payfee"
          }
        },
        {
          account: "atomicassets",
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "rwax",
            asset_ids: assetIds,
            memo: "deposit"
          }
        },
        {
          account: "rwax",
          name: "tokenizenfts",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            user: account,
            asset_ids: assetIds,
            fee_currency: `8,${feeToken.symbol}`
          }
        }
      ];
      const result = await wharfKitService2.transact(actions);
      log.info("Tokenization transaction executed successfully", "RWaxService.executeTokenization", { result });
      return result;
    } catch (error) {
      log.error("Error executing tokenization:", "RWaxService.executeTokenization", error instanceof Error ? error : new Error(String(error)));
      throw error;
    }
  }
  /**
   * Execute redemption transaction
   */
  async executeRedemption(assetId, wpixalAmount, feeToken) {
    try {
      const { wharfKitService: wharfKitService2 } = await __vitePreload(async () => {
        const { wharfKitService: wharfKitService3 } = await Promise.resolve().then(() => wharfkit);
        return { wharfKitService: wharfKitService3 };
      }, true ? void 0 : void 0);
      if (!wharfKitService2.isLoggedIn()) {
        throw new Error("Wallet not connected");
      }
      const account = wharfKitService2.getAccountName();
      if (!account) {
        throw new Error("No account found");
      }
      const actions = [
        {
          account: "nft.hive",
          name: "boost",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            booster: account
          }
        },
        {
          account: feeToken.contract,
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "rwax",
            quantity: feeToken.fee,
            memo: "payfee"
          }
        },
        {
          account: "pixeljourney",
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "rwax",
            quantity: wpixalAmount,
            memo: "redeem"
          }
        },
        {
          account: "rwax",
          name: "redeem",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            redeemer: account,
            contract: "pixeljourney",
            quantity: wpixalAmount,
            asset_id: assetId,
            fee_currency: `8,${feeToken.symbol}`
          }
        }
      ];
      const result = await wharfKitService2.transact(actions);
      log.info("Redemption transaction executed successfully", "RWaxService.executeRedemption", { result });
      return result;
    } catch (error) {
      log.error("Error executing redemption:", "RWaxService.executeRedemption", error instanceof Error ? error : new Error(String(error)));
      throw error;
    }
  }
}
const rwaxService = new RWaxService();
function normalizeIPFSUrl(imageUrl) {
  if (!imageUrl) {
    return "";
  }
  if (imageUrl.startsWith("http://") || imageUrl.startsWith("https://")) {
    return imageUrl;
  }
  if (imageUrl.startsWith("data:") || imageUrl.startsWith("blob:")) {
    return imageUrl;
  }
  if (imageUrl.startsWith("ipfs://")) {
    const hash = imageUrl.replace("ipfs://", "");
    return getIPFSGatewayUrl(hash);
  }
  if (imageUrl.includes("/ipfs/")) {
    const hash = imageUrl.split("/ipfs/")[1];
    return getIPFSGatewayUrl(hash);
  }
  if (imageUrl.startsWith("Qm") && imageUrl.length > 40) {
    return getIPFSGatewayUrl(imageUrl);
  }
  if (imageUrl.length > 40 && /^[a-zA-Z0-9]+$/.test(imageUrl)) {
    return getIPFSGatewayUrl(imageUrl);
  }
  return getIPFSGatewayUrl(imageUrl);
}
function getIPFSGatewayUrl(hash) {
  const gateways = API_ENDPOINTS.IPFS.GATEWAYS;
  const randomGateway = gateways[Math.floor(Math.random() * gateways.length)];
  const cleanHash = hash.replace(/^\/?(ipfs\/)?/, "");
  return `${randomGateway}${cleanHash}`;
}
const TokenizeFeeModal = ({
  isOpen,
  onClose,
  onSuccess,
  nft
}) => {
  const [feeTokens, setFeeTokens] = reactExports.useState([]);
  const [selectedFeeToken, setSelectedFeeToken] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(false);
  const { showError } = useNotifications();
  reactExports.useEffect(() => {
    if (isOpen) {
      loadFeeTokens();
    }
  }, [isOpen]);
  const loadFeeTokens = async () => {
    try {
      setLoading(true);
      const tokens = await rwaxService.getFeeTokens();
      setFeeTokens(tokens);
      const waxToken = tokens.find((token) => token.symbol === "WAX");
      if (waxToken) {
        setSelectedFeeToken(waxToken);
      }
    } catch (error) {
      log.error("Failed to load fee tokens", "TokenizeFeeModal.loadFeeTokens", error);
      showError("Failed to load fee tokens");
    } finally {
      setLoading(false);
    }
  };
  const handleConfirm = async () => {
    if (selectedFeeToken && nft) {
      try {
        setLoading(true);
        await rwaxService.executeTokenization([nft.asset_id], selectedFeeToken);
        onSuccess?.();
        handleClose();
      } catch (error) {
        log.error("Failed to tokenize asset", "TokenizeFeeModal.handleConfirm", error);
        showError("Failed to tokenize asset");
      } finally {
        setLoading(false);
      }
    }
  };
  const handleClose = () => {
    setSelectedFeeToken(null);
    onClose();
  };
  if (!isOpen) return null;
  return reactDomExports.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content tokenize-fee-modal", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: " Tokenize into WPIXAL" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-button", onClick: handleClose, children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
        nft && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tokenize-asset-preview", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: normalizeIPFSUrl(nft.img),
              alt: nft.name,
              className: "tokenize-asset-image",
              onError: (e) => {
                const target = e.target;
                target.src = "https://pixeljourney.xyz/img/toppixals/10.webp";
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: nft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "tokenize-description", children: "This will tokenize your Pixal PFP into WPIXAL tokens on the RWAX platform." })
        ] }),
        loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading fee options..." })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fee-selection", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Select Fee Token:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fee-options", children: feeTokens.map((token, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `fee-option ${selectedFeeToken === token ? "selected" : ""}`,
              onClick: () => setSelectedFeeToken(token),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fee-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fee-amount", children: token.fee }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "fee-contract", children: [
                    "(",
                    token.contract,
                    ")"
                  ] })
                ] }),
                token.wax_value && token.symbol !== "WAX" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-equivalent", children: [
                  " ",
                  parseFloat(token.wax_value).toFixed(4),
                  " WAX"
                ] })
              ]
            },
            index
          )) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "cancel-button", onClick: handleClose, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "confirm-button tokenize-confirm",
            onClick: handleConfirm,
            disabled: !selectedFeeToken || loading,
            children: "Tokenize Asset"
          }
        )
      ] })
    ] }) }),
    document.body
  );
};
class StakingService {
  constructor() {
    __publicField(this, "MAX_BATCH_SIZE", 10);
    __publicField(this, "RETRY_ATTEMPTS", 3);
    __publicField(this, "RETRY_DELAY", 1e3);
    // 1 second
    __publicField(this, "FARMS_CONTRACT", "farms.waxdao");
    __publicField(this, "TOKEN_FARMS_CONTRACT", "tf.waxdao");
    __publicField(this, "PXJ_CONTRACT", "pixeljourney");
    __publicField(this, "WUF_CONTRACT", "wuffi");
    __publicField(this, "PXJ_FARM_NAME", "pxjfarm1");
  }
  /**
   * Stake multiple NFTs using stakenfts action (matches user's transaction examples)
   */
  async stakeNFTsPixelJourney(session, assetIds, farmName = "pixeljourney") {
    try {
      const action = {
        account: this.FARMS_CONTRACT,
        name: "stakenfts",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          user: WharfKitService.safeGetActor(session),
          farmname: farmName,
          assets_to_stake: assetIds
        }
      };
      const result = await this.executeTransactionWithRetry(session, [action]);
      if (result.success) {
        logger.info("NFTs Staked Successfully", "StakingService", {
          user: WharfKitService.safeGetActor(session),
          farm_name: farmName,
          asset_count: assetIds.length,
          asset_ids: assetIds,
          transaction_id: result.transaction_id
        });
      }
      return result;
    } catch (error) {
      logger.error("stakeNFTsPixelJourney failed", "StakingService", error, {
        asset_ids: assetIds,
        farm_name: farmName
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        transaction_id: "",
        gas_used: 0
      };
    }
  }
  /**
   * Unstake multiple NFTs using unstake action (matches user's transaction examples)
   */
  async unstakeNFTsPixelJourney(session, assetIds, farmName = "pixeljourney") {
    try {
      const action = {
        account: this.FARMS_CONTRACT,
        name: "unstake",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          user: WharfKitService.safeGetActor(session),
          farmname: farmName,
          asset_ids: assetIds
        }
      };
      const result = await this.executeTransactionWithRetry(session, [action]);
      if (result.success) {
        logger.info("NFTs Unstaked Successfully", "StakingService", {
          user: WharfKitService.safeGetActor(session),
          farm_name: farmName,
          asset_count: assetIds.length,
          asset_ids: assetIds,
          transaction_id: result.transaction_id
        });
      }
      return result;
    } catch (error) {
      logger.error("unstakeNFTsPixelJourney failed", "StakingService", error, {
        asset_ids: assetIds,
        farm_name: farmName
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        transaction_id: "",
        gas_used: 0
      };
    }
  }
  /**
   * Stake multiple NFTs in batches with comprehensive error handling (legacy method)
   */
  async stakeNFTsBatch(session, assetIds, farmName = "pixeljourney") {
    const result = {
      success: true,
      successful_transactions: [],
      failed_transactions: [],
      total_gas_used: 0
    };
    try {
      const batches = this.createBatches(assetIds, this.MAX_BATCH_SIZE);
      for (const batch of batches) {
        try {
          const batchResult = await this.processBatch(
            session,
            batch,
            "stake",
            farmName
          );
          result.successful_transactions.push(...batchResult.successful_transactions);
          result.failed_transactions.push(...batchResult.failed_transactions);
          result.total_gas_used += batchResult.total_gas_used;
          if (batches.indexOf(batch) < batches.length - 1) {
            await this.delay(500);
          }
        } catch (error) {
          batch.forEach((assetId) => {
            result.failed_transactions.push({
              asset_id: assetId,
              error: error instanceof Error ? error.message : "Batch processing failed"
            });
          });
        }
      }
      result.success = result.failed_transactions.length === 0;
      logger.info("NFT Staking Batch Operation", "StakingService", {
        total_assets: assetIds.length,
        successful: result.successful_transactions.length,
        failed: result.failed_transactions.length,
        farm_name: farmName
      });
      return result;
    } catch (error) {
      logger.error("stakeNFTsBatch failed", "StakingService", error, {
        asset_ids: assetIds,
        farm_name: farmName
      });
      return {
        success: false,
        successful_transactions: [],
        failed_transactions: assetIds.map((id) => ({
          asset_id: id,
          error: error instanceof Error ? error.message : "Unknown error"
        })),
        total_gas_used: 0
      };
    }
  }
  /**
   * Unstake multiple NFTs in batches
   */
  async unstakeNFTsBatch(session, assetIds) {
    const result = {
      success: true,
      successful_transactions: [],
      failed_transactions: [],
      total_gas_used: 0
    };
    try {
      const batches = this.createBatches(assetIds, this.MAX_BATCH_SIZE);
      for (const batch of batches) {
        try {
          const batchResult = await this.processBatch(
            session,
            batch,
            "unstake"
          );
          result.successful_transactions.push(...batchResult.successful_transactions);
          result.failed_transactions.push(...batchResult.failed_transactions);
          result.total_gas_used += batchResult.total_gas_used;
          if (batches.indexOf(batch) < batches.length - 1) {
            await this.delay(500);
          }
        } catch (error) {
          batch.forEach((assetId) => {
            result.failed_transactions.push({
              asset_id: assetId,
              error: error instanceof Error ? error.message : "Batch processing failed"
            });
          });
        }
      }
      result.success = result.failed_transactions.length === 0;
      logger.info("NFT Unstaking Batch Operation", "StakingService", {
        total_assets: assetIds.length,
        successful: result.successful_transactions.length,
        failed: result.failed_transactions.length
      });
      return result;
    } catch (error) {
      logger.error("unstakeNFTsBatch failed", "StakingService", error, {
        asset_ids: assetIds
      });
      return {
        success: false,
        successful_transactions: [],
        failed_transactions: assetIds.map((id) => ({
          asset_id: id,
          error: error instanceof Error ? error.message : "Unknown error"
        })),
        total_gas_used: 0
      };
    }
  }
  /**
   * Claim all pending rewards for a user
   */
  async claimAllRewards(session, farmName = "pixeljourney") {
    try {
      const actions = [{
        account: this.FARMS_CONTRACT,
        name: "claim",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          user: WharfKitService.safeGetActor(session),
          farmname: farmName
        }
      }];
      const result = await this.executeTransactionWithRetry(session, actions);
      if (result.success) {
        logger.info("Rewards Claimed Successfully", "StakingService", {
          user: WharfKitService.safeGetActor(session),
          farm_name: farmName,
          transaction_id: result.transaction_id
        });
      }
      return result;
    } catch (error) {
      logger.error("claimAllRewards failed", "StakingService", error, {
        user: WharfKitService.safeGetActor(session),
        farm_name: farmName
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to claim rewards"
      };
    }
  }
  /**
   * Get detailed staking information for a user from farms.waxdao contract tables
   */
  async getStakingInfo(account, farmName = "pixeljourney") {
    try {
      const stakedResponse = await fetch(
        `${API_ENDPOINTS.WAX_CHAIN.GREYMASS}/v1/chain/get_table_rows`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            json: true,
            code: this.FARMS_CONTRACT,
            scope: this.FARMS_CONTRACT,
            table: "stakers",
            lower_bound: account,
            upper_bound: account,
            limit: 1e3
          })
        }
      );
      if (!stakedResponse.ok) {
        throw new Error(`Failed to fetch staking info: ${stakedResponse.statusText}`);
      }
      const stakedData = await stakedResponse.json();
      const userStakeData = stakedData.rows.find((row) => row.user === account) || {};
      const stakedAssets = userStakeData.staked_assets || [];
      const pendingRewards = userStakeData.pending_rewards || [];
      const stakedNfts = stakedAssets.map((assetId) => ({
        asset_id: assetId,
        template_id: "0",
        // Would need to fetch from AtomicAssets API
        farm_name: farmName,
        stake_time: Date.now() / 1e3,
        // Would need actual stake time from contract
        rewards_per_hour: { pxj: 0, wuf: 0 },
        // Would calculate based on template
        multiplier: 1
      })) || [];
      const rewards = pendingRewards.map((reward) => ({
        token: reward.quantity.split(" ")[1],
        // Extract token symbol from asset format
        amount: parseFloat(reward.quantity.split(" ")[0]),
        // Extract amount
        contract: reward.contract,
        precision: 4
      }));
      const totalStakingPower = stakedNfts.reduce((sum, nft) => {
        const hourlyRewards = Object.values(nft.rewards_per_hour).reduce((a, b) => a + b, 0);
        return sum + hourlyRewards * nft.multiplier;
      }, 0);
      const estimatedDailyRewards = [
        {
          token: "PXJ",
          amount: stakedNfts.reduce((sum, nft) => sum + (nft.rewards_per_hour.pxj || 0) * 24, 0),
          contract: this.PXJ_CONTRACT,
          precision: 4
        },
        {
          token: "WUF",
          amount: stakedNfts.reduce((sum, nft) => sum + (nft.rewards_per_hour.wuf || 0) * 24, 0),
          contract: this.WUF_CONTRACT,
          precision: 4
        }
      ];
      return {
        staked_nfts: stakedNfts,
        pending_rewards: rewards,
        total_staking_power: totalStakingPower,
        estimated_daily_rewards: estimatedDailyRewards
      };
    } catch (error) {
      logger.error("getStakingInfo failed", "StakingService", error, {
        account,
        farm_name: farmName
      });
      return {
        staked_nfts: [],
        pending_rewards: [],
        total_staking_power: 0,
        estimated_daily_rewards: []
      };
    }
  }
  /**
   * Stake tokens to tf.waxdao farm
   */
  async stakeTokens(session, amount, farmName = this.PXJ_FARM_NAME) {
    try {
      const actions = [{
        account: this.PXJ_CONTRACT,
        name: "transfer",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          from: WharfKitService.safeGetActor(session),
          to: this.TOKEN_FARMS_CONTRACT,
          quantity: amount,
          memo: `stake:${farmName}`
        }
      }];
      const result = await this.executeTransactionWithRetry(session, actions);
      if (result.success) {
        logger.info("Token staked successfully", "StakingService", {
          type: "token_stake",
          user: WharfKitService.safeGetActor(session),
          amount,
          farm_name: farmName
        });
      }
      return result;
    } catch (error) {
      logger.error("stakeTokens failed", "StakingService", error, {
        user: WharfKitService.safeGetActor(session),
        amount,
        farm_name: farmName
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Unstake tokens from tf.waxdao farm
   */
  async unstakeTokens(session, amount, farmName = this.PXJ_FARM_NAME) {
    try {
      const actions = [{
        account: this.TOKEN_FARMS_CONTRACT,
        name: "unstake",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          user: WharfKitService.safeGetActor(session),
          farm_name: farmName,
          quantity: amount
        }
      }];
      const result = await this.executeTransactionWithRetry(session, actions);
      if (result.success) {
        logger.info("Token unstaked successfully", "StakingService", {
          type: "token_unstake",
          user: WharfKitService.safeGetActor(session),
          amount,
          farm_name: farmName
        });
      }
      return result;
    } catch (error) {
      logger.error("unstakeTokens failed", "StakingService", error, {
        user: WharfKitService.safeGetActor(session),
        amount,
        farm_name: farmName
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Claim rewards from tf.waxdao farm
   */
  async claimTokenFarmRewards(session, farmName = this.PXJ_FARM_NAME) {
    try {
      const actions = [{
        account: this.TOKEN_FARMS_CONTRACT,
        name: "getreward",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          user: WharfKitService.safeGetActor(session),
          farm_name: farmName
        }
      }];
      const result = await this.executeTransactionWithRetry(session, actions);
      if (result.success) {
        logger.info("Token farm rewards claimed successfully", "StakingService", {
          type: "token_claim_rewards",
          user: WharfKitService.safeGetActor(session),
          farm_name: farmName
        });
      }
      return result;
    } catch (error) {
      logger.error("claimTokenFarmRewards failed", "StakingService", error, {
        user: WharfKitService.safeGetActor(session),
        farm_name: farmName
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Get token farm information from tf.waxdao
   */
  async getTokenFarmInfo(farmName = this.PXJ_FARM_NAME) {
    try {
      const response = await fetch(
        `${API_ENDPOINTS.WAX_CHAIN.GREYMASS}/v1/chain/get_table_rows`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            json: true,
            code: this.TOKEN_FARMS_CONTRACT,
            scope: this.TOKEN_FARMS_CONTRACT,
            table: "farms",
            lower_bound: farmName,
            upper_bound: farmName,
            limit: 1
          })
        }
      );
      if (!response.ok) {
        throw new Error(`Failed to fetch farm info: ${response.statusText}`);
      }
      const data = await response.json();
      const farmData = data.rows.find((row) => row.farm_name === farmName);
      if (!farmData) {
        return null;
      }
      return {
        farm_name: farmData.farm_name,
        creator: farmData.creator,
        time_created: farmData.time_created,
        staking_token: farmData.staking_token,
        incentive_count: farmData.incentive_count,
        total_staked: farmData.total_staked,
        vesting_time: farmData.vesting_time,
        last_update_time: farmData.last_update_time
      };
    } catch (error) {
      logger.error("getTokenFarmInfo failed", "StakingService", error, {
        farm_name: farmName
      });
      return null;
    }
  }
  /**
   * Get user's token staking information from tf.waxdao
   */
  async getTokenStakingInfo(account, farmName = this.PXJ_FARM_NAME) {
    try {
      const response = await fetch(
        `${API_ENDPOINTS.WAX_CHAIN.GREYMASS}/v1/chain/get_table_rows`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            json: true,
            code: this.TOKEN_FARMS_CONTRACT,
            scope: farmName,
            table: "stakers",
            lower_bound: account,
            upper_bound: account,
            limit: 1
          })
        }
      );
      if (!response.ok) {
        throw new Error(`Failed to fetch token staking info: ${response.statusText}`);
      }
      const data = await response.json();
      const stakerData = data.rows.find((row) => row.user === account);
      if (!stakerData) {
        return null;
      }
      const pendingRewards = (stakerData.pending_rewards || []).map((reward) => ({
        token: reward.quantity.split(" ")[1],
        amount: parseFloat(reward.quantity.split(" ")[0]),
        contract: reward.contract,
        precision: 4
      }));
      return {
        farm_name: farmName,
        user: stakerData.user,
        staked_amount: stakerData.staked_amount,
        stake_time: stakerData.stake_time,
        pending_rewards: pendingRewards,
        vesting_time: stakerData.vesting_time,
        last_claim_time: stakerData.last_claim_time
      };
    } catch (error) {
      logger.error("getTokenStakingInfo failed", "StakingService", error, {
        account,
        farm_name: farmName
      });
      return null;
    }
  }
  /**
   * Calculate optimal staking strategy based on user's NFTs
   */
  async calculateOptimalStakingStrategy(account, farmName = "pixeljourney") {
    try {
      const stakingInfo = await this.getStakingInfo(account, farmName);
      const stakedAssetIds = new Set(stakingInfo.staked_nfts.map((nft) => nft.asset_id));
      const availableResponse = await fetch(
        `${apiService.atomicAssetsAPI}/atomicassets/v1/assets?owner=${account}&collection_name=pixeljourney&page=1&limit=1000&order=desc&sort=asset_id`
      );
      if (!availableResponse.ok) {
        throw new Error("Failed to fetch available NFTs");
      }
      const availableData = await availableResponse.json();
      const availableNfts = availableData.data?.filter(
        (asset) => !stakedAssetIds.has(asset.asset_id)
      ).map((asset) => ({
        asset_id: asset.asset_id,
        template_id: asset.template.template_id,
        farm_name: farmName,
        stake_time: 0,
        rewards_per_hour: this.calculateRewardsPerHour(asset.template.template_id),
        multiplier: 1
      })) || [];
      const templateRewards = await this.getTemplateRewards();
      const recommendedStakes = availableNfts.map((nft) => {
        const rewards = templateRewards[nft.template_id] || { pxj: 0, wuf: 0 };
        const rarityMultiplier = this.getRarityMultiplier(this.getTemplateRarity(nft.template_id));
        const dailyReturn = (rewards.pxj + rewards.wuf) * 24 * rarityMultiplier;
        return {
          asset_id: nft.asset_id,
          expected_daily_return: dailyReturn,
          priority: this.calculateStakingPriority(this.getTemplateRarity(nft.template_id), dailyReturn)
        };
      }).sort((a, b) => b.priority - a.priority);
      const totalExpectedReturn = recommendedStakes.reduce(
        (sum, stake) => sum + stake.expected_daily_return,
        0
      );
      const optimizationTips = this.generateOptimizationTips(
        recommendedStakes,
        availableNfts
      );
      return {
        recommended_stakes: recommendedStakes,
        total_expected_daily_return: totalExpectedReturn,
        optimization_tips: optimizationTips,
        available_nfts: availableNfts
      };
    } catch (error) {
      logger.error("calculateOptimalStakingStrategy failed", "StakingService", error, {
        account
      });
      return {
        recommended_stakes: [],
        total_expected_daily_return: 0,
        optimization_tips: ["Unable to calculate optimal strategy. Please try again later."],
        available_nfts: []
      };
    }
  }
  /**
   * Process a batch of transactions
   */
  async processBatch(session, assetIds, action, farmName) {
    const actions = assetIds.map((assetId) => {
      if (action === "stake") {
        return {
          account: this.FARMS_CONTRACT,
          name: "stake",
          authorization: [{
            actor: WharfKitService.safeGetActor(session),
            permission: WharfKitService.safeGetPermission(session)
          }],
          data: {
            owner: WharfKitService.safeGetActor(session),
            asset_id: assetId,
            farm_name: farmName || "pixeljourney"
          }
        };
      } else {
        return {
          account: this.FARMS_CONTRACT,
          name: "unstake",
          authorization: [{
            actor: WharfKitService.safeGetActor(session),
            permission: WharfKitService.safeGetPermission(session)
          }],
          data: {
            owner: WharfKitService.safeGetActor(session),
            asset_id: assetId
          }
        };
      }
    });
    try {
      const result = await this.executeTransactionWithRetry(session, actions);
      if (result.success) {
        return {
          success: true,
          successful_transactions: assetIds,
          failed_transactions: [],
          total_gas_used: result.gas_used || 0
        };
      } else {
        return {
          success: false,
          successful_transactions: [],
          failed_transactions: assetIds.map((id) => ({
            asset_id: id,
            error: result.error || "Transaction failed"
          })),
          total_gas_used: 0
        };
      }
    } catch (error) {
      return {
        success: false,
        successful_transactions: [],
        failed_transactions: assetIds.map((id) => ({
          asset_id: id,
          error: error instanceof Error ? error.message : "Unknown error"
        })),
        total_gas_used: 0
      };
    }
  }
  /**
   * Execute transaction with retry logic
   */
  async executeTransactionWithRetry(session, actions, attempt = 1) {
    try {
      const result = await session.transact({ actions });
      const transactionResult = result;
      return {
        success: true,
        transaction_id: transactionResult?.transaction_id || transactionResult?.id || "",
        gas_used: transactionResult?.cpu_usage_us || transactionResult?.max_net_usage_words || 0
      };
    } catch (error) {
      if (attempt < this.RETRY_ATTEMPTS) {
        await this.delay(this.RETRY_DELAY * attempt);
        return this.executeTransactionWithRetry(session, actions, attempt + 1);
      }
      return {
        success: false,
        error: error instanceof Error ? error.message : "Transaction failed"
      };
    }
  }
  /**
   * Create batches from array of items
   */
  createBatches(items, batchSize) {
    const batches = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }
  /**
   * Delay execution for specified milliseconds
   */
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Get template rewards from farms.waxdao contract table
   */
  async getTemplateRewards() {
    try {
      const response = await fetch(
        `${API_ENDPOINTS.WAX_CHAIN.GREYMASS}/v1/chain/get_table_rows`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            json: true,
            code: this.FARMS_CONTRACT,
            scope: this.FARMS_CONTRACT,
            table: "templrewards",
            // Template rewards table from ABI
            limit: 1e3
          })
        }
      );
      if (!response.ok) {
        throw new Error("Failed to fetch template rewards");
      }
      const data = await response.json();
      const templateRewards = {};
      data.rows.forEach((template) => {
        const rewards = { pxj: 0, wuf: 0 };
        if (template.hourly_rewards && Array.isArray(template.hourly_rewards)) {
          template.hourly_rewards.forEach((reward) => {
            const amount = parseFloat(reward.quantity.split(" ")[0]);
            const symbol = reward.quantity.split(" ")[1];
            if (symbol === "PXJ") rewards.pxj = amount;
            if (symbol === "WUF") rewards.wuf = amount;
          });
        }
        templateRewards[template.template_id] = rewards;
      });
      return templateRewards;
    } catch {
      return {
        "1001": { pxj: 50, wuf: 25 },
        // Black Ingredient
        "1002": { pxj: 10, wuf: 5 },
        // Tertiary Ingredient
        "1003": { pxj: 2, wuf: 1 },
        // Rare Ingredient
        "1004": { pxj: 0.5, wuf: 0.25 },
        // Uncommon Ingredient
        "1005": { pxj: 0.1, wuf: 0.05 }
        // Common Ingredient
      };
    }
  }
  /**
   * Get rarity multiplier for staking rewards
   */
  getRarityMultiplier(rarity) {
    switch (rarity.toLowerCase()) {
      case "legendary":
        return 5;
      case "epic":
        return 3;
      case "rare":
        return 2;
      case "uncommon":
        return 1.5;
      default:
        return 1;
    }
  }
  /**
   * Calculate staking priority based on rarity and expected return
   */
  calculateStakingPriority(rarity, dailyReturn) {
    const rarityScore = this.getRarityMultiplier(rarity) * 100;
    const returnScore = dailyReturn * 10;
    return rarityScore + returnScore;
  }
  /**
   * Generate optimization tips for staking strategy
   */
  generateOptimizationTips(recommendedStakes, availableNfts) {
    const tips = [];
    const rarityCount = availableNfts.reduce((acc, nft) => {
      const rarity = this.getTemplateRarity(nft.template_id);
      acc[rarity] = (acc[rarity] || 0) + 1;
      return acc;
    }, {});
    if (rarityCount["Legendary"] > 0) {
      tips.push("Prioritize staking Legendary ingredients for maximum rewards");
    }
    if (rarityCount["Epic"] > 5) {
      tips.push("Consider staking Epic ingredients in batches to optimize gas costs");
    }
    if (recommendedStakes.length > 20) {
      tips.push("Use batch staking to reduce transaction costs for large collections");
    }
    const totalDailyReturn = recommendedStakes.reduce((sum, stake) => sum + stake.expected_daily_return, 0);
    if (totalDailyReturn > 100) {
      tips.push("Your collection has high earning potential - consider staking all eligible NFTs");
    }
    if (tips.length === 0) {
      tips.push("Stake your highest rarity NFTs first for optimal returns");
    }
    return tips;
  }
  /**
   * Calculate rewards per hour for a template ID
   */
  calculateRewardsPerHour(templateId) {
    const defaultRewards = {
      "1001": { pxj: 50, wuf: 25 },
      "1002": { pxj: 10, wuf: 5 },
      "1003": { pxj: 2, wuf: 1 },
      "1004": { pxj: 0.5, wuf: 0.25 },
      "1005": { pxj: 0.1, wuf: 0.05 }
    };
    return defaultRewards[templateId] || { pxj: 0, wuf: 0 };
  }
  /**
   * Get rarity for a template ID
   */
  getTemplateRarity(templateId) {
    const templateRarities = {
      "1001": "Legendary",
      "1002": "Epic",
      "1003": "Rare",
      "1004": "Uncommon",
      "1005": "Common"
    };
    return templateRarities[templateId] || "Common";
  }
}
const stakingService = new StakingService();
const ProgressiveImage = React.memo(({
  imageUrl,
  videoUrl,
  alt,
  className = "",
  loading = "lazy",
  enableAnimations = true,
  placeholder,
  onLoad,
  onError
}) => {
  const [isLoaded, setIsLoaded] = reactExports.useState(false);
  const [isError, setIsError] = reactExports.useState(false);
  const [isInView, setIsInView] = reactExports.useState(loading === "eager");
  const imgRef = reactExports.useRef(null);
  const videoRef = reactExports.useRef(null);
  const processUrl = (url) => {
    if (!url) return null;
    if (typeof url !== "string") return null;
    if (url.startsWith("http")) return url;
    if (url.startsWith("Qm")) return `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${url}`;
    return url;
  };
  const processedVideoUrl = processUrl(videoUrl);
  const processedImageUrl = processUrl(imageUrl);
  const getLoadingPlaceholder = () => {
    if (placeholder) return placeholder;
    const svg = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
      <rect width="200" height="200" fill="#f8fafc"/>
      <rect x="50" y="80" width="100" height="8" rx="4" fill="#e2e8f0">
        <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" repeatCount="indefinite"/>
      </rect>
      <rect x="60" y="100" width="80" height="6" rx="3" fill="#e2e8f0">
        <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" begin="0.3s" repeatCount="indefinite"/>
      </rect>
      <rect x="70" y="120" width="60" height="6" rx="3" fill="#e2e8f0">
        <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" begin="0.6s" repeatCount="indefinite"/>
      </rect>
    </svg>`;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  };
  const getErrorPlaceholder = () => {
    const svg = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
      <rect width="200" height="200" fill="#fef2f2"/>
      <circle cx="100" cy="80" r="20" fill="#fca5a5"/>
      <text x="100" y="85" text-anchor="middle" font-family="Arial" font-size="16" fill="#dc2626">!</text>
      <text x="100" y="120" text-anchor="middle" font-family="Arial" font-size="12" fill="#991b1b">Failed to load</text>
    </svg>`;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  };
  reactExports.useEffect(() => {
    if (loading === "eager" || isInView) return;
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      {
        rootMargin: "50px"
        // Start loading 50px before the image comes into view
      }
    );
    const currentRef = imgRef.current || videoRef.current;
    if (currentRef) {
      observer.observe(currentRef);
    }
    return () => observer.disconnect();
  }, [loading, isInView]);
  const handleLoad = () => {
    setIsLoaded(true);
    setIsError(false);
    onLoad?.();
  };
  const handleError = () => {
    setIsError(true);
    setIsLoaded(false);
    onError?.();
  };
  if (!isInView || !isLoaded && !isError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `progressive-image-container ${className}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          ref: imgRef,
          src: getLoadingPlaceholder(),
          alt: `Loading ${alt}`,
          className: "progressive-image-placeholder",
          style: {
            width: "100%",
            height: "100%",
            objectFit: "cover",
            filter: "blur(2px)",
            transition: "filter 0.3s ease"
          }
        }
      ),
      isInView && processedImageUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: processedImageUrl,
          alt,
          style: { display: "none" },
          onLoad: handleLoad,
          onError: handleError
        }
      ),
      isInView && processedVideoUrl && enableAnimations && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "video",
        {
          ref: videoRef,
          src: processedVideoUrl,
          style: { display: "none" },
          onLoadedData: handleLoad,
          onError: handleError,
          muted: true,
          loop: true
        }
      )
    ] });
  }
  if (isError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: getErrorPlaceholder(),
        alt: `Error loading ${alt}`,
        className,
        style: {
          width: "100%",
          height: "100%",
          objectFit: "cover"
        }
      }
    );
  }
  if (processedVideoUrl && enableAnimations && isLoaded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "video",
      {
        ref: videoRef,
        className,
        muted: true,
        loop: true,
        autoPlay: true,
        poster: processedImageUrl || void 0,
        style: {
          width: "100%",
          height: "100%",
          objectFit: "cover",
          opacity: isLoaded ? 1 : 0,
          transition: "opacity 0.3s ease"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: processedVideoUrl, type: "video/mp4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: processedVideoUrl, type: "video/webm" })
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      ref: imgRef,
      src: processedImageUrl || getErrorPlaceholder(),
      alt,
      className,
      style: {
        width: "100%",
        height: "100%",
        objectFit: "cover",
        opacity: isLoaded ? 1 : 0,
        transition: "opacity 0.3s ease"
      }
    }
  );
});
ProgressiveImage.displayName = "ProgressiveImage";
const NFTCard = reactExports.memo(({
  nft,
  selectedNFTs,
  isSelected,
  settings,
  dropdownOpen,
  onNFTClick,
  onCollectionClick,
  onSchemaClick,
  onToggleSelection,
  onDropdownToggle,
  onListingOpen,
  onTransferOpen,
  onBurnOpen,
  onAuctionOpen,
  onRecyclePixal,
  onCraftingOpen,
  onViewOffers,
  onUnpackPixelPack,
  onStakeOpen,
  onTokenizePixal,
  onImageZoom
}) => {
  const isDropdownOpen = dropdownOpen === nft.asset_id;
  const isPixal = nft.collection.collection_name === "pixeljourney" && nft.schema.schema_name === "pixals";
  const isIngredient = nft.collection.collection_name === "pixeljourney" && nft.schema.schema_name === "ingredients";
  const isWaxRockPixal = MarketplaceConfigService.isValidWaxRock(nft.data.WaxRock);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `inventory-page-card ${selectedNFTs.size > 0 ? "selectable" : ""} ${isSelected ? "selected" : ""}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selection-checkbox", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: isSelected,
            onChange: () => onToggleSelection(nft.asset_id),
            onClick: (e) => e.stopPropagation()
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "inventory-page-media",
            onClick: () => {
              if (selectedNFTs.size > 0) {
                onToggleSelection(nft.asset_id);
              } else {
                onNFTClick(nft);
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ProgressiveImage,
                {
                  imageUrl: getAssetImageUrl(nft),
                  videoUrl: getAssetVideoUrl(nft),
                  alt: nft.name,
                  className: "inventory-media",
                  loading: "lazy",
                  enableAnimations: settings.enableAnimatedNFTs
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "zoom-overlay",
                  onClick: (e) => {
                    e.stopPropagation();
                    onImageZoom(getAssetImageUrl(nft) || "", getAssetVideoUrl(nft) || "", nft.name || `Asset #${nft.asset_id}`);
                  },
                  title: "Click to zoom",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "zoom-icon", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21 21-4.35-4.35" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11 8v6M8 11h6" })
                  ] })
                }
              ),
              nft.mint_number && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mint-badge", children: [
                "#",
                nft.mint_number
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-page-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h3",
            {
              className: "inventory-page-name",
              onClick: () => {
                if (selectedNFTs.size > 0) {
                  onToggleSelection(nft.asset_id);
                } else {
                  onNFTClick(nft);
                }
              },
              children: nft.name
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-page-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "inventory-page-collection",
                onClick: () => onCollectionClick(nft.collection.collection_name),
                children: typeof nft.collection === "string" ? nft.collection : nft.collection?.name || nft.collection?.collection_name || "Unknown"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "inventory-page-schema",
                onClick: () => onSchemaClick(nft.schema.schema_name),
                children: nft.schema.schema_name
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-page-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "basic-actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "inv-action-btn list-btn",
                  onClick: (e) => {
                    e.stopPropagation();
                    onListingOpen(nft);
                  },
                  title: "List for Sale",
                  "aria-label": `List ${nft.name} for sale`,
                  children: ""
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "inv-action-btn transfer-btn",
                  onClick: (e) => {
                    e.stopPropagation();
                    onTransferOpen(nft);
                  },
                  title: "Transfer",
                  "aria-label": `Transfer ${nft.name} to another account`,
                  children: ""
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "inv-action-btn offers-btn",
                  onClick: (e) => {
                    e.stopPropagation();
                    onViewOffers(nft);
                  },
                  "aria-label": `View offers for ${nft.name}`,
                  title: "View Offers",
                  children: ""
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "more-actions-dropdown", "data-dropdown-id": nft.asset_id, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "more-actions-btn",
                  onClick: (e) => {
                    e.stopPropagation();
                    onDropdownToggle(nft.asset_id);
                  },
                  title: "More Actions",
                  "aria-label": `More actions for ${nft.name}`,
                  "aria-expanded": isDropdownOpen,
                  children: ""
                }
              ),
              isDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inv-dropdown-menu", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "inv-dropdown-item auction-item",
                    onClick: (e) => {
                      e.stopPropagation();
                      onAuctionOpen(nft);
                    },
                    "aria-label": `Create auction for ${nft.name}`,
                    children: " Create Auction"
                  }
                ),
                !isWaxRockPixal && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "inv-dropdown-item burn-item",
                    onClick: (e) => {
                      e.stopPropagation();
                      onBurnOpen(nft);
                    },
                    "aria-label": `Burn ${nft.name}`,
                    children: " Burn"
                  }
                ),
                isPixal && !isWaxRockPixal && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "inv-dropdown-item recycle-item",
                    onClick: (e) => {
                      e.stopPropagation();
                      onRecyclePixal(nft);
                    },
                    "aria-label": `Recycle ${nft.name}`,
                    children: " Recycle"
                  }
                ),
                isPixal && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "inv-dropdown-item tokenize-item",
                    onClick: (e) => {
                      e.stopPropagation();
                      onTokenizePixal(nft);
                    },
                    "aria-label": `Tokenize ${nft.name} into WPIXAL`,
                    children: " Tokenize into WPIXAL"
                  }
                ),
                (isPixal || isIngredient) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    className: "inv-dropdown-item craft-item",
                    onClick: (e) => {
                      e.stopPropagation();
                      onCraftingOpen(nft);
                    },
                    "aria-label": `Use ${nft.name} for crafting`,
                    children: [
                      " ",
                      isIngredient ? "Craft with Ingredient" : "Craft"
                    ]
                  }
                ),
                nft.collection.collection_name === "pixeljourney" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "inv-dropdown-item stake-item",
                    onClick: (e) => {
                      e.stopPropagation();
                      onStakeOpen(nft);
                    },
                    "aria-label": `Stake ${nft.name}`,
                    children: " Stake NFT"
                  }
                ),
                NeftyBlendService.isPixelPack(nft) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "inv-dropdown-item unpack-item",
                    onClick: (e) => {
                      e.stopPropagation();
                      onUnpackPixelPack(nft);
                    },
                    children: " Unpack"
                  }
                )
              ] })
            ] })
          ] })
        ] })
      ]
    }
  );
});
const Inventory = reactExports.memo(() => {
  const navigate = useNavigate();
  const { settings } = useDisplaySettings();
  const { showSuccess, showError, confirm: confirm2 } = useNotifications();
  const [inventory, setInventory] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [listingModalOpen, setListingModalOpen] = reactExports.useState(false);
  const [transferModalOpen, setTransferModalOpen] = reactExports.useState(false);
  const [burnModalOpen, setBurnModalOpen] = reactExports.useState(false);
  const [showBulkListingModal, setShowBulkListingModal] = reactExports.useState(false);
  const [showBulkTransferModal, setShowBulkTransferModal] = reactExports.useState(false);
  const [showBulkDistributeModal, setShowBulkDistributeModal] = reactExports.useState(false);
  const [showBulkBurnModal, setShowBulkBurnModal] = reactExports.useState(false);
  const [showUnpackModal, setShowUnpackModal] = reactExports.useState(false);
  const [showBulkAuctionModal, setShowBulkAuctionModal] = reactExports.useState(false);
  const [showAuctionModal, setShowAuctionModal] = reactExports.useState(false);
  const [actionNFT, setActionNFT] = reactExports.useState(null);
  const [selectedItems, setSelectedItems] = reactExports.useState(/* @__PURE__ */ new Set());
  const [isMultiSelectMode, setIsMultiSelectMode] = reactExports.useState(false);
  const [dropdownOpen, setDropdownOpen] = reactExports.useState(null);
  const [craftingModalOpen, setCraftingModalOpen] = reactExports.useState(false);
  const [craftingIngredient, setCraftingIngredient] = reactExports.useState(null);
  const [viewOffersModalOpen, setViewOffersModalOpen] = reactExports.useState(false);
  const [offersNFT, setOffersNFT] = reactExports.useState(null);
  const [tokenizeModalOpen, setTokenizeModalOpen] = reactExports.useState(false);
  const [tokenizeNFT, setTokenizeNFT] = reactExports.useState(null);
  const [zoomedImage, setZoomedImage] = reactExports.useState(null);
  const [showImageZoom, setShowImageZoom] = reactExports.useState(false);
  const handleMediaZoom = reactExports.useCallback((imageUrl, videoUrl, name) => {
    const mediaUrl = videoUrl || imageUrl;
    const mediaType = videoUrl ? "video" : "image";
    let processedUrl = mediaUrl;
    if (mediaUrl.startsWith("Qm") || mediaUrl.startsWith("baf")) {
      processedUrl = `https://ipfs.io/ipfs/${mediaUrl}`;
    } else if (mediaUrl.startsWith("/ipfs/")) {
      processedUrl = `https://ipfs.io${mediaUrl}`;
    } else if (mediaUrl.startsWith("ipfs://")) {
      processedUrl = mediaUrl.replace("ipfs://", "https://ipfs.io/ipfs/");
    }
    setZoomedImage({ url: processedUrl, name, type: mediaType });
    setShowImageZoom(true);
  }, []);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [debouncedSearchTerm, setDebouncedSearchTerm] = reactExports.useState("");
  const [searchSuggestions, setSearchSuggestions] = reactExports.useState([]);
  const [filter, setFilter] = reactExports.useState("all");
  const [selectedCollection, setSelectedCollection] = reactExports.useState("all");
  const [selectedSchema, setSelectedSchema] = reactExports.useState("all");
  const [selectedTemplate, setSelectedTemplate] = reactExports.useState("");
  const [sortBy, setSortBy] = reactExports.useState("transferred");
  const [sortOrder, setSortOrder] = reactExports.useState("desc");
  const [collectionSearchTerm] = reactExports.useState("");
  const [availableCollections, setAvailableCollections] = reactExports.useState([]);
  const [availableSchemas, setAvailableSchemas] = reactExports.useState([]);
  const [showAdvancedFilters, setShowAdvancedFilters] = reactExports.useState(false);
  const [dateRange, setDateRange] = reactExports.useState({ start: "", end: "" });
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [hasMore, setHasMore] = reactExports.useState(false);
  const [loadingMore, setLoadingMore] = reactExports.useState(false);
  const [loadingAll, setLoadingAll] = reactExports.useState(false);
  const ITEMS_PER_PAGE = 1e3;
  const [totalPages, setTotalPages] = reactExports.useState(1);
  const { isConnected, account, login, session } = useWallet$1();
  const loadInventory = reactExports.useCallback(async (page = 1, append = false) => {
    if (!account) return;
    if (loading || loadingMore) {
      log.debug("Skipping loadInventory - already loading", "Inventory");
      return;
    }
    if (page === 1) {
      setLoading(true);
      setCurrentPage(1);
    } else {
      setLoadingMore(true);
    }
    try {
      log.debug("Loading inventory", "Inventory", { filter, page, ITEMS_PER_PAGE, sortBy, sortOrder });
      let response;
      const apiOptions = {
        page,
        limit: ITEMS_PER_PAGE,
        order: sortOrder,
        sort: sortBy.includes("_") ? "asset_id" : sortBy,
        // Handle legacy sort options
        search: debouncedSearchTerm || void 0,
        template_id: selectedTemplate || void 0
      };
      if (dateRange.start) {
        apiOptions.after = new Date(dateRange.start).getTime() / 1e3;
      }
      if (dateRange.end) {
        apiOptions.before = new Date(dateRange.end).getTime() / 1e3;
      }
      switch (filter) {
        case "pixals":
          apiOptions.collection_name = "pixeljourney";
          apiOptions.schema_name = "pixals";
          break;
        case "ingredients":
          apiOptions.collection_name = "pixeljourney";
          apiOptions.schema_name = "ingredients";
          break;
        case "waxrock":
          apiOptions.collection_name = "pixeljourney";
          apiOptions.schema_name = "pixals";
          break;
        case "packs":
          apiOptions.collection_name = "pixeljourney";
          apiOptions.schema_name = "packs";
          break;
        case "all":
        default:
          if (selectedCollection !== "all") {
            apiOptions.collection_name = selectedCollection;
          }
          if (selectedSchema !== "all") {
            apiOptions.schema_name = selectedSchema;
          }
          break;
      }
      const apiResponse = await apiService.getUserInventoryEnhanced(account, apiOptions);
      response = {
        data: apiResponse.assets || [],
        hasMore: apiResponse.hasMore,
        totalCount: apiResponse.total || 0,
        collections: apiResponse.collections || [],
        schemas: apiResponse.schemas || []
      };
      if (response.collections && response.collections.length > 0) {
        setAvailableCollections((prev) => {
          const combined = [.../* @__PURE__ */ new Set([...prev, ...response.collections])];
          return combined.sort();
        });
      }
      if (response.schemas && response.schemas.length > 0) {
        setAvailableSchemas((prev) => {
          const combined = [.../* @__PURE__ */ new Set([...prev, ...response.schemas])];
          return combined.sort();
        });
      }
      log.debug("Inventory Response", "Inventory", { itemsReceived: response?.data?.length || 0, totalAvailable: response?.totalCount || "unknown", hasMore: response?.hasMore });
      let inventoryNFTs = response.data.map((asset) => ({
        asset_id: asset.asset_id,
        name: asset.name,
        img: asset.image || asset.img,
        // Handle both formats
        video: asset.video || asset.traits?.video || asset.data?.video || void 0,
        collection: {
          name: asset.collection || asset.collection_name,
          collection_name: asset.collection || asset.collection_name
        },
        schema: {
          schema_name: asset.schema || asset.schema_name
        },
        template: {
          template_id: asset.template_id || asset.template?.template_id || "0",
          max_supply: asset.max_supply || asset.template?.max_supply || "0"
        },
        data: asset.traits || asset.data || {},
        mint_number: asset.template_mint || asset.mint_number
      }));
      if (page === 1 && filter === "all") {
        const collections = [...new Set(
          inventoryNFTs.map((nft) => nft.collection.collection_name).filter((name) => typeof name === "string" && name.trim() !== "")
        )].sort();
        setAvailableCollections(collections);
      }
      if (append && page > 1) {
        setInventory((prev) => [...prev, ...inventoryNFTs]);
        setCurrentPage(page);
      } else {
        setInventory(inventoryNFTs);
        setCurrentPage(1);
      }
      setHasMore(response.hasMore);
    } catch (error) {
      log.error("Error loading inventory", "Inventory", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      if (page === 1 && !append) {
        setInventory([]);
        log.warn("Failed to load inventory", "Inventory", { errorMessage });
      } else {
        log.warn("Failed to load more inventory items", "Inventory", { errorMessage });
      }
      setHasMore(false);
    } finally {
      setLoading(false);
      setLoadingMore(false);
    }
  }, [account, filter, selectedCollection, ITEMS_PER_PAGE]);
  reactExports.useEffect(() => {
    if (isConnected && account) {
      log.debug("Inventory reload triggered", "Inventory", {
        filter,
        selectedCollection,
        selectedSchema,
        selectedTemplate,
        sortBy,
        sortOrder,
        searchTerm,
        dateRange
      });
      loadInventory(1, false);
    }
  }, [isConnected, account, filter, selectedCollection, selectedSchema, selectedTemplate, sortBy, sortOrder, searchTerm, dateRange]);
  const loadMoreItems = reactExports.useCallback(() => {
    if (hasMore && !loadingMore && account) {
      loadInventory(currentPage + 1, true);
    }
  }, [hasMore, loadingMore, currentPage, account, loadInventory]);
  const loadAllItems = reactExports.useCallback(async () => {
    if (!hasMore || loadingAll || !account) {
      log.debug("LoadAll skipped", "Inventory", { hasMore, loadingAll, account });
      return;
    }
    setLoadingAll(true);
    log.debug("Starting loadAllItems with concurrent requests", "Inventory", { currentInventoryLength: inventory.length, hasMore, currentPage });
    const concurrentRequests = 2;
    let startPage = currentPage + 1;
    let allNewItems = [];
    let hasMoreItems = true;
    let totalRequests = 0;
    try {
      while (hasMoreItems && totalRequests < 50) {
        const requestPromises = [];
        const requestPages = [];
        for (let i = 0; i < concurrentRequests && hasMoreItems; i++) {
          const page = startPage + i;
          requestPages.push(page);
          const requestPromise = (async () => {
            const offset = (page - 1) * 1e3;
            try {
              switch (filter) {
                case "pixals":
                  return await apiService.getUserInventoryBySchema(account, "pixeljourney", "pixals", 1e3, offset);
                case "ingredients":
                  return await apiService.getUserInventoryBySchema(account, "pixeljourney", "ingredients", 1e3, offset);
                case "waxrock":
                  return await apiService.getUserInventoryWaxRocks(account, 1e3, offset);
                case "all":
                default: {
                  const collectionFilter = selectedCollection !== "all" ? selectedCollection : void 0;
                  return await apiService.getUserInventoryWithFilter(account, page, 1e3, collectionFilter);
                }
              }
            } catch (error) {
              log.error("Error in individual request", "Inventory", error instanceof Error ? error : new Error(String(error)));
              return { assets: [], total: 0, hasMore: false };
            }
          })();
          requestPromises.push(requestPromise);
        }
        log.debug("LoadAll Concurrent Batch", "Inventory", { pages: requestPages, currentItems: inventory.length + allNewItems.length });
        const responses = await Promise.allSettled(requestPromises);
        totalRequests += responses.length;
        let batchHasItems = false;
        for (let i = 0; i < responses.length; i++) {
          const result = responses[i];
          const page = requestPages[i];
          if (result.status === "fulfilled") {
            const response = result.value;
            log.debug("LoadAll Response", "Inventory", { page, items: response?.assets?.length || 0, hasMore: response?.hasMore, total: response?.total });
            if (response && response.assets && response.assets.length > 0) {
              batchHasItems = true;
              let inventoryNFTs = response.assets.map((nft) => ({
                asset_id: nft.asset_id,
                name: nft.name,
                img: nft.image,
                video: nft.video || nft.traits?.video || void 0,
                collection: {
                  name: nft.collection,
                  collection_name: nft.collection
                },
                schema: {
                  schema_name: nft.schema
                },
                template: {
                  template_id: nft.template_id?.toString() || "0",
                  max_supply: nft.max_supply || "0"
                },
                data: nft.traits || {},
                mint_number: nft.template_mint
              }));
              if (filter === "waxrock") {
                inventoryNFTs = inventoryNFTs.filter((nft) => {
                  const waxRock = nft.data.WaxRock;
                  return nft.collection.collection_name === "pixeljourney" && nft.schema.schema_name === "pixals" && waxRock && waxRock !== "none";
                });
              }
              allNewItems.push(...inventoryNFTs);
            }
            if (!response || !response.hasMore) {
              hasMoreItems = false;
            }
          } else {
            log.error("LoadAll Request Failed", "Inventory", new Error(`Page ${page}: ${result.reason}`));
          }
        }
        if (!batchHasItems) {
          hasMoreItems = false;
          log.debug("No more items found, stopping LoadAll", "Inventory");
        }
        startPage += concurrentRequests;
        if (allNewItems.length > 0) {
          setInventory((prev) => {
            const newInventory = [...prev, ...allNewItems];
            log.debug("Updated inventory", "Inventory", { previousCount: prev.length, newCount: newInventory.length, addedCount: allNewItems.length });
            return newInventory;
          });
          setCurrentPage(startPage - 1);
          allNewItems = [];
        }
        if (hasMoreItems) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
      }
      log.debug("LoadAll Complete with concurrent requests", "Inventory", { totalItems: inventory.length, totalRequests });
      setHasMore(false);
    } catch (error) {
      log.error("Error loading all items", "Inventory", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      log.warn("Failed to load all inventory items", "Inventory", { errorMessage });
      setHasMore(false);
    } finally {
      setLoadingAll(false);
    }
  }, [hasMore, loadingAll, account, currentPage, ITEMS_PER_PAGE, filter, selectedCollection, inventory.length]);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownOpen && !event.target.closest(".more-actions-dropdown")) {
        setDropdownOpen(null);
      }
    };
    const adjustDropdownPosition = () => {
      if (dropdownOpen) {
        const dropdown = document.querySelector(`[data-dropdown-id="${dropdownOpen}"] .inv-dropdown-menu`);
        if (dropdown) {
          const rect = dropdown.getBoundingClientRect();
          const viewportWidth = window.innerWidth;
          dropdown.classList.remove("dropdown-left", "dropdown-down");
          if (rect.right > viewportWidth) {
            dropdown.classList.add("dropdown-left");
          }
          if (rect.top < 0) {
            dropdown.classList.add("dropdown-down");
          }
        }
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    if (dropdownOpen) {
      setTimeout(adjustDropdownPosition, 0);
    }
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [dropdownOpen]);
  const handleNFTClick = (nft) => {
    navigate(`/assets/${nft.asset_id}`);
  };
  const handleCollectionClick = (collectionName) => {
    navigate(`/marketplace?collection=${collectionName}`);
  };
  const handleSchemaClick = (schemaName) => {
    navigate(`/marketplace?schema=${schemaName}`);
  };
  const handleRecyclePixal = async (nft) => {
    if (!account || !session) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    if (MarketplaceConfigService.isPixalPFP(nft.template.template_id)) {
      const waxRock = nft.data?.WaxRock;
      if (waxRock && MarketplaceConfigService.isValidWaxRock(waxRock)) {
        showError(
          "WaxRock Protection",
          `This is a rare WaxRock Pixal PFP (${waxRock}) and cannot be recycled. WaxRock Pixals are protected from burning and recycling on our platform.`
        );
        return;
      }
    }
    try {
      const confirmed = await confirm2(
        "Confirm Recycle",
        `Are you sure you want to recycle ${nft.name}?

This will cost 12,000 PXJ tokens and cannot be undone.`,
        "Recycle",
        "Cancel"
      );
      if (!confirmed) return;
      const transaction = await NeftyBlendService.recyclePixal(nft.asset_id, account);
      await NeftyBlendService.executeRecycle(transaction, session);
      showSuccess("Recycle Successful", "Pixal recycled successfully!");
      await loadInventory();
    } catch (error) {
      log.error("Recycle failed", "Inventory", error);
      showError(
        "Recycle Failed",
        error instanceof Error ? error.message : "Unknown error occurred"
      );
    }
  };
  const handleTokenizePixal = async (nft) => {
    if (!account || !session) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    if (!MarketplaceConfigService.isPixalPFP(nft.template.template_id)) {
      showError("Invalid NFT", "Only Pixal PFPs can be tokenized into WPIXAL");
      return;
    }
    setTokenizeNFT(nft);
    setTokenizeModalOpen(true);
  };
  const handleCraftingOpen = (nft) => {
    setCraftingIngredient(nft);
    setCraftingModalOpen(true);
  };
  const handleViewOffers = (nft) => {
    setOffersNFT(nft);
    setViewOffersModalOpen(true);
  };
  const handleStakeOpen = async (nft) => {
    if (!account || !session) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    if (nft.collection.collection_name !== "pixeljourney") {
      showError("Invalid Asset", "Only Pixel Journey NFTs can be staked");
      return;
    }
    try {
      const confirmed = await confirm2(
        "Confirm Staking",
        `Are you sure you want to stake ${nft.name}?

Your assets will remain in your inventory as the Pixel Journey uses non-custodial staking.`,
        "Stake NFT",
        "Cancel"
      );
      if (!confirmed) return;
      const result = await stakingService.stakeNFTsPixelJourney(
        session,
        [nft.asset_id],
        "pixeljourney"
      );
      if (result.success) {
        showSuccess("NFT Staked Successfully", `${nft.name} has been staked successfully!`);
        await loadInventory();
      } else {
        showError("Staking Failed", result.error || "Failed to stake NFT");
      }
    } catch (error) {
      console.error("Staking error:", error);
      showError("Staking Failed", error instanceof Error ? error.message : "An unexpected error occurred");
    }
  };
  const handleUnpackPixelPack = async (nft) => {
    if (!account || !session) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    try {
      const confirmed = await confirm2(
        "Confirm Unpack",
        `Are you sure you want to unpack ${nft.name}?

This action cannot be undone.`,
        "Unpack",
        "Cancel"
      );
      if (!confirmed) return;
      const transaction = await NeftyBlendService.unpackPixelPack(nft.asset_id, account);
      await NeftyBlendService.executeUnpack(transaction, session);
      showSuccess("Unpack Successful", "Pixelpack unpacked successfully!");
      await loadInventory();
    } catch (error) {
      log.error("Unpack failed", "Inventory", error);
      showError(
        "Unpack Failed",
        error instanceof Error ? error.message : "Unknown error occurred"
      );
    }
  };
  const toggleItemSelection = (assetId) => {
    const newSelected = new Set(selectedItems);
    if (newSelected.has(assetId)) {
      newSelected.delete(assetId);
      if (newSelected.size === 0) {
        setIsMultiSelectMode(false);
      }
    } else {
      newSelected.add(assetId);
      if (!isMultiSelectMode) {
        setIsMultiSelectMode(true);
      }
    }
    setSelectedItems(newSelected);
  };
  const selectAllItems = () => {
    const allIds = new Set(filteredInventory.map((nft) => nft.asset_id));
    const allSelected = allIds.size > 0 && [...allIds].every((id) => selectedItems.has(id));
    if (allSelected) {
      const newSelected = new Set(selectedItems);
      allIds.forEach((id) => newSelected.delete(id));
      setSelectedItems(newSelected);
    } else {
      const newSelected = /* @__PURE__ */ new Set([...selectedItems, ...allIds]);
      setSelectedItems(newSelected);
    }
  };
  const clearSelection = () => {
    setSelectedItems(/* @__PURE__ */ new Set());
  };
  const handleBulkListing = () => {
    if (selectedItems.size === 0) return;
    setShowBulkListingModal(true);
  };
  const handleBulkTransfer = () => {
    if (selectedItems.size === 0) return;
    setShowBulkTransferModal(true);
  };
  const handleBulkDistribute = () => {
    if (selectedItems.size === 0) return;
    setShowBulkDistributeModal(true);
  };
  const handleBulkAuction = () => {
    if (selectedItems.size === 0) return;
    setShowBulkAuctionModal(true);
  };
  const handleBulkBurn = () => {
    if (selectedItems.size === 0) return;
    setShowBulkBurnModal(true);
  };
  const handleBulkStake = async () => {
    if (selectedItems.size === 0) return;
    if (!account || !session) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    const selectedNFTs = inventory.filter((nft) => selectedItems.has(nft.asset_id));
    const stakeableNFTs = selectedNFTs.filter((nft) => nft.collection.collection_name === "pixeljourney");
    if (stakeableNFTs.length === 0) {
      showError("No Stakeable NFTs", "Only Pixel Journey NFTs can be staked. Please select some Pixel Journey assets.");
      return;
    }
    if (stakeableNFTs.length !== selectedNFTs.length) {
      const nonStakeableCount = selectedNFTs.length - stakeableNFTs.length;
      console.log(`Skipping ${nonStakeableCount} non-Pixel Journey NFTs, staking ${stakeableNFTs.length} Pixel Journey NFTs`);
    }
    try {
      const assetIds = stakeableNFTs.map((nft) => nft.asset_id);
      const result = await stakingService.stakeNFTsPixelJourney(
        session,
        assetIds,
        "pixeljourney"
      );
      if (result.success) {
        showSuccess("NFTs Staked Successfully", `${stakeableNFTs.length} NFT${stakeableNFTs.length > 1 ? "s have" : " has"} been staked successfully!`);
        setSelectedItems(/* @__PURE__ */ new Set());
        setIsMultiSelectMode(false);
        await loadInventory();
      } else {
        showError("Staking Failed", result.error || "Failed to stake NFTs");
      }
    } catch (error) {
      console.error("Bulk staking error:", error);
      showError("Staking Failed", error instanceof Error ? error.message : "An unexpected error occurred");
    }
  };
  const handleClaimRewards = async () => {
    if (!account || !session) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    try {
      const result = await stakingService.claimAllRewards(session, "pixeljourney");
      if (result.success) {
        showSuccess("Rewards Claimed Successfully", "All pending rewards have been claimed and transferred to your wallet!");
      } else {
        showError("Claim Failed", result.error || "Failed to claim rewards");
      }
    } catch (error) {
      console.error("Claim rewards error:", error);
      showError("Claim Failed", error instanceof Error ? error.message : "An unexpected error occurred");
    }
  };
  const handleBulkUnpackPixelPacks = async () => {
    if (selectedItems.size === 0) return;
    if (!account || !session) {
      showError("Wallet Required", "Please connect your wallet first");
      return;
    }
    const selectedNFTs = inventory.filter((nft) => selectedItems.has(nft.asset_id));
    const pixelPackNFTs = selectedNFTs.filter((nft) => NeftyBlendService.isPixelPack(nft));
    if (pixelPackNFTs.length === 0) {
      showError("No pixelpack NFTs selected", "Please select pixelpack items to unpack.");
      return;
    }
    try {
      const confirmed = await confirm2(
        "Confirm Bulk Unpack",
        `Are you sure you want to unpack ${pixelPackNFTs.length} pixelpack(s)?

This action cannot be undone and will be processed in batches of 20.`,
        "Unpack All",
        "Cancel"
      );
      if (!confirmed) return;
      const assetIds = pixelPackNFTs.map((nft) => nft.asset_id);
      const transactions = await NeftyBlendService.unpackPixelPacksBulk(assetIds, account);
      for (let i = 0; i < transactions.length; i++) {
        const transaction = transactions[i];
        showSuccess(`Processing batch ${i + 1} of ${transactions.length}...`, "Bulk Unpack");
        await NeftyBlendService.executeUnpack(transaction, session);
      }
      showSuccess("Bulk Unpack Successful", `Successfully unpacked ${pixelPackNFTs.length} pixelpack(s)!`);
      setSelectedItems(/* @__PURE__ */ new Set());
      await loadInventory();
    } catch (error) {
      log.error("Bulk unpack failed", "Inventory", error);
      showError(
        "Bulk Unpack Failed",
        error instanceof Error ? error.message : "Unknown error occurred"
      );
    }
  };
  reactExports.useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
    }, 300);
    return () => clearTimeout(timer);
  }, [searchTerm]);
  const generateSearchSuggestions = reactExports.useCallback((query) => {
    if (!query || query.length < 2) return [];
    const suggestions = /* @__PURE__ */ new Map();
    const queryLower = query.toLowerCase();
    inventory.forEach((nft) => {
      if (nft.name.toLowerCase().includes(queryLower)) {
        const key = `name:${nft.name}`;
        if (!suggestions.has(key)) {
          suggestions.set(key, {
            text: nft.name,
            type: "name",
            count: 1
          });
        } else {
          const existing = suggestions.get(key);
          existing.count = (existing.count || 0) + 1;
        }
      }
      if (nft.collection.collection_name.toLowerCase().includes(queryLower)) {
        const key = `collection:${nft.collection.collection_name}`;
        if (!suggestions.has(key)) {
          suggestions.set(key, {
            text: nft.collection.collection_name,
            type: "collection",
            count: 1
          });
        } else {
          const existing = suggestions.get(key);
          existing.count = (existing.count || 0) + 1;
        }
      }
      if (nft.schema.schema_name.toLowerCase().includes(queryLower)) {
        const key = `schema:${nft.schema.schema_name}`;
        if (!suggestions.has(key)) {
          suggestions.set(key, {
            text: nft.schema.schema_name,
            type: "schema",
            count: 1
          });
        } else {
          const existing = suggestions.get(key);
          existing.count = (existing.count || 0) + 1;
        }
      }
    });
    return Array.from(suggestions.values()).sort((a, b) => (b.count || 0) - (a.count || 0)).slice(0, 8);
  }, [inventory]);
  reactExports.useEffect(() => {
    const suggestions = generateSearchSuggestions(searchTerm);
    setSearchSuggestions(suggestions);
  }, [searchTerm, generateSearchSuggestions]);
  const filteredInventory = reactExports.useMemo(() => {
    const filtered = inventory.filter((nft) => {
      const matchesSearch = debouncedSearchTerm === "" || nft.name.toLowerCase().includes(debouncedSearchTerm.toLowerCase()) || nft.collection.collection_name.toLowerCase().includes(debouncedSearchTerm.toLowerCase()) || nft.schema.schema_name.toLowerCase().includes(debouncedSearchTerm.toLowerCase());
      const matchesFilter = filter === "all" || filter === "pixals" && nft.collection.collection_name === "pixeljourney" && nft.schema.schema_name === "pixals" || filter === "waxrock" && nft.collection.collection_name === "pixeljourney" && nft.schema.schema_name === "pixals" && nft.data?.WaxRock && nft.data.WaxRock !== "none" || filter === "ingredients" && nft.collection.collection_name === "pixeljourney" && nft.schema.schema_name === "ingredients" || filter === "packs" && NeftyBlendService.isPackNFT(nft);
      return matchesSearch && matchesFilter;
    });
    return filtered.sort((a, b) => {
      switch (sortBy) {
        case "name_asc":
          return a.name.localeCompare(b.name);
        case "name_desc":
          return b.name.localeCompare(a.name);
        case "collection_asc":
          return a.collection.collection_name.localeCompare(b.collection.collection_name);
        case "collection_desc":
          return b.collection.collection_name.localeCompare(a.collection.collection_name);
        case "mint_asc":
          return (a.mint_number || 0) - (b.mint_number || 0);
        case "mint_desc":
          return (b.mint_number || 0) - (a.mint_number || 0);
        // Rarity sorting removed - Pixal PFPs don't have rarity attributes
        default:
          return 0;
      }
    });
  }, [inventory, debouncedSearchTerm, filter, sortBy]);
  const filteredCount = filteredInventory.length;
  reactExports.useEffect(() => {
    const pages = Math.ceil(filteredCount / ITEMS_PER_PAGE);
    setTotalPages(Math.max(1, pages));
  }, [filteredCount]);
  const currentItems = reactExports.useMemo(() => {
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return filteredInventory.slice(startIndex, endIndex);
  }, [filteredInventory, currentPage, ITEMS_PER_PAGE]);
  const goToNextPage = reactExports.useCallback(() => {
    if (currentPage < totalPages) {
      setCurrentPage((prev) => prev + 1);
    }
  }, [currentPage, totalPages]);
  const goToPrevPage = reactExports.useCallback(() => {
    if (currentPage > 1) {
      setCurrentPage((prev) => prev - 1);
    }
  }, [currentPage]);
  reactExports.useEffect(() => {
    setCurrentPage(1);
  }, [filter, selectedCollection, debouncedSearchTerm, sortBy]);
  if (!isConnected) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-page", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "inventory-page-title", children: "My NFT Inventory" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "inventory-page-subtitle", children: "View and manage your Pixel Journey NFTs" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "connect-wallet-prompt", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connect-wallet-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", className: "wallet-icon", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 12V7H5a2 2 0 0 1 0-4h14v4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 5v14a2 2 0 0 0 2 2h16v-5" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "18", cy: "12", r: "2" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Connect Your Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your wallet to view your NFT inventory and manage your Pixel Journey assets." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: login, children: "Connect Wallet" })
      ] }) })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "inventory-title", children: "My NFT Inventory" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-action-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn inventory-action-btn craft-btn",
            onClick: () => {
              setCraftingModalOpen(true);
            },
            title: "Open crafting interface",
            children: " Craft"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn btn-success inventory-action-btn",
            onClick: handleClaimRewards,
            title: "Claim all pending staking rewards",
            disabled: !account || !session,
            children: " Claim"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-page-filters", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        AdvancedSearch,
        {
          searchTerm,
          onSearchChange: (term) => {
            setSearchTerm(term);
            setCurrentPage(1);
          },
          suggestions: searchSuggestions,
          placeholder: "Search NFTs by name, collection, or schema...",
          showFilters: false,
          className: "inventory-search"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-controls", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-filter-tabs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `inventory-filter-tab ${filter === "all" ? "active" : ""}`,
              onClick: () => {
                setFilter("all");
                setCurrentPage(1);
              },
              children: "All NFTs"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `inventory-filter-tab ${filter === "pixals" ? "active" : ""}`,
              onClick: () => {
                setFilter("pixals");
                setCurrentPage(1);
              },
              children: "Pixals"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `inventory-filter-tab ${filter === "waxrock" ? "active" : ""}`,
              onClick: () => {
                setFilter("waxrock");
                setCurrentPage(1);
              },
              children: "WaxRock"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `inventory-filter-tab ${filter === "ingredients" ? "active" : ""}`,
              onClick: () => {
                setFilter("ingredients");
                setCurrentPage(1);
              },
              children: "Ingredients"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `inventory-filter-tab ${filter === "packs" ? "active" : ""}`,
              onClick: () => {
                setFilter("packs");
                setCurrentPage(1);
              },
              children: "Packs"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "enhanced-filters", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sort-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Sort by:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: sortBy,
                onChange: (e) => {
                  setSortBy(e.target.value);
                  setCurrentPage(1);
                },
                className: "sort-select",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "transferred", children: "Latest Received" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "created", children: "Latest Created" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "updated", children: "Recently Updated" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "minted", children: "Latest Minted" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "asset_id", children: "Asset ID" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_asc", children: "Name (A-Z)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name_desc", children: "Name (Z-A)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_asc", children: "Collection (A-Z)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "collection_desc", children: "Collection (Z-A)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_asc", children: "Mint Number (Low-High)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_desc", children: "Mint Number (High-Low)" })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-filter-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Collection:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: selectedCollection,
                onChange: (e) => {
                  setSelectedCollection(e.target.value);
                  setCurrentPage(1);
                },
                className: "collection-select",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All Collections" }),
                  availableCollections.filter(
                    (collection) => typeof collection === "string" && collection.toLowerCase().includes(collectionSearchTerm.toLowerCase())
                  ).map((collection) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: collection, children: collection }, collection))
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "schema-filter-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Schema:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: selectedSchema,
                onChange: (e) => {
                  setSelectedSchema(e.target.value);
                  setCurrentPage(1);
                },
                className: "schema-select",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All Schemas" }),
                  availableSchemas.map((schema) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: schema, children: schema }, schema))
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-filter-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Template ID:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Enter template ID...",
                value: selectedTemplate,
                onChange: (e) => {
                  setSelectedTemplate(e.target.value);
                  setCurrentPage(1);
                },
                className: "template-input"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `advanced-filters-toggle ${showAdvancedFilters ? "active" : ""}`,
              onClick: () => setShowAdvancedFilters(!showAdvancedFilters),
              children: [
                showAdvancedFilters ? "" : "",
                " Advanced Filters"
              ]
            }
          )
        ] }),
        showAdvancedFilters && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "advanced-filters-panel", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "date-range-filter", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Date Range:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "date-inputs", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "date",
                  value: dateRange.start,
                  onChange: (e) => {
                    setDateRange((prev) => ({ ...prev, start: e.target.value }));
                    setCurrentPage(1);
                  },
                  className: "date-input",
                  placeholder: "Start date"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "to" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "date",
                  value: dateRange.end,
                  onChange: (e) => {
                    setDateRange((prev) => ({ ...prev, end: e.target.value }));
                    setCurrentPage(1);
                  },
                  className: "date-input",
                  placeholder: "End date"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "filter-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "clear-filters-btn",
              onClick: () => {
                setSelectedCollection("all");
                setSelectedSchema("all");
                setSelectedTemplate("");
                setDateRange({ start: "", end: "" });
                setSearchTerm("");
                setSortBy("transferred");
                setSortOrder("desc");
                setCurrentPage(1);
              },
              children: "Clear All Filters"
            }
          ) })
        ] })
      ] }),
      selectedItems.size > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-actions-toolbar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selection-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            selectedItems.size,
            " item",
            selectedItems.size !== 1 ? "s" : "",
            " selected"
          ] }),
          selectedItems.size > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "clear-selection", onClick: clearSelection, children: "Clear" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "select-all", onClick: selectAllItems, children: (() => {
            const allIds = new Set(filteredInventory.map((nft) => nft.asset_id));
            const allSelected = allIds.size > 0 && [...allIds].every((id) => selectedItems.has(id));
            return allSelected ? "Deselect All" : "Select All";
          })() })
        ] }),
        selectedItems.size > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "bulk-btn list-btn", onClick: handleBulkListing, children: [
            " List (",
            selectedItems.size,
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "bulk-btn auction-btn", onClick: handleBulkAuction, children: [
            " Auction (",
            selectedItems.size,
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "bulk-btn transfer-btn", onClick: handleBulkTransfer, children: [
            " Transfer (",
            selectedItems.size,
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "bulk-btn distribute-btn", onClick: handleBulkDistribute, children: [
            " Distribute (",
            selectedItems.size,
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "bulk-btn burn-btn", onClick: handleBulkBurn, children: [
            " Burn (",
            selectedItems.size,
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "bulk-btn stake-btn",
              onClick: handleBulkStake,
              children: [
                " Stake (",
                selectedItems.size,
                ")"
              ]
            }
          ),
          (() => {
            const selectedNFTs = inventory.filter((nft) => selectedItems.has(nft.asset_id));
            const pixelPackCount = selectedNFTs.filter((nft) => NeftyBlendService.isPixelPack(nft)).length;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: pixelPackCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "bulk-btn unpack-btn", onClick: handleBulkUnpackPixelPacks, children: [
              " Unpack Pixelpacks (",
              pixelPackCount,
              ")"
            ] }) });
          })()
        ] })
      ] })
    ] }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading your NFTs..." })
    ] }),
    !loading && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inventory-page-stats", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        filteredCount,
        " NFTs found"
      ] }) }),
      inventory.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inventory-page-grid", children: currentItems.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          NFTCard,
          {
            nft,
            selectedNFTs: selectedItems,
            isSelected: selectedItems.has(nft.asset_id),
            settings,
            dropdownOpen,
            onNFTClick: handleNFTClick,
            onCollectionClick: handleCollectionClick,
            onSchemaClick: handleSchemaClick,
            onToggleSelection: toggleItemSelection,
            onDropdownToggle: (assetId) => setDropdownOpen(dropdownOpen === assetId ? null : assetId),
            onListingOpen: (nft2) => {
              setActionNFT(nft2);
              setListingModalOpen(true);
            },
            onTransferOpen: (nft2) => {
              setActionNFT(nft2);
              setTransferModalOpen(true);
            },
            onBurnOpen: (nft2) => {
              setActionNFT(nft2);
              setBurnModalOpen(true);
            },
            onAuctionOpen: (nft2) => {
              setActionNFT(nft2);
              setShowAuctionModal(true);
              setDropdownOpen(null);
            },
            onRecyclePixal: (nft2) => {
              handleRecyclePixal(nft2);
              setDropdownOpen(null);
            },
            onImageZoom: handleMediaZoom,
            onCraftingOpen: (nft2) => {
              handleCraftingOpen(nft2);
              setDropdownOpen(null);
            },
            onViewOffers: (nft2) => {
              handleViewOffers(nft2);
              setDropdownOpen(null);
            },
            onUnpackPixelPack: (nft2) => {
              handleUnpackPixelPack(nft2);
              setDropdownOpen(null);
            },
            onStakeOpen: (nft2) => {
              handleStakeOpen(nft2);
              setDropdownOpen(null);
            },
            onTokenizePixal: (nft2) => {
              handleTokenizePixal(nft2);
              setDropdownOpen(null);
            }
          },
          nft.asset_id
        )) }),
        totalPages > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-controls", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "pagination-btn",
              onClick: goToPrevPage,
              disabled: currentPage === 1,
              children: " Previous"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Page ",
              currentPage,
              " of ",
              totalPages
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "pagination-items", children: [
              "(",
              filteredCount,
              " total items)"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "pagination-btn",
              onClick: goToNextPage,
              disabled: currentPage === totalPages,
              children: "Next "
            }
          )
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-inventory", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", className: "empty-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M9 1v6m6-6v6" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No NFTs Found" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "You don't have any ",
          filter === "all" ? "Pixel Journey" : filter,
          " NFTs yet."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Visit the marketplace to start collecting!" }),
        (filter === "waxrock" || filter === "pixals" || filter === "ingredients") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-inventory-cta", style: { marginTop: "20px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: "cta-button",
            onClick: () => {
              const categoryMap = {
                "waxrock": "waxrocks",
                "pixals": "pixals",
                "ingredients": "ingredients"
              };
              const marketplaceCategory = categoryMap[filter];
              navigate(`/marketplace?category=${marketplaceCategory}`);
            },
            style: {
              background: "linear-gradient(45deg, #4ecdc4, #45b7d1)",
              border: "none",
              padding: "12px 24px",
              borderRadius: "25px",
              color: "white",
              fontSize: "16px",
              fontWeight: "600",
              cursor: "pointer",
              transition: "all 0.3s ease",
              boxShadow: "0 4px 15px rgba(78, 205, 196, 0.3)"
            },
            onMouseOver: (e) => {
              e.currentTarget.style.transform = "translateY(-2px)";
              e.currentTarget.style.boxShadow = "0 6px 20px rgba(78, 205, 196, 0.4)";
            },
            onMouseOut: (e) => {
              e.currentTarget.style.transform = "translateY(0)";
              e.currentTarget.style.boxShadow = "0 4px 15px rgba(78, 205, 196, 0.3)";
            },
            children: [
              " Browse ",
              filter === "waxrock" ? "WaxRock" : filter.charAt(0).toUpperCase() + filter.slice(1),
              " Marketplace"
            ]
          }
        ) })
      ] }),
      inventory.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-container", children: hasMore ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "load-more-btn",
            onClick: loadMoreItems,
            disabled: loadingMore || loadingAll,
            children: loadingMore ? "Loading..." : "Load More NFTs"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "load-more-btn load-all-btn",
            onClick: loadAllItems,
            disabled: loadingMore || loadingAll,
            style: { marginLeft: "10px", backgroundColor: "var(--success-color)" },
            children: loadingAll ? "Loading All..." : "Load All NFTs"
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          " Page ",
          currentPage,
          " - All NFTs loaded (",
          inventory.length,
          " total)"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "0.9em", color: "var(--text-secondary)", marginTop: "5px" }, children: "No more items to load" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NFTDetailsModal,
      {
        nft: actionNFT ? {
          sale_id: "",
          asset_id: actionNFT.asset_id,
          name: actionNFT.name,
          image: actionNFT.img,
          video: actionNFT.video,
          price: "Not for sale",
          seller: account || "",
          collection: actionNFT.collection.collection_name,
          schema: actionNFT.schema.schema_name,
          template_mint: actionNFT.mint_number,
          max_supply: actionNFT.template.max_supply,
          traits: actionNFT.data
        } : null,
        isOpen: isModalOpen,
        onClose: () => setIsModalOpen(false)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListingModal,
      {
        nft: actionNFT,
        isOpen: listingModalOpen,
        onClose: () => {
          setListingModalOpen(false);
          setActionNFT(null);
        },
        onSuccess: () => {
          loadInventory();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TransferModal,
      {
        nft: actionNFT,
        isOpen: transferModalOpen,
        onClose: () => {
          setTransferModalOpen(false);
          setActionNFT(null);
        },
        onSuccess: () => {
          loadInventory();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BurnModal,
      {
        nft: actionNFT,
        isOpen: burnModalOpen,
        onClose: () => {
          setBurnModalOpen(false);
          setActionNFT(null);
        },
        onSuccess: () => {
          loadInventory();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CraftingModal,
      {
        isOpen: craftingModalOpen,
        onClose: () => {
          setCraftingModalOpen(false);
          setCraftingIngredient(null);
        },
        ingredient: craftingIngredient
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ViewOffersModal,
      {
        nft: offersNFT,
        isOpen: viewOffersModalOpen,
        onClose: () => {
          setViewOffersModalOpen(false);
          setOffersNFT(null);
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TokenizeFeeModal,
      {
        nft: tokenizeNFT,
        isOpen: tokenizeModalOpen,
        onClose: () => {
          setTokenizeModalOpen(false);
          setTokenizeNFT(null);
        },
        onSuccess: () => {
          setTokenizeModalOpen(false);
          setTokenizeNFT(null);
          loadInventory();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BulkListingModal,
      {
        nfts: inventory.filter((nft) => selectedItems.has(nft.asset_id)),
        isOpen: showBulkListingModal,
        onClose: () => {
          setShowBulkListingModal(false);
        },
        onSuccess: () => {
          setSelectedItems(/* @__PURE__ */ new Set());
          setIsMultiSelectMode(false);
          loadInventory();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BulkTransferModal,
      {
        nfts: inventory.filter((nft) => selectedItems.has(nft.asset_id)),
        isOpen: showBulkTransferModal,
        onClose: () => {
          setShowBulkTransferModal(false);
        },
        onSuccess: () => {
          setSelectedItems(/* @__PURE__ */ new Set());
          setIsMultiSelectMode(false);
          loadInventory();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DistributeModal,
      {
        nfts: inventory.filter((nft) => selectedItems.has(nft.asset_id)),
        isOpen: showBulkDistributeModal,
        onClose: () => {
          setShowBulkDistributeModal(false);
        },
        onSuccess: () => {
          setSelectedItems(/* @__PURE__ */ new Set());
          setIsMultiSelectMode(false);
          loadInventory();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BulkBurnModal,
      {
        nfts: inventory.filter((nft) => selectedItems.has(nft.asset_id)),
        isOpen: showBulkBurnModal,
        onClose: () => {
          setShowBulkBurnModal(false);
        },
        onSuccess: () => {
          setSelectedItems(/* @__PURE__ */ new Set());
          setIsMultiSelectMode(false);
          loadInventory();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      UnpackModal,
      {
        selectedNFTs: inventory.filter((nft) => selectedItems.has(nft.asset_id)),
        isOpen: showUnpackModal,
        onClose: () => {
          setShowUnpackModal(false);
        },
        userAccount: account || "",
        walletSession: session,
        onUnpackComplete: () => {
          setSelectedItems(/* @__PURE__ */ new Set());
          setIsMultiSelectMode(false);
          loadInventory(1, false);
          showSuccess("Packs unpacked successfully!");
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BulkAuctionModal,
      {
        nfts: inventory.filter((nft) => selectedItems.has(nft.asset_id)),
        isOpen: showBulkAuctionModal,
        onClose: () => {
          setShowBulkAuctionModal(false);
        },
        onSuccess: () => {
          setSelectedItems(/* @__PURE__ */ new Set());
          setIsMultiSelectMode(false);
          loadInventory();
        }
      }
    ),
    actionNFT && /* @__PURE__ */ jsxRuntimeExports.jsx(
      BulkAuctionModal,
      {
        nfts: [actionNFT],
        isOpen: showAuctionModal,
        onClose: () => {
          setShowAuctionModal(false);
          setActionNFT(null);
        },
        onSuccess: () => {
          loadInventory();
        }
      }
    ),
    showImageZoom && zoomedImage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "image-zoom-modal", onClick: () => setShowImageZoom(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "zoom-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "zoom-modal-close",
          onClick: () => setShowImageZoom(false),
          "aria-label": "Close zoom modal",
          children: ""
        }
      ),
      zoomedImage.type === "video" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "video",
        {
          src: zoomedImage.url,
          className: "zoom-modal-video",
          controls: true,
          autoPlay: true,
          muted: true,
          loop: true,
          children: "Your browser does not support the video tag."
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: zoomedImage.url,
          alt: zoomedImage.name,
          className: "zoom-modal-image"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "zoom-modal-title", children: zoomedImage.name })
    ] }) })
  ] });
});
const TruncatedText = React.memo(({
  text,
  maxLength = 240,
  className = ""
}) => {
  const [isExpanded, setIsExpanded] = reactExports.useState(false);
  if (!text || text.length <= maxLength) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className, children: text });
  }
  const truncatedText = text.slice(0, maxLength).trim();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className, children: isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    text,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: "read-more-btn collapse-btn",
        onClick: (e) => {
          e.preventDefault();
          e.stopPropagation();
          setIsExpanded(false);
        },
        children: "read less"
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    truncatedText,
    truncatedText.endsWith(".") ? "" : "...",
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: "read-more-btn expand-btn",
        onClick: (e) => {
          e.preventDefault();
          e.stopPropagation();
          setIsExpanded(true);
        },
        children: "read more"
      }
    )
  ] }) });
});
TruncatedText.displayName = "TruncatedText";
class IPFSRateLimiter {
  constructor() {
    __publicField(this, "requestQueue", []);
    __publicField(this, "isProcessing", false);
    __publicField(this, "gatewayStats", /* @__PURE__ */ new Map());
    // Rate limiting configuration
    __publicField(this, "MIN_REQUEST_INTERVAL", 200);
    // 200ms between requests
    __publicField(this, "MAX_CONCURRENT_REQUESTS", 3);
    __publicField(this, "MAX_RETRIES", 3);
    __publicField(this, "GATEWAY_COOLDOWN", 3e4);
    // 30 seconds cooldown for blocked gateways
    __publicField(this, "REQUEST_TIMEOUT", 1e4);
    // 10 second timeout
    __publicField(this, "activeRequests", 0);
    __publicField(this, "lastRequestTime", 0);
  }
  /**
   * Add a request to the queue with rate limiting
   */
  async requestImage(url) {
    return new Promise((resolve, reject) => {
      const queuedRequest = {
        url,
        resolve,
        reject,
        retryCount: 0,
        timestamp: Date.now()
      };
      this.requestQueue.push(queuedRequest);
      this.processQueue();
    });
  }
  /**
   * Process the request queue with rate limiting
   */
  async processQueue() {
    if (this.isProcessing || this.requestQueue.length === 0) {
      return;
    }
    this.isProcessing = true;
    while (this.requestQueue.length > 0 && this.activeRequests < this.MAX_CONCURRENT_REQUESTS) {
      const request = this.requestQueue.shift();
      if (!request) break;
      if (Date.now() - request.timestamp > this.REQUEST_TIMEOUT) {
        request.reject(new Error("Request timeout in queue"));
        continue;
      }
      const timeSinceLastRequest = Date.now() - this.lastRequestTime;
      if (timeSinceLastRequest < this.MIN_REQUEST_INTERVAL) {
        const delay = this.MIN_REQUEST_INTERVAL - timeSinceLastRequest;
        await this.delay(delay);
      }
      this.lastRequestTime = Date.now();
      this.activeRequests++;
      this.processRequest(request).finally(() => {
        this.activeRequests--;
        setTimeout(() => this.processQueue(), 0);
      });
    }
    this.isProcessing = false;
  }
  /**
   * Process individual request with gateway selection and fallback
   */
  async processRequest(request) {
    try {
      const gateway = this.selectBestGateway(request.url);
      if (!gateway) {
        throw new Error("No available gateways");
      }
      const result = await this.makeRequest(request.url, gateway);
      this.updateGatewayStats(gateway, true);
      request.resolve(result);
    } catch (error) {
      const gateway = this.extractGateway(request.url);
      if (gateway) {
        this.updateGatewayStats(gateway, false);
      }
      if (request.retryCount < this.MAX_RETRIES) {
        request.retryCount++;
        logger.warn(`Retrying IPFS request (${request.retryCount}/${this.MAX_RETRIES})`, "IPFSRateLimiter", {
          url: request.url,
          error: error instanceof Error ? error.message : "Unknown error"
        });
        await this.delay(1e3 * request.retryCount);
        this.requestQueue.unshift(request);
      } else {
        const finalError = error instanceof Error ? error : new Error(String(error));
        logger.error("IPFS request failed after all retries", "IPFSRateLimiter", finalError, {
          url: request.url
        });
        request.reject(finalError);
      }
    }
  }
  /**
   * Make the actual HTTP request with timeout
   */
  async makeRequest(originalUrl, gateway) {
    const hash = this.extractIPFSHash(originalUrl);
    if (!hash) {
      throw new Error("Invalid IPFS URL");
    }
    const url = `${gateway}${hash}`;
    return new Promise((resolve, reject) => {
      const img = new Image();
      const timeout = setTimeout(() => {
        img.onload = null;
        img.onerror = null;
        reject(new Error("Request timeout"));
      }, this.REQUEST_TIMEOUT);
      img.onload = () => {
        clearTimeout(timeout);
        resolve(url);
      };
      img.onerror = (error) => {
        clearTimeout(timeout);
        reject(new Error(`Failed to load image: ${error}`));
      };
      img.src = url;
    });
  }
  /**
   * Select the best available gateway based on stats
   */
  selectBestGateway(_url) {
    const gateways = [
      "https://ipfs.io/ipfs/",
      "https://gateway.pinata.cloud/ipfs/",
      "https://dweb.link/ipfs/",
      "https://cf-ipfs.com/ipfs/"
    ];
    const now = Date.now();
    const availableGateways = gateways.filter((gateway) => {
      const stats = this.gatewayStats.get(gateway);
      if (!stats) return true;
      if (stats.isBlocked && now < stats.blockUntil) {
        return false;
      }
      if (stats.isBlocked && now >= stats.blockUntil) {
        stats.isBlocked = false;
        stats.errorCount = 0;
      }
      return true;
    });
    if (availableGateways.length === 0) {
      return null;
    }
    availableGateways.sort((a, b) => {
      const statsA = this.gatewayStats.get(a);
      const statsB = this.gatewayStats.get(b);
      const errorRateA = statsA ? statsA.errorCount / Math.max(statsA.requestCount, 1) : 0;
      const errorRateB = statsB ? statsB.errorCount / Math.max(statsB.requestCount, 1) : 0;
      return errorRateA - errorRateB;
    });
    return availableGateways[0];
  }
  /**
   * Update gateway statistics
   */
  updateGatewayStats(gateway, success) {
    let stats = this.gatewayStats.get(gateway);
    if (!stats) {
      stats = {
        lastRequest: 0,
        requestCount: 0,
        errorCount: 0,
        isBlocked: false,
        blockUntil: 0
      };
      this.gatewayStats.set(gateway, stats);
    }
    stats.lastRequest = Date.now();
    stats.requestCount++;
    if (!success) {
      stats.errorCount++;
      const errorRate = stats.errorCount / stats.requestCount;
      if (errorRate > 0.5 && stats.requestCount >= 5) {
        stats.isBlocked = true;
        stats.blockUntil = Date.now() + this.GATEWAY_COOLDOWN;
        logger.warn(`Blocking gateway due to high error rate`, "IPFSRateLimiter", {
          gateway,
          errorRate,
          requestCount: stats.requestCount,
          errorCount: stats.errorCount
        });
      }
    }
  }
  /**
   * Extract IPFS hash from URL
   */
  extractIPFSHash(url) {
    const match = url.match(/\/ipfs\/([a-zA-Z0-9]+)/);
    return match ? match[1] : null;
  }
  /**
   * Extract gateway from URL
   */
  extractGateway(url) {
    const match = url.match(/(https?:\/\/[^\/]+\/ipfs\/)/);
    return match ? match[1] : null;
  }
  /**
   * Utility delay function
   */
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Get queue status for debugging
   */
  getStatus() {
    return {
      queueLength: this.requestQueue.length,
      activeRequests: this.activeRequests,
      gatewayStats: Object.fromEntries(this.gatewayStats)
    };
  }
  /**
   * Clear all queued requests and reset stats
   */
  reset() {
    this.requestQueue.forEach((request) => {
      request.reject(new Error("Rate limiter reset"));
    });
    this.requestQueue = [];
    this.gatewayStats.clear();
    this.activeRequests = 0;
    this.isProcessing = false;
  }
}
const ipfsRateLimiter = new IPFSRateLimiter();
const loadIPFSImageWithRateLimit = (url) => {
  return ipfsRateLimiter.requestImage(url);
};
class ImageService {
  constructor() {
    __publicField(this, "imageCache", /* @__PURE__ */ new Map());
    __publicField(this, "loadingPromises", /* @__PURE__ */ new Map());
    __publicField(this, "MAX_CACHE_SIZE", 500);
  }
  /**
   * Generate SVG fallback image
   */
  generateFallbackSVG(config = {}) {
    const {
      width = 150,
      height = 150,
      backgroundColor = "#f3f4f6",
      textColor = "#6b7280",
      text,
      type = "generic"
    } = config;
    const displayText = text || this.getDefaultText(type);
    const fontSize = Math.min(width, height) * 0.15;
    const svg = `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
        <rect width="100%" height="100%" fill="${backgroundColor}"/>
        <g transform="translate(${width / 2}, ${height / 2})">
          ${this.getIconForType(type, Math.min(width, height) * 0.3, textColor)}
          <text 
            x="0" 
            y="${fontSize * 1.5}" 
            font-family="system-ui, -apple-system, sans-serif" 
            font-size="${fontSize}" 
            font-weight="500" 
            fill="${textColor}" 
            text-anchor="middle" 
            dominant-baseline="middle"
          >
            ${displayText}
          </text>
        </g>
      </svg>
    `;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
  /**
   * Get default text for image type
   */
  getDefaultText(type) {
    switch (type) {
      case "nft":
        return "NFT";
      case "collection":
        return "Collection";
      case "avatar":
        return "Avatar";
      case "token":
        return "Token";
      default:
        return "Image";
    }
  }
  /**
   * Get SVG icon for image type
   */
  getIconForType(type, size, color) {
    const iconSize = size;
    const strokeWidth = Math.max(1, iconSize * 0.08);
    switch (type) {
      case "nft":
        return `
          <rect 
            x="${-iconSize / 2}" 
            y="${-iconSize / 2}" 
            width="${iconSize}" 
            height="${iconSize}" 
            rx="${iconSize * 0.1}" 
            fill="none" 
            stroke="${color}" 
            stroke-width="${strokeWidth}"
          />
          <circle 
            cx="0" 
            cy="${-iconSize * 0.15}" 
            r="${iconSize * 0.15}" 
            fill="${color}"
          />
        `;
      case "collection":
        return `
          <rect 
            x="${-iconSize / 2}" 
            y="${-iconSize / 2}" 
            width="${iconSize * 0.7}" 
            height="${iconSize * 0.7}" 
            rx="${iconSize * 0.05}" 
            fill="none" 
            stroke="${color}" 
            stroke-width="${strokeWidth}"
          />
          <rect 
            x="${-iconSize / 2 + iconSize * 0.15}" 
            y="${-iconSize / 2 + iconSize * 0.15}" 
            width="${iconSize * 0.7}" 
            height="${iconSize * 0.7}" 
            rx="${iconSize * 0.05}" 
            fill="none" 
            stroke="${color}" 
            stroke-width="${strokeWidth}"
          />
        `;
      case "avatar":
        return `
          <circle 
            cx="0" 
            cy="${-iconSize * 0.1}" 
            r="${iconSize * 0.25}" 
            fill="none" 
            stroke="${color}" 
            stroke-width="${strokeWidth}"
          />
          <path 
            d="M ${-iconSize * 0.35} ${iconSize * 0.3} Q 0 ${iconSize * 0.1} ${iconSize * 0.35} ${iconSize * 0.3}" 
            fill="none" 
            stroke="${color}" 
            stroke-width="${strokeWidth}"
          />
        `;
      case "token":
        return `
          <circle 
            cx="0" 
            cy="0" 
            r="${iconSize * 0.4}" 
            fill="none" 
            stroke="${color}" 
            stroke-width="${strokeWidth}"
          />
          <text 
            x="0" 
            y="${iconSize * 0.1}" 
            font-family="system-ui, -apple-system, sans-serif" 
            font-size="${iconSize * 0.3}" 
            font-weight="bold" 
            fill="${color}" 
            text-anchor="middle" 
            dominant-baseline="middle"
          >
            $
          </text>
        `;
      default:
        return `
          <rect 
            x="${-iconSize / 2}" 
            y="${-iconSize / 2}" 
            width="${iconSize}" 
            height="${iconSize}" 
            rx="${iconSize * 0.1}" 
            fill="none" 
            stroke="${color}" 
            stroke-width="${strokeWidth}"
          />
          <path 
            d="M ${-iconSize * 0.2} ${-iconSize * 0.1} L ${iconSize * 0.2} ${-iconSize * 0.1} L 0 ${iconSize * 0.2} Z" 
            fill="${color}"
          />
        `;
    }
  }
  /**
   * Load image with fallback support
   */
  async loadImage(src, config = {}) {
    if (!src) {
      return {
        success: false,
        src: this.generateFallbackSVG(config),
        fallbackUsed: true
      };
    }
    const cached = this.imageCache.get(src);
    if (cached) {
      return {
        success: true,
        src: cached,
        fallbackUsed: false
      };
    }
    const existingPromise = this.loadingPromises.get(src);
    if (existingPromise) {
      return existingPromise;
    }
    const loadingPromise = this.performImageLoad(src, config);
    this.loadingPromises.set(src, loadingPromise);
    try {
      const result = await loadingPromise;
      return result;
    } finally {
      this.loadingPromises.delete(src);
    }
  }
  /**
   * Perform actual image loading
   */
  async performImageLoad(src, config) {
    if (this.isIPFSUrl(src)) {
      try {
        const rateLimitedUrl = await loadIPFSImageWithRateLimit(src);
        this.addToCache(src, rateLimitedUrl);
        return {
          success: true,
          src: rateLimitedUrl,
          fallbackUsed: false
        };
      } catch (error) {
        logger.warn(`IPFS rate-limited load failed: ${src}`, "ImageService", { error });
        return {
          success: false,
          src: this.generateFallbackSVG(config),
          fallbackUsed: true,
          error: error instanceof Error ? error : new Error("IPFS load failed")
        };
      }
    }
    return new Promise((resolve) => {
      const img = new Image();
      const timeout = setTimeout(() => {
        img.onload = null;
        img.onerror = null;
        resolve({
          success: false,
          src: this.generateFallbackSVG(config),
          fallbackUsed: true,
          error: new Error("Image load timeout")
        });
      }, 1e4);
      img.onload = () => {
        clearTimeout(timeout);
        this.addToCache(src, src);
        resolve({
          success: true,
          src,
          fallbackUsed: false
        });
      };
      img.onerror = (error) => {
        clearTimeout(timeout);
        const fallbackSrc = this.generateFallbackSVG(config);
        logger.warn(`Failed to load image: ${src}`, "ImageService", { error });
        resolve({
          success: false,
          src: fallbackSrc,
          fallbackUsed: true,
          error: error instanceof Error ? error : new Error("Image load failed")
        });
      };
      img.src = src;
    });
  }
  /**
   * Add image to cache
   */
  addToCache(key, value) {
    if (this.imageCache.size >= this.MAX_CACHE_SIZE) {
      const firstKey = this.imageCache.keys().next().value;
      if (firstKey) {
        this.imageCache.delete(firstKey);
      }
    }
    this.imageCache.set(key, value);
  }
  /**
   * Preload multiple images
   */
  async preloadImages(urls, config = {}) {
    const promises = urls.map((url) => this.loadImage(url, config));
    return Promise.all(promises);
  }
  /**
   * Get optimized image URL with fallback
   */
  getOptimizedImageUrl(src, config = {}) {
    if (!src) {
      return this.generateFallbackSVG(config);
    }
    if (src.startsWith("data:") || src.startsWith("blob:")) {
      return src;
    }
    if (src.includes("ipfs.io") || src.includes("ipfs://")) {
      return this.optimizeIPFSUrl(src);
    }
    return src;
  }
  /**
   * Check if URL is an IPFS URL
   */
  isIPFSUrl(src) {
    return src.includes("/ipfs/") || src.startsWith("ipfs://") || src.includes("gateway.pinata.cloud");
  }
  /**
   * Optimize IPFS URLs for better loading
   */
  optimizeIPFSUrl(src) {
    if (this.isIPFSUrl(src)) {
      return src;
    }
    return src;
  }
  /**
   * Clear image cache
   */
  clearCache() {
    this.imageCache.clear();
    this.loadingPromises.clear();
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      size: this.imageCache.size,
      maxSize: this.MAX_CACHE_SIZE,
      hitRate: 0
      // Would need to track hits/misses for accurate calculation
    };
  }
}
const imageService = new ImageService();
const FallbackImage = ({
  src,
  alt,
  className = "",
  style = {},
  width,
  height,
  type = "generic",
  fallbackText,
  backgroundColor,
  textColor,
  onLoad,
  onError,
  loading = "lazy",
  placeholder = true
}) => {
  const [imageSrc, setImageSrc] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const [loadResult, setLoadResult] = reactExports.useState(null);
  const imgRef = reactExports.useRef(null);
  const loadingRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (loadingRef.current) return;
    loadingRef.current = true;
    const loadImage = async () => {
      setIsLoading(true);
      const config = {
        width,
        height,
        type,
        text: fallbackText,
        backgroundColor,
        textColor
      };
      try {
        const result = await imageService.loadImage(src || "", config);
        setImageSrc(result.src);
        setLoadResult(result);
        if (onLoad) {
          onLoad(result);
        }
        if (!result.success && result.error && onError) {
          onError(result.error);
        }
      } catch (error) {
        const fallbackSrc = imageService.generateFallbackSVG(config);
        setImageSrc(fallbackSrc);
        setLoadResult({
          success: false,
          src: fallbackSrc,
          fallbackUsed: true,
          error
        });
        if (onError) {
          onError(error);
        }
      } finally {
        setIsLoading(false);
        loadingRef.current = false;
      }
    };
    loadImage();
  }, [src, width, height, type, fallbackText, backgroundColor, textColor, onLoad, onError]);
  const handleImageLoad = () => {
    setIsLoading(false);
  };
  const handleImageError = () => {
    if (loadResult && !loadResult.fallbackUsed) {
      const config = {
        width,
        height,
        type,
        text: fallbackText,
        backgroundColor,
        textColor
      };
      const fallbackSrc = imageService.generateFallbackSVG(config);
      setImageSrc(fallbackSrc);
      setLoadResult({
        success: false,
        src: fallbackSrc,
        fallbackUsed: true
      });
    }
    setIsLoading(false);
  };
  const combinedStyle = {
    ...style,
    ...width && { width },
    ...height && { height }
  };
  const combinedClassName = `fallback-image ${className} ${isLoading ? "loading" : ""} ${loadResult?.fallbackUsed ? "fallback-used" : ""}`.trim();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fallback-image-container", style: { position: "relative", display: "inline-block" }, children: [
    isLoading && placeholder && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "image-placeholder",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: width || "100%",
          height: height || "100%",
          backgroundColor: backgroundColor || "#f3f4f6",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          borderRadius: "4px",
          zIndex: 1
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner", style: {
          width: "20px",
          height: "20px",
          border: "2px solid #e5e7eb",
          borderTop: "2px solid #3b82f6",
          borderRadius: "50%",
          animation: "spin 1s linear infinite"
        } })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        ref: imgRef,
        src: imageSrc || "",
        alt,
        className: combinedClassName,
        style: {
          ...combinedStyle,
          opacity: isLoading ? 0 : 1,
          transition: "opacity 0.3s ease"
        },
        loading,
        onLoad: handleImageLoad,
        onError: handleImageError
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        .fallback-image {
          display: block;
          max-width: 100%;
          height: auto;
        }
        
        .fallback-image.loading {
          opacity: 0;
        }
        
        .fallback-image.fallback-used {
          filter: grayscale(0.1);
        }
        
        .image-placeholder {
          background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
          background-size: 200% 100%;
          animation: shimmer 1.5s infinite;
        }
        
        @keyframes shimmer {
          0% { background-position: -200% 0; }
          100% { background-position: 200% 0; }
        }
      ` })
  ] });
};
const NFTImage = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackImage, { ...props, type: "nft" });
const CollectionImage = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackImage, { ...props, type: "collection" });
const TokenImage = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackImage, { ...props, type: "token" });
const TIER_OPTIONS = [
  {
    id: "bronze",
    name: "Bronze",
    cost: 5e6,
    costFormatted: "5M PXJ",
    icon: "",
    description: "Perfect for new collections getting started",
    benefits: [
      "Basic marketplace listing",
      "Collection verification badge",
      "Community Discord access",
      "Monthly featured spot rotation"
    ]
  },
  {
    id: "silver",
    name: "Silver",
    cost: 15e6,
    costFormatted: "15M PXJ",
    icon: "",
    description: "Enhanced visibility and analytics access",
    benefits: [
      "All Bronze benefits",
      "Priority marketplace placement",
      "Weekly newsletter mentions",
      "Custom collection banner",
      "Analytics dashboard access"
    ]
  },
  {
    id: "gold",
    name: "Gold",
    cost: 3e7,
    costFormatted: "30M PXJ",
    icon: "",
    description: "Premium promotion and exclusive events",
    benefits: [
      "All Silver benefits",
      "Homepage featured carousel",
      "Social media promotion",
      "Exclusive events participation",
      "Direct community manager contact"
    ]
  },
  {
    id: "platinum",
    name: "Platinum",
    cost: 5e7,
    costFormatted: "50M PXJ",
    icon: "",
    description: "Ultimate tier with maximum benefits",
    benefits: [
      "All Gold benefits",
      "Permanent homepage presence",
      "Dedicated marketing campaigns",
      "WaxRock Council consideration",
      "Platform governance participation",
      "White-label marketplace options"
    ]
  }
];
const CollectionTierModal = ({ isOpen, onClose }) => {
  const [selectedTier, setSelectedTier] = reactExports.useState("");
  const [collectionName, setCollectionName] = reactExports.useState("");
  const [isProcessing, setIsProcessing] = reactExports.useState(false);
  const [userBalance, setUserBalance] = reactExports.useState(null);
  const [balanceLoading, setBalanceLoading] = reactExports.useState(false);
  const { session, isConnected } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  React.useEffect(() => {
    if (isOpen && isConnected && session) {
      fetchUserBalance();
    }
  }, [isOpen, isConnected, session]);
  const fetchUserBalance = async () => {
    if (!session) return;
    setBalanceLoading(true);
    try {
      const pxjBalance = await apiService.getWaxCurrencyBalance(
        WharfKitService.safeGetActor(session),
        "token.pxj",
        "PXJ"
      );
      const balance = pxjBalance.length > 0 ? parseFloat(pxjBalance[0].balance.split(" ")[0]) : 0;
      setUserBalance(balance);
    } catch (error) {
      log.error("Failed to fetch PXJ balance", "CollectionTierModal", error);
      setUserBalance(0);
    } finally {
      setBalanceLoading(false);
    }
  };
  const handleTierPayment = async () => {
    if (!selectedTier || !collectionName.trim()) {
      showError("Please select a tier and enter a collection name");
      return;
    }
    if (!isConnected || !session) {
      showError("Please connect your wallet to proceed with payment");
      return;
    }
    const tier = TIER_OPTIONS.find((t) => t.id === selectedTier);
    if (!tier) {
      showError("Invalid tier selected");
      return;
    }
    if (userBalance !== null && userBalance < tier.cost) {
      showError(`Insufficient PXJ balance. You need at least ${tier.costFormatted} to upgrade to ${tier.name} tier.`);
      return;
    }
    setIsProcessing(true);
    try {
      const memo = `upgrade-collection:${collectionName.toUpperCase()}:${tier.id.toUpperCase()}`;
      const transferAction = {
        account: "token.pxj",
        name: "transfer",
        authorization: [{
          actor: WharfKitService.safeGetActor(session),
          permission: "active"
        }],
        data: {
          from: WharfKitService.safeGetActor(session),
          to: "market.pxj",
          quantity: `${tier.cost.toFixed(8)} PXJ`,
          memo
        }
      };
      await wharfKitService.transact([transferAction]);
      showSuccess(`Successfully upgraded ${collectionName} to ${tier.name} tier! Your upgrade will be processed by our team.`);
      onClose();
      setSelectedTier("");
      setCollectionName("");
    } catch (error) {
      log.error("Tier upgrade payment failed", "CollectionTierModal", error instanceof Error ? error : new Error(String(error)));
      showError(`Payment failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    } finally {
      setIsProcessing(false);
    }
  };
  const selectedTierData = TIER_OPTIONS.find((t) => t.id === selectedTier);
  const canAfford = (tier) => userBalance !== null && userBalance >= tier.cost;
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-backdrop", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content collection-tier-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "modal-title", children: "Upgrade Collection Tier" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "balance-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-label", children: "Your PXJ Balance:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "collection-balance-amount", children: balanceLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "loading-text", children: "Loading..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: userBalance !== null && userBalance > 0 ? "balance-positive" : "balance-zero", children: userBalance !== null ? `${userBalance.toLocaleString()} PXJ` : "Unable to load" }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "collectionName", children: "Collection Name:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            id: "collectionName",
            value: collectionName,
            onChange: (e) => setCollectionName(e.target.value),
            placeholder: "Enter your collection name",
            className: "collection-input",
            disabled: isProcessing
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-selection", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Select Tier:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-grid", children: TIER_OPTIONS.map((tier) => {
          const affordable = canAfford(tier);
          const isSelected = selectedTier === tier.id;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `tier-card ${isSelected ? "selected" : ""} ${!affordable ? "unaffordable" : ""}`,
              onClick: () => !isProcessing && setSelectedTier(tier.id),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-header", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-icon", children: tier.icon }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-info", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "tier-name", children: tier.name }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-cost", children: tier.costFormatted })
                  ] }),
                  !affordable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "insufficient-badge", children: "Insufficient Balance" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "tier-description", children: tier.description }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-benefits", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Benefits:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: tier.benefits.map((benefit, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: benefit }, index)) })
                ] })
              ]
            },
            tier.id
          );
        }) })
      ] }),
      selectedTierData && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-tier-summary", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Upgrade Summary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Collection:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: collectionName || "Not specified" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Tier:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              selectedTierData.icon,
              " ",
              selectedTierData.name
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Cost:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: selectedTierData.costFormatted })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Remaining Balance:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: userBalance !== null ? `${(userBalance - selectedTierData.cost).toLocaleString()} PXJ` : "Unknown" })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-secondary",
          onClick: onClose,
          disabled: isProcessing,
          children: "Cancel"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: handleTierPayment,
          disabled: isProcessing || !selectedTier || !collectionName.trim() || !isConnected || selectedTierData && userBalance !== null && userBalance < selectedTierData.cost,
          children: isProcessing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "loading-spinner" }),
            "Processing..."
          ] }) : `Upgrade to ${selectedTierData?.name || "Selected Tier"}`
        }
      )
    ] })
  ] }) });
};
const Collections = () => {
  const [collections, setCollections] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [showTierModal, setShowTierModal] = reactExports.useState(false);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [sortBy, setSortBy] = reactExports.useState("name");
  const [displayedCount, setDisplayedCount] = reactExports.useState(12);
  const [loadingMore, setLoadingMore] = reactExports.useState(false);
  const [showTierPerks, setShowTierPerks] = reactExports.useState(false);
  const [totalFetched, setTotalFetched] = reactExports.useState(0);
  const [pxApprovedProjects, setPxApprovedProjects] = reactExports.useState([
    {
      name: "Pixel Journey",
      collection: "pixeljourney",
      image: null,
      description: "The original Pixel Journey collection",
      tier: "platinum",
      verified: true
    },
    {
      name: "Fried Factory",
      collection: "friedfactory",
      image: null,
      description: "3D NFT collection by @Friedfactory the 3D legend (and artist of our Journey Ingredients too)!",
      tier: "partner",
      verified: true
    },
    {
      name: "Crypto Muffins",
      collection: "crptomuffins",
      image: null,
      description: "Delicious crypto-themed NFT collection by AKU!",
      tier: "gold",
      verified: true
    },
    {
      name: "Aku Fish Heads",
      collection: "akufishheads",
      image: null,
      description: "Unique AKU-licious NFT collection",
      tier: "silver",
      verified: true
    },
    {
      name: "Pantheon",
      collection: "pantheon",
      image: null,
      description: "Mythological NFT collection",
      tier: "bronze",
      verified: true
    },
    {
      name: "Pocket People",
      collection: "pocketsizedp",
      image: null,
      description: "Pocket Sized PFPs by our first Partner, Kettleman!",
      tier: "partner",
      verified: true
    },
    {
      name: "NIMAs Odyssey",
      collection: "nimasodyssey",
      image: null,
      description: "NIMAs Odyssey, a Discord RPG Driven NFT Mining Game",
      tier: "partner",
      verified: true
    }
  ]);
  const fetchPxApprovedImages = reactExports.useCallback(async () => {
    try {
      setPxApprovedProjects((currentProjects) => {
        const projectsNeedingImages = currentProjects.filter((project) => !project.image);
        if (projectsNeedingImages.length === 0) {
          return currentProjects;
        }
        Promise.all(
          projectsNeedingImages.map(async (project) => {
            try {
              const collectionData = await apiService.getCollectionDetails(project.collection);
              return {
                ...project,
                image: collectionData?.img || null
              };
            } catch (error2) {
              log.warn(`Failed to fetch image for ${project.collection}`, "Collections", error2);
              return project;
            }
          })
        ).then((updatedProjectsWithImages) => {
          setPxApprovedProjects(
            (prevProjects) => prevProjects.map((project) => {
              const updated = updatedProjectsWithImages.find((up) => up.collection === project.collection);
              return updated || project;
            })
          );
        });
        return currentProjects;
      });
    } catch (error2) {
      log.error("Failed to fetch PxApproved project images", "Collections", error2);
    }
  }, []);
  const fetchMarketDataForCollections = async (collections2) => {
    const updatedCollections = [...collections2];
    const batchSize = 5;
    for (let i = 0; i < collections2.length; i += batchSize) {
      const batch = collections2.slice(i, i + batchSize);
      const batchResults = await Promise.allSettled(batch.map(async (collection, batchIndex) => {
        const collectionIndex = i + batchIndex;
        try {
          const [floorPriceData, marketStats] = await Promise.all([
            apiService.getCollectionFloorPrice(collection.collection_name),
            apiService.getCollectionMarketStats({ collection_name: collection.collection_name })
          ]);
          return {
            index: collectionIndex,
            data: {
              ...updatedCollections[collectionIndex],
              floor_price: floorPriceData.floorPrice,
              volume: marketStats.data?.volume,
              market_cap: marketStats.data?.volume ? (floorPriceData.floorPrice * parseFloat(marketStats.data.volume)).toFixed(2) : void 0,
              assets: marketStats.data?.sales,
              loading_market_data: false
            }
          };
        } catch (error2) {
          ErrorMessageService.logError("Collections.fetchMarketDataForCollections", error2, {
            collection_name: collection.collection_name
          });
          return {
            index: collectionIndex,
            data: {
              ...updatedCollections[collectionIndex],
              loading_market_data: false
            }
          };
        }
      }));
      batchResults.forEach((result) => {
        if (result.status === "fulfilled") {
          updatedCollections[result.value.index] = result.value.data;
        }
      });
      if (i + batchSize < collections2.length) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
    setCollections([...updatedCollections]);
  };
  const fetchCollections = async (limit = 50) => {
    setLoading(true);
    setError(null);
    try {
      const data = await apiService.getCollections({ limit, whitelistOnly: true });
      const mappedCollections = (data || []).map((col) => ({
        collection_name: col.collection_name,
        name: col.name,
        img: col.img,
        author: col.author,
        created_at_time: col.created_at_time,
        created_at_block: col.created_at_block,
        loading_market_data: true
      }));
      setCollections(mappedCollections);
      setTotalFetched(data?.length || 0);
      fetchMarketDataForCollections(mappedCollections);
    } catch (error2) {
      const errorObj = error2 instanceof Error ? error2 : new Error("Failed to fetch collections");
      setError(errorObj);
      ErrorMessageService.logError("Collections.fetchCollections", errorObj, { limit });
    } finally {
      setLoading(false);
    }
  };
  reactExports.useEffect(() => {
    fetchCollections();
    fetchPxApprovedImages();
  }, [fetchPxApprovedImages]);
  const filteredCollections = collections.filter(
    (collection) => collection.name.toLowerCase().includes(searchTerm.toLowerCase()) || collection.collection_name.toLowerCase().includes(searchTerm.toLowerCase()) || collection.author.toLowerCase().includes(searchTerm.toLowerCase())
  ).sort((a, b) => {
    switch (sortBy) {
      case "name":
        return a.name.localeCompare(b.name);
      case "author":
        return a.author.localeCompare(b.author);
      case "created":
        return new Date(b.created_at_time).getTime() - new Date(a.created_at_time).getTime();
      default:
        return 0;
    }
  });
  const filteredPxApproved = pxApprovedProjects.filter(
    (project) => project.name.toLowerCase().includes(searchTerm.toLowerCase()) || project.collection.toLowerCase().includes(searchTerm.toLowerCase())
  );
  const displayedCollections = filteredCollections.slice(0, displayedCount);
  const hasMoreCollections = filteredCollections.length > displayedCount || totalFetched >= 50 && displayedCount >= filteredCollections.length;
  const loadMoreCollections = async () => {
    setLoadingMore(true);
    try {
      if (displayedCount < collections.length) {
        setDisplayedCount((prev) => prev + 12);
      } else {
        const newLimit = totalFetched + 50;
        const data = await apiService.getCollections({ limit: newLimit, whitelistOnly: true });
        if (data && data.length > totalFetched) {
          const mappedCollections = data.map((col) => ({
            collection_name: col.collection_name,
            name: col.name,
            img: col.img,
            author: col.author,
            created_at_time: col.created_at_time,
            created_at_block: col.created_at_block,
            loading_market_data: true
          }));
          setCollections(mappedCollections);
          setTotalFetched(data.length);
          setDisplayedCount((prev) => prev + 12);
          const newCollections = mappedCollections.slice(totalFetched);
          if (newCollections.length > 0) {
            fetchMarketDataForCollections(newCollections);
          }
        }
      }
    } catch (error2) {
      const errorObj = error2 instanceof Error ? error2 : new Error("Failed to load more collections");
      ErrorMessageService.logError("Collections.loadMoreCollections", errorObj, {
        displayedCount,
        totalFetched
      });
    } finally {
      setLoadingMore(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collections-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "perk-tiers-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collections-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Collections" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "collections-subtitle", children: "Discover amazing NFT collections on the WAX blockchain" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "PxApproved Collections" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Only PxApproved collections are listed on our marketplace by default. This ensures quality and authenticity for our community." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "a",
            {
              href: "https://discord.gg/pixeljourney",
              target: "_blank",
              rel: "noopener noreferrer",
              className: "discord-link",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "discord-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z" }) }),
                "Join Discord for More Info"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "payment-button",
              onClick: () => setShowTierModal(true),
              children: "Upgrade Collection Tier"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "toggle-tiers-button",
              onClick: () => setShowTierPerks(!showTierPerks),
              children: [
                showTierPerks ? "Hide Tier Details" : "Show Tier Details",
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    className: `toggle-icon ${showTierPerks ? "rotated" : ""}`,
                    viewBox: "0 0 24 24",
                    fill: "currentColor",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" })
                  }
                )
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "tiers-description", children: "Elevate your collection's status on PxMarket with our tier system. Each tier unlocks exclusive benefits and promotional opportunities." }),
      showTierPerks && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tiers-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tiers-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "PxApproved Perk Tiers" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tiers-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card tier-bronze", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Bronze" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-cost", children: "5M PXJ" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-benefits", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Benefits:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Basic marketplace listing" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Collection verification badge" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Community Discord access" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Monthly featured spot rotation" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card tier-silver", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Silver" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-cost", children: "15M PXJ" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-benefits", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Benefits:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "All Bronze benefits" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Priority marketplace placement" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Weekly newsletter mentions" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Custom collection banner" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Analytics dashboard access" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card tier-gold", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Gold" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-cost", children: "30M PXJ" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-benefits", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Benefits:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "All Silver benefits" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Homepage featured carousel" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Social media promotion" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Exclusive events participation" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Direct community manager contact" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card tier-partner", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Partner" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-cost", children: "Special Agreement" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-benefits", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Benefits:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "All Gold benefits" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Co-marketing opportunities" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Revenue sharing programs" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Joint event hosting" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Custom integration support" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card tier-platinum", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Platinum" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-cost", children: "50M PXJ" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-benefits", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Benefits:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "All Partner benefits" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Permanent homepage presence" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Dedicated marketing campaigns" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "WaxRock Council consideration" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Platform governance participation" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "White-label marketplace options" })
              ] })
            ] })
          ] })
        ] })
      ] }),
      showTierPerks && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "council-note", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "council-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "council-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "WaxRock Council Authority" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "The WaxRock Council reserves the right to grant special tier status to exceptional collections through community proposals and voting. Collections may also lobby for tier upgrades through formal governance processes." })
        ] })
      ] }) }),
      showTierPerks && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "apply-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Ready to Upgrade Your Collection?" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Contact our team to discuss tier upgrades and promotional opportunities." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "apply-buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://discord.gg/pixeljourney", target: "_blank", rel: "noopener noreferrer", className: "apply-btn discord-btn", children: "Apply via Discord" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "apply-btn payment-btn", onClick: () => setShowTierModal(true), children: "Instant Tier Upgrade" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollectionTierModal,
      {
        isOpen: showTierModal,
        onClose: () => setShowTierModal(false)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-filter-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-controls", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-input-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "search-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Search collections, authors, or names...",
              value: searchTerm,
              onChange: (e) => setSearchTerm(e.target.value),
              className: "search-input"
            }
          ),
          searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setSearchTerm(""),
              className: "clear-search",
              "aria-label": "Clear search",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }) })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sort-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "sortBy", children: "Sort by:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              id: "sortBy",
              value: sortBy,
              onChange: (e) => setSortBy(e.target.value),
              className: "sort-select",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name", children: "Name" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "author", children: "Author" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "created", children: "Created Date" })
              ]
            }
          )
        ] })
      ] }),
      searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-results-info", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "Found ",
        filteredCollections.length + filteredPxApproved.length,
        ' results for "',
        searchTerm,
        '"'
      ] }) })
    ] }),
    (!searchTerm || filteredPxApproved.length > 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxapproved-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
        "PxApproved ",
        searchTerm && `(${filteredPxApproved.length})`
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "approved-projects-grid", children: filteredPxApproved.map((project, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/collections/${project.collection}`, className: "project-card-link", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `project-card project-card-${project.tier}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "project-tier-badge", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `tier-label tier-${project.tier}`, children: project.tier.toUpperCase() }),
          project.verified && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "verified-badge", children: "" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: project.image && typeof project.image === "string" ? project.image.startsWith("http") ? project.image : `https://ipfs.io/ipfs/${project.image}` : "/img/placeholder-collection.svg",
            alt: project.name,
            className: "project-image",
            onError: (e) => {
              e.currentTarget.src = "/img/placeholder-collection.svg";
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "project-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: project.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "project-collection", children: project.collection }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TruncatedText,
            {
              text: project.description,
              maxLength: 240,
              className: "project-description"
            }
          )
        ] })
      ] }) }, index)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "all-collections-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
        "More Collections on WAX ",
        searchTerm && `(${filteredCollections.length})`
      ] }),
      error ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        ErrorMessage,
        {
          errorType: "COLLECTION_NOT_FOUND",
          onRetry: () => fetchCollections(),
          showRetry: true
        }
      ) : loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-spinner", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading collections..." })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collections-grid", children: displayedCollections.length > 0 ? displayedCollections.map((collection) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Link,
          {
            to: `/collections/${collection.collection_name}`,
            className: "collection-card",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CollectionImage,
                {
                  src: collection.img ? collection.img.startsWith("http") ? collection.img : `https://ipfs.io/ipfs/${collection.img}` : void 0,
                  alt: collection.collection_name,
                  width: 150,
                  height: 150,
                  fallbackText: collection.collection_name,
                  className: "collection-image"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-row-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: collection.name }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-row-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "collection-name", children: collection.collection_name }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-market-data", children: collection.loading_market_data ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-data-loading", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mini-spinner" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading market data..." })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  collection.floor_price !== void 0 && collection.floor_price > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-stat", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Floor:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "stat-value", children: [
                      collection.floor_price.toFixed(4),
                      " WAX"
                    ] })
                  ] }),
                  collection.volume && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-stat", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Volume:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "stat-value", children: [
                      parseFloat(collection.volume).toLocaleString(),
                      " WAX"
                    ] })
                  ] }),
                  collection.assets && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-stat", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Assets:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: collection.assets })
                  ] })
                ] }) })
              ] })
            ]
          },
          collection.collection_name
        )) : searchTerm ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "no-results", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "no-results-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No collections found" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Try adjusting your search terms or browse all collections" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setSearchTerm(""),
              className: "clear-search-button",
              children: "Clear Search"
            }
          )
        ] }) : null }),
        hasMoreCollections && !searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: loadMoreCollections,
            disabled: loadingMore,
            className: "load-more-button",
            children: loadingMore ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "button-spinner" }),
              "Loading..."
            ] }) : `Load More Collections (${filteredCollections.length - displayedCount} remaining)`
          }
        ) })
      ] })
    ] })
  ] });
};
const COLLECTION_TIERS = {
  "pixeljourney": {
    tier: "platinum",
    verified: true,
    quickLinks: [
      { label: "Main Website", url: "https://pixeljourney.xyz", icon: "" },
      { label: "Discord", url: "http://discord.gg/pixel-journey-1130670500776005734", icon: "" },
      { label: "X/Twitter", url: "https://x.com/PXJourney", icon: "" },
      { label: "Whitepaper", url: "https://docs.pixeljourney.xyz", icon: "" }
    ],
    benefits: [
      "Premium marketplace placement",
      "Exclusive promotional campaigns",
      "Priority customer support",
      "Advanced analytics dashboard",
      "Custom branding options"
    ],
    ownerMessage: "Welcome to Pixel Journey! Join our community of adventurers exploring the digital realm. Connect with fellow travelers, learn about all the things and discover exclusive content.",
    discordUrl: "http://discord.gg/pixel-journey-1130670500776005734",
    learnAboutGrid: [
      {
        title: "PXJ Token",
        description: "Learn about our native utility token, its use cases, and how it powers the Pixel Journey ecosystem.",
        icon: "",
        url: "https://docs.pixeljourney.xyz/season-1/kickstarting-the-pxj-economy"
      },
      {
        title: "NFT Collections",
        description: "Discover our diverse range of NFT collectibles, from Pixal PFPs to Pixel Ingredients and special editions.",
        icon: "",
        url: "https://docs.pixeljourney.xyz/season-1/the-pixal-pfps"
      },
      {
        title: "Leaderboards",
        description: "Explore the PXJourney mechanics, quests, and adventures awaiting in Pixel Journey.",
        icon: "",
        url: "https://lb.pixeljourney.xyz/"
      },
      {
        title: "Staking & Rewards",
        description: "Understand how to stake your NFTs and tokens to earn rewards and participate in governance.",
        icon: "",
        url: "https://pixeljourney.xyz/staking"
      },
      {
        title: "Roadmap",
        description: "Check out our development roadmap and upcoming features planned for the ecosystem.",
        icon: "",
        url: "/journeymap"
      },
      {
        title: "Community",
        description: "Join our vibrant community of adventurers, participate in events, and connect with fellow travelers.",
        icon: "",
        url: "http://discord.gg/pixel-journey-1130670500776005734"
      }
    ]
  },
  "friedfactory": {
    tier: "partner",
    verified: true,
    quickLinks: [
      { label: "Artist Portfolio", url: "https://friedfactory.art", icon: "" },
      { label: "Discord", url: "https://discord.gg/friedfactory", icon: "" },
      { label: "Twitter", url: "https://twitter.com/friedfactory", icon: "" }
    ],
    benefits: [
      "Co-marketing opportunities",
      "Revenue sharing programs",
      "Joint event hosting",
      "Cross-promotion support"
    ]
  },
  "crptomuffins": {
    tier: "gold",
    verified: true,
    quickLinks: [
      { label: "Collection Info", url: "#", icon: "" },
      { label: "Discord", url: "#", icon: "" }
    ],
    benefits: [
      "Homepage featured carousel",
      "Social media promotion",
      "Exclusive events participation",
      "Direct community manager contact"
    ]
  },
  "akufishheads": {
    tier: "silver",
    verified: true,
    quickLinks: [
      { label: "Collection Info", url: "#", icon: "" }
    ],
    benefits: [
      "Priority marketplace placement",
      "Weekly newsletter mentions",
      "Custom collection banner",
      "Analytics dashboard access"
    ]
  },
  "pantheon": {
    tier: "bronze",
    verified: true,
    benefits: [
      "Basic marketplace listing",
      "Collection verification badge",
      "Community Discord access",
      "Monthly featured spot rotation"
    ]
  },
  "pocketsizedp": {
    tier: "partner",
    verified: true,
    quickLinks: [
      { label: "Collection Info", url: "#", icon: "" }
    ],
    benefits: [
      "Co-marketing opportunities",
      "Revenue sharing programs",
      "Joint event hosting",
      "Cross-promotion support"
    ]
  },
  "nimasodyssey": {
    tier: "partner",
    verified: true,
    benefits: [
      "Co-marketing opportunities",
      "Revenue sharing programs",
      "Joint event hosting",
      "Cross-promotion support"
    ]
  }
};
function getCollectionTier(collectionName) {
  return COLLECTION_TIERS[collectionName] || null;
}
function getTierBadgeConfig(tier) {
  const configs = {
    "platinum": {
      icon: "",
      label: "Platinum",
      className: "tier-platinum",
      color: "#e5e4e2"
    },
    "partner": {
      icon: "",
      label: "Partner",
      className: "tier-partner",
      color: "#667eea"
    },
    "gold": {
      icon: "",
      label: "Gold",
      className: "tier-gold",
      color: "#ffd700"
    },
    "silver": {
      icon: "",
      label: "Silver",
      className: "tier-silver",
      color: "#c0c0c0"
    },
    "bronze": {
      icon: "",
      label: "Bronze",
      className: "tier-bronze",
      color: "#cd7f32"
    }
  };
  return configs[tier];
}
const QuickLinks = ({ collectionName }) => {
  const tierInfo = getCollectionTier(collectionName);
  if (!tierInfo) {
    return null;
  }
  const badgeConfig = getTierBadgeConfig(tierInfo.tier);
  const hasQuickLinks = tierInfo.quickLinks && tierInfo.quickLinks.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quick-links-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `tier-badge ${badgeConfig.className}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-icon", children: badgeConfig.icon }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-label", children: badgeConfig.label }),
      tierInfo.verified && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "verified-icon", children: "" })
    ] }) }),
    hasQuickLinks && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "links-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "links-title", children: "Quick Links" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "links-grid", children: tierInfo.quickLinks.map((link, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "a",
        {
          href: link.url,
          target: "_blank",
          rel: "noopener noreferrer",
          className: "quick-link",
          children: [
            link.icon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "link-icon", children: link.icon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "link-label", children: link.label })
          ]
        },
        index
      )) })
    ] }),
    (tierInfo.ownerMessage || tierInfo.discordUrl) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "owner-section", children: [
      tierInfo.ownerMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "owner-message", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "owner-title-container", style: {
          display: "flex",
          alignItems: "center",
          gap: "8px",
          marginBottom: "8px"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "owner-title", children: "From the Collection Owner" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "info-tooltip",
              title: "This message is provided directly by the collection owner to share information about their project, community, or special announcements with collectors and fans.",
              style: {
                display: "inline-flex",
                alignItems: "center",
                justifyContent: "center",
                width: "16px",
                height: "16px",
                borderRadius: "50%",
                backgroundColor: "rgba(255, 255, 255, 0.1)",
                border: "1px solid rgba(255, 255, 255, 0.2)",
                color: "rgba(255, 255, 255, 0.7)",
                fontSize: "12px",
                fontWeight: "bold",
                cursor: "help",
                transition: "all 0.2s ease"
              },
              onMouseEnter: (e) => {
                e.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.15)";
                e.currentTarget.style.borderColor = "rgba(255, 255, 255, 0.3)";
                e.currentTarget.style.color = "rgba(255, 255, 255, 0.9)";
              },
              onMouseLeave: (e) => {
                e.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
                e.currentTarget.style.borderColor = "rgba(255, 255, 255, 0.2)";
                e.currentTarget.style.color = "rgba(255, 255, 255, 0.7)";
              },
              children: "?"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "owner-text", children: tierInfo.ownerMessage })
      ] }),
      tierInfo.discordUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "discord-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "a",
        {
          href: tierInfo.discordUrl,
          target: "_blank",
          rel: "noopener noreferrer",
          className: "discord-link",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "discord-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "discord-text", children: "Join Our Discord Community" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "external-icon", children: "" })
          ]
        }
      ) })
    ] }),
    tierInfo.learnAboutGrid && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "learn-about-section", style: { marginTop: "2rem" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "learn-about-title", children: "Learn About Pixel Journey" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "learn-about-grid", style: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(280px, 1fr))",
        gap: "16px",
        marginTop: "16px"
      }, children: tierInfo.learnAboutGrid.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "learn-about-card",
          style: {
            background: "rgba(255, 255, 255, 0.05)",
            border: "1px solid rgba(255, 255, 255, 0.1)",
            borderRadius: "12px",
            padding: "20px",
            transition: "all 0.3s ease",
            cursor: item.url ? "pointer" : "default"
          },
          onClick: () => item.url && window.open(item.url, "_blank"),
          onMouseEnter: (e) => {
            if (item.url) {
              e.currentTarget.style.background = "rgba(255, 255, 255, 0.08)";
              e.currentTarget.style.borderColor = "rgba(255, 255, 255, 0.2)";
              e.currentTarget.style.transform = "translateY(-2px)";
            }
          },
          onMouseLeave: (e) => {
            if (item.url) {
              e.currentTarget.style.background = "rgba(255, 255, 255, 0.05)";
              e.currentTarget.style.borderColor = "rgba(255, 255, 255, 0.1)";
              e.currentTarget.style.transform = "translateY(0)";
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "learn-card-header", style: {
              display: "flex",
              alignItems: "center",
              gap: "12px",
              marginBottom: "12px"
            }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "learn-card-icon", style: {
                fontSize: "24px",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                width: "40px",
                height: "40px",
                background: "rgba(255, 255, 255, 0.1)",
                borderRadius: "8px"
              }, children: item.icon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "learn-card-title", style: {
                margin: 0,
                fontSize: "16px",
                fontWeight: "600",
                color: "white"
              }, children: item.title }),
              item.url && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "external-link-icon", style: {
                marginLeft: "auto",
                fontSize: "14px",
                color: "rgba(255, 255, 255, 0.6)"
              }, children: "" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "learn-card-description", style: {
              margin: 0,
              fontSize: "14px",
              lineHeight: "1.5",
              color: "rgba(255, 255, 255, 0.8)"
            }, children: item.description })
          ]
        },
        index
      )) })
    ] })
  ] });
};
const ChatWidget = ({ collectionName }) => {
  const { account, isConnected } = useWallet$1();
  const { showError, showSuccess } = useNotifications();
  const { settings } = useDisplaySettings();
  const [isExpanded, setIsExpanded] = reactExports.useState(false);
  const [isMinimized, setIsMinimized] = reactExports.useState(true);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [isSending, setIsSending] = reactExports.useState(false);
  const [messages, setMessages] = reactExports.useState([]);
  const [unreadCount, setUnreadCount] = reactExports.useState(0);
  const [lastReadTimestamp, setLastReadTimestamp] = reactExports.useState(null);
  const [newMessage, setNewMessage] = reactExports.useState("");
  const [costInfo, setCostInfo] = reactExports.useState(null);
  const [isSponsored, setIsSponsored] = reactExports.useState(false);
  const [autoRefresh, setAutoRefresh] = reactExports.useState(true);
  const [refreshInterval, setRefreshInterval] = reactExports.useState(30);
  const [showSponsoredInfo, setShowSponsoredInfo] = reactExports.useState(false);
  const [showEmojiPicker, setShowEmojiPicker] = reactExports.useState(false);
  const [showPriceInfo, setShowPriceInfo] = reactExports.useState(false);
  const [filters, setFilters] = reactExports.useState({
    collection: collectionName || void 0,
    hideSpam: true
  });
  const messagesEndRef = reactExports.useRef(null);
  const refreshIntervalRef = reactExports.useRef(null);
  const messageInputRef = reactExports.useRef(null);
  const insertFormatting = (prefix, suffix = "") => {
    const textarea = messageInputRef.current;
    if (!textarea) return;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = newMessage.substring(start, end);
    const beforeText = newMessage.substring(0, start);
    const afterText = newMessage.substring(end);
    const newText = beforeText + prefix + selectedText + suffix + afterText;
    setNewMessage(newText);
    setTimeout(() => {
      textarea.focus();
      const newCursorPos = start + prefix.length + selectedText.length + suffix.length;
      textarea.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };
  const insertEmoji = (emoji) => {
    const textarea = messageInputRef.current;
    if (!textarea) return;
    const start = textarea.selectionStart;
    const beforeText = newMessage.substring(0, start);
    const afterText = newMessage.substring(start);
    const newText = beforeText + emoji + afterText;
    setNewMessage(newText);
    setShowEmojiPicker(false);
    setTimeout(() => {
      textarea.focus();
      const newCursorPos = start + emoji.length;
      textarea.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };
  const renderMessageContent = (content) => {
    const formatted = formatSafeMarkdown(content);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { dangerouslySetInnerHTML: { __html: formatted } });
  };
  reactExports.useEffect(() => {
    if (messages.length === 0) {
      setUnreadCount(0);
      return;
    }
    if (lastReadTimestamp) {
      const unreadMessages = messages.filter(
        (msg) => new Date(msg.timestamp) > new Date(lastReadTimestamp)
      );
      setUnreadCount(unreadMessages.length);
    } else {
      setUnreadCount(isMinimized ? messages.length : 0);
    }
  }, [messages, lastReadTimestamp, isMinimized]);
  reactExports.useEffect(() => {
    if (!isMinimized && messages.length > 0) {
      const latestMessage = messages[messages.length - 1];
      setLastReadTimestamp(latestMessage.timestamp);
      setUnreadCount(0);
    }
  }, [isMinimized, messages]);
  const loadMessages = reactExports.useCallback(async (silent = false) => {
    if (!silent) setIsLoading(true);
    try {
      const chatFilters = collectionName ? { ...filters, collection: collectionName } : filters;
      const fetchedMessages = await chatService.getMessages(chatFilters, 50, 0);
      setMessages(fetchedMessages);
    } catch (error) {
      log.error("Error loading messages:", "ChatWidget", error);
      if (!silent) {
        showError("Failed to load chat messages");
      }
    } finally {
      if (!silent) setIsLoading(false);
    }
  }, [filters, collectionName, showError]);
  reactExports.useEffect(() => {
    if (collectionName && (!filters.collection || filters.collection !== collectionName)) {
      setFilters((prev) => ({ ...prev, collection: collectionName }));
    }
  }, [collectionName, filters]);
  reactExports.useEffect(() => {
    loadMessages();
  }, [loadMessages]);
  reactExports.useEffect(() => {
    if (autoRefresh && !isMinimized) {
      refreshIntervalRef.current = setInterval(() => {
        loadMessages(true);
      }, refreshInterval * 1e3);
    } else {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
        refreshIntervalRef.current = null;
      }
    }
    return () => {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
    };
  }, [autoRefresh, isMinimized, refreshInterval, loadMessages]);
  const calculateCost = reactExports.useCallback(async () => {
    if (!account || !newMessage) return;
    try {
      const cost = await chatService.calculateMessageCost(newMessage, account, isSponsored);
      setCostInfo(cost);
    } catch (error) {
      log.error("Error calculating cost:", "ChatWidget", error);
    }
  }, [account, newMessage, isSponsored]);
  reactExports.useEffect(() => {
    if (newMessage && account) {
      calculateCost();
    } else {
      setCostInfo(null);
    }
  }, [newMessage, account, calculateCost]);
  reactExports.useEffect(() => {
    scrollToBottom();
  }, [messages]);
  if (!settings.showChatButton) {
    return null;
  }
  const sendMessage = async () => {
    if (!account || !newMessage.trim()) return;
    setIsSending(true);
    try {
      const messageToSend = collectionName ? `::col:${collectionName}:: ${newMessage.trim()}` : newMessage.trim();
      const txId = await chatService.sendMessage(
        messageToSend,
        account,
        collectionName,
        isSponsored
      );
      showSuccess("Message sent!", `Transaction: ${txId.substring(0, 8)}...`);
      setNewMessage("");
      setCostInfo(null);
      setIsSponsored(false);
      setTimeout(() => {
        loadMessages(true);
      }, 2e3);
    } catch (error) {
      log.error("Error sending message:", "ChatWidget", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (errorMessage.includes("transaction ID not found")) {
        showError(
          "Message Status Unclear",
          "Your message may have been sent successfully. Please check your transaction history or refresh the chat to confirm."
        );
      } else {
        showError("Failed to send message", errorMessage);
      }
    } finally {
      setIsSending(false);
    }
  };
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };
  const formatTimestamp = (timestamp) => {
    const date = new Date(timestamp);
    const now = /* @__PURE__ */ new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 6e4);
    const diffHours = Math.floor(diffMs / 36e5);
    const diffDays = Math.floor(diffMs / 864e5);
    if (diffMins < 1) return "now";
    if (diffMins < 60) return `${diffMins}m`;
    if (diffHours < 24) return `${diffHours}h`;
    if (diffDays < 7) return `${diffDays}d`;
    return date.toLocaleDateString();
  };
  const formatPxjAmount = (amount) => {
    const num = parseFloat(amount.split(" ")[0]);
    if (num >= 1e3) return `${(num / 1e3).toFixed(1)}K PXJ`;
    return `${num.toFixed(0)} PXJ`;
  };
  const getMessageTypeClass = (message) => {
    if (message.isSponsored) return "chat_message--sponsored";
    if (message.messageType === "premium") return "chat_message--premium";
    return "chat_message--normal";
  };
  const handleKeyPress = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };
  if (isMinimized) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_widget chat_widget--minimized", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        className: "chat_toggle-btn",
        onClick: () => setIsMinimized(false),
        title: "Open Chat",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_icon", children: "" }),
          unreadCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_notification-badge", children: unreadCount })
        ]
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `chat_widget ${isExpanded ? "chat_widget--expanded" : "chat_widget--normal"}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_header-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_title", children: collectionName ? `${collectionName} Chat` : "Global Chat" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "chat_status", children: [
          messages.length,
          " messages"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_header-right", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "chat_btn chat_btn--icon",
            onClick: () => loadMessages(),
            disabled: isLoading,
            title: "Refresh",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `chat_refresh-icon ${isLoading ? "chat_refresh-icon--spinning" : ""}`, children: "" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "chat_btn chat_btn--icon",
            onClick: () => setIsExpanded(!isExpanded),
            title: isExpanded ? "Minimize" : "Expand",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isExpanded ? "" : "" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "chat_btn chat_btn--icon",
            onClick: () => setIsMinimized(true),
            title: "Close",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" })
          }
        )
      ] })
    ] }),
    !collectionName && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_filters", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "select",
        {
          className: "chat_select",
          value: filters.collection || "",
          onChange: (e) => setFilters({ ...filters, collection: e.target.value || void 0 }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "All Collections" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "pixeljourney", children: "Pixel Journey" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "pixalcards", children: "Pixal Cards" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "chat_checkbox-label", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: filters.hideSpam || false,
            onChange: (e) => setFilters({ ...filters, hideSpam: e.target.checked })
          }
        ),
        "Hide Spam"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "chat_checkbox-label", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: filters.showOnlySponsored || false,
            onChange: (e) => setFilters({ ...filters, showOnlySponsored: e.target.checked })
          }
        ),
        "Sponsored Only"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_messages", children: [
      isLoading && messages.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_loading", children: "Loading messages..." }) : messages.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_empty", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No messages yet." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Be the first to start the conversation!" })
      ] }) : messages.map((message) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `chat_message ${getMessageTypeClass(message)}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_message-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_message-avatar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: `https://api.dicebear.com/7.x/identicon/svg?seed=${message.sender}`,
              alt: message.sender,
              className: "chat_avatar"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_message-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_sender", children: message.sender }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_timestamp", children: formatTimestamp(message.timestamp) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_amount", children: formatPxjAmount(message.pxjAmount) }),
            message.isSponsored && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "chat_sponsored-badge", children: "SPONSORED" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_message-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: `https://wax.bloks.io/transaction/${message.transactionId}`,
              target: "_blank",
              rel: "noopener noreferrer",
              className: "chat_tx-link",
              title: "View on Explorer",
              children: ""
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_message-content", children: renderMessageContent(message.message) })
      ] }, message.id)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: messagesEndRef })
    ] }),
    isConnected ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_input-section", children: [
      costInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_cost-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_cost-display", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "chat_cost-amount", children: [
            "Cost: ",
            (costInfo.totalCost / 1e4).toFixed(4),
            " PXJ"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "chat_info-btn",
              onClick: () => setShowPriceInfo(!showPriceInfo),
              title: "View price breakdown",
              children: ""
            }
          )
        ] }),
        costInfo.hasPixalPFP && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "chat_discount", children: [
          "Pixal PFP Discount: ",
          costInfo.discount,
          "%"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "chat_char-count", children: [
          newMessage.length,
          "/240 chars"
        ] }),
        showPriceInfo && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_price-tooltip", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_price-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Price Breakdown" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-factor", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Base Cost:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              (costInfo.baseCost / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-factor", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Character Cost (",
              newMessage.length,
              " chars):"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              ((costInfo.totalCost - costInfo.baseCost) / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] }),
          costInfo.hasPixalPFP && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-factor discount", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Pixal PFP Discount (",
              costInfo.discount,
              "%):"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "-",
              ((costInfo.baseCost + (costInfo.totalCost - costInfo.baseCost)) * (costInfo.discount / 100) / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-factor total", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Total Cost:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              (costInfo.totalCost / 1e4).toFixed(4),
              " PXJ"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-note", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: "Cost increases by 100% per 50 extra characters. Holders capped at 500 PXJ." }) })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_input-controls", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_sponsored-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "chat_checkbox-label", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                checked: isSponsored,
                onChange: (e) => setIsSponsored(e.target.checked)
              }
            ),
            "Sponsored (",
            costInfo?.hasPixalPFP ? "10,000" : "25,000",
            " PXJ)"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "chat_info-btn",
              onClick: () => setShowSponsoredInfo(!showSponsoredInfo),
              title: "Learn more about sponsored messages",
              children: ""
            }
          ),
          showSponsoredInfo && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_info-tooltip", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_info-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Sponsored Messages" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: " Messages appear with special highlighting" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: " Higher visibility in chat feed" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              " Costs ",
              costInfo?.hasPixalPFP ? "10,000" : "25,000",
              " PXJ regardless of length"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              " ",
              costInfo?.hasPixalPFP ? "Pixal PFP holders get 60% discount!" : "Get a Pixal PFP for 60% discount!"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: " Perfect for announcements & promotions" })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "chat_checkbox-label", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: autoRefresh,
              onChange: (e) => setAutoRefresh(e.target.checked)
            }
          ),
          "Auto-refresh"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_formatting-toolbar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "chat_format-btn",
            onClick: () => insertFormatting("**", "**"),
            title: "Bold",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "B" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "chat_format-btn",
            onClick: () => insertFormatting("*", "*"),
            title: "Italic",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("em", { children: "I" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_emoji-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "chat_format-btn",
              onClick: () => setShowEmojiPicker(!showEmojiPicker),
              title: "Add emoji",
              children: ""
            }
          ),
          showEmojiPicker && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_emoji-picker", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_emoji-grid", children: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""].map((emoji) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "chat_emoji-btn",
              onClick: () => insertEmoji(emoji),
              children: emoji
            },
            emoji
          )) }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_input-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            ref: messageInputRef,
            className: "chat_input",
            placeholder: `Type your message... (${collectionName ? collectionName : "global"} chat)`,
            value: newMessage,
            onChange: (e) => setNewMessage(e.target.value),
            onKeyPress: handleKeyPress,
            maxLength: 240,
            rows: isExpanded ? 3 : 2,
            disabled: isSending
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "chat_send-btn",
            onClick: sendMessage,
            disabled: !newMessage.trim() || isSending,
            children: isSending ? "" : ""
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_login-prompt", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your wallet to join the chat!" }) }),
    isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat_settings", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat_setting-group", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Auto-refresh interval:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "select",
        {
          value: refreshInterval,
          onChange: (e) => setRefreshInterval(Number(e.target.value)),
          className: "chat_select chat_select--small",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 10, children: "10s" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 30, children: "30s" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 60, children: "1m" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 300, children: "5m" })
          ]
        }
      )
    ] }) })
  ] });
};
const ImageZoom = ({ isOpen, imageUrl, imageName, onClose }) => {
  if (!isOpen) return null;
  const handleKeyDown = (e) => {
    if (e.key === "Escape") {
      onClose();
    }
  };
  React.useEffect(() => {
    if (isOpen) {
      document.addEventListener("keydown", handleKeyDown);
      document.body.style.overflow = "hidden";
    }
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.body.style.overflow = "unset";
    };
  }, [isOpen]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "image-zoom-modal", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "zoom-modal-content", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: "zoom-modal-close",
        onClick: onClose,
        children: ""
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: imageUrl,
        alt: imageName,
        className: "zoom-modal-image"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "zoom-modal-info", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: imageName }) })
  ] }) });
};
const CollectionDetail = React.memo(() => {
  const { collectionName } = useParams();
  const { settings } = useDisplaySettings();
  const [collection, setCollection] = reactExports.useState(null);
  const [schemas, setSchemas] = reactExports.useState([]);
  const [templates2, setTemplates] = reactExports.useState([]);
  const [analytics, setAnalytics] = reactExports.useState(null);
  const [volumePeriod, setVolumePeriod] = reactExports.useState("24");
  const [volumeData, setVolumeData] = reactExports.useState({});
  const [loadingVolume, setLoadingVolume] = reactExports.useState(false);
  const [marketCapCurrency, setMarketCapCurrency] = reactExports.useState("WAX");
  const [waxToUsdRate, setWaxToUsdRate] = reactExports.useState(0.05);
  const [holders, setHolders] = reactExports.useState([]);
  const [holdersPage, setHoldersPage] = reactExports.useState(1);
  const [loadingMoreHolders, setLoadingMoreHolders] = reactExports.useState(false);
  const [hasMoreHolders, setHasMoreHolders] = reactExports.useState(true);
  const [topSales, setTopSales] = reactExports.useState([]);
  const [displayedSales, setDisplayedSales] = reactExports.useState([]);
  const [salesPage, setSalesPage] = reactExports.useState(1);
  const [salesPerPage] = reactExports.useState(10);
  const [hasMoreSales, setHasMoreSales] = reactExports.useState(false);
  const [similarCollections, setSimilarCollections] = reactExports.useState([]);
  const [atomicMarketStats, setAtomicMarketStats] = reactExports.useState(null);
  const [selectedSchema, setSelectedSchema] = reactExports.useState("");
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [activeTab, setActiveTab] = reactExports.useState("sales");
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [sortBy, setSortBy] = reactExports.useState("name");
  const [showImageZoom, setShowImageZoom] = reactExports.useState(false);
  const [zoomedImage, setZoomedImage] = reactExports.useState({ url: "", name: "" });
  const [showShareModal, setShowShareModal] = reactExports.useState(false);
  const filteredSchemas = schemas.filter(
    (schema) => schema.schema_name.toLowerCase().includes(searchTerm.toLowerCase())
  ).sort((a, b) => {
    switch (sortBy) {
      case "name":
        return a.schema_name.localeCompare(b.schema_name);
      case "created":
        return new Date(b.created_at_time).getTime() - new Date(a.created_at_time).getTime();
      default:
        return 0;
    }
  });
  const filteredTemplates = templates2.filter((template) => {
    const matchesSearch = template.immutable_data?.name && String(template.immutable_data.name).toLowerCase().includes(searchTerm.toLowerCase()) || template.template_id.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesSchema = !selectedSchema || template.schema_name === selectedSchema;
    return matchesSearch && matchesSchema;
  }).sort((a, b) => {
    switch (sortBy) {
      case "name": {
        const nameA = String(a.immutable_data?.name || `Template #${a.template_id}`);
        const nameB = String(b.immutable_data?.name || `Template #${b.template_id}`);
        return nameA.localeCompare(nameB);
      }
      case "created":
        return new Date(b.created_at_time).getTime() - new Date(a.created_at_time).getTime();
      case "supply":
        return parseInt(b.issued_supply) - parseInt(a.issued_supply);
      default:
        return 0;
    }
  });
  const fetchVolumeData = reactExports.useCallback(async (days) => {
    if (!collectionName) return "0";
    try {
      const response = await fetch(`https://wax-api.hivebp.io/v3/volume/${days}/${collectionName}`);
      if (!response.ok) throw new Error("Failed to fetch volume data");
      const data = await response.json();
      return data.volume ? String(data.volume) : "0";
    } catch (error2) {
      console.warn(`Failed to fetch ${days}d volume data:`, error2);
      return "0";
    }
  }, [collectionName]);
  const fetchCollectionStats = reactExports.useCallback(async () => {
    if (!collectionName) return null;
    try {
      const response = await fetch(`https://wax-api.hivebp.io/v3/collection-stats/${collectionName}`);
      if (!response.ok) throw new Error("Failed to fetch collection stats");
      const data = await response.json();
      return {
        numUsers: data.numUsers || 0,
        usdMarketCap: data.usdMarketCap || 0,
        waxMarketCap: data.waxMarketCap || 0,
        numAssets: data.numAssets || 0
      };
    } catch (error2) {
      console.warn("Failed to fetch collection stats:", error2);
      return null;
    }
  }, [collectionName]);
  const handleVolumePeriodChange = reactExports.useCallback(async () => {
    if (!collectionName) return;
    setLoadingVolume(true);
    const periods = ["24", "7", "30", "90", "365"];
    const currentIndex = periods.indexOf(volumePeriod);
    const nextPeriod = periods[(currentIndex + 1) % periods.length];
    if (volumeData[nextPeriod]) {
      setVolumePeriod(nextPeriod);
      setLoadingVolume(false);
      return;
    }
    const newVolumeValue = await fetchVolumeData(nextPeriod);
    setVolumeData((prev) => ({ ...prev, [nextPeriod]: newVolumeValue }));
    setVolumePeriod(nextPeriod);
    setLoadingVolume(false);
  }, [collectionName, volumePeriod, volumeData, fetchVolumeData]);
  const handleMarketCapToggle = async () => {
    if (marketCapCurrency === "WAX") {
      try {
        const response = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=wax&vs_currencies=usd");
        const data = await response.json();
        if (data.wax && data.wax.usd) {
          setWaxToUsdRate(data.wax.usd);
        }
      } catch (error2) {
        console.warn("Could not fetch WAX price:", error2);
      }
      setMarketCapCurrency("USD");
    } else {
      setMarketCapCurrency("WAX");
    }
  };
  const loadCollectionData = reactExports.useCallback(async () => {
    if (!collectionName) return;
    setLoading(true);
    setError(null);
    try {
      const [collectionInfo, schemasData, templatesData] = await Promise.all([
        apiService.getCollectionDetails(collectionName),
        apiService.getCollectionSchemas(collectionName),
        apiService.getCollectionTemplates(collectionName)
      ]);
      setCollection(collectionInfo);
      setSchemas(schemasData);
      setTemplates(templatesData);
      Promise.all([
        apiService.getCollectionAnalytics(collectionName),
        apiService.getEnhancedCollectionStats(collectionName),
        apiService.getCollectionVolumeGraph(collectionName, 30),
        apiService.getSimilarCollections(collectionName),
        apiService.getCollectionHolders(collectionName, 500),
        apiService.getCollectionTopSales(collectionName, 50),
        fetchVolumeData("24"),
        // Fetch initial 24h volume data
        fetchCollectionStats(),
        // Fetch collection stats from HiveBP API
        apiService.getCollectionMarketStats({ collection_name: collectionName, symbol: "WAX" })
        // Fetch atomicmarket stats
      ]).then(([analyticsData, enhancedStats, , similarData, holdersData, salesData, volume24h, collectionStats, marketStats]) => {
        setVolumeData((prev) => ({ ...prev, "24": volume24h }));
        const processedMarketStats = marketStats.success && marketStats.data ? {
          sales: marketStats.data.sales || "0",
          volume: marketStats.data.volume ? String(parseFloat(marketStats.data.volume) / Math.pow(10, 8)) : "0",
          suggested_median: marketStats.data.suggested_median ? String(parseFloat(marketStats.data.suggested_median) / Math.pow(10, 8)) : "0",
          suggested_average: marketStats.data.suggested_average ? String(parseFloat(marketStats.data.suggested_average) / Math.pow(10, 8)) : "0"
        } : null;
        setAtomicMarketStats(processedMarketStats);
        const combinedAnalytics = {
          volume: processedMarketStats?.volume || analyticsData?.volume || "0",
          sales: processedMarketStats?.sales || analyticsData?.sales || "0",
          floor_price: enhancedStats.floorPrice && !isNaN(enhancedStats.floorPrice) ? String(enhancedStats.floorPrice) : analyticsData?.floor_price && !isNaN(parseFloat(analyticsData.floor_price)) ? analyticsData.floor_price : analyticsData?.floor && !isNaN(parseFloat(analyticsData.floor)) ? analyticsData.floor : processedMarketStats?.suggested_median && !isNaN(parseFloat(processedMarketStats.suggested_median)) ? processedMarketStats.suggested_median : salesData && salesData.length > 0 ? (() => {
            const validPrices = salesData.slice(-5).map((sale) => {
              const price = typeof sale.price === "string" ? sale.price : sale.price?.amount || "0";
              return parseFloat(price || "0");
            }).filter((price) => !isNaN(price) && price > 0);
            return validPrices.length > 0 ? String(Math.min(...validPrices).toFixed(2)) : "0";
          })() : "0",
          market_cap: collectionStats?.waxMarketCap ? String(collectionStats.waxMarketCap) : enhancedStats.marketCap ? String(enhancedStats.marketCap) : analyticsData?.market_cap || "0",
          holders: collectionStats?.numUsers || analyticsData?.holders || 0,
          assets: collectionStats?.numAssets ? String(collectionStats.numAssets) : analyticsData?.assets || "0",
          volume_24h: volume24h || (enhancedStats.volume24h ? String(enhancedStats.volume24h) : analyticsData?.volume_24h || analyticsData?.volume || "0")
        };
        setAnalytics(combinedAnalytics);
        setSimilarCollections(similarData);
        setHolders(holdersData);
        setTopSales(salesData || []);
      }).catch((error2) => {
        log.error("Enhanced analytics failed to load", "CollectionDetail.loadCollectionData", error2, { collectionName });
      });
    } catch (error2) {
      log.error("Failed to load collection data", "CollectionDetail.loadCollectionData", error2, { collectionName });
      setError(`Failed to load collection "${collectionName}". This collection may not exist or be temporarily unavailable.`);
    } finally {
      setLoading(false);
    }
  }, [collectionName]);
  const loadTemplates = reactExports.useCallback(async (schemaName) => {
    if (!collectionName) return;
    try {
      const templatesData = await apiService.getCollectionTemplates(collectionName, schemaName);
      setTemplates(templatesData);
    } catch (error2) {
      log.error("Failed to load collection templates", "CollectionDetail.loadTemplates", error2, { collectionName, schemaName });
    }
  }, [collectionName]);
  reactExports.useEffect(() => {
    if (collectionName) {
      loadCollectionData();
    }
  }, [collectionName, loadCollectionData]);
  reactExports.useEffect(() => {
    if (selectedSchema && collectionName) {
      loadTemplates(selectedSchema);
    }
  }, [selectedSchema, collectionName, loadTemplates]);
  const loadMoreHolders = async () => {
    if (!collectionName || loadingMoreHolders || !hasMoreHolders) return;
    setLoadingMoreHolders(true);
    try {
      const nextPage = holdersPage + 1;
      const offset = (nextPage - 1) * 500;
      const newHolders = await apiService.getCollectionHolders(collectionName, 500, offset);
      if (newHolders && newHolders.length > 0) {
        setHolders((prev) => [...prev, ...newHolders]);
        setHoldersPage(nextPage);
        setHasMoreHolders(newHolders.length === 500);
      } else {
        setHasMoreHolders(false);
      }
    } catch (error2) {
      console.error("Error loading more holders:", error2);
      setHasMoreHolders(false);
    } finally {
      setLoadingMoreHolders(false);
    }
  };
  reactExports.useEffect(() => {
    const startIndex = 0;
    const endIndex = salesPage * salesPerPage;
    const newDisplayedSales = topSales.slice(startIndex, endIndex);
    setDisplayedSales(newDisplayedSales);
    setHasMoreSales(endIndex < topSales.length);
  }, [topSales, salesPage, salesPerPage]);
  const loadMoreSales = () => {
    if (hasMoreSales) {
      setSalesPage((prev) => prev + 1);
    }
  };
  const getImageUrl = (imgPath) => {
    if (!imgPath) return void 0;
    if (imgPath.startsWith("http")) return imgPath;
    return `https://ipfs.io/ipfs/${imgPath}`;
  };
  const getTemplateImage = (template) => {
    if (template.immutable_data?.img) {
      const img = template.immutable_data.img;
      if (typeof img === "string") {
        return img.startsWith("Qm") ? `https://ipfs.io/ipfs/${img}` : img;
      }
    }
    return "https://pixeljourney.xyz/img/toppixals/10.webp";
  };
  const getVideoUrl = (template) => {
    if (template.immutable_data?.video) {
      const video = template.immutable_data.video;
      if (typeof video === "string") {
        return video.startsWith("Qm") ? `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${video}` : video;
      }
    }
    return null;
  };
  const formatSaleDate = (dateString) => {
    if (!dateString) return "N/A";
    try {
      let date;
      if (dateString.includes("T")) {
        date = new Date(dateString);
      } else {
        const timestamp = parseInt(dateString);
        if (timestamp > 946684800 && timestamp < 4102444800) {
          date = new Date(timestamp * 1e3);
        } else if (timestamp > 9466848e5 && timestamp < 41024448e5) {
          date = new Date(timestamp);
        } else {
          return "N/A";
        }
      }
      if (isNaN(date.getTime())) {
        return "N/A";
      }
      return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    } catch {
      return "N/A";
    }
  };
  const renderMediaElement = (template, className = "template-image") => {
    const videoUrl = getVideoUrl(template);
    const imageUrl = getTemplateImage(template);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MediaRenderer,
      {
        imageUrl,
        videoUrl,
        alt: String(template.immutable_data?.name || "NFT"),
        className,
        enableAnimations: settings.enableAnimatedNFTs
      }
    );
  };
  const formatSupply = (current, max) => {
    if (max === "0") return `${current} (Unlimited)`;
    return `${current} / ${max}`;
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading collection details..." })
    ] }) });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Collection Error" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/collections", className: "back-link", children: " Back to Collections" })
    ] }) });
  }
  if (!collection) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Collection Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        'The collection "',
        collectionName,
        '" could not be found.'
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/collections", className: "back-link", children: " Back to Collections" })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-profile-page", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-hero", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hero-background", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: getImageUrl(collection.img || ""),
            alt: collection.name || collection.collection_name,
            className: "hero-bg-image"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hero-overlay" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hero-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "breadcrumb", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", className: "breadcrumb-link", children: "Home" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-separator", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/collections", className: "breadcrumb-link", children: "Collections" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-separator", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-current", children: collection.name || collection.collection_name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-profile", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-logo-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: getImageUrl(collection.img || ""),
              alt: collection.name || collection.collection_name,
              className: "collection-logo"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "title-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "collection-title", children: collection.name || collection.collection_name }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-actions-row", style: {
              display: "flex",
              alignItems: "center",
              gap: "12px",
              marginTop: "8px",
              marginBottom: "12px"
            }, children: [
              (() => {
                const tierInfo = getCollectionTier(collection.collection_name);
                if (tierInfo) {
                  const badgeConfig = getTierBadgeConfig(tierInfo.tier);
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `collection-tier-badge ${badgeConfig.className}`, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-icon", children: badgeConfig.icon }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tier-label", children: badgeConfig.label }),
                    tierInfo.verified && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "verified-icon", children: "" })
                  ] });
                }
                return null;
              })(),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  className: "share-button",
                  onClick: () => setShowShareModal(true),
                  style: {
                    background: "rgba(255, 255, 255, 0.1)",
                    border: "1px solid rgba(255, 255, 255, 0.2)",
                    borderRadius: "8px",
                    padding: "8px 12px",
                    color: "white",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    fontSize: "14px",
                    fontWeight: "500",
                    transition: "all 0.2s ease"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.background = "rgba(255, 255, 255, 0.15)";
                    e.currentTarget.style.borderColor = "rgba(255, 255, 255, 0.3)";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.background = "rgba(255, 255, 255, 0.1)";
                    e.currentTarget.style.borderColor = "rgba(255, 255, 255, 0.2)";
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 16.08C17.24 16.08 16.56 16.38 16.04 16.85L8.91 12.7C8.96 12.47 9 12.24 9 12C9 11.76 8.96 11.53 8.91 11.3L15.96 7.19C16.5 7.69 17.21 8 18 8C19.66 8 21 6.66 21 5C21 3.34 19.66 2 18 2C16.34 2 15 3.34 15 5C15 5.24 15.04 5.47 15.09 5.7L8.04 9.81C7.5 9.31 6.79 9 6 9C4.34 9 3 10.34 3 12C3 13.66 4.34 15 6 15C6.79 15 7.5 14.69 8.04 14.19L15.16 18.34C15.11 18.55 15.08 18.77 15.08 19C15.08 20.61 16.39 21.92 18 21.92C19.61 21.92 20.92 20.61 20.92 19C20.92 17.39 19.61 16.08 18 16.08Z", fill: "currentColor" }) }),
                    "Share Collection"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "collection-handle", children: [
              "@",
              collection.collection_name
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "collection-creator", children: [
              "Created by ",
              collection.author
            ] }),
            collection.data?.description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-description", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TruncatedText,
              {
                text: String(collection.data.description || ""),
                maxLength: 100,
                className: "description-text"
              }
            ) })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-dashboard", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-grid", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: analytics?.assets || collection.assets || 0 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Total Assets" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: schemas.length }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Schemas" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: templates2.length }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Templates" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: holders.length }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Holders" })
        ] })
      ] }),
      analytics && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-grid", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card premium clickable", onClick: handleMarketCapToggle, style: { cursor: "pointer" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: analytics.market_cap && analytics.market_cap !== "0" ? marketCapCurrency === "WAX" ? `${parseFloat(analytics.market_cap).toLocaleString()} WAX` : `$${(parseFloat(analytics.market_cap) * waxToUsdRate).toLocaleString(void 0, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "N/A" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-label", children: [
            "Market Cap (",
            marketCapCurrency,
            ")"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card premium", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: atomicMarketStats?.sales && atomicMarketStats.sales !== "0" ? `${parseInt(atomicMarketStats.sales).toLocaleString()}` : analytics?.sales && analytics.sales !== "0" ? `${parseInt(analytics.sales).toLocaleString()}` : "N/A" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "All Time Sales" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card premium", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: atomicMarketStats?.volume && atomicMarketStats.volume !== "0" ? `${parseFloat(atomicMarketStats.volume).toLocaleString()} WAX` : analytics?.volume && analytics.volume !== "0" ? `${parseFloat(analytics.volume).toLocaleString()} WAX` : "N/A" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "All Time Volume" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card premium clickable", onClick: handleVolumePeriodChange, style: { cursor: "pointer" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: loadingVolume ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { opacity: 0.6 }, children: "Loading..." }) : volumeData[volumePeriod] && volumeData[volumePeriod] !== "0" ? `${parseFloat(volumeData[volumePeriod]).toLocaleString()} WAX` : analytics?.volume_24h && analytics.volume_24h !== "0" ? `${parseFloat(analytics.volume_24h).toLocaleString()} WAX` : "N/A" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-label", children: [
            volumePeriod === "24" ? "24H" : volumePeriod === "7" ? "7D" : volumePeriod === "30" ? "30D" : volumePeriod === "90" ? "90D" : "365D",
            " Volume",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "0.8em", opacity: 0.7, marginLeft: "4px" }, children: "" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card premium", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: analytics.floor_price && analytics.floor_price !== "0" && !isNaN(parseFloat(analytics.floor_price)) && parseFloat(analytics.floor_price) > 0 ? `${parseFloat(analytics.floor_price).toFixed(2)} WAX` : atomicMarketStats?.suggested_median && atomicMarketStats.suggested_median !== "0" && !isNaN(parseFloat(atomicMarketStats.suggested_median)) ? `${parseFloat(atomicMarketStats.suggested_median).toFixed(2)} WAX` : topSales && topSales.length > 0 ? (() => {
            const validPrices = topSales.slice(-3).map((sale) => {
              const price = typeof sale.price === "string" ? sale.price : sale.price?.amount || "0";
              return parseFloat(price || "0");
            }).filter((price) => !isNaN(price) && price > 0);
            return validPrices.length > 0 ? `~${Math.min(...validPrices).toFixed(2)} WAX` : "N/A";
          })() : "N/A" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Floor Price" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(QuickLinks, { collectionName: collection.collection_name }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-content-navigation", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-nav-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-nav-tabs", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `collection-nav-tab ${activeTab === "sales" ? "active" : ""}`,
            onClick: () => setActiveTab("sales"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-text", children: "Top Sales" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-count", children: displayedSales.length })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `collection-nav-tab ${activeTab === "holders" ? "active" : ""}`,
            onClick: () => setActiveTab("holders"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-text", children: "Holders" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-count", children: holders.length })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `collection-nav-tab ${activeTab === "schemas" ? "active" : ""}`,
            onClick: () => setActiveTab("schemas"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-text", children: "Schemas" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-count", children: filteredSchemas.length })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `collection-nav-tab ${activeTab === "templates" ? "active" : ""}`,
            onClick: () => setActiveTab("templates"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-text", children: "Templates" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-count", children: filteredTemplates.length })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `collection-nav-tab ${activeTab === "similar" ? "active" : ""}`,
            onClick: () => setActiveTab("similar"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-text", children: "Similar" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-count", children: similarCollections.length })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `collection-nav-tab ${activeTab === "chat" ? "active" : ""}`,
            onClick: () => setActiveTab("chat"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-text", children: "Chat" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tab-count", children: "0" })
            ] })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nav-indicator" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content-area", children: [
      activeTab === "sales" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sales-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sales-grid", children: displayedSales.length > 0 ? displayedSales.map((sale, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-rank", children: [
            "#",
            index + 1
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-media", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MediaRenderer,
              {
                imageUrl: getSaleAssetImageUrl(sale),
                videoUrl: getSaleAssetVideoUrl(sale),
                alt: String(sale.assets?.[0]?.data?.name || sale.assets?.[0]?.template?.immutable_data?.name || "NFT"),
                className: "sale-image",
                controls: true,
                muted: true,
                loop: true,
                enableAnimations: settings.enableAnimatedNFTs
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "zoom-overlay",
                onClick: () => {
                  const imageUrl = getSaleAssetImageUrl(sale);
                  const name = String(sale.assets?.[0]?.data?.name || sale.assets?.[0]?.template?.immutable_data?.name || "NFT");
                  if (imageUrl) {
                    setZoomedImage({ url: imageUrl, name });
                  }
                  setShowImageZoom(true);
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" })
                ] })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sale-name", children: sale.assets?.[0]?.data?.name || sale.assets?.[0]?.template?.immutable_data?.name || "Unnamed NFT" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-template", children: [
              "Template #",
              sale.assets?.[0]?.template?.template_id
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sale-price", children: sale.price ? (parseInt(sale.price.amount) / Math.pow(10, sale.price.token_precision)).toFixed(sale.price.token_precision) + " " + sale.price.token_symbol : "N/A" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sale-date", children: formatSaleDate(sale.updated_at_time || "") })
          ] })
        ] }, sale.sale_id || index)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-data", children: "No sales data available" }) }),
        hasMoreSales && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "load-more-btn",
            onClick: loadMoreSales,
            children: "Load More Sales"
          }
        ) })
      ] }),
      activeTab === "holders" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "holders-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "holders-grid", children: holders.length > 0 ? holders.map((holder, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "holder-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "holder-rank", children: [
            "#",
            index + 1
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/profile-lookup/${holder.account}`, className: "holder-account clickable", children: holder.account }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "holder-count", children: [
            holder.assets,
            " assets"
          ] })
        ] }, index)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-data", children: "No holders data available" }) }),
        hasMoreHolders && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "load-more-btn",
            onClick: loadMoreHolders,
            disabled: loadingMoreHolders,
            children: loadingMoreHolders ? "Loading..." : "Load More Holders"
          }
        ) })
      ] }),
      activeTab === "similar" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "similar-collections", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "similar-collections-grid", children: similarCollections.length > 0 ? similarCollections.slice(0, 12).map((similar, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "similar-collection-item", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/collections/${similar.collection_name}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "similar-collection-name", children: similar.collection_name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "similar-collection-volume", children: "Similar Collection" })
      ] }) }, index)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-data", children: "No similar collections found" }) }) }),
      activeTab === "chat" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "chat-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChatWidget,
        {
          collectionName
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-filter-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-controls", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-input-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "search-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: `Search ${activeTab}...`,
                value: searchTerm,
                onChange: (e) => setSearchTerm(e.target.value),
                className: "search-input"
              }
            ),
            searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setSearchTerm(""),
                className: "clear-search",
                "aria-label": "Clear search",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }) })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sort-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "sortBy", children: "Sort by:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                id: "sortBy",
                value: sortBy,
                onChange: (e) => setSortBy(e.target.value),
                className: "sort-select",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name", children: "Name" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "created", children: "Created Date" }),
                  activeTab === "templates" && /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "supply", children: "Supply" })
                ]
              }
            )
          ] })
        ] }),
        searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-results-info", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "Found ",
          activeTab === "schemas" ? filteredSchemas.length : filteredTemplates.length,
          ' results for "',
          searchTerm,
          '"'
        ] }) }),
        activeTab === "schemas" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "schemas-section", children: filteredSchemas.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-state", children: searchTerm ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "empty-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No schemas found" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            'No schemas match your search "',
            searchTerm,
            '"'
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setSearchTerm(""), className: "clear-search-button", children: "Clear Search" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No schemas found for this collection." }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "schemas-grid", children: filteredSchemas.map((schema) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "schema-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "schema-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: schema.schema_name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "view-templates-btn",
                onClick: () => {
                  setSelectedSchema(schema.schema_name);
                  setActiveTab("templates");
                },
                children: "View Templates"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "schema-format", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Attributes:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attributes-list", children: schema.format.map((attr, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "attr-name", children: attr.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "attr-type", children: attr.type })
            ] }, index)) })
          ] })
        ] }, schema.schema_name)) }) }),
        activeTab === "templates" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "templates-section", children: [
          selectedSchema && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "schema-filter", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Filter by Schema:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: selectedSchema,
                onChange: (e) => setSelectedSchema(e.target.value),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "All Schemas" }),
                  schemas.map((schema) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: schema.schema_name, children: schema.schema_name }, schema.schema_name))
                ]
              }
            )
          ] }),
          filteredTemplates.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-state", children: searchTerm ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "empty-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No templates found" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              'No templates match your search "',
              searchTerm,
              '"'
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setSearchTerm(""), className: "clear-search-button", children: "Clear Search" })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "No templates found",
            selectedSchema ? ` for schema "${selectedSchema}"` : " for this collection",
            "."
          ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "templates-grid", children: filteredTemplates.map((template) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Link,
            {
              to: `/collections/${collectionName}/templates/${template.template_id}`,
              className: "template-card",
              children: [
                renderMediaElement(template, "template-image"),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: String(template.immutable_data?.name || `Template #${template.template_id}`) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "template-schema", children: [
                    "Template ID: ",
                    template.template_id
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "template-supply", children: [
                    "Supply: ",
                    formatSupply(template.issued_supply, template.max_supply)
                  ] })
                ] })
              ]
            },
            template.template_id
          )) })
        ] })
      ] })
    ] }),
    showImageZoom && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ImageZoom,
      {
        isOpen: showImageZoom,
        imageUrl: zoomedImage.url,
        imageName: zoomedImage.name,
        onClose: () => setShowImageZoom(false)
      }
    ),
    showShareModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ShareModal,
      {
        isOpen: showShareModal,
        onClose: () => setShowShareModal(false),
        title: collection?.name || collection?.collection_name || "Collection",
        description: String(collection?.data?.description || `Check out this amazing collection: ${collection?.name || collection?.collection_name}`),
        imageUrl: getImageUrl(collection?.img || ""),
        shareUrl: `${window.location.origin}/collections/${collection?.collection_name}`,
        defaultShareText: `Check out the ${collection?.name || collection?.collection_name} collection on PxMarket!  Explore it at market.pixeljourney.xyz`,
        type: "collection"
      }
    )
  ] });
});
CollectionDetail.displayName = "CollectionDetail";
const TemplateDetail = () => {
  const { collectionName, templateId } = useParams();
  const { settings } = useDisplaySettings();
  const [template, setTemplate] = reactExports.useState(null);
  const [collection, setCollection] = reactExports.useState(null);
  const [schema, setSchema] = reactExports.useState(null);
  const [assets, setAssets] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [assetsLoading, setAssetsLoading] = reactExports.useState(false);
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [hasMore, setHasMore] = reactExports.useState(true);
  const [showShareModal, setShowShareModal] = reactExports.useState(false);
  const assetsPerPage = 20;
  const loadTemplateData = reactExports.useCallback(async () => {
    if (!collectionName || !templateId) return;
    setLoading(true);
    try {
      const [templates2, collectionData, schemasData] = await Promise.all([
        apiService.getCollectionTemplates(collectionName),
        apiService.getCollectionDetails(collectionName),
        apiService.getCollectionSchemas(collectionName)
      ]);
      const templateData = templates2.find((t) => t.template_id === templateId);
      setTemplate(templateData || null);
      setCollection(collectionData);
      if (templateData) {
        const assets2 = await apiService.getCollectionAssets(collectionName, void 0, templateId, 1);
        if (assets2.length > 0) {
          const schemaName = assets2[0].schema_name;
          const schemaData = schemasData.find((s) => s.schema_name === schemaName);
          setSchema(schemaData || null);
        }
      }
    } catch (error) {
      console.error("Error loading template data:", error);
    } finally {
      setLoading(false);
    }
  }, [collectionName, templateId, setLoading, setTemplate, setCollection, setSchema]);
  const loadAssets = reactExports.useCallback(async (page) => {
    if (!collectionName || !templateId) return;
    setAssetsLoading(true);
    try {
      const assetsData = await apiService.getCollectionAssets(
        collectionName,
        void 0,
        // schemaName
        templateId,
        assetsPerPage
      );
      if (page === 1) {
        setAssets(assetsData);
      } else {
        setAssets((prev) => [...prev, ...assetsData]);
      }
      setHasMore(assetsData.length === assetsPerPage);
      setCurrentPage(page);
    } catch (error) {
      console.error("Error loading assets:", error);
    } finally {
      setAssetsLoading(false);
    }
  }, [collectionName, templateId, setAssetsLoading, setAssets, setHasMore, setCurrentPage]);
  reactExports.useEffect(() => {
    if (collectionName && templateId) {
      loadTemplateData();
      loadAssets(1);
    }
  }, [collectionName, templateId, loadTemplateData, loadAssets]);
  const loadMoreAssets = () => {
    if (!assetsLoading && hasMore) {
      loadAssets(currentPage + 1);
    }
  };
  const formatDate = (timestamp) => {
    return new Date(parseInt(timestamp) * 1e3).toLocaleDateString();
  };
  const renderAttributeValue = (value) => {
    if (typeof value === "object" && value !== null) {
      return JSON.stringify(value);
    }
    return String(value);
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading template details..." })
    ] }) });
  }
  if (!template) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Template Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        'The template "',
        templateId,
        '" could not be found in collection "',
        collectionName,
        '".'
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/collections/${collectionName}`, className: "back-link", children: " Back to Collection" })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-detail-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "breadcrumb", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/collections", className: "breadcrumb-link", children: "Collections" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-separator", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/collections/${collectionName}`, className: "breadcrumb-link", children: collection?.name || collectionName }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-separator", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-current", children: `Template #${templateId}` })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-image-container", children: template && /* @__PURE__ */ jsxRuntimeExports.jsx(
          MediaRenderer,
          {
            imageUrl: getTemplateImageUrl(template),
            videoUrl: getTemplateVideoUrl(template),
            alt: "Template",
            className: "template-image",
            enableAnimations: settings.enableAnimatedNFTs
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: `Template #${templateId}` }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "template-id", children: [
            "Template ID: ",
            template.template_id
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "template-schema", children: [
            "Schema: ",
            schema?.schema_name || "Loading..."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "template-collection", children: [
            "Collection: ",
            collection?.name || collection?.collection_name || "Loading..."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-stats", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: template.issued_supply }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Minted" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: template.max_supply === "0" ? "" : template.max_supply }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Max Supply" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: assets.length }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Assets Loaded" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "template-created", children: [
            "Created: ",
            formatDate(template.created_at_time)
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "share-btn",
              onClick: () => setShowShareModal(true),
              style: {
                marginTop: "20px",
                padding: "12px 24px",
                background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
                border: "none",
                borderRadius: "12px",
                color: "white",
                fontWeight: "600",
                cursor: "pointer",
                transition: "all 0.3s ease",
                display: "flex",
                alignItems: "center",
                gap: "8px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z" }) }),
                "Share Template"
              ]
            }
          )
        ] })
      ] }),
      template.immutable_data && Object.keys(template.immutable_data).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-attributes", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Template Attributes" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attributes-grid", children: Object.entries(template.immutable_data).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "attribute-name", children: key }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "attribute-value", children: renderAttributeValue(value) })
        ] }, key)) })
      ] }),
      schema && schema.format && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "schema-format", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Schema Format" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "format-grid", children: schema.format.map((field, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "format-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "format-name", children: String(field.name) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "format-type", children: String(field.type) })
        ] }, index)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "assets-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
          "Assets (",
          template.issued_supply,
          " total)"
        ] }),
        assets.length === 0 && !assetsLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-state", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No assets found for this template." }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "assets-grid", children: assets.map((asset) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Link,
            {
              to: `/assets/${asset.asset_id}`,
              className: "asset-card",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MediaRenderer,
                  {
                    imageUrl: getAssetImageUrl(asset),
                    videoUrl: getAssetVideoUrl(asset),
                    alt: asset.name || `Asset #${asset.asset_id}`,
                    className: "asset-image",
                    enableAnimations: settings.enableAnimatedNFTs
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: asset.name || `Asset #${asset.asset_id}` }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-id", children: [
                    "#",
                    asset.asset_id
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-owner", children: [
                    "Owner: ",
                    asset.owner
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-minted", children: [
                    "Minted: ",
                    formatDate(asset.minted_at_time)
                  ] })
                ] })
              ]
            },
            asset.asset_id
          )) }),
          hasMore && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "load-more-btn",
              onClick: loadMoreAssets,
              disabled: assetsLoading,
              children: assetsLoading ? "Loading..." : "Load More Assets"
            }
          ) })
        ] })
      ] })
    ] }),
    template && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ShareModal,
      {
        isOpen: showShareModal,
        onClose: () => setShowShareModal(false),
        title: `Template #${templateId}`,
        description: `${collection?.name || collection?.collection_name} collection`,
        imageUrl: getTemplateImageUrl(template),
        shareUrl: `${window.location.origin}/collections/${collectionName}/templates/${templateId}`,
        defaultShareText: `Check out this amazing template: Template #${templateId} from ${collection?.name || collection?.collection_name} collection!  View it at ${window.location.origin}/collections/${collectionName}/templates/${templateId}`,
        type: "template"
      }
    )
  ] });
};
const AssetDetail = () => {
  const { assetId } = useParams();
  const [asset, setAsset] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(false);
  const [listing, setListing] = reactExports.useState(null);
  const [listingLoading, setListingLoading] = reactExports.useState(false);
  const [usdPrice, setUsdPrice] = reactExports.useState("");
  const { isConnected, purchaseNFT, login } = useWallet$1();
  const { showSuccess, showError, showWarning } = useNotifications();
  const loadAssetData = reactExports.useCallback(async () => {
    if (!assetId) return;
    setLoading(true);
    try {
      const assetData = await apiService.getAssetDetails(assetId);
      setAsset(assetData);
    } catch (error) {
      log.error("Failed to load asset data", "AssetDetail.loadAssetData", error, { assetId });
    } finally {
      setLoading(false);
    }
  }, [assetId]);
  const checkListingStatus = reactExports.useCallback(async () => {
    if (!assetId) return;
    setListingLoading(true);
    try {
      const marketplaceData = await apiService.getMarketplaceNFTs({
        page: 1,
        limit: 1,
        asset_id: assetId
      });
      if (marketplaceData.data && marketplaceData.data.length > 0) {
        const saleData = marketplaceData.data[0];
        const nftAsset = {
          sale_id: saleData.sale_id,
          asset_id: saleData.asset_id,
          name: asset?.name || `Asset #${saleData.asset_id}`,
          image: String(asset?.data?.img || asset?.template?.immutable_data?.img || ""),
          price: saleData.price,
          seller: saleData.seller,
          collection: asset?.collection?.collection_name || "Unknown",
          schema: asset?.schema?.schema_name || "Unknown",
          template_mint: void 0,
          max_supply: asset?.template?.max_supply || void 0,
          traits: asset?.data ? Object.fromEntries(
            Object.entries(asset.data).filter(([, value]) => value !== void 0 && value !== null)
          ) : {}
        };
        setListing(nftAsset);
        if (nftAsset.price) {
          try {
            const priceValue = parseFloat(nftAsset.price.replace(" WAX", ""));
            const waxPriceResponse = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=wax&vs_currencies=usd");
            const waxPriceData = await waxPriceResponse.json();
            const waxToUsd = waxPriceData.wax?.usd || 0;
            const usdValue = (priceValue * waxToUsd).toFixed(2);
            setUsdPrice(`$${usdValue} USD`);
          } catch (error) {
            log.warn("Failed to fetch USD price for asset", "AssetDetail.checkListingStatus", { assetId, error: error.message });
          }
        }
      } else {
        setListing(null);
        setUsdPrice("");
      }
    } catch (error) {
      log.error("Failed to check listing status", "AssetDetail.checkListingStatus", error, { assetId });
      setListing(null);
    } finally {
      setListingLoading(false);
    }
  }, [assetId]);
  reactExports.useEffect(() => {
    if (assetId) {
      loadAssetData();
      checkListingStatus();
    }
  }, [assetId, loadAssetData, checkListingStatus]);
  const handlePurchase = async () => {
    if (!listing) return;
    try {
      if (!isConnected) {
        showWarning("Please connect your wallet to purchase this NFT");
        try {
          await login();
        } catch (error) {
          log.error("Wallet login failed during purchase", "AssetDetail.handlePurchase", error, { assetId, saleId: listing.sale_id });
          return;
        }
      }
      if (!listing.sale_id || !listing.price) {
        showError("This NFT is not available for purchase");
        return;
      }
      const priceValue = listing.price.replace(" WAX", "");
      log.info("Initiating NFT purchase", "AssetDetail.handlePurchase", { saleId: listing.sale_id, price: priceValue, assetId });
      await purchaseNFT(listing.sale_id, priceValue);
      showSuccess(`Successfully purchased ${listing.name || "NFT"}!`);
      checkListingStatus();
    } catch (error) {
      log.error("NFT purchase failed", "AssetDetail.handlePurchase", error, { assetId, saleId: listing?.sale_id, price: listing?.price });
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      showError(`Purchase failed: ${errorMessage}`);
    }
  };
  const getImageUrl = (imgPath) => {
    if (!imgPath) return "https://pixeljourney.xyz/img/toppixals/10.webp";
    if (imgPath.startsWith("http")) return imgPath;
    return createIPFSUrl(imgPath);
  };
  const getAssetImage = () => {
    if (!asset) return "https://pixeljourney.xyz/img/toppixals/10.webp";
    return getAssetImageUrl(asset) ?? "https://pixeljourney.xyz/img/toppixals/10.webp";
  };
  const getAssetVideo = () => {
    if (!asset) return null;
    return getAssetVideoUrl(asset);
  };
  const formatDate = (timestamp) => {
    return new Date(parseInt(timestamp) * 1e3).toLocaleString();
  };
  const renderAttributeValue = (value) => {
    if (value === null || value === void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "null-value", children: "null" });
    }
    if (typeof value === "boolean") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "boolean-value", children: value.toString() });
    }
    if (typeof value === "number") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "number-value", children: value.toLocaleString() });
    }
    if (typeof value === "object") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "object-value", children: JSON.stringify(value, null, 2) });
    }
    const strValue = String(value);
    if (strValue.match(/\.(jpg|jpeg|png|gif|webp)$/i) || strValue.startsWith("Qm")) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "image-attribute", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: getImageUrl(strValue),
            alt: "Attribute image",
            className: "attribute-image",
            onError: (e) => {
              e.currentTarget.style.display = "none";
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "image-hash", children: strValue })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "string-value", children: strValue });
  };
  const getAllAttributes = () => {
    if (!asset) return {};
    return {
      ...asset.template?.immutable_data,
      ...asset.data
    };
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading asset details..." })
    ] }) });
  }
  if (!asset) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Asset Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        'The asset "',
        assetId,
        '" could not be found.'
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/collections", className: "back-link", children: " Back to Collections" })
    ] }) });
  }
  const videoUrl = getAssetVideo();
  const allAttributes = getAllAttributes();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-content", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "breadcrumb", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", className: "breadcrumb-link", children: "Home" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-separator", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/collections", className: "breadcrumb-link", children: "Collections" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-separator", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/collections/${asset.collection.collection_name}`, className: "breadcrumb-link", children: asset.collection.name || asset.collection.collection_name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-separator", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "breadcrumb-current", children: asset.name || `Asset #${assetId}` })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-media-container", children: videoUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "video",
        {
          src: videoUrl,
          className: "asset-video",
          controls: true,
          poster: getAssetImage(),
          children: "Your browser does not support the video tag."
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: getAssetImage(),
          alt: asset.name || `Asset #${assetId}`,
          className: "asset-image",
          onError: () => {
          }
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: asset.name || `Asset #${assetId}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-id", children: [
          "Asset ID: ",
          asset.asset_id
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-links", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-collection", children: [
            "Collection:",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/collections/${asset.collection.collection_name}`, children: asset.collection.name || asset.collection.collection_name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-template", children: [
            "Template:",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/collections/${asset.collection.collection_name}/templates/${asset.template.template_id}`, children: asset.template?.immutable_data?.name || `#${asset.template.template_id}` })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-schema", children: [
            "Schema: ",
            asset.schema.schema_name
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-ownership", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "owner-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "owner-label", children: "Owner:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "owner-address", children: asset.owner })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "author-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "author-label", children: "Collection Author:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "author-address", children: asset.owner || "Unknown" })
          ] })
        ] }),
        listingLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-status loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Checking listing status..." }) }) : listing ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-status available", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Available for Sale" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-display", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-wax", children: listing.price }),
              usdPrice && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-usd", children: usdPrice })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "buy-now-btn",
              onClick: handlePurchase,
              disabled: !isConnected,
              children: isConnected ? "Buy Now" : "Connect Wallet to Buy"
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-status not-listed", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Not currently listed for sale" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-timestamps", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "timestamp", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "timestamp-label", children: "Minted:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "timestamp-value", children: formatDate(asset.minted_at_time) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "timestamp", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "timestamp-label", children: "Last Transfer:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "timestamp-value", children: formatDate(asset.transferred_at_time) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "timestamp", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "timestamp-label", children: "Last Update:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "timestamp-value", children: formatDate(asset.updated_at_time) })
          ] })
        ] }),
        asset.burned_by_account && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "burn-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "burn-label", children: " Burned by:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "burn-account", children: asset.burned_by_account }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "burn-time", children: formatDate(asset.burned_at_time) })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-info-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Template Information" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-stats", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-stat", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Template ID:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: asset.template.template_id })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-stat", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Max Supply:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: asset.template.max_supply === "0" ? "Unlimited" : asset.template.max_supply })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-stat", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Issued Supply:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: asset.template.issued_supply })
        ] })
      ] })
    ] }),
    Object.keys(allAttributes).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-attributes", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Attributes" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attributes-grid", children: Object.entries(allAttributes).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "attribute-name", children: key }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attribute-value", children: renderAttributeValue(value) })
      ] }, key)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "schema-format", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Schema Format" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "format-grid", children: asset.schema.format?.map((field, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "format-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "format-name", children: field.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "format-type", children: field.type })
      ] }, index)) })
    ] }),
    asset.backed_tokens && asset.backed_tokens.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "backed-tokens", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Backed Tokens" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tokens-list", children: asset.backed_tokens.map((token, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: JSON.stringify(token, null, 2) }) }, index)) })
    ] })
  ] }) });
};
const ListingDetail = () => {
  const { saleId } = useParams();
  const navigate = useNavigate();
  const [listing, setListing] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const [usdPrice, setUsdPrice] = reactExports.useState("");
  const [isDetailsModalOpen, setIsDetailsModalOpen] = reactExports.useState(false);
  const [isOfferModalOpen, setIsOfferModalOpen] = reactExports.useState(false);
  const [isShareModalOpen, setIsShareModalOpen] = reactExports.useState(false);
  const [showImageZoom, setShowImageZoom] = reactExports.useState(false);
  const [saleState, setSaleState] = reactExports.useState(0);
  reactExports.useEffect(() => {
    if (saleId) {
      loadListingData();
    }
  }, [saleId]);
  const loadListingData = async () => {
    if (!saleId) return;
    try {
      setLoading(true);
      setError(null);
      const url = `${apiService.atomicMarketAPI}/atomicmarket/v1/sales/${saleId}`;
      const response = await apiService.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const sale = data.data;
        setSaleState(sale.state);
        const nftAsset = {
          sale_id: sale.sale_id,
          asset_id: sale.assets[0]?.asset_id || "",
          name: sale.assets[0]?.name || `${sale.assets[0]?.collection?.collection_name || "Unknown"} #${sale.assets[0]?.asset_id}`,
          image: getAssetImage(sale.assets[0]),
          price: `${(parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision)).toFixed(4)} ${sale.price.token_symbol}`,
          seller: sale.seller,
          collection: sale.assets[0]?.collection?.collection_name || "Unknown",
          schema: sale.assets[0]?.schema?.schema_name || "Unknown",
          template_mint: parseInt(sale.assets[0]?.template?.template_id || "0") || 0,
          max_supply: sale.assets[0]?.template?.max_supply || "0",
          traits: Object.fromEntries(
            Object.entries(sale.assets[0]?.data || {}).map(([key, value]) => [
              key,
              value === null || value === void 0 ? "" : typeof value === "string" || typeof value === "number" || typeof value === "boolean" ? value : String(value)
            ])
          )
        };
        setListing(nftAsset);
        const waxPrice = parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision);
        const usdValue = await apiService.getUSDPrice(waxPrice);
        setUsdPrice(usdValue);
      } else {
        setError("Listing not found");
      }
    } catch (err) {
      console.error("Error loading listing:", err);
      setError(`Failed to load listing data: ${err instanceof Error ? err.message : "Unknown error"}`);
    } finally {
      setLoading(false);
    }
  };
  const getAssetImage = (asset) => {
    if (!asset) return "";
    if (asset.data?.img) {
      return asset.data.img.startsWith("http") ? asset.data.img : `https://ipfs.io/ipfs/${asset.data.img}`;
    }
    if (asset.data?.image) {
      return asset.data.image.startsWith("http") ? asset.data.image : `https://ipfs.io/ipfs/${asset.data.image}`;
    }
    if (asset.template?.immutable_data?.img) {
      return asset.template.immutable_data.img.startsWith("http") ? asset.template.immutable_data.img : `https://ipfs.io/ipfs/${asset.template.immutable_data.img}`;
    }
    if (asset.template?.immutable_data?.image) {
      return asset.template.immutable_data.image.startsWith("http") ? asset.template.immutable_data.image : `https://ipfs.io/ipfs/${asset.template.immutable_data.image}`;
    }
    return "https://pixeljourney.xyz/img/toppixals/10.webp";
  };
  const { isConnected, purchaseNFT, login } = useWallet$1();
  const { showSuccess, showError, showWarning } = useNotifications();
  const handlePurchase = async () => {
    if (!listing) return;
    try {
      if (!isConnected) {
        showWarning("Please connect your wallet to purchase this NFT");
        try {
          await login();
        } catch (error2) {
          log.error("Login failed", "ListingDetail", error2);
          return;
        }
      }
      if (!listing.sale_id || !listing.price) {
        showError("This NFT is not available for purchase");
        return;
      }
      const priceValue = listing.price.replace(" WAX", "");
      log.info("Purchasing NFT", "ListingDetail.handlePurchase", { saleId: listing.sale_id, price: priceValue });
      await purchaseNFT(listing.sale_id, priceValue);
      showSuccess(`Successfully purchased ${listing.name || "NFT"}!`);
      navigate("/marketplace");
    } catch (error2) {
      log.error("Purchase failed", "ListingDetail", error2);
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error occurred";
      showError(`Purchase failed: ${errorMessage}`);
    }
  };
  const handleSellerClick = () => {
    if (!listing || !listing.seller) return;
    navigate(`/user-profile-lookup?user=${encodeURIComponent(listing.seller)}`);
  };
  const handleCollectionClick = () => {
    if (!listing) return;
    navigate(`/collections/${listing.collection}`);
  };
  const handleAssetClick = () => {
    if (!listing || !listing.asset_id) return;
    navigate(`/assets/${listing.asset_id}`);
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading listing..." })
    ] }) });
  }
  if (error || !listing) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-detail-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Listing Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error || "The requested listing could not be found." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => navigate("/marketplace"), className: "btn-primary", children: "Back to Marketplace" })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-detail-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-detail-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => navigate(-1), className: "back-button", children: " Back" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Listing Details" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-detail-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-image-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listing-image", children: listing.image.includes(".mp4") || listing.image.includes(".webm") ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "video",
        {
          src: listing.image,
          controls: true,
          muted: true,
          loop: true,
          className: "listing-media"
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: listing.image,
            alt: listing.name,
            className: "listing-media",
            onError: (e) => {
              const target = e.target;
              target.src = "https://pixeljourney.xyz/img/toppixals/10.webp";
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "zoom-overlay",
            onClick: () => setShowImageZoom(true),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" })
            ] })
          }
        )
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-info-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: listing.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setIsDetailsModalOpen(true),
                className: "listing-detail-nav-btn",
                children: " View Details"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => setIsOfferModalOpen(true),
                className: "listing-detail-nav-btn",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 -8 72 72", fill: "currentColor", style: { width: "16px", height: "16px", marginRight: "8px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M64,12.78v17s-3.63.71-4.38.81-3.08.85-4.78-.78C52.22,27.25,42.93,18,42.93,18a3.54,3.54,0,0,0-4.18-.21c-2.36,1.24-5.87,3.07-7.33,3.78a3.37,3.37,0,0,1-5.06-2.64,3.44,3.44,0,0,1,2.1-3c3.33-2,10.36-6,13.29-7.52,1.78-1,3.06-1,5.51,1C50.27,12,53,14.27,53,14.27a2.75,2.75,0,0,0,2.26.43C58.63,14,64,12.78,64,12.78ZM27,41.5a3,3,0,0,0-3.55-4.09,3.07,3.07,0,0,0-.64-3,3.13,3.13,0,0,0-3-.75,3.07,3.07,0,0,0-.65-3,3.38,3.38,0,0,0-4.72.13c-1.38,1.32-2.27,3.72-1,5.14s2.64.55,3.72.3c-.3,1.07-1.2,2.07-.09,3.47s2.64.55,3.72.3c-.3,1.07-1.16,2.16-.1,3.46s2.84.61,4,.25c-.45,1.15-1.41,2.39-.18,3.79s4.08.75,5.47-.58a3.32,3.32,0,0,0,.3-4.68A3.18,3.18,0,0,0,27,41.5Zm25.35-8.82L41.62,22a3.53,3.53,0,0,0-3.77-.68c-1.5.66-3.43,1.56-4.89,2.24a8.15,8.15,0,0,1-3.29,1.1,5.59,5.59,0,0,1-3-10.34C29,12.73,34.09,10,34.09,10a6.46,6.46,0,0,0-5-2C25.67,8,18.51,12.7,18.51,12.7a5.61,5.61,0,0,1-4.93.13L8,10.89v19.4s1.59.46,3,1a6.33,6.33,0,0,1,1.56-2.47,6.17,6.17,0,0,1,8.48-.06,5.4,5.4,0,0,1,1.34,2.37,5.49,5.49,0,0,1,2.29,1.4A5.4,5.4,0,0,1,26,34.94a5.47,5.47,0,0,1,3.71,4,5.38,5.38,0,0,1,2.39,1.43,5.65,5.65,0,0,1,1.48,4.89a0,0,0,0,1,0,0s.8.9,1.29,1.39a2.46,2.46,0,0,0,3.48-3.48s2,2.48,4.28,1c2-1.4,1.69-3.06.74-4a3.19,3.19,0,0,0,4.77.13,2.45,2.45,0,0,0,.13-3.3s1.33,1.81,4,.12c1.89-1.6,1-3.43,0-4.39Z" }) }),
                  "Make Offer"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setIsShareModalOpen(true),
                className: "listing-detail-nav-btn",
                children: " Share"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-price-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-display", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-main", children: listing.price }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-usd", children: usdPrice }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sale-status-display", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `status-badge ${saleState === 1 ? "status-active" : saleState === 3 ? "status-sold" : "status-canceled"}`, children: saleState === 1 ? " Available" : saleState === 3 ? " Sold" : " Canceled" }) })
          ] }),
          saleState === 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handlePurchase, className: "listing-detail-nav-btn listing-detail-primary-btn purchase-btn", children: " Buy Now" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("button", { disabled: true, className: "listing-detail-nav-btn listing-detail-primary-btn purchase-btn", children: saleState === 3 ? " Sold" : " Not Available" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-label", children: "Collection:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value link", onClick: handleCollectionClick, children: listing.collection })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-label", children: "Schema:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value", children: listing.schema })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-label", children: "Asset ID:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value link", onClick: handleAssetClick, children: listing.asset_id })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-label", children: "Seller:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value link", onClick: handleSellerClick, children: listing.seller })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-label", children: "Sale ID:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value", children: listing.sale_id })
          ] }),
          listing.template_mint && listing.template_mint > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-label", children: "Mint:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-value", children: [
              listing.template_mint,
              " / ",
              listing.max_supply === "0" ? "" : listing.max_supply
            ] })
          ] })
        ] }),
        listing.traits && Object.keys(listing.traits).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listing-attributes", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Attributes" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attributes-grid", children: Object.entries(listing.traits).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "attribute-name", children: key }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "attribute-value", children: value })
          ] }, key)) })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NFTDetailsModal,
      {
        nft: listing,
        isOpen: isDetailsModalOpen,
        onClose: () => setIsDetailsModalOpen(false)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SendOfferModal,
      {
        nft: listing,
        isOpen: isOfferModalOpen,
        onClose: () => setIsOfferModalOpen(false)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SocialShare,
      {
        nft: listing,
        isOpen: isShareModalOpen,
        onClose: () => setIsShareModalOpen(false)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ImageZoom,
      {
        isOpen: showImageZoom,
        onClose: () => setShowImageZoom(false),
        imageUrl: listing.image,
        imageName: listing.name
      }
    )
  ] });
};
const TransactionDetails = () => {
  const { transactionId } = useParams();
  const navigate = useNavigate();
  const [transaction, setTransaction] = reactExports.useState(null);
  const [blockInfo, setBlockInfo] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const [activeTab, setActiveTab] = reactExports.useState("overview");
  reactExports.useEffect(() => {
    if (transactionId) {
      fetchTransactionDetails(transactionId);
    }
  }, [transactionId]);
  const fetchTransactionDetails = async (txId) => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch(`https://wax.eosrio.io/v1/history/get_transaction`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          id: txId
        })
      });
      if (!response.ok) {
        throw new Error(`Failed to fetch transaction: ${response.status}`);
      }
      const data = await response.json();
      if (!data.id) {
        throw new Error("Transaction not found");
      }
      const parsedTransaction = {
        transaction_id: data.id,
        block_num: data.block_num,
        block_time: data.block_time,
        action_name: data.trx?.transaction?.actions?.[0]?.name || "unknown",
        actor: data.trx?.transaction?.actions?.[0]?.authorization?.[0]?.actor || "unknown",
        receiver: data.trx?.transaction?.actions?.[0]?.account || "unknown",
        status: data.receipt?.status === "executed" ? "success" : "failed",
        cpu_usage_us: data.receipt?.cpu_usage_us || 0,
        net_usage_words: data.receipt?.max_net_usage_words || data.receipt?.net_usage_words || 0,
        traces: data.traces || []
      };
      const actionData = data.trx?.transaction?.actions?.[0]?.data;
      if (actionData) {
        if (actionData.asset_ids) {
          parsedTransaction.asset_id = actionData.asset_ids[0];
        }
        if (actionData.from) {
          parsedTransaction.from = actionData.from;
        }
        if (actionData.to) {
          parsedTransaction.to = actionData.to;
        }
        if (actionData.memo) {
          parsedTransaction.memo = actionData.memo;
        }
        if (actionData.listing_price_to_assert) {
          parsedTransaction.price = `${parseFloat(actionData.listing_price_to_assert.split(" ")[0])} WAX`;
        }
      }
      setTransaction(parsedTransaction);
      const blockResponse = await fetch(`https://wax.eosrio.io/v1/chain/get_block`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          block_num_or_id: data.block_num
        })
      });
      if (blockResponse.ok) {
        const blockData = await blockResponse.json();
        setBlockInfo({
          block_num: blockData.block_num,
          block_id: blockData.id,
          timestamp: blockData.timestamp,
          producer: blockData.producer,
          transaction_count: blockData.transactions?.length || 0
        });
      }
    } catch (err) {
      log.error("Error fetching transaction details", "TransactionDetails.fetchTransactionDetails", err);
      setError(err instanceof Error ? err.message : "Failed to load transaction details");
    } finally {
      setLoading(false);
    }
  };
  const formatDate = (dateString) => {
    return (/* @__PURE__ */ new Date(dateString + "Z")).toLocaleString();
  };
  const handleUserClick = (account) => {
    navigate(`/user-profile-lookup?user=${encodeURIComponent(account)}`);
  };
  const handleAssetClick = (assetId) => {
    navigate(`/assets/${assetId}`);
  };
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transaction-details-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading transaction details..." })
    ] }) }) });
  }
  if (error || !transaction) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transaction-details-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Transaction Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error || "The requested transaction could not be found." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => navigate(-1), className: "btn btn-primary", children: "Go Back" })
    ] }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-details-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => navigate(-1), className: "back-button", children: " Back" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-title", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Transaction Details" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-id", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "ID: ",
            transaction.transaction_id
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => copyToClipboard(transaction.transaction_id),
              className: "copy-button",
              title: "Copy transaction ID",
              children: ""
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `transaction-status ${transaction.status}`, children: [
        transaction.status === "success" ? "" : "",
        " ",
        transaction.status.toUpperCase()
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-navigation", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${activeTab === "overview" ? "active" : ""}`,
          onClick: () => setActiveTab("overview"),
          children: "Overview"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${activeTab === "traces" ? "active" : ""}`,
          onClick: () => setActiveTab("traces"),
          children: "Action Traces"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${activeTab === "raw" ? "active" : ""}`,
          onClick: () => setActiveTab("raw"),
          children: "Raw Data"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
      activeTab === "overview" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overview-tab", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Basic Information" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Block Number:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: transaction.block_num.toLocaleString() })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Timestamp:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatDate(transaction.block_time) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Action:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "action-name", children: transaction.action_name })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Contract:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "contract-name", children: transaction.receiver })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Transaction Parties" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Actor:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "clickable-account",
                  onClick: () => handleUserClick(transaction.actor),
                  children: transaction.actor
                }
              )
            ] }),
            transaction.from && transaction.from !== transaction.actor && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "From:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "clickable-account",
                  onClick: () => handleUserClick(transaction.from),
                  children: transaction.from
                }
              )
            ] }),
            transaction.to && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "To:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "clickable-account",
                  onClick: () => handleUserClick(transaction.to),
                  children: transaction.to
                }
              )
            ] })
          ] })
        ] }),
        (transaction.asset_id || transaction.price) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Asset Information" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
            transaction.asset_id && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Asset ID:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "clickable-asset",
                  onClick: () => handleAssetClick(transaction.asset_id),
                  children: transaction.asset_id
                }
              )
            ] }),
            transaction.asset_name && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Asset Name:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: transaction.asset_name })
            ] }),
            transaction.collection_name && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Collection:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: typeof transaction.collection_name === "string" ? transaction.collection_name : transaction.collection_name?.collection_name || transaction.collection_name?.name || "Unknown" })
            ] }),
            transaction.price && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Price:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price", children: transaction.price })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Resource Usage" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "CPU Usage:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                transaction.cpu_usage_us.toLocaleString(),
                " s"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "NET Usage:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                transaction.net_usage_words.toLocaleString(),
                " words"
              ] })
            ] })
          ] })
        ] }),
        blockInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Block Information" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Block ID:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "block-id", children: blockInfo.block_id })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Producer:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: blockInfo.producer })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Transactions in Block:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: blockInfo.transaction_count })
            ] })
          ] })
        ] }),
        transaction.memo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Memo" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "memo-content", children: transaction.memo })
        ] })
      ] }),
      activeTab === "traces" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "traces-tab", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Action Traces" }),
        transaction.traces && transaction.traces.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "traces-list", children: transaction.traces.map((trace, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "trace-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "trace-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "trace-index", children: [
              "#",
              index + 1
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "trace-action", children: trace.act?.name || "unknown" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "trace-account", children: trace.act?.account || "unknown" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "trace-data", children: JSON.stringify(trace, null, 2) })
        ] }, index)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No action traces available for this transaction." })
      ] }),
      activeTab === "raw" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "raw-tab", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Raw Transaction Data" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "raw-data", children: JSON.stringify(transaction, null, 2) })
      ] })
    ] })
  ] }) });
};
const StakingModal = ({
  isOpen,
  onClose,
  resourceType,
  action,
  onSuccess
}) => {
  const [amount, setAmount] = reactExports.useState("");
  const [isProcessing, setIsProcessing] = reactExports.useState(false);
  const { session, transact } = useWallet$1();
  const { showError } = useNotifications();
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!session || !amount || parseFloat(amount) <= 0) return;
    setIsProcessing(true);
    try {
      const waxAmount = `${parseFloat(amount).toFixed(8)} WAX`;
      if (action === "stake") {
        const actions = [{
          account: "eosio",
          name: "delegatebw",
          authorization: [{
            actor: session.actor.toString(),
            permission: session.permission.toString()
          }],
          data: {
            from: session.actor.toString(),
            receiver: session.actor.toString(),
            stake_net_quantity: resourceType === "net" ? waxAmount : "0.00000000 WAX",
            stake_cpu_quantity: resourceType === "cpu" ? waxAmount : "0.00000000 WAX",
            transfer: false
          }
        }];
        await transact(actions);
      } else {
        const actions = [{
          account: "eosio",
          name: "undelegatebw",
          authorization: [{
            actor: session.actor.toString(),
            permission: session.permission.toString()
          }],
          data: {
            from: session.actor.toString(),
            receiver: session.actor.toString(),
            unstake_net_quantity: resourceType === "net" ? waxAmount : "0.00000000 WAX",
            unstake_cpu_quantity: resourceType === "cpu" ? waxAmount : "0.00000000 WAX"
          }
        }];
        await transact(actions);
      }
      onSuccess?.();
      onClose();
    } catch (error) {
      log.error(`Failed to ${action} ${resourceType.toUpperCase()}`, "StakingModal.handleSubmit", error, { action, resourceType, amount });
      showError(`Failed to ${action} ${resourceType.toUpperCase()}. Please try again.`, "Transaction Failed");
    } finally {
      setIsProcessing(false);
    }
  };
  if (!isOpen) return null;
  const resourceName = resourceType.toUpperCase();
  const actionName = action === "stake" ? "Stake" : "Unstake";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
        actionName,
        " ",
        resourceName
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-icon", children: resourceType === "cpu" ? "" : "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-description", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
            resourceName,
            " ",
            actionName
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: action === "stake" ? `Stake WAX to increase your ${resourceName} resources. Staked tokens will be locked for 3 days after unstaking.` : `Unstake WAX from your ${resourceName} resources. Tokens will be available after a 3-day waiting period.` })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "amount", children: "Amount (WAX)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              id: "amount",
              value: amount,
              onChange: (e) => setAmount(e.target.value),
              placeholder: "Enter WAX amount",
              min: "0.00000001",
              step: "0.00000001",
              required: true,
              disabled: isProcessing
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: onClose,
              disabled: isProcessing,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary",
              disabled: isProcessing || !amount || parseFloat(amount) <= 0,
              children: isProcessing ? "Processing..." : `${actionName} ${resourceName}`
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const RAMModal = ({
  isOpen,
  onClose,
  action,
  onSuccess
}) => {
  const [amount, setAmount] = reactExports.useState("");
  const [isProcessing, setIsProcessing] = reactExports.useState(false);
  const [ramPrice, setRamPrice] = reactExports.useState(null);
  const [userRamBytes, setUserRamBytes] = reactExports.useState(null);
  const [isLoadingData, setIsLoadingData] = reactExports.useState(false);
  const { session, transact } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  reactExports.useEffect(() => {
    if (isOpen && session) {
      fetchRAMData();
    }
  }, [isOpen, session]);
  const fetchRAMData = async () => {
    if (!session) return;
    setIsLoadingData(true);
    try {
      const ramMarketResponse = await fetch("https://wax.greymass.com/v1/chain/get_table_rows", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          json: true,
          code: "eosio",
          scope: "eosio",
          table: "rammarket",
          limit: 1
        })
      });
      if (ramMarketResponse.ok) {
        const ramMarketData = await ramMarketResponse.json();
        if (ramMarketData.rows && ramMarketData.rows.length > 0) {
          const ramMarket = ramMarketData.rows[0];
          const waxBalance = parseFloat(ramMarket.quote.balance.split(" ")[0]);
          const ramSupply = parseFloat(ramMarket.base.balance.split(" ")[0]);
          const price = waxBalance / ramSupply;
          setRamPrice(price);
        }
      }
      const accountResponse = await fetch("https://wax.greymass.com/v1/chain/get_account", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ account_name: session.actor.toString() })
      });
      if (accountResponse.ok) {
        const accountData = await accountResponse.json();
        setUserRamBytes(accountData.ram_quota - accountData.ram_usage);
      }
    } catch (error) {
      log.error("Failed to fetch RAM market data", "RAMModal.fetchRAMData", error, { account: session?.actor.toString() });
    } finally {
      setIsLoadingData(false);
    }
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!session || !amount || parseFloat(amount) <= 0) return;
    if (action === "sell" && userRamBytes !== null) {
      const bytesToSell = Math.floor(parseFloat(amount));
      if (bytesToSell > userRamBytes) {
        showError("Insufficient RAM", `You only have ${userRamBytes.toLocaleString()} bytes available to sell.`);
        return;
      }
    }
    setIsProcessing(true);
    try {
      if (action === "buy") {
        const waxAmount = `${parseFloat(amount).toFixed(8)} WAX`;
        const actions = [{
          account: "eosio",
          name: "buyram",
          authorization: [{
            actor: WharfKitService.safeGetActor(session),
            permission: WharfKitService.safeGetPermission(session)
          }],
          data: {
            payer: WharfKitService.safeGetActor(session),
            receiver: WharfKitService.safeGetActor(session),
            quant: waxAmount
          }
        }];
        await transact(actions);
        showSuccess("RAM Purchase Successful", `Successfully purchased RAM with ${waxAmount}!`);
      } else {
        const bytes = Math.floor(parseFloat(amount));
        const actions = [{
          account: "eosio",
          name: "sellram",
          authorization: [{
            actor: WharfKitService.safeGetActor(session),
            permission: WharfKitService.safeGetPermission(session)
          }],
          data: {
            account: WharfKitService.safeGetActor(session),
            bytes
          }
        }];
        await transact(actions);
        showSuccess("RAM Sale Successful", `Successfully sold ${bytes.toLocaleString()} bytes of RAM!`);
      }
      onSuccess?.();
      onClose();
      setAmount("");
    } catch (error) {
      log.error(`Failed to ${action} RAM`, "RAMModal.handleSubmit", error, { action, amount, account: WharfKitService.safeGetActor(session) });
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      showError(`RAM ${action === "buy" ? "Purchase" : "Sale"} Failed`, errorMessage);
    } finally {
      setIsProcessing(false);
    }
  };
  if (!isOpen) return null;
  const actionName = action === "buy" ? "Buy" : "Sell";
  const inputLabel = action === "buy" ? "Amount (WAX)" : "Bytes to Sell";
  const inputPlaceholder = action === "buy" ? "Enter WAX amount" : "Enter bytes amount";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
        actionName,
        " RAM"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-description", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
            "RAM ",
            actionName
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: action === "buy" ? "Purchase RAM with WAX tokens. RAM is used to store account data and smart contract state." : "Sell RAM bytes back to the system for WAX tokens. Only sell RAM you don't need." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ram-market-info", children: isLoadingData ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-info", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading RAM market data..." }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            ramPrice !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Current RAM Price:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "stat-value", children: [
                (ramPrice * 1024).toFixed(8),
                " WAX/KB"
              ] })
            ] }),
            action === "sell" && userRamBytes !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Available RAM:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "stat-value", children: [
                userRamBytes.toLocaleString(),
                " bytes"
              ] })
            ] }),
            action === "buy" && ramPrice !== null && amount && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Estimated RAM:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "stat-value", children: [
                Math.floor(parseFloat(amount) / ramPrice).toLocaleString(),
                " bytes"
              ] })
            ] }),
            action === "sell" && ramPrice !== null && amount && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Estimated WAX:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "stat-value", children: [
                (parseFloat(amount) * ramPrice).toFixed(8),
                " WAX"
              ] })
            ] })
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "amount", children: inputLabel }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              id: "amount",
              value: amount,
              onChange: (e) => setAmount(e.target.value),
              placeholder: inputPlaceholder,
              min: action === "buy" ? "0.00000001" : "1",
              step: action === "buy" ? "0.00000001" : "1",
              required: true,
              disabled: isProcessing
            }
          ),
          action === "buy" && /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "form-hint", children: "Minimum: 0.00000001 WAX" }),
          action === "sell" && /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "form-hint", children: "Enter the number of bytes to sell" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: onClose,
              disabled: isProcessing,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary",
              disabled: isProcessing || !amount || parseFloat(amount) <= 0,
              children: isProcessing ? "Processing..." : `${actionName} RAM`
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const TokenTransferModal = ({ token, isOpen, onClose, onSuccess }) => {
  const [recipient, setRecipient] = reactExports.useState("");
  const [amount, setAmount] = reactExports.useState("");
  const [memo, setMemo] = reactExports.useState("");
  const [isTransferring, setIsTransferring] = reactExports.useState(false);
  const [recipients, setRecipients] = reactExports.useState([]);
  const [isBulkTransfer, setIsBulkTransfer] = reactExports.useState(false);
  const { session, transferTokens } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  const validateWaxAccount = (account) => {
    const waxAccountRegex = /^[a-z1-5.]{1,12}$/;
    return waxAccountRegex.test(account) && account.length >= 1 && account.length <= 12;
  };
  const validateAmount = (value) => {
    const numValue = parseFloat(value);
    const maxBalance = parseFloat(token?.balance || "0");
    return numValue > 0 && numValue <= maxBalance;
  };
  const parseRecipients = (recipientString) => {
    return recipientString.split(",").map((r) => r.trim().toLowerCase()).filter((r) => r.length > 0);
  };
  const handleRecipientChange = (value) => {
    setRecipient(value.toLowerCase());
    const parsedRecipients = parseRecipients(value);
    setRecipients(parsedRecipients);
    setIsBulkTransfer(parsedRecipients.length > 1);
  };
  const handleMaxClick = () => {
    if (token) {
      const balanceAmount = token.balance.split(" ")[0];
      setAmount(balanceAmount);
    }
  };
  const getAmountPerRecipient = () => {
    if (!amount || recipients.length === 0) return 0;
    return parseFloat(amount) / recipients.length;
  };
  const getTokenPrecision = (balance) => {
    const parts = balance.split(" ");
    if (parts.length > 0) {
      const decimalPart = parts[0].split(".")[1];
      return decimalPart ? decimalPart.length : 0;
    }
    return 8;
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!token || !session || !recipient.trim() || !amount.trim()) {
      showError("Validation Error", "Please fill in all required fields");
      return;
    }
    const invalidRecipients = recipients.filter((r) => !validateWaxAccount(r));
    if (invalidRecipients.length > 0) {
      showError(
        "Invalid Account Names",
        `Invalid WAX account names: ${invalidRecipients.join(", ")}. Account names must be 12 characters, lowercase letters and numbers 1-5.`
      );
      return;
    }
    if (!validateAmount(amount)) {
      showError(
        "Invalid Amount",
        "Please enter a valid amount that does not exceed your balance"
      );
      return;
    }
    setIsTransferring(true);
    try {
      const precision = getTokenPrecision(token.balance);
      const actions = [];
      if (isBulkTransfer && recipients.length > 1) {
        const amountPerRecipient = getAmountPerRecipient();
        const formattedAmountPerRecipient = amountPerRecipient.toFixed(precision) + " " + token.symbol;
        for (const recipientAccount of recipients) {
          actions.push({
            account: token.contract,
            name: "transfer",
            authorization: [{
              actor: session.actor,
              permission: session.permission
            }],
            data: {
              from: WharfKitService.safeGetActor(session),
              to: recipientAccount,
              quantity: formattedAmountPerRecipient,
              memo: memo.trim() || "Bulk transfer via PxMarket - market.pixeljourney.xyz"
            }
          });
        }
      } else {
        const formattedAmount = parseFloat(amount).toFixed(precision) + " " + token.symbol;
        actions.push({
          account: token.contract,
          name: "transfer",
          authorization: [{
            actor: WharfKitService.safeGetActor(session),
            permission: WharfKitService.safeGetPermission(session)
          }],
          data: {
            from: WharfKitService.safeGetActor(session),
            to: recipients[0] || recipient.trim(),
            quantity: formattedAmount,
            memo: memo.trim() || "Transferred via PxMarket - market.pixeljourney.xyz"
          }
        });
      }
      if (isBulkTransfer) {
        let successCount = 0;
        for (const recipientAccount of recipients) {
          try {
            if (!transferTokens) {
              log.error("transferTokens service not available", "TokenTransferModal");
              continue;
            }
            const result = await transferTokens(
              recipientAccount,
              getAmountPerRecipient().toString(),
              token.symbol,
              memo.trim() || "Bulk transfer via PxMarket - market.pixeljourney.xyz"
            );
            if (result) successCount++;
          } catch (error) {
            log.error(`Transfer to ${recipientAccount} failed`, "TokenTransferModal", error);
          }
        }
        if (successCount > 0) {
          const successMessage = successCount === recipients.length ? `${amount} ${token.symbol} transferred to all ${recipients.length} recipients successfully!` : `${amount} ${token.symbol} transferred to ${successCount}/${recipients.length} recipients successfully!`;
          showSuccess("Bulk Transfer Complete", successMessage);
        }
      } else {
        if (!transferTokens) {
          showError("Transfer Error", "Transfer service not available");
          return;
        }
        const result = await transferTokens(
          recipients[0] || recipient.trim(),
          amount,
          token.symbol,
          memo.trim() || "Transferred via PxMarket - market.pixeljourney.xyz"
        );
        if (result) {
          showSuccess("Transfer Successful", `${amount} ${token.symbol} transferred successfully!`);
        }
      }
      onSuccess?.();
      onClose();
      setRecipient("");
      setAmount("");
      setMemo("");
      setRecipients([]);
      setIsBulkTransfer(false);
    } catch (error) {
      log.error("Token transfer failed", "TokenTransferModal", error);
      showError(
        "Transfer Failed",
        error instanceof Error ? error.message : "Unknown error occurred"
      );
    } finally {
      setIsTransferring(false);
    }
  };
  const handleClose = () => {
    if (!isTransferring) {
      setRecipient("");
      setAmount("");
      setMemo("");
      setRecipients([]);
      setIsBulkTransfer(false);
      onClose();
    }
  };
  if (!isOpen || !token) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content token-transfer-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
        "Transfer ",
        token.symbol
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "modal-close",
          onClick: handleClose,
          disabled: isTransferring,
          children: ""
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-preview", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: token.symbol }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "token-contract", children: token.contract }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "token-balance", children: [
            "Available: ",
            token.balance,
            " ",
            token.symbol
          ] }),
          token.value !== "N/A" && token.value !== "0.00" && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "token-usd-value", children: [
            " $",
            token.value,
            " USD"
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "modal-form token-transfer-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "recipient", children: isBulkTransfer ? "Recipients (comma-separated) *" : "Recipient WAX Account *" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "recipient",
              value: recipient,
              onChange: (e) => handleRecipientChange(e.target.value),
              placeholder: isBulkTransfer ? "e.g. pixeljourney,market.pxj,council.pxj" : "e.g. pixeljourney",
              required: true,
              disabled: isTransferring,
              className: "recipient-input"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "input-help", children: isBulkTransfer ? `Enter WAX account names separated by commas (${recipients.length} recipients detected)` : "Enter a valid WAX account name (12 characters, lowercase letters and numbers 1-5)" }),
          isBulkTransfer && recipients.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipients-preview", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Recipients:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: recipients.map((rec, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: validateWaxAccount(rec) ? "valid" : "invalid", children: [
              rec,
              " ",
              !validateWaxAccount(rec) && ""
            ] }, index)) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "amount", children: "Amount *" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "amount-input-wrapper", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                id: "amount",
                value: amount,
                onChange: (e) => setAmount(e.target.value),
                placeholder: "0.00000000",
                step: "0.00000001",
                min: "0",
                max: token.balance.split(" ")[0],
                required: true,
                disabled: isTransferring,
                className: "amount-input"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "max-btn",
                onClick: handleMaxClick,
                disabled: isTransferring,
                children: "MAX"
              }
            )
          ] }),
          isBulkTransfer && recipients.length > 1 && amount && /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { className: "distribution-info", children: [
            "Each recipient will receive: ",
            getAmountPerRecipient().toFixed(getTokenPrecision(token.balance)),
            " ",
            token.symbol
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "memo", children: "Memo (Optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "memo",
              value: memo,
              onChange: (e) => setMemo(e.target.value),
              placeholder: "Optional transfer message",
              maxLength: 256,
              disabled: isTransferring,
              className: "memo-input"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transfer-warning", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "warning-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Warning:" }),
            " This action cannot be undone. Make sure you trust the recipient and have entered the correct account name and amount."
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn-secondary",
              onClick: handleClose,
              disabled: isTransferring,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary transfer-btn",
              disabled: isTransferring || !recipient.trim() || !amount.trim() || !validateWaxAccount(recipient.trim()) || !validateAmount(amount),
              children: isTransferring ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
                isBulkTransfer ? "Bulk Transferring..." : "Transferring..."
              ] }) : isBulkTransfer ? `Bulk Transfer ${token.symbol}` : `Transfer ${token.symbol}`
            }
          )
        ] })
      ] })
    ] })
  ] }) });
};
const PortfolioAnalytics = () => {
  const { isConnected, account } = useWallet$1();
  const [portfolioMetrics, setPortfolioMetrics] = reactExports.useState(null);
  const [collectionPerformance, setCollectionPerformance] = reactExports.useState([]);
  const [insights, setInsights] = reactExports.useState([]);
  const [timeSeriesData, setTimeSeriesData] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [selectedTimeframe, setSelectedTimeframe] = reactExports.useState("30d");
  const [selectedView, setSelectedView] = reactExports.useState("overview");
  const generateTimeSeriesData = reactExports.useCallback(async (metrics) => {
    if (!account) return;
    try {
      const transactions = await apiService.getUserTransactions(account, 1e3);
      const days = selectedTimeframe === "7d" ? 7 : selectedTimeframe === "30d" ? 30 : selectedTimeframe === "90d" ? 90 : 365;
      const data = [];
      const now = /* @__PURE__ */ new Date();
      for (let i = days; i >= 0; i--) {
        const targetDate = new Date(now);
        targetDate.setDate(targetDate.getDate() - i);
        const targetTimestamp = targetDate.getTime();
        const relevantTransactions = transactions.filter((tx) => {
          const txDate = new Date(tx.block_time).getTime();
          return txDate <= targetTimestamp;
        });
        let valueAtDate = 0;
        let investedAtDate = 0;
        relevantTransactions.forEach((tx) => {
          if (tx.type === "purchase" && tx.price) {
            const price = parseFloat(tx.price.replace(/[^0-9.-]/g, "") || "0");
            investedAtDate += price;
            valueAtDate += price;
          } else if (tx.type === "sale" && tx.price) {
            const price = parseFloat(tx.price.replace(/[^0-9.-]/g, "") || "0");
            valueAtDate -= price;
          }
        });
        if (i === 0) {
          valueAtDate = metrics.totalValue;
          investedAtDate = metrics.totalInvested;
        } else if (valueAtDate === 0 && investedAtDate === 0) {
          valueAtDate = 0;
          investedAtDate = 0;
        }
        data.push({
          date: targetDate.toISOString().split("T")[0],
          value: valueAtDate,
          invested: investedAtDate
        });
      }
      setTimeSeriesData(data);
    } catch (error) {
      console.error("Error generating time series data:", error);
      const data = [];
      const days = selectedTimeframe === "7d" ? 7 : selectedTimeframe === "30d" ? 30 : selectedTimeframe === "90d" ? 90 : 365;
      for (let i = days; i >= 0; i--) {
        const date = /* @__PURE__ */ new Date();
        date.setDate(date.getDate() - i);
        data.push({
          date: date.toISOString().split("T")[0],
          value: i === 0 ? metrics.totalValue : metrics.totalValue * 0.95,
          // Slight historical discount
          invested: metrics.totalInvested
        });
      }
      setTimeSeriesData(data);
    }
  }, [account, selectedTimeframe]);
  const calculatePortfolioMetrics = reactExports.useCallback(async () => {
    if (!account) return;
    setLoading(true);
    try {
      const inventory = await apiService.getUserInventory(account);
      const transactions = await apiService.getUserTransactions(account);
      let totalValue = 0;
      let totalInvested = 0;
      const collectionData = {};
      for (const nft of inventory) {
        const currentPrice = parseFloat(nft.price || "0");
        totalValue += currentPrice;
        const purchaseTransaction = transactions.find(
          (tx) => tx.asset_id === nft.asset_id && tx.type === "purchase"
        );
        const investedAmount = purchaseTransaction ? parseFloat(purchaseTransaction.price || "0") : currentPrice;
        totalInvested += investedAmount;
        if (!collectionData[nft.collection]) {
          collectionData[nft.collection] = {
            collection: nft.collection,
            totalValue: 0,
            totalInvested: 0,
            profitLoss: 0,
            profitLossPercentage: 0,
            nftCount: 0,
            averagePrice: 0,
            floorPrice: 0,
            performance: "neutral"
          };
        }
        collectionData[nft.collection].totalValue += currentPrice;
        collectionData[nft.collection].totalInvested += investedAmount;
        collectionData[nft.collection].nftCount += 1;
      }
      const collections = Object.values(collectionData).map((collection) => {
        collection.profitLoss = collection.totalValue - collection.totalInvested;
        collection.profitLossPercentage = collection.totalInvested > 0 ? collection.profitLoss / collection.totalInvested * 100 : 0;
        collection.averagePrice = collection.nftCount > 0 ? collection.totalValue / collection.nftCount : 0;
        if (collection.profitLossPercentage > 20) collection.performance = "excellent";
        else if (collection.profitLossPercentage > 5) collection.performance = "good";
        else if (collection.profitLossPercentage > -5) collection.performance = "neutral";
        else collection.performance = "poor";
        return collection;
      });
      const profitLoss = totalValue - totalInvested;
      const profitLossPercentage = totalInvested > 0 ? profitLoss / totalInvested * 100 : 0;
      const sortedByPerformance = collections.sort((a, b) => b.profitLossPercentage - a.profitLossPercentage);
      const bestPerforming = sortedByPerformance[0]?.collection || "N/A";
      const worstPerforming = sortedByPerformance[sortedByPerformance.length - 1]?.collection || "N/A";
      const averageHoldingTime = 45;
      const metrics = {
        totalValue,
        totalInvested,
        profitLoss,
        profitLossPercentage,
        totalNFTs: inventory.length,
        uniqueCollections: collections.length,
        averageHoldingTime,
        bestPerformingCollection: bestPerforming,
        worstPerformingCollection: worstPerforming
      };
      setPortfolioMetrics(metrics);
      setCollectionPerformance(collections);
      generateInsights(metrics, collections);
      await generateTimeSeriesData(metrics);
    } catch (error) {
      console.error("Error calculating portfolio metrics:", error);
    } finally {
      setLoading(false);
    }
  }, [account, generateTimeSeriesData]);
  const generateInsights = (metrics, collections) => {
    const newInsights = [];
    if (metrics.profitLoss > 0) {
      newInsights.push({
        type: "profit",
        title: "Portfolio in Profit",
        description: `Your portfolio has gained ${metrics.profitLossPercentage.toFixed(1)}% since initial investment`,
        value: `+${metrics.profitLoss.toFixed(2)} WAX`
      });
    } else if (metrics.profitLoss < 0) {
      newInsights.push({
        type: "loss",
        title: "Portfolio Underperforming",
        description: `Your portfolio is down ${Math.abs(metrics.profitLossPercentage).toFixed(1)}% from initial investment`,
        value: `${metrics.profitLoss.toFixed(2)} WAX`
      });
    }
    const bestCollection = collections.find((c) => c.collection === metrics.bestPerformingCollection);
    if (bestCollection && bestCollection.profitLossPercentage > 10) {
      newInsights.push({
        type: "profit",
        title: "Top Performer",
        description: `${bestCollection.collection} is your best performing collection`,
        value: `+${bestCollection.profitLossPercentage.toFixed(1)}%`,
        collection: bestCollection.collection
      });
    }
    if (collections.length < 3) {
      newInsights.push({
        type: "opportunity",
        title: "Diversification Opportunity",
        description: "Consider diversifying across more collections to reduce risk",
        value: `${collections.length} collections`
      });
    }
    const largestCollection = collections.reduce(
      (max, collection) => collection.totalValue > max.totalValue ? collection : max,
      collections[0]
    );
    if (largestCollection && largestCollection.totalValue / metrics.totalValue > 0.6) {
      newInsights.push({
        type: "warning",
        title: "High Concentration Risk",
        description: `${largestCollection.collection} represents over 60% of your portfolio`,
        collection: largestCollection.collection
      });
    }
    setInsights(newInsights);
  };
  reactExports.useEffect(() => {
    if (isConnected && account) {
      calculatePortfolioMetrics();
    }
  }, [isConnected, account, calculatePortfolioMetrics]);
  const formatWAX = (amount) => {
    return `${amount.toFixed(2)} WAX`;
  };
  const formatPercentage = (percentage) => {
    const sign = percentage >= 0 ? "+" : "";
    return `${sign}${percentage.toFixed(1)}%`;
  };
  if (!isConnected) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portfolio-analytics", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-connection-prompt", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Connect Your Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your WAX wallet to view detailed portfolio analytics and investment insights." })
    ] }) });
  }
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portfolio-analytics", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Analyzing your portfolio..." })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portfolio-analytics", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "analytics-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Portfolio Analytics" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "analytics-controls", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "timeframe-selector", children: ["7d", "30d", "90d", "1y"].map((timeframe) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `timeframe-btn ${selectedTimeframe === timeframe ? "active" : ""}`,
            onClick: () => setSelectedTimeframe(timeframe),
            children: timeframe
          },
          timeframe
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "view-selector", children: ["overview", "collections", "insights"].map((view) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `view-btn ${selectedView === view ? "active" : ""}`,
            onClick: () => setSelectedView(view),
            children: view.charAt(0).toUpperCase() + view.slice(1)
          },
          view
        )) })
      ] })
    ] }),
    selectedView === "overview" && portfolioMetrics && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overview-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metrics-grid", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-card primary", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Total Portfolio Value" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-icon", children: "" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-value", children: formatWAX(portfolioMetrics.totalValue) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `metric-change ${portfolioMetrics.profitLoss >= 0 ? "positive" : "negative"}`, children: [
            formatPercentage(portfolioMetrics.profitLossPercentage),
            " (",
            formatWAX(portfolioMetrics.profitLoss),
            ")"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Total Invested" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-icon", children: "" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-value", children: formatWAX(portfolioMetrics.totalInvested) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "NFTs Owned" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-icon", children: "" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "metric-value", children: portfolioMetrics.totalNFTs }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-subtitle", children: [
            portfolioMetrics.uniqueCollections,
            " collections"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Avg. Holding Time" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-icon", children: "" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metric-value", children: [
            portfolioMetrics.averageHoldingTime,
            "d"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "performance-chart", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Portfolio Performance" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chart-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "performance-svg", viewBox: "0 0 800 200", children: timeSeriesData.map((point, index) => {
            const x = index / (timeSeriesData.length - 1) * 780 + 10;
            const y = 190 - point.value / Math.max(...timeSeriesData.map((d) => d.value)) * 180;
            const investedY = 190 - point.invested / Math.max(...timeSeriesData.map((d) => d.value)) * 180;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
              index > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: (index - 1) / (timeSeriesData.length - 1) * 780 + 10,
                    y1: 190 - timeSeriesData[index - 1].value / Math.max(...timeSeriesData.map((d) => d.value)) * 180,
                    x2: x,
                    y2: y,
                    stroke: "#4CAF50",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: (index - 1) / (timeSeriesData.length - 1) * 780 + 10,
                    y1: 190 - timeSeriesData[index - 1].invested / Math.max(...timeSeriesData.map((d) => d.value)) * 180,
                    x2: x,
                    y2: investedY,
                    stroke: "#FF9800",
                    strokeWidth: "2",
                    strokeDasharray: "5,5"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: x, cy: y, r: "3", fill: "#4CAF50" })
            ] }, index);
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chart-legend", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "legend-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "legend-color", style: { backgroundColor: "var(--success-color)" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Current Value" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "legend-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "legend-color dashed", style: { backgroundColor: "var(--warning-color)" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Invested Amount" })
            ] })
          ] })
        ] })
      ] })
    ] }),
    selectedView === "collections" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collections-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Collection Performance" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collections-grid", children: collectionPerformance.map((collection, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `collection-card ${collection.performance}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: collection.collection }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `performance-badge ${collection.performance}`, children: collection.performance })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-metrics", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-metric", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-label", children: "Value:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-value", children: formatWAX(collection.totalValue) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-metric", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-label", children: "P&L:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `metric-value ${collection.profitLoss >= 0 ? "positive" : "negative"}`, children: formatPercentage(collection.profitLossPercentage) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-metric", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-label", children: "NFTs:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-value", children: collection.nftCount })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-metric", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-label", children: "Avg Price:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "metric-value", children: formatWAX(collection.averagePrice) })
          ] })
        ] })
      ] }, index)) })
    ] }),
    selectedView === "insights" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "insights-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Investment Insights" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "insights-grid", children: insights.map((insight, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `insight-card ${insight.type}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "insight-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `insight-icon ${insight.type}`, children: [
            insight.type === "profit" && "",
            insight.type === "loss" && "",
            insight.type === "opportunity" && "",
            insight.type === "warning" && ""
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: insight.title }),
          insight.value && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "insight-value", children: insight.value })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "insight-description", children: insight.description }),
        insight.collection && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "insight-collection", children: [
          "Collection: ",
          insight.collection
        ] })
      ] }, index)) })
    ] })
  ] });
};
const useGetAccountResources = () => {
  const { account, session } = useWallet$1();
  const [resources, setResources] = reactExports.useState(null);
  const [resourcesAreLoading, setResourcesAreLoading] = reactExports.useState(false);
  const getResources = reactExports.useCallback(async (accountName = null) => {
    if (!session && !accountName) {
      log.warn("No wallet session or account name provided");
      return;
    }
    const targetAccount = accountName || account;
    if (!targetAccount) {
      log.warn("No target account found");
      return;
    }
    setResourcesAreLoading(true);
    try {
      const { apiService: apiService2 } = await __vitePreload(async () => {
        const { apiService: apiService3 } = await Promise.resolve().then(() => api);
        return { apiService: apiService3 };
      }, true ? void 0 : void 0);
      const accountData = await apiService2.getWaxAccountInfo(targetAccount);
      if (!accountData) {
        throw new Error("Failed to fetch account resources: No data returned");
      }
      const resourceData = {
        account_name: targetAccount,
        cpu_limit: {
          used: accountData.cpu_limit?.used || 0,
          available: accountData.cpu_limit?.available || 0,
          max: accountData.cpu_limit?.max || 0
        },
        net_limit: {
          used: accountData.net_limit?.used || 0,
          available: accountData.net_limit?.available || 0,
          max: accountData.net_limit?.max || 0
        },
        ram_usage: accountData.ram_usage || 0,
        ram_quota: accountData.ram_quota || 0,
        total_resources: accountData.total_resources || {},
        self_delegated_bandwidth: accountData.self_delegated_bandwidth || {},
        refund_request: accountData.refund_request || null,
        voter_info: accountData.voter_info || null
      };
      setResources(resourceData);
      log.info("Account resources fetched:", resourceData);
    } catch (error) {
      log.error("Error fetching account resources:", error);
      setResources(null);
    } finally {
      setResourcesAreLoading(false);
    }
  }, [session, account]);
  return [resources, getResources, resourcesAreLoading];
};
const useGetPowerupState = () => {
  const [powerupState, setPowerupState] = reactExports.useState(null);
  const [powerupStateIsLoading, setPowerupStateIsLoading] = reactExports.useState(false);
  const getPowerupState = reactExports.useCallback(async () => {
    setPowerupStateIsLoading(true);
    try {
      const { apiService: apiService2 } = await __vitePreload(async () => {
        const { apiService: apiService3 } = await Promise.resolve().then(() => api);
        return { apiService: apiService3 };
      }, true ? void 0 : void 0);
      const data = await apiService2.getPowerupState();
      if (data.rows && data.rows.length > 0) {
        const state = data.rows[0];
        const powerupStateData = {
          version: state.version || 0,
          net: {
            version: state.net?.version || 0,
            weight: state.net?.weight || "0",
            weight_ratio: state.net?.weight_ratio || "0",
            assumed_stake_weight: state.net?.assumed_stake_weight || "0",
            initial_weight_ratio: state.net?.initial_weight_ratio || "0",
            target_weight_ratio: state.net?.target_weight_ratio || "0",
            initial_timestamp: state.net?.initial_timestamp || "",
            target_timestamp: state.net?.target_timestamp || "",
            exponent: state.net?.exponent || 2,
            decay_secs: state.net?.decay_secs || 86400,
            min_price: state.net?.min_price || "0",
            max_price: state.net?.max_price || "0",
            utilization: state.net?.utilization || "0",
            adjusted_utilization: state.net?.adjusted_utilization || "0",
            utilization_timestamp: state.net?.utilization_timestamp || ""
          },
          cpu: {
            version: state.cpu?.version || 0,
            weight: state.cpu?.weight || "0",
            weight_ratio: state.cpu?.weight_ratio || "0",
            assumed_stake_weight: state.cpu?.assumed_stake_weight || "0",
            initial_weight_ratio: state.cpu?.initial_weight_ratio || "0",
            target_weight_ratio: state.cpu?.target_weight_ratio || "0",
            initial_timestamp: state.cpu?.initial_timestamp || "",
            target_timestamp: state.cpu?.target_timestamp || "",
            exponent: state.cpu?.exponent || 2,
            decay_secs: state.cpu?.decay_secs || 86400,
            min_price: state.cpu?.min_price || "0",
            max_price: state.cpu?.max_price || "0",
            utilization: state.cpu?.utilization || "0",
            adjusted_utilization: state.cpu?.adjusted_utilization || "0",
            utilization_timestamp: state.cpu?.utilization_timestamp || ""
          },
          powerup_days: state.powerup_days || 1,
          min_powerup_fee: state.min_powerup_fee || "0.0001 WAX"
        };
        setPowerupState(powerupStateData);
      } else {
        console.warn("No powerup state data found");
        setPowerupState(null);
      }
    } catch (error) {
      console.error("Error fetching powerup state:", error);
      setPowerupState(null);
    } finally {
      setPowerupStateIsLoading(false);
    }
  }, []);
  return [powerupState, getPowerupState, powerupStateIsLoading];
};
const useGetChainInfo = () => {
  const [chainInfo, setChainInfo] = reactExports.useState(null);
  const [chainInfoIsLoading, setChainInfoIsLoading] = reactExports.useState(false);
  const getChainInfo = reactExports.useCallback(async () => {
    setChainInfoIsLoading(true);
    try {
      const { apiService: apiService2 } = await __vitePreload(async () => {
        const { apiService: apiService3 } = await Promise.resolve().then(() => api);
        return { apiService: apiService3 };
      }, true ? void 0 : void 0);
      const data = await apiService2.getChainInfo();
      const chainInfoData = {
        server_version: data.server_version || "",
        chain_id: data.chain_id || "",
        head_block_num: data.head_block_num || 0,
        last_irreversible_block_num: data.last_irreversible_block_num || 0,
        last_irreversible_block_id: data.last_irreversible_block_id || "",
        head_block_id: data.head_block_id || "",
        head_block_time: data.head_block_time || "",
        head_block_producer: data.head_block_producer || "",
        virtual_block_cpu_limit: data.virtual_block_cpu_limit || 0,
        virtual_block_net_limit: data.virtual_block_net_limit || 0,
        block_cpu_limit: data.block_cpu_limit || 0,
        block_net_limit: data.block_net_limit || 0,
        server_version_string: data.server_version_string || "",
        fork_db_head_block_num: data.fork_db_head_block_num || 0,
        fork_db_head_block_id: data.fork_db_head_block_id || ""
      };
      setChainInfo(chainInfoData);
    } catch (error) {
      console.error("Error fetching chain info:", error);
      setChainInfo(null);
    } finally {
      setChainInfoIsLoading(false);
    }
  }, []);
  return [chainInfo, getChainInfo, chainInfoIsLoading];
};
const defaultSpinnerDuration = 3e3;
const defaultTxSettings = {};
const PROCESSING_TX_TEXT = "Processing transaction...";
const POWERUP_FRAC = 1e15;
function calculateAmount(frac, state) {
  if (!frac) return 0;
  return frac * parseFloat(state.weight) / POWERUP_FRAC;
}
function calcPowerupFee(state, utilizationIncrease) {
  if (utilizationIncrease <= 0) return 0;
  const max_price = parseFloat(state.max_price.split(" ")[0]);
  const min_price = parseFloat(state.min_price.split(" ")[0]);
  const priceIntegralDelta = (startUtilization2, endUtilization2) => {
    const coefficient = (max_price - min_price) / parseFloat(state.exponent);
    const startU = startUtilization2 / parseFloat(state.weight);
    const endU = endUtilization2 / parseFloat(state.weight);
    const delta = min_price * endU - min_price * startU + coefficient * (Math.pow(endU, parseFloat(state.exponent)) - Math.pow(startU, parseFloat(state.exponent)));
    return delta;
  };
  const priceFunction = (utilization) => {
    let price = min_price;
    const newExponent = state.exponent - 1;
    if (newExponent <= 0) {
      return max_price;
    } else {
      price += (max_price - min_price) * Math.pow(parseFloat(utilization) / state.weight, newExponent);
    }
    return price;
  };
  let fee2 = 0;
  let startUtilization = parseFloat(state.utilization);
  let endUtilization = parseFloat(startUtilization) + parseFloat(utilizationIncrease);
  if (startUtilization < parseFloat(state.adjusted_utilization)) {
    fee2 += priceFunction(parseFloat(state.adjusted_utilization)) * Math.min(parseFloat(utilizationIncrease), parseFloat(state.adjusted_utilization) - parseFloat(startUtilization)) / parseFloat(state.weight);
    startUtilization = parseFloat(state.adjusted_utilization);
  }
  if (startUtilization < endUtilization) {
    fee2 += priceIntegralDelta(startUtilization, endUtilization);
  }
  const min_fee = 1e-8;
  const threshold = 1e-8;
  if (fee2 < threshold) {
    if (fee2 < min_fee) {
      return min_fee.toFixed(8);
    } else {
      return fee2.toPrecision(1).replace(/e-9/, "0.00000000");
    }
  } else {
    return fee2.toFixed(8);
  }
}
const cpu_frac_to_submit = 1e11;
const net_frac_to_submit = 2e9;
const waxToCpuFrac = (amount, cpuAllocation) => {
  if (!amount || cpuAllocation === void 0) {
    return 0;
  }
  const cpuFraction = cpuAllocation / 100;
  return cpuFraction * cpu_frac_to_submit;
};
const waxToNetFrac = (amount, cpuAllocation) => {
  if (!amount || cpuAllocation === void 0) {
    return 0;
  }
  const netFraction = (100 - cpuAllocation) / 100;
  return netFraction * net_frac_to_submit;
};
function predictResourceAmounts(cpuFrac, netFrac, cpuState, netState) {
  const cpuAmount = calculateAmount(cpuFrac, cpuState);
  const netAmount = calculateAmount(netFrac, netState);
  const cpuFee = calcPowerupFee(cpuState, cpuAmount);
  const netFee = calcPowerupFee(netState, netAmount);
  return {
    cpuAmount,
    netAmount,
    cpuFee,
    netFee
  };
}
const netCalc = (netAmount, chainInfo) => {
  if (!netAmount || netAmount <= 0) {
    return "0 bytes";
  }
  if (netAmount >= 1024 * 1024) {
    return `${(netAmount / (1024 * 1024)).toFixed(2)} MB`;
  } else if (netAmount >= 1024) {
    return `${(netAmount / 1024).toFixed(2)} KB`;
  } else {
    return `${netAmount} bytes`;
  }
};
const estimateCpuWithElasticLimit = (cpuFrac, netFrac, cpuState, netState, chainInfo) => {
  if (chainInfo && chainInfo.virtual_block_cpu_limit && chainInfo.block_cpu_limit) {
    let base_limit = parseFloat(chainInfo.block_cpu_limit);
    let current_limit = parseFloat(chainInfo.virtual_block_cpu_limit);
    let elastic_multiplier = current_limit / base_limit;
    const predicted = predictResourceAmounts(cpuFrac, netFrac, cpuState, netState);
    const cpuMicroseconds = predicted.cpuAmount * elastic_multiplier;
    if (!cpuMicroseconds || cpuMicroseconds <= 0) {
      return "0 ms";
    }
    const cpuMs = cpuMicroseconds / 1e3;
    if (cpuMs >= 1e3) {
      return `${(cpuMs / 1e3).toFixed(2)} seconds`;
    } else {
      return `${cpuMs.toFixed(2)} ms`;
    }
  }
  return "0 ms";
};
const submitPowerupTx = async (setRefresh, accountToBoost, maxPayment, cpu_frac, net_frac, setShowTxModal, setTxModalText, setTxIsLoading, wharfSession) => {
  setShowTxModal(true);
  setTxModalText("Awaiting confirmation...");
  if (localStorage.getItem("wharf--session") == null) {
    setTxModalText(
      "You are not logged in. Click the wallet icon in the top menu"
    );
    return;
  }
  const session = wharfSession;
  let max_payment = `${Number(maxPayment).toFixed(8)} WAX`;
  const action = [
    {
      account: "waxdao",
      name: "powerup",
      authorization: [session.permissionLevel],
      data: {}
    },
    {
      account: "eosio",
      name: "powerup",
      authorization: [session.permissionLevel],
      data: {
        payer: session.actor,
        receiver: accountToBoost,
        days: 1,
        net_frac: parseFloat(net_frac).toFixed(0),
        cpu_frac: parseFloat(cpu_frac).toFixed(0),
        max_payment
      }
    }
  ];
  try {
    const result = await session.transact({ actions: action }, defaultTxSettings);
    setTxIsLoading(true);
    setTxModalText(PROCESSING_TX_TEXT);
    const timer = setTimeout(() => {
      setTxModalText(`${accountToBoost} has been boosted with ${max_payment}`);
      setRefresh((prev) => !prev);
      setTxIsLoading(false);
    }, defaultSpinnerDuration);
    return () => clearTimeout(timer);
  } catch (e) {
    log.error("Powerup transaction error:", e);
    setTxModalText(e.message);
  }
};
const PxBadges = () => {
  const { account } = useWallet();
  const [badges, setBadges] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [collapsedCategories, setCollapsedCategories] = reactExports.useState(/* @__PURE__ */ new Set());
  const [badgeStats, setBadgeStats] = reactExports.useState(null);
  const [showShareModal, setShowShareModal] = reactExports.useState(false);
  const loadUserBadges = reactExports.useCallback(async () => {
    if (!account) return;
    try {
      setLoading(true);
      const result = await badgeService.checkUserBadges(account);
      const stats = await badgeService.getUserBadgeStats(account);
      setBadges(result.badges);
      setBadgeStats(stats);
    } catch (error) {
      log.error("Error loading badges", "PxBadges.loadUserBadges", error, { account });
    } finally {
      setLoading(false);
    }
  }, [account]);
  reactExports.useEffect(() => {
    if (account) {
      loadUserBadges();
    } else {
      setBadges([]);
      setLoading(false);
    }
  }, [account, loadUserBadges]);
  const categories = reactExports.useMemo(() => {
    const allBadgeDefinitions = badgeService.getAllBadgeDefinitions();
    const categoryMap = {
      holdings: {
        id: "holdings",
        name: "Token Holdings",
        icon: "",
        description: "Achievements for holding various tokens",
        badges: []
      },
      ownership: {
        id: "ownership",
        name: "NFT Collections",
        icon: "",
        description: "Achievements for owning NFTs and collectibles",
        badges: []
      },
      trading: {
        id: "trading",
        name: "Trading Mastery",
        icon: "",
        description: "Achievements for trading activities",
        badges: []
      },
      social: {
        id: "social",
        name: "Community",
        icon: "",
        description: "Achievements for community participation",
        badges: []
      },
      achievement: {
        id: "achievement",
        name: "Special Achievements",
        icon: "",
        description: "Rare and special accomplishments",
        badges: []
      },
      special: {
        id: "special",
        name: "Legendary",
        icon: "",
        description: "Ultra-rare legendary achievements",
        badges: []
      }
    };
    allBadgeDefinitions.forEach((badgeDef) => {
      const category = categoryMap[badgeDef.type] || categoryMap.achievement;
      const earnedBadge = badges.find((b) => b.id === badgeDef.id);
      category.badges.push(earnedBadge || {
        ...badgeDef,
        unlockedAt: void 0
      });
    });
    return Object.values(categoryMap).filter((cat) => cat.badges.length > 0);
  }, [badges]);
  const achievementSeries = reactExports.useMemo(() => {
    const series = [];
    const pixalCollectorBadges = badges.filter((b) => b.id.startsWith("pixal-collector")).sort((a, b) => (a.tier || 0) - (b.tier || 0));
    if (pixalCollectorBadges.length > 0) {
      const steps = [1, 2, 3, 4, 5].map((tier) => {
        const badge = pixalCollectorBadges.find((b) => b.tier === tier);
        return {
          tier,
          earned: !!badge?.unlockedAt,
          current: badge?.progress && !badge.unlockedAt
        };
      });
      series.push({
        name: "Pixal Collector",
        badges: pixalCollectorBadges,
        steps
      });
    }
    const waxrockCollectorBadges = badges.filter((b) => b.id.startsWith("waxrock-collector")).sort((a, b) => (a.tier || 0) - (b.tier || 0));
    if (waxrockCollectorBadges.length > 0) {
      const steps = [1, 2, 3].map((tier) => {
        const badge = waxrockCollectorBadges.find((b) => b.tier === tier);
        return {
          tier,
          earned: !!badge?.unlockedAt,
          current: badge?.progress && !badge.unlockedAt
        };
      });
      series.push({
        name: "WaxRock Collector",
        badges: waxrockCollectorBadges,
        steps
      });
    }
    return series;
  }, [badges]);
  const toggleCategory = (categoryId) => {
    const newCollapsed = new Set(collapsedCategories);
    if (newCollapsed.has(categoryId)) {
      newCollapsed.delete(categoryId);
    } else {
      newCollapsed.add(categoryId);
    }
    setCollapsedCategories(newCollapsed);
  };
  const getRarityClass = (badge) => {
    if (badge.rarity === "legendary") return "legendary";
    if (badge.rarity === "epic") return "epic";
    if (badge.rarity === "rare") return "rare";
    return "";
  };
  const formatDate = (date) => {
    if (!date) return "";
    const d = new Date(date);
    return d.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric"
    });
  };
  if (!account) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pxbadges-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "no-achievements", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-achievements-icon", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-achievements-text", children: "Connect Your Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-achievements-subtitle", children: "Connect your wallet to view your achievements and progress" })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxbadges-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxbadges-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", gap: "1rem", marginBottom: "1rem" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "pxbadges-title", children: "Achievements" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setShowShareModal(true),
            style: {
              background: "rgba(255, 215, 0, 0.2)",
              border: "2px solid #ffd700",
              borderRadius: "50%",
              width: "48px",
              height: "48px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              cursor: "pointer",
              transition: "all 0.3s ease",
              color: "#ffd700"
            },
            onMouseEnter: (e) => {
              e.currentTarget.style.background = "rgba(255, 215, 0, 0.3)";
              e.currentTarget.style.transform = "scale(1.1)";
            },
            onMouseLeave: (e) => {
              e.currentTarget.style.background = "rgba(255, 215, 0, 0.2)";
              e.currentTarget.style.transform = "scale(1)";
            },
            title: "Share Achievements",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z" }) })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pxbadges-subtitle", children: "Track your progress and unlock prestigious badges in the Pixel Journey ecosystem" }),
      badgeStats && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-stats", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-number", children: badgeStats.totalBadges }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Total Earned" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-number", children: badgeStats.badgesByRarity?.legendary || 0 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Legendary" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-number", children: badgeStats.badgesByRarity?.epic || 0 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Epic" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-number", children: badgeStats.badgesByRarity?.rare || 0 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Rare" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-number", children: badgeStats.progressBadges?.length || 0 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "In Progress" })
        ] })
      ] })
    ] }),
    loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievements-loading", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      "Loading achievements..."
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-categories", children: [
      achievementSeries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "category-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "category-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "category-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "category-title", children: "Achievement Series" })
        ] }),
        achievementSeries.map((series) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-card earned", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "achievement-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "achievement-name", children: series.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "achievement-description", children: [
                "Multi-tier achievement series with ",
                series.steps.length,
                " levels"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "achievement-series", children: series.steps.map((step) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `series-step ${step.earned ? "completed" : step.current ? "current" : ""}`,
              children: step.tier
            },
            step.tier
          )) })
        ] }, series.name))
      ] }),
      categories.map((category) => {
        const earnedCount = category.badges.filter((b) => b.unlockedAt).length;
        const totalCount = category.badges.length;
        const isCollapsed = collapsedCategories.has(category.id);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "category-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "category-header",
              onClick: () => toggleCategory(category.id),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "category-icon", children: category.icon }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "category-title", children: category.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "category-progress", children: [
                  earnedCount,
                  "/",
                  totalCount
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `category-toggle ${isCollapsed ? "collapsed" : ""}`, children: "" })
              ]
            }
          ),
          !isCollapsed && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "achievements-grid", children: category.badges.map((badge) => {
            const isEarned = !!badge.unlockedAt;
            const rarityClass = getRarityClass(badge);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `achievement-card ${isEarned ? "earned" : ""} ${rarityClass}`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-header", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "achievement-icon", children: badge.icon }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "achievement-name", children: badge.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "achievement-description", children: badge.description }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "achievement-requirements", children: badge.requirements })
                    ] })
                  ] }),
                  badge.tier && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-tier", children: [
                    "Tier ",
                    badge.tier
                  ] }),
                  badge.progress && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "achievement-progress", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "progress-fill",
                        style: { width: `${badge.progress.percentage}%` }
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "progress-text", children: [
                      badge.progress.current.toLocaleString(),
                      " / ",
                      badge.progress.required.toLocaleString(),
                      "(",
                      badge.progress.percentage,
                      "%)"
                    ] })
                  ] }),
                  isEarned && badge.unlockedAt && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "achievement-date", children: formatDate(badge.unlockedAt) })
                ]
              },
              badge.id
            );
          }) })
        ] }, category.id);
      }),
      categories.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "no-achievements", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-achievements-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-achievements-text", children: "No Achievements Yet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-achievements-subtitle", children: "Start participating in the Pixel Journey ecosystem to earn your first badges!" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ShareModal,
      {
        isOpen: showShareModal,
        onClose: () => setShowShareModal(false),
        title: `${account}'s Achievements`,
        description: `Check out my achievements in the Pixel Journey ecosystem! I've earned ${badgeStats?.totalBadges || 0} badges including ${badgeStats?.badgesByRarity?.legendary || 0} legendary achievements.`,
        shareUrl: `${window.location.origin}/pxbadges?user=${account}`,
        defaultShareText: `Check out my achievements in the Pixel Journey ecosystem! I've earned ${badgeStats?.totalBadges || 0} badges. #PixelJourney #Achievements`,
        type: "achievement",
        badges,
        totalBadges: badgeStats?.totalBadges || 0,
        legendaryCount: badgeStats?.badgesByRarity?.legendary || 0,
        username: account || ""
      }
    )
  ] });
};
class AlcorService {
  constructor() {
    __publicField(this, "ALCOR_API_BASE", "https://alcor.exchange/api/v2");
    __publicField(this, "WAX_CONTRACT", "eosio.token");
    __publicField(this, "WPIXAL_CONTRACT", "pixeljourney");
    __publicField(this, "WAX_SYMBOL", "WAX");
    __publicField(this, "WPIXAL_SYMBOL", "WPIXAL");
    __publicField(this, "WAX_TOKEN_ID", "wax-eosio.token");
    __publicField(this, "WPIXAL_TOKEN_ID", "wpixal-pixeljourney");
    // Cache for tokens to avoid repeated API calls
    __publicField(this, "tokensCache", null);
    __publicField(this, "tokensCacheExpiry", 0);
    __publicField(this, "CACHE_DURATION", 5 * 60 * 1e3);
  }
  // 5 minutes
  /**
   * Get all available tokens from Alcor Exchange
   */
  async getAllTokens() {
    try {
      if (this.tokensCache && Date.now() < this.tokensCacheExpiry) {
        return this.tokensCache;
      }
      const url = `${this.ALCOR_API_BASE}/tokens`;
      const response = await fetch(url, {
        method: "GET",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        mode: "cors"
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const tokens = await response.json();
      this.tokensCache = tokens.map((token) => ({
        id: token.id || `${token.symbol.toLowerCase()}-${token.contract}`,
        symbol: token.symbol,
        contract: token.contract,
        precision: token.precision || 8,
        logo: token.logo,
        usd_price: token.usd_price,
        system_price: token.system_price
      }));
      this.tokensCacheExpiry = Date.now() + this.CACHE_DURATION;
      return this.tokensCache || [];
    } catch (error) {
      log.error("Error fetching all tokens:", "AlcorService.getAllTokens", error);
      return [
        {
          id: this.WAX_TOKEN_ID,
          symbol: this.WAX_SYMBOL,
          contract: this.WAX_CONTRACT,
          precision: 8
        },
        {
          id: this.WPIXAL_TOKEN_ID,
          symbol: this.WPIXAL_SYMBOL,
          contract: this.WPIXAL_CONTRACT,
          precision: 8
        }
      ];
    }
  }
  /**
   * Get swap quote for any token pair using Alcor's swapRouter API
   */
  async getSwapQuoteForPair(inputToken, outputToken, amount, userAccount, tradeType = "EXACT_INPUT", slippageTolerance = 0.05) {
    try {
      const url = `${this.ALCOR_API_BASE}/swapRouter/getRoute?trade_type=${tradeType}&input=${inputToken.token_id}&output=${outputToken.token_id}&amount=${parseFloat(amount).toFixed(inputToken.precision)}&slippage=${slippageTolerance.toFixed(2)}&receiver=${userAccount}&maxHops=3&v2=true`;
      log.info("Fetching swap route from:", url);
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      log.info("Swap route response:", data);
      if (!data.swaps || data.swaps.length === 0) {
        throw new Error("No swap route found for this token pair");
      }
      const swap = data.swaps[0];
      return {
        input_amount: data.maxSent || swap.maxSent || data.input || swap.input,
        output_amount: data.output || swap.output || data.minReceived || swap.minReceived,
        price_impact: data.priceImpact?.toString() || "0",
        minimum_received: data.minReceived || swap.minReceived,
        route: data.route?.map((poolId, index) => ({
          pool_id: poolId,
          token_in: index === 0 ? `${inputToken.symbol}@${inputToken.contract}` : "intermediate",
          token_out: index === data.route.length - 1 ? `${outputToken.symbol}@${outputToken.contract}` : "intermediate",
          amount_in: index === 0 ? data.input || swap.input : "0",
          amount_out: index === data.route.length - 1 ? data.output || swap.output : "0"
        })) || [],
        memo: data.memo || swap.memo,
        input_token: inputToken,
        output_token: outputToken
      };
    } catch (error) {
      log.error("Error getting swap quote for pair:", "AlcorService.getSwapQuoteForPair", error);
      throw new Error(`Failed to get swap quote for ${inputToken.symbol}/${outputToken.symbol}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Get a quote for buying exact WPIXAL amount using Alcor's swapRouter API (legacy method)
   */
  async getExactOutputQuote(wpixalAmount, userAccount, slippageTolerance = 0.05) {
    try {
      const url = `${this.ALCOR_API_BASE}/swapRouter/getRoute?trade_type=EXACT_OUTPUT&input=${this.WAX_TOKEN_ID}&output=${this.WPIXAL_TOKEN_ID}&amount=${parseFloat(wpixalAmount).toFixed(8)}&slippage=${slippageTolerance.toFixed(2)}&receiver=${userAccount}&maxHops=3&v2=true`;
      log.error("Fetching swap route from:", url);
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      log.error("Swap route response:", data);
      if (!data.swaps || data.swaps.length === 0) {
        throw new Error("No swap route found");
      }
      const swap = data.swaps[0];
      return {
        input_amount: data.maxSent || swap.maxSent,
        output_amount: data.output || swap.output,
        price_impact: data.priceImpact?.toString() || "0",
        minimum_received: data.minReceived || swap.minReceived,
        route: data.route?.map((poolId, index) => ({
          pool_id: poolId,
          token_in: index === 0 ? `${this.WAX_SYMBOL}@${this.WAX_CONTRACT}` : "intermediate",
          token_out: index === data.route.length - 1 ? `${this.WPIXAL_SYMBOL}@${this.WPIXAL_CONTRACT}` : "intermediate",
          amount_in: index === 0 ? data.input || swap.input : "0",
          amount_out: index === data.route.length - 1 ? data.output || swap.output : "0"
        })) || [],
        memo: data.memo || swap.memo,
        input_token: {
          symbol: this.WAX_SYMBOL,
          contract: this.WAX_CONTRACT,
          precision: 8,
          token_id: this.WAX_TOKEN_ID
        },
        output_token: {
          symbol: this.WPIXAL_SYMBOL,
          contract: this.WPIXAL_CONTRACT,
          precision: 8,
          token_id: this.WPIXAL_TOKEN_ID
        }
      };
    } catch (error) {
      log.error("Error getting exact output quote:", "alcorService.getExactOutputQuote", error);
      throw new Error(`Failed to get swap quote: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Get a quote for swapping WAX to WPIXAL (legacy method for compatibility)
   */
  async getSwapQuote(waxAmount) {
    const rate = await this.getExchangeRate();
    const approximateWpixal = (parseFloat(waxAmount) / rate).toFixed(8);
    return this.getExactOutputQuote(approximateWpixal, "dummy.account", 0.5);
  }
  /**
   * Execute WAX to WPIXAL swap for exact WPIXAL output (legacy method)
   */
  async executeSwap(wpixalAmount, userAccount, slippageTolerance = 0.5) {
    try {
      const quote = await this.getExactOutputQuote(wpixalAmount, userAccount, slippageTolerance);
      const transaction = {
        expiration: new Date(Date.now() + 30 * 60 * 1e3).toISOString(),
        // 30 min expiration; adjust as needed
        ref_block_num: 0,
        // Filled by Wharfkit/node
        ref_block_prefix: 0,
        // Filled by Wharfkit/node
        max_net_usage_words: 0,
        max_cpu_usage_ms: 0,
        delay_sec: 0,
        context_free_actions: [],
        actions: [
          {
            account: this.WAX_CONTRACT,
            name: "transfer",
            authorization: [{
              actor: userAccount,
              permission: "active"
            }],
            data: {
              from: userAccount,
              to: "swap.alcor",
              // Alcor's swap contract
              quantity: `${parseFloat(quote.input_amount).toFixed(8)} ${this.WAX_SYMBOL}`,
              memo: quote.memo
            }
          }
        ],
        transaction_extensions: []
      };
      log.info("Swap transaction prepared", "AlcorService.executeSwap", {
        wpixalAmount,
        maxWaxInput: quote.input_amount,
        memo: quote.memo,
        route: quote.route
      });
      return transaction;
    } catch (error) {
      log.error("Error executing swap:", "AlcorService.executeSwap", error instanceof Error ? error : new Error(String(error)));
      throw error;
    }
  }
  /**
   * Execute swap for any token pair
   */
  async executeSwapForPair(inputToken, outputToken, amount, userAccount, tradeType = "EXACT_INPUT", slippageTolerance = 0.05) {
    try {
      const quote = await this.getSwapQuoteForPair(
        inputToken,
        outputToken,
        amount,
        userAccount,
        tradeType,
        slippageTolerance
      );
      const transaction = {
        expiration: new Date(Date.now() + 30 * 60 * 1e3).toISOString(),
        // 30 min expiration
        ref_block_num: 0,
        // Filled by Wharfkit/node
        ref_block_prefix: 0,
        // Filled by Wharfkit/node
        max_net_usage_words: 0,
        max_cpu_usage_ms: 0,
        delay_sec: 0,
        context_free_actions: [],
        actions: [
          {
            account: inputToken.contract,
            name: "transfer",
            authorization: [{
              actor: userAccount,
              permission: "active"
            }],
            data: {
              from: userAccount,
              to: "swap.alcor",
              // Alcor's swap contract
              quantity: `${parseFloat(quote.input_amount).toFixed(inputToken.precision)} ${inputToken.symbol}`,
              memo: quote.memo
            }
          }
        ],
        transaction_extensions: []
      };
      log.info("Generic swap transaction prepared", "AlcorService.executeSwapForPair", {
        inputToken: inputToken.symbol,
        outputToken: outputToken.symbol,
        amount,
        tradeType,
        inputAmount: quote.input_amount,
        outputAmount: quote.output_amount,
        memo: quote.memo,
        route: quote.route
      });
      return transaction;
    } catch (error) {
      log.error("Error executing swap for pair:", "AlcorService.executeSwapForPair", error instanceof Error ? error : new Error(String(error)));
      throw error;
    }
  }
  /**
   * Get current WAX/WPIXAL exchange rate (WAX needed for 1 WPIXAL)
   */
  async getExchangeRate() {
    try {
      const quote = await this.getExactOutputQuote("1.00000000", "dummy.account", 0);
      return parseFloat(quote.input_amount);
    } catch (error) {
      log.error("Error getting exchange rate:", "AlcorService.getExchangeRate", error instanceof Error ? error : new Error(String(error)));
      return 292e-6;
    }
  }
  /**
   * Check if there's sufficient liquidity for the swap
   */
  async checkLiquidity(wpixalAmount) {
    try {
      const quote = await this.getExactOutputQuote(wpixalAmount, "dummy.account", 0.5);
      const priceImpact = parseFloat(quote.price_impact);
      return priceImpact < 5;
    } catch (error) {
      log.error("Error checking liquidity:", "AlcorService.checkLiquidity", error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }
  /**
   * Estimate WAX needed for a specific WPIXAL amount
   */
  async estimateWaxNeeded(wpixalAmount) {
    try {
      const quote = await this.getExactOutputQuote(wpixalAmount, "dummy.account", 0);
      return quote.input_amount;
    } catch (error) {
      log.error("Error estimating WAX needed:", "AlcorService.estimateWaxNeeded", error instanceof Error ? error : new Error(String(error)));
      throw error;
    }
  }
}
const alcorService = new AlcorService();
const TokenDropdown = ({
  selectedToken,
  onTokenSelect,
  availableTokens = ["WAX", "WPIXAL"],
  className = "",
  filterByAvailable = false
}) => {
  const { account } = useWallet();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [tokens, setTokens] = reactExports.useState([]);
  const [alcorTokens, setAlcorTokens] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const dropdownRef = reactExports.useRef(null);
  const loadAlcorTokens = async () => {
    try {
      const tokens2 = await alcorService.getAllTokens();
      setAlcorTokens(tokens2);
      return tokens2;
    } catch (error) {
      log.error("Failed to load Alcor tokens", "TokenDropdown.loadAlcorTokens", error);
      const fallbackTokens = [
        { symbol: "WAX", contract: "eosio.token", precision: 8, logo: null },
        { symbol: "WPIXAL", contract: "pixeljourney", precision: 8, logo: null },
        { symbol: "PIXAL", contract: "pixeljourney", precision: 8, logo: null },
        { symbol: "LSWAX", contract: "token.defi", precision: 8, logo: null },
        { symbol: "BRWL", contract: "brawlertoken", precision: 4, logo: null },
        { symbol: "TLM", contract: "alien.worlds", precision: 4, logo: null },
        { symbol: "WOMBAT", contract: "wombattoken", precision: 4, logo: null }
      ];
      setAlcorTokens(fallbackTokens);
      return fallbackTokens;
    }
  };
  const favoredTokenConfigs = {
    "PXJ": { contract: "pixeljourney", decimals: 8, icon: "", priority: 1 },
    "WPIXAL": { contract: "pixeljourney", decimals: 8, icon: "", priority: 2 },
    "WAX": { contract: "eosio.token", decimals: 8, icon: "", priority: 3 },
    "KING": { contract: "alpha.waxfun", decimals: 8, icon: "", priority: 4 },
    "WAXUSDC": { contract: "eth.token", decimals: 8, icon: "", priority: 5 },
    "WAXWBTC": { contract: "eth.token", decimals: 8, icon: "", priority: 6 },
    "WUF": { contract: "wuffi", decimals: 4, icon: "", priority: 7 },
    "LSWAX": { contract: "token.defi", decimals: 8, icon: "", priority: 8 },
    "BRWL": { contract: "brawlertoken", decimals: 4, icon: "", priority: 9 },
    "TLM": { contract: "alien.worlds", decimals: 4, icon: "", priority: 10 },
    "WOMBAT": { contract: "wombattoken", decimals: 4, icon: "", priority: 11 }
  };
  const getTokenConfig = (symbol) => {
    const favoredToken = favoredTokenConfigs[symbol];
    if (favoredToken) {
      return {
        contract: favoredToken.contract,
        decimals: favoredToken.decimals,
        icon: favoredToken.icon,
        logo: null,
        priority: favoredToken.priority
      };
    }
    const alcorToken = alcorTokens.find((t) => t.symbol === symbol);
    if (alcorToken) {
      return {
        contract: alcorToken.contract,
        decimals: alcorToken.precision,
        icon: getTokenIcon2(symbol),
        logo: alcorToken.logo,
        priority: 999
        // Lower priority for non-favored tokens
      };
    }
    return { contract: "eosio.token", decimals: 8, icon: "", logo: null, priority: 1e3 };
  };
  const getTokenIcon2 = (symbol) => {
    const iconMap = {
      "WAX": "",
      "WPIXAL": "",
      "PIXAL": "",
      "LSWAX": "",
      "BRWL": "",
      "TLM": "",
      "WOMBAT": ""
    };
    return iconMap[symbol] || "";
  };
  const loadTokenBalances = async () => {
    if (alcorTokens.length === 0) {
      await loadAlcorTokens();
    }
    if (!account) {
      const tokensToShow = filterByAvailable ? availableTokens : alcorTokens.map((t) => t.symbol);
      const defaultTokens = tokensToShow.map((symbol) => {
        const config = getTokenConfig(symbol);
        return {
          symbol,
          contract: config.contract,
          amount: "0.0000",
          decimals: config.decimals,
          icon: config.icon,
          logo: config.logo
        };
      });
      setTokens(defaultTokens);
      return;
    }
    setLoading(true);
    try {
      const lightApiResponse = await apiService.getLightApiBalances(account);
      if (lightApiResponse && lightApiResponse.balances) {
        const tokenOptions = [];
        const tokensToProcess = filterByAvailable ? availableTokens : alcorTokens.map((t) => t.symbol);
        for (const symbol of tokensToProcess) {
          const config = getTokenConfig(symbol);
          if (!config) continue;
          const balance = lightApiResponse.balances.find(
            (b) => b.currency === symbol && b.contract === config.contract
          );
          tokenOptions.push({
            symbol,
            contract: config.contract,
            amount: balance ? balance.amount : "0.0000",
            decimals: balance ? parseInt(balance.decimals) : config.decimals,
            icon: config.icon,
            logo: config.logo,
            priority: config.priority || 999
          });
        }
        tokenOptions.sort((a, b) => (a.priority || 999) - (b.priority || 999));
        if (!filterByAvailable) {
          for (const balance of lightApiResponse.balances) {
            if (!tokensToProcess.includes(balance.currency)) {
              const config = getTokenConfig(balance.currency);
              if (config) {
                tokenOptions.push({
                  symbol: balance.currency,
                  contract: balance.contract,
                  amount: balance.amount,
                  decimals: parseInt(balance.decimals),
                  icon: config.icon,
                  logo: config.logo,
                  priority: config.priority || 999
                });
              }
            }
          }
          tokenOptions.sort((a, b) => (a.priority || 999) - (b.priority || 999));
        }
        setTokens(tokenOptions);
      } else {
        const tokensToShow = filterByAvailable ? availableTokens : alcorTokens.map((t) => t.symbol);
        const defaultTokens = tokensToShow.map((symbol) => {
          const config = getTokenConfig(symbol);
          return {
            symbol,
            contract: config.contract,
            amount: "0.0000",
            decimals: config.decimals,
            icon: config.icon,
            logo: config.logo,
            priority: config.priority || 999
          };
        });
        defaultTokens.sort((a, b) => (a.priority || 999) - (b.priority || 999));
        setTokens(defaultTokens);
      }
    } catch (error) {
      log.error("Failed to load token balances", "TokenDropdown.loadTokenBalances", error);
      const tokensToShow = filterByAvailable ? availableTokens : alcorTokens.map((t) => t.symbol);
      const defaultTokens = tokensToShow.map((symbol) => {
        const config = getTokenConfig(symbol);
        return {
          symbol,
          contract: config.contract,
          amount: "0.0000",
          decimals: config.decimals,
          icon: config.icon,
          logo: config.logo,
          priority: config.priority || 999
        };
      });
      defaultTokens.sort((a, b) => (a.priority || 999) - (b.priority || 999));
      setTokens(defaultTokens);
    } finally {
      setLoading(false);
    }
  };
  reactExports.useEffect(() => {
    loadAlcorTokens();
  }, []);
  reactExports.useEffect(() => {
    loadTokenBalances();
  }, [account, availableTokens, alcorTokens, filterByAvailable]);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const handleTokenSelect = (token) => {
    onTokenSelect(token.symbol);
    setIsOpen(false);
  };
  const selectedTokenData = tokens.find((t) => t.symbol === selectedToken);
  const selectedTokenConfig = getTokenConfig(selectedToken);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `token-dropdown ${className}`, ref: dropdownRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        className: "token-button",
        onClick: () => setIsOpen(!isOpen),
        type: "button",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-icon", children: selectedTokenData?.logo ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: selectedTokenData.logo, alt: selectedToken, className: "token-logo" }) : selectedTokenData?.icon || selectedTokenConfig?.icon || "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-symbol", children: selectedToken }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `dropdown-arrow ${isOpen ? "open" : ""}`, children: "" })
        ]
      }
    ),
    isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-dropdown-menu", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-dropdown-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading tokens..." }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      tokens.map((token) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `token-option ${token.symbol === selectedToken ? "selected" : ""}`,
          onClick: () => handleTokenSelect(token),
          type: "button",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-option-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-option-icon", children: token.logo ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: token.logo, alt: token.symbol, className: "token-logo" }) : token.icon }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-option-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-option-symbol", children: token.symbol }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-option-contract", children: token.contract })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-option-balance", children: parseFloat(token.amount).toFixed(4) })
          ]
        },
        `${token.contract}-${token.symbol}`
      )),
      tokens.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-dropdown-empty", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "No tokens available" }) })
    ] }) })
  ] });
};
const SwapInterface = ({
  isModal = false,
  onClose,
  initialSellAmount = 0,
  initialBuyAmount = 1
}) => {
  const { showSuccess, showError } = useNotifications();
  const { account, session } = useWallet();
  const [sellAmount, setSellAmount] = reactExports.useState(initialSellAmount.toString());
  const [buyAmount, setBuyAmount] = reactExports.useState(initialBuyAmount.toString());
  const [sellToken, setSellToken] = reactExports.useState("WAX");
  const [buyToken, setBuyToken] = reactExports.useState("WPIXAL");
  const [loading, setLoading] = reactExports.useState(false);
  const [quoteData, setQuoteData] = reactExports.useState(null);
  const [slippage, setSlippage] = reactExports.useState(0.5);
  const [showSlippageSettings, setShowSlippageSettings] = reactExports.useState(false);
  const [balances, setBalances] = reactExports.useState({});
  const [isLoadingBalances, setIsLoadingBalances] = reactExports.useState(false);
  const [alcorTokens, setAlcorTokens] = reactExports.useState([]);
  const loadAlcorTokens = reactExports.useCallback(async () => {
    try {
      const tokens = await alcorService.getAllTokens();
      setAlcorTokens(tokens);
      return tokens;
    } catch (error) {
      log.error("Failed to load Alcor tokens", "SwapInterface.loadAlcorTokens", error);
      return [];
    }
  }, []);
  const favoredTokenConfigs = {
    "PXJ": { contract: "pixeljourney", precision: 8, priority: 1 },
    "WPIXAL": { contract: "pixeljourney", precision: 8, priority: 2 },
    "WAX": { contract: "eosio.token", precision: 8, priority: 3 },
    "KING": { contract: "alpha.waxfun", precision: 8, priority: 4 },
    "WAXUSDC": { contract: "eth.token", precision: 8, priority: 5 },
    "WAXWBTC": { contract: "eth.token", precision: 8, priority: 6 },
    "WUF": { contract: "wuffi", precision: 4, priority: 7 },
    "LSWAX": { contract: "token.defi", precision: 8, priority: 8 },
    "BRWL": { contract: "brawlertoken", precision: 4, priority: 9 },
    "TLM": { contract: "alien.worlds", precision: 4, priority: 10 },
    "WOMBAT": { contract: "wombattoken", precision: 4, priority: 11 },
    "TACO": { contract: "t.taco", precision: 8, priority: 12 },
    "SHING": { contract: "t.taco", precision: 8, priority: 13 },
    "YEET": { contract: "token.yeet", precision: 4, priority: 14 },
    "DMT": { contract: "defiminingtk", precision: 4, priority: 15 },
    "FGL": { contract: "fgltokenmgmt", precision: 4, priority: 16 },
    "SOREN": { contract: "farfromhomes", precision: 4, priority: 17 }
  };
  const getTokenInfo = reactExports.useCallback((symbol) => {
    const favoredToken = favoredTokenConfigs[symbol];
    if (favoredToken) {
      return {
        symbol,
        contract: favoredToken.contract,
        precision: favoredToken.precision,
        token_id: `${favoredToken.contract}-${symbol}`,
        priority: favoredToken.priority
      };
    }
    const token = alcorTokens.find((t) => t.symbol === symbol);
    if (token) {
      return {
        symbol: token.symbol,
        contract: token.contract,
        precision: token.precision,
        token_id: token.id,
        priority: 999
        // Lower priority for non-favored tokens
      };
    }
    return null;
  }, [alcorTokens]);
  const loadBalances = reactExports.useCallback(async () => {
    if (!account) {
      setBalances({});
      return;
    }
    setIsLoadingBalances(true);
    try {
      if (alcorTokens.length === 0) {
        await loadAlcorTokens();
      }
      const lightApiResponse = await apiService.getLightApiBalances(account);
      const newBalances = {};
      if (lightApiResponse && lightApiResponse.balances) {
        for (const balance of lightApiResponse.balances) {
          const tokenInfo = getTokenInfo(balance.currency);
          if (tokenInfo && tokenInfo.contract === balance.contract) {
            newBalances[balance.currency] = `${balance.amount} ${balance.currency}`;
          }
        }
        Object.keys(favoredTokenConfigs).forEach((symbol) => {
          if (!newBalances[symbol]) {
            newBalances[symbol] = `0.0000 ${symbol}`;
          }
        });
      } else {
        Object.keys(favoredTokenConfigs).forEach((symbol) => {
          newBalances[symbol] = `0.0000 ${symbol}`;
        });
      }
      setBalances(newBalances);
    } catch (error) {
      log.error("Error loading balances", "SwapInterface.loadBalances", error);
      showError("Failed to load token balances");
      const defaultBalances = {};
      Object.keys(favoredTokenConfigs).forEach((symbol) => {
        defaultBalances[symbol] = `0.0000 ${symbol}`;
      });
      setBalances(defaultBalances);
    } finally {
      setIsLoadingBalances(false);
    }
  }, [account, showError, alcorTokens, loadAlcorTokens]);
  reactExports.useEffect(() => {
    loadAlcorTokens();
  }, []);
  reactExports.useEffect(() => {
    loadBalances();
    const balanceInterval = setInterval(loadBalances, 3e4);
    return () => clearInterval(balanceInterval);
  }, [loadBalances]);
  const getQuote = reactExports.useCallback(async () => {
    if (!sellAmount || parseFloat(sellAmount) <= 0) {
      setQuoteData(null);
      setBuyAmount("0");
      return;
    }
    try {
      setLoading(true);
      const sellTokenInfo = getTokenInfo(sellToken);
      const buyTokenInfo = getTokenInfo(buyToken);
      if (!sellTokenInfo || !buyTokenInfo) {
        throw new Error(`Token configuration not found for ${!sellTokenInfo ? sellToken : buyToken}`);
      }
      const quote = await alcorService.getSwapQuoteForPair(
        sellTokenInfo,
        buyTokenInfo,
        sellAmount,
        (slippage / 100).toString()
      );
      if (quote && quote.output_amount) {
        setQuoteData(quote);
        setBuyAmount(parseFloat(quote.output_amount).toFixed(sellTokenInfo.precision || 4));
      } else {
        throw new Error("No valid quote received");
      }
    } catch (error) {
      log.error("Error getting swap quote", "SwapInterface.getQuote", error);
      setQuoteData(null);
      setBuyAmount("0");
    } finally {
      setLoading(false);
    }
  }, [sellAmount, sellToken, buyToken, account, slippage, getTokenInfo]);
  reactExports.useEffect(() => {
    if (sellToken && buyToken && sellToken !== buyToken) {
      getQuote();
    }
  }, [sellToken, buyToken, getQuote]);
  const handleSwapTokens = () => {
    const tempToken = sellToken;
    const tempAmount = sellAmount;
    setSellToken(buyToken);
    setBuyToken(tempToken);
    setSellAmount(buyAmount);
    setBuyAmount(tempAmount);
  };
  const handleMaxClick = () => {
    const maxBalance = balances[sellToken] || `0.0000 ${sellToken}`;
    const amount = maxBalance.split(" ")[0];
    setSellAmount(amount);
  };
  const handlePercentageClick = (percentage) => {
    const balanceStr = balances[sellToken] || `0.0000 ${sellToken}`;
    const maxBalance = parseFloat(balanceStr.split(" ")[0]);
    const amount = (maxBalance * percentage / 100).toFixed(4);
    setSellAmount(amount);
  };
  const executeSwap = async () => {
    if (!account || !session) {
      showError("Please connect your wallet first");
      return;
    }
    if (!quoteData) {
      showError("No quote available");
      return;
    }
    try {
      setLoading(true);
      const sellTokenInfo = getTokenInfo(sellToken);
      const buyTokenInfo = getTokenInfo(buyToken);
      if (!sellTokenInfo || !buyTokenInfo) {
        throw new Error(`Token configuration not found for ${!sellTokenInfo ? sellToken : buyToken}`);
      }
      const swapTransaction = await alcorService.executeSwapForPair(
        sellTokenInfo,
        buyTokenInfo,
        sellAmount,
        account,
        "EXACT_INPUT",
        slippage / 100
      );
      const result = await session.transact({ actions: swapTransaction.actions });
      showSuccess(`Successfully swapped ${sellAmount} ${sellToken} for ${buyAmount} ${buyToken}`);
      log.info("Swap transaction completed", "SwapInterface.executeSwap", {
        sellAmount,
        sellToken,
        buyAmount,
        buyToken,
        transactionId: result?.transaction?.id || result?.transactionId || result?.id || "unknown"
      });
      await loadBalances();
      setSellAmount("0");
      setBuyAmount("0");
      setQuoteData(null);
      if (isModal && onClose) {
        onClose();
      }
    } catch (error) {
      log.error("Error executing swap", "SwapInterface.executeSwap", error);
      showError("Failed to execute swap transaction");
    } finally {
      setLoading(false);
    }
  };
  const content = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `swap-interface ${isModal ? "modal-content" : ""}`, children: [
    isModal && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Swap Tokens" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-button", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-section sell-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-section-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "section-label", children: "Sell" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "balance", children: [
            "Balance: ",
            isLoadingBalances ? "Loading..." : balances[sellToken] || `0.0000 ${sellToken}`
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              value: sellAmount,
              onChange: (e) => setSellAmount(e.target.value),
              placeholder: "0",
              className: "amount-input"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-selector", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TokenDropdown,
            {
              selectedToken: sellToken,
              onTokenSelect: setSellToken,
              filterByAvailable: false,
              className: "sell-token-dropdown"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "percentage-buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handlePercentageClick(15), children: "15%" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handlePercentageClick(25), children: "25%" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handlePercentageClick(50), children: "50%" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handlePercentageClick(75), children: "75%" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleMaxClick, className: "max-button", children: "MAX" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-arrow-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "swap-arrow", onClick: handleSwapTokens, children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "refresh-quote-button",
            onClick: getQuote,
            disabled: loading || !sellAmount || parseFloat(sellAmount) <= 0,
            title: "Refresh price quote",
            children: loading ? "" : ""
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-section buy-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-section-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "section-label", children: "Buy" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "balance", children: [
            "Balance: ",
            isLoadingBalances ? "Loading..." : balances[buyToken] || `0.0000 ${buyToken}`
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              value: buyAmount,
              readOnly: true,
              placeholder: "0",
              className: "amount-input",
              title: "Output amount is calculated automatically"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-selector", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TokenDropdown,
            {
              selectedToken: buyToken,
              onTokenSelect: setBuyToken,
              filterByAvailable: false,
              className: "buy-token-dropdown"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "percentage-buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handlePercentageClick(15), children: "15%" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handlePercentageClick(25), children: "25%" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handlePercentageClick(50), children: "50%" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handlePercentageClick(75), children: "75%" })
        ] })
      ] }),
      quoteData && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quote-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quote-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "quote-label", children: "Rate" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "quote-value", children: [
            quoteData.rate || "0.00340412",
            " WPIXAL per WAX (0.02%)"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quote-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "quote-label", children: "Expected Output" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "quote-value", children: quoteData.expectedOutput || buyAmount })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quote-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "quote-label", children: "Price Impact" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "quote-value", children: quoteData.priceImpact || "< 0.01%" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quote-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "quote-label", children: "Maximum Send after slippage" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "quote-value", children: [
            quoteData.maxSent || "309.45013892",
            " WAX (0.50%)"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slippage-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "slippage-toggle",
            onClick: () => setShowSlippageSettings(!showSlippageSettings),
            children: " Multiroute"
          }
        ),
        showSlippageSettings && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slippage-settings", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Slippage Tolerance" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slippage-options", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: slippage === 0.1 ? "active" : "",
                onClick: () => setSlippage(0.1),
                children: "0.1%"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: slippage === 0.5 ? "active" : "",
                onClick: () => setSlippage(0.5),
                children: "0.5%"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: slippage === 1 ? "active" : "",
                onClick: () => setSlippage(1),
                children: "1.0%"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                value: slippage,
                onChange: (e) => setSlippage(parseFloat(e.target.value) || 0.5),
                step: "0.1",
                min: "0.1",
                max: "50",
                className: "custom-slippage"
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "swap-button",
          onClick: executeSwap,
          disabled: loading || !account || !quoteData || parseFloat(sellAmount) <= 0,
          children: loading ? "Processing ..." : `Swap ${sellToken} To ${buyToken}`
        }
      )
    ] })
  ] });
  if (isModal) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "swap-modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: (e) => e.stopPropagation(), children: content }) });
  }
  return content;
};
const UserProfile = () => {
  const { account, isConnected, session, login } = useWallet$1();
  const { showError, showSuccess } = useNotifications();
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = reactExports.useState("overview");
  const [transactions, setTransactions] = reactExports.useState([]);
  const [collectionAvatars, setCollectionAvatars] = reactExports.useState({});
  const [userStats, setUserStats] = reactExports.useState(null);
  const [accountData, setAccountData] = reactExports.useState(null);
  const [resourceData, setResourceData] = reactExports.useState(null);
  const [tokenBalances, setTokenBalances] = reactExports.useState([]);
  const [waxBalance, setWaxBalance] = reactExports.useState("0.0000 WAX");
  const [selectedTokens, setSelectedTokens] = reactExports.useState(/* @__PURE__ */ new Set());
  const [bulkSellLoading, setBulkSellLoading] = reactExports.useState(false);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [userBadges, setUserBadges] = reactExports.useState([]);
  const [lastTransactionDate, setLastTransactionDate] = reactExports.useState(null);
  const [transactionFilter, setTransactionFilter] = reactExports.useState("all");
  const [dateRange, setDateRange] = reactExports.useState("all");
  const [customDateRange, setCustomDateRange] = reactExports.useState({ start: "", end: "" });
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [transactionsPerPage] = reactExports.useState(10);
  const [sortBy, setSortBy] = reactExports.useState("date");
  const [sortOrder, setSortOrder] = reactExports.useState("desc");
  const [isExporting, setIsExporting] = reactExports.useState(false);
  const [isLoadingTransactions, setIsLoadingTransactions] = reactExports.useState(false);
  const [transactionError, setTransactionError] = reactExports.useState(null);
  const [exportError, setExportError] = reactExports.useState(null);
  const [stakingModal, setStakingModal] = reactExports.useState({ isOpen: false, resourceType: "cpu", action: "stake" });
  const [ramModal, setRAMModal] = reactExports.useState({ isOpen: false, action: "buy" });
  const [tokenTransferModal, setTokenTransferModal] = reactExports.useState({ isOpen: false, token: null });
  const [accountToBoost, setAccountToBoost] = reactExports.useState(account || "");
  const [cpuAllocation, setCpuAllocation] = reactExports.useState(100);
  const [powerupAmount, setPowerupAmount] = reactExports.useState(0);
  const [txIsLoading, setTxIsLoading] = reactExports.useState(false);
  const [, getResources] = useGetAccountResources();
  const [powerupState, getPowerupState] = useGetPowerupState();
  const [chainInfo, getChainInfo] = useGetChainInfo();
  const loadTransactions = reactExports.useCallback(async () => {
    log.debug("loadTransactions called with account", "UserProfile", { account });
    setIsLoadingTransactions(true);
    setTransactionError(null);
    if (!account) {
      log.debug("No account connected, using test account", "UserProfile");
      const testAccount = "pixeljourney";
      try {
        log.debug("Fetching transactions for test account", "UserProfile", { testAccount });
        const realTransactions = await apiService.getUserTransactions(testAccount, 20);
        log.debug("Test transactions fetched", "UserProfile", { count: realTransactions?.length || 0, sample: realTransactions?.slice(0, 2) });
        if (!realTransactions || realTransactions.length === 0) {
          log.warn("No test transactions returned", "UserProfile");
          setTransactions([]);
        } else {
          const typedTransactions = realTransactions.map((tx) => ({
            ...tx,
            type: tx.type,
            status: tx.status || "completed"
          }));
          setTransactions(typedTransactions);
        }
      } catch (err) {
        log.error("Error loading test transactions", "UserProfile", err, {
          name: err instanceof Error ? err.name : "Unknown",
          message: err instanceof Error ? err.message : String(err),
          stack: err instanceof Error ? err.stack : void 0
        });
        const errorMessage = err instanceof Error ? err.message : "Unable to load transaction history. Please try again later.";
        setTransactionError(errorMessage);
        showError("Transaction Error", errorMessage);
      } finally {
        setIsLoadingTransactions(false);
      }
      return;
    }
    try {
      log.debug("Loading transactions for connected account", "UserProfile", { account, apiServiceAvailable: !!apiService, getUserTransactionsType: typeof apiService.getUserTransactions });
      const realTransactions = await apiService.getUserTransactions(account, 20);
      log.debug("Fetched transactions", "UserProfile", { count: realTransactions?.length || 0, sample: realTransactions?.slice(0, 2) });
      if (!realTransactions || realTransactions.length === 0) {
        log.warn("No transactions returned from API", "UserProfile");
        setTransactions([]);
      } else {
        const typedTransactions = realTransactions.map((tx) => ({
          ...tx,
          type: tx.type,
          status: tx.status || "completed"
        }));
        setTransactions(typedTransactions);
      }
    } catch (err) {
      log.error("Error loading transactions", "UserProfile", err, {
        name: err instanceof Error ? err.name : "Unknown",
        message: err instanceof Error ? err.message : String(err),
        stack: err instanceof Error ? err.stack : void 0
      });
      const errorMessage = err instanceof Error ? err.message : "Unable to load transaction history. Please try again later.";
      setTransactionError(errorMessage);
      showError("Transaction Error", errorMessage);
    } finally {
      setIsLoadingTransactions(false);
    }
  }, [account, showError]);
  const loadUserStats = reactExports.useCallback(async () => {
    if (!account) return;
    try {
      const realStats = await apiService.getUserStats(account);
      setUserStats(realStats);
      if (realStats.favoriteCollections.length > 0) {
        fetchCollectionAvatars(realStats.favoriteCollections);
      }
    } catch (err) {
      log.error("Error loading user stats", "UserProfile", err);
      throw err;
    }
  }, [account]);
  const fetchAccountData = reactExports.useCallback(async () => {
    if (!account) return;
    try {
      const data = await apiService.getWaxAccountInfo(account);
      if (data) {
        setAccountData(data);
        if (data.cpu_limit && data.net_limit && data.ram_quota) {
          setResourceData({
            cpu: {
              used: data.cpu_limit.used,
              available: data.cpu_limit.available,
              max: data.cpu_limit.max
            },
            net: {
              used: data.net_limit.used,
              available: data.net_limit.available,
              max: data.net_limit.max
            },
            ram: {
              used: data.ram_usage,
              available: data.ram_quota - data.ram_usage,
              max: data.ram_quota
            }
          });
        }
      }
    } catch (error2) {
      log.error("Failed to fetch account data", "UserProfile", error2);
      showError("Account Data Error", "Unable to fetch account information. Some features may not work properly.");
    }
  }, [account, showError]);
  const fetchLastTransactionDate = reactExports.useCallback(async () => {
    if (!account) return;
    try {
      const transactions2 = await apiService.getUserTransactions(account, 1);
      if (transactions2 && transactions2.length > 0) {
        setLastTransactionDate(transactions2[0].block_time);
      }
    } catch (error2) {
      log.error("Failed to fetch last transaction date", "UserProfile", error2);
      setLastTransactionDate(null);
    }
  }, [account]);
  const EXCLUDED_CONTRACTS = reactExports.useMemo(() => [
    "swap.taco",
    "alpha.waxfun",
    "beta.waxfun"
  ], []);
  const TOP_TOKENS = reactExports.useMemo(() => [
    { symbol: "WAX", contract: "eosio.token" },
    { symbol: "PXJ", contract: "pixeljourney" },
    { symbol: "WPIXAL", contract: "pixeljourney" },
    { symbol: "WUF", contract: "wuffi" },
    { symbol: "TLM", contract: "alien.worlds" }
  ], []);
  const fetchTokenBalancesFallback = reactExports.useCallback(async () => {
    if (!account) return;
    try {
      const balances = [];
      const validTopTokens = TOP_TOKENS.filter(
        (token) => !EXCLUDED_CONTRACTS.includes(token.contract)
      );
      for (let i = 0; i < validTopTokens.length; i++) {
        const token = validTopTokens[i];
        try {
          if (i > 0) {
            await delay(500);
          }
          const tokenBalances2 = await apiService.getWaxCurrencyBalance(account, token.contract, token.symbol);
          if (tokenBalances2 && tokenBalances2.length > 0) {
            let usdValue = "N/A";
            const balanceAmount = parseFloat(tokenBalances2[0].balance.split(" ")[0]);
            try {
              if (token.symbol === "WAX" && token.contract === "eosio.token") {
                const waxPriceUSD = await priceService.getWaxPriceUSD();
                usdValue = formatNumber(balanceAmount * waxPriceUSD, 2);
              } else if (token.symbol === "WPIXAL" && token.contract === "pixeljourney") {
                const wpixalPriceUSD = await priceService.getWpixalPriceUSD();
                usdValue = formatNumber(balanceAmount * wpixalPriceUSD, 4);
              } else if (token.symbol === "PXJ" && token.contract === "pixeljourney") {
                const pxjPriceUSD = await priceService.getPxjPriceUSD();
                usdValue = formatNumber(balanceAmount * pxjPriceUSD, 6);
              } else if (token.symbol === "WUF" && token.contract === "wuffi") {
                usdValue = "0.00";
              } else {
                usdValue = "N/A";
              }
            } catch (error2) {
              log.warn(`Failed to fetch price for ${token.symbol} in fallback`, "UserProfile", { error: error2 });
              usdValue = "0.00";
            }
            const balanceWithValue = {
              ...tokenBalances2[0],
              value: usdValue
            };
            if (token.symbol === "WAX" && token.contract === "eosio.token") {
              try {
                const waxBalance2 = await balanceService.getWaxBalance(account);
                setWaxBalance(waxBalance2);
              } catch (error2) {
                log.warn("Failed to get WAX balance from balance service, using fallback", "UserProfile", { error: error2 });
                setWaxBalance(balanceWithValue.balance);
              }
            }
            balances.push(balanceWithValue);
          }
        } catch (error2) {
          log.error(`Failed to fetch ${token.symbol} balance`, "UserProfile", error2);
        }
      }
      setTokenBalances(balances);
    } catch (error2) {
      log.error("Failed to fetch token balances with fallback", "UserProfile", error2);
    }
  }, [account, TOP_TOKENS, EXCLUDED_CONTRACTS]);
  const fetchUserBadges = reactExports.useCallback(async () => {
    if (!account) return;
    try {
      const badges = await badgeService.checkUserBadges(account);
      setUserBadges(badges.badges);
    } catch (error2) {
      log.error("Failed to fetch user badges", "UserProfile.fetchUserBadges", error2, { account });
    }
  }, [account]);
  const fetchTokenBalances = reactExports.useCallback(async () => {
    if (!account) return;
    try {
      const lightApiBalances = await apiService.getLightApiBalances(account);
      if (lightApiBalances && lightApiBalances.balances) {
        const balancesWithValues = [];
        const sortedBalances = lightApiBalances.balances.filter((balance) => parseFloat(balance.amount) > 1e-4).sort((a, b) => parseFloat(b.amount) - parseFloat(a.amount)).sort((a, b) => {
          const aIsTop = TOP_TOKENS.some((token) => token.symbol === a.currency && token.contract === a.contract);
          const bIsTop = TOP_TOKENS.some((token) => token.symbol === b.currency && token.contract === b.contract);
          if (aIsTop && !bIsTop) return -1;
          if (!aIsTop && bIsTop) return 1;
          return 0;
        });
        const validBalances = sortedBalances.filter(
          (balance) => !EXCLUDED_CONTRACTS.includes(balance.contract)
        );
        for (let i = 0; i < validBalances.length; i++) {
          const balance = validBalances[i];
          try {
            if (i > 0) {
              await delay(300);
            }
            let usdValue = "0.00";
            const balanceAmount = parseFloat(balance.amount);
            try {
              if (balance.currency === "WAX" && balance.contract === "eosio.token") {
                const waxPriceUSD = await priceService.getWaxPriceUSD();
                usdValue = formatNumber(balanceAmount * waxPriceUSD, 2);
              } else if (balance.currency === "WPIXAL" && balance.contract === "pixeljourney") {
                const wpixalPriceUSD = await priceService.getWpixalPriceUSD();
                usdValue = formatNumber(balanceAmount * wpixalPriceUSD, 4);
              } else if (balance.currency === "PXJ" && balance.contract === "pixeljourney") {
                const pxjPriceUSD = await priceService.getPxjPriceUSD();
                usdValue = formatNumber(balanceAmount * pxjPriceUSD, 6);
              } else if (balance.currency === "WUF" && balance.contract === "wuffi") {
                usdValue = "0.00";
              } else {
                usdValue = "N/A";
              }
            } catch (error2) {
              log.warn(`Failed to fetch price for ${balance.currency}`, "UserProfile", { error: error2 });
              usdValue = "0.00";
            }
            const formattedBalance = {
              balance: `${balance.amount} ${balance.currency}`,
              symbol: balance.currency,
              contract: balance.contract,
              value: usdValue
            };
            if (balance.currency === "WAX" && balance.contract === "eosio.token") {
              try {
                const waxBalance2 = await balanceService.getWaxBalance(account);
                setWaxBalance(waxBalance2);
              } catch (error2) {
                log.warn("Failed to get WAX balance from balance service, using fallback", "UserProfile", { error: error2 });
                setWaxBalance(formattedBalance.balance);
              }
            }
            balancesWithValues.push(formattedBalance);
          } catch (error2) {
            log.error(`Failed to get price for ${balance.currency}`, "UserProfile", error2);
            const formattedBalance = {
              balance: `${balance.amount} ${balance.currency}`,
              symbol: balance.currency,
              contract: balance.contract,
              value: "0.00"
            };
            balancesWithValues.push(formattedBalance);
          }
        }
        setTokenBalances(balancesWithValues);
      }
    } catch (error2) {
      log.error("Failed to fetch token balances", "UserProfile", error2);
      await fetchTokenBalancesFallback();
    }
  }, [account, EXCLUDED_CONTRACTS, TOP_TOKENS, fetchTokenBalancesFallback]);
  const loadUserData = reactExports.useCallback(async () => {
    if (!account) return;
    setLoading(true);
    setError(null);
    try {
      await loadTransactions();
      await loadUserStats();
      await fetchTokenBalances();
      await fetchUserBadges();
    } catch (err) {
      log.error("Error loading user data", "UserProfile", err);
      setError("Failed to load user data");
      showError("User Data Error", "Unable to load user profile data. Please try refreshing the page.");
    } finally {
      setLoading(false);
    }
  }, [account, showError, fetchTokenBalances, loadTransactions, loadUserStats, fetchUserBadges]);
  reactExports.useEffect(() => {
    if (isConnected && account) {
      const initializeData = async () => {
        try {
          await loadUserData();
          await fetchAccountData();
          await fetchLastTransactionDate();
          await getPowerupState();
          await getChainInfo();
          getResources();
        } catch (error2) {
          log.error("Error initializing user data", "UserProfile", error2);
          showError("Failed to Load User Data", "Unable to initialize user profile. Please try refreshing the page.");
          setError("Failed to load user data");
        }
      };
      initializeData();
    }
  }, [isConnected, account]);
  reactExports.useEffect(() => {
    if (account) {
      setAccountToBoost(account);
    }
  }, [account]);
  const handleInputChange = (e) => {
    const value = e.target.value;
    if (value === "" || /^\d*\.?\d*$/.test(value)) {
      if (value === "" || !isNaN(Number(value))) {
        if (value !== "") {
          const maxWax = parseFloat(waxBalance.split(" ")[0]);
          if (Number(value) > maxWax) {
            return;
          }
        }
        setPowerupAmount(Number(value));
      }
    }
  };
  const handleSliderChange = (e) => {
    const percentage = Number(e.target.value);
    const maxWax = parseFloat(waxBalance.split(" ")[0]);
    const newAmount = Number(maxWax * percentage / 100).toFixed(8);
    setPowerupAmount(Number(newAmount));
  };
  const handleCpuSliderChange = (e) => {
    const percent = Number(e.target.value);
    setCpuAllocation(percent);
  };
  const calculateResourceUsage = (currentUsed, max) => {
    if (max === 0) return 0;
    return currentUsed / max * 100;
  };
  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  const openStakingModal = (resourceType, action) => {
    setStakingModal({ isOpen: true, resourceType, action });
  };
  const closeStakingModal = () => {
    setStakingModal({ isOpen: false, resourceType: "cpu", action: "stake" });
  };
  const openRAMModal = (action) => {
    setRAMModal({ isOpen: true, action });
  };
  const closeRAMModal = () => {
    setRAMModal({ isOpen: false, action: "buy" });
  };
  const openTokenTransferModal = (token) => {
    setTokenTransferModal({ isOpen: true, token });
  };
  const closeTokenTransferModal = () => {
    setTokenTransferModal({ isOpen: false, token: null });
  };
  const handleTokenTransferSuccess = () => {
    fetchAccountData();
    closeTokenTransferModal();
  };
  const handleResourceSuccess = () => {
    fetchAccountData();
  };
  const handleSelectAll = () => {
    if (selectedTokens.size === tokenBalances.length) {
      setSelectedTokens(/* @__PURE__ */ new Set());
    } else {
      const allTokenKeys = tokenBalances.map((_, index) => index.toString());
      setSelectedTokens(new Set(allTokenKeys));
    }
  };
  const handleBulkSell = async () => {
    if (selectedTokens.size === 0 || !account) return;
    setBulkSellLoading(true);
    try {
      const selectedTokenData = Array.from(selectedTokens).map(
        (index) => tokenBalances[parseInt(index)]
      ).filter((token) => token.symbol !== "PXJ");
      if (selectedTokenData.length === 0) {
        showError("Invalid Selection", "No valid tokens selected for swap (PXJ cannot be swapped for itself)");
        return;
      }
      let totalPxjReceived = 0;
      const swapResults = [];
      for (const token of selectedTokenData) {
        try {
          const amount = parseFloat(token.balance.split(" ")[0]);
          const swapQuote = await apiService.getAlcorSwapQuote({
            from_token: token.symbol,
            from_contract: token.contract,
            to_token: "PXJ",
            to_contract: "pixeljourney",
            amount: amount.toString(),
            slippage: 0.5
          });
          if (swapQuote && parseFloat(swapQuote.output.amount) > 0) {
            swapResults.push({
              token: token.symbol,
              amount,
              pxjReceived: parseFloat(swapQuote.output.amount),
              success: true
            });
            totalPxjReceived += parseFloat(swapQuote.output.amount);
          } else {
            swapResults.push({
              token: token.symbol,
              amount,
              pxjReceived: 0,
              success: false,
              error: "No liquidity available"
            });
          }
        } catch (error2) {
          log.error(`Failed to get swap quote for ${token.symbol}`, "UserProfile", error2);
          swapResults.push({
            token: token.symbol,
            amount: parseFloat(token.balance.split(" ")[0]),
            pxjReceived: 0,
            success: false,
            error: "Swap quote failed"
          });
        }
      }
      const successfulSwaps = swapResults.filter((r) => r.success);
      const failedSwaps = swapResults.filter((r) => !r.success);
      let message = `Bulk Sell Summary:

`;
      if (successfulSwaps.length > 0) {
        message += `Successful swaps (${successfulSwaps.length}):
`;
        successfulSwaps.forEach((swap) => {
          message += ` ${swap.amount} ${swap.token}  ${swap.pxjReceived.toFixed(8)} PXJ
`;
        });
        message += `
Total PXJ received: ${totalPxjReceived.toFixed(8)} PXJ
`;
      }
      if (failedSwaps.length > 0) {
        message += `
Failed swaps (${failedSwaps.length}):
`;
        failedSwaps.forEach((swap) => {
          message += ` ${swap.amount} ${swap.token} - ${swap.error}
`;
        });
      }
      message += `
Note: This is a preview. Actual swaps would require wallet confirmation.`;
      showSuccess("Bulk Sell Summary", message);
      setSelectedTokens(/* @__PURE__ */ new Set());
      if (successfulSwaps.length > 0) {
        await fetchTokenBalances();
      }
    } catch (error2) {
      log.error("Bulk sell failed", "UserProfile", error2);
      showError("Bulk Sell Failed", "Bulk sell failed. Please try again.");
    } finally {
      setBulkSellLoading(false);
    }
  };
  const fetchCollectionAvatars = async (collections) => {
    const avatars = {};
    for (const collection of collections) {
      try {
        const response = await fetch(`https://aa.dapplica.io/atomicassets/v1/collections/${collection}`);
        const data = await response.json();
        if (data.success && data.data?.img) {
          const img = data.data.img;
          avatars[collection] = img.startsWith("http") ? img : `https://ipfs.io/ipfs/${img}`;
        }
      } catch (error2) {
        log.error(`Error fetching avatar for collection ${collection}`, "UserProfile", error2);
      }
    }
    setCollectionAvatars(avatars);
  };
  const filteredTransactions = transactions.filter((tx) => {
    if (transactionFilter !== "all") {
      if (transactionFilter === "tokens") {
        if (tx.type !== "token_send" && tx.type !== "token_receive") return false;
      } else if (tx.type !== transactionFilter) {
        return false;
      }
    }
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      const matchesAssetName = tx.asset_name?.toLowerCase().includes(query);
      const matchesCollection = tx.collection_name?.toLowerCase().includes(query);
      const matchesTxId = tx.transaction_id.toLowerCase().includes(query);
      const matchesFrom = tx.from?.toLowerCase().includes(query);
      const matchesTo = tx.to?.toLowerCase().includes(query);
      if (!matchesAssetName && !matchesCollection && !matchesTxId && !matchesFrom && !matchesTo) {
        return false;
      }
    }
    if (dateRange !== "all") {
      const txDate = new Date(tx.block_time);
      if (dateRange === "custom") {
        if (customDateRange.start && customDateRange.end) {
          const startDate = new Date(customDateRange.start);
          const endDate = new Date(customDateRange.end);
          endDate.setHours(23, 59, 59, 999);
          if (txDate < startDate || txDate > endDate) return false;
        } else if (customDateRange.start) {
          const startDate = new Date(customDateRange.start);
          if (txDate < startDate) return false;
        } else if (customDateRange.end) {
          const endDate = new Date(customDateRange.end);
          endDate.setHours(23, 59, 59, 999);
          if (txDate > endDate) return false;
        }
      } else {
        const now = /* @__PURE__ */ new Date();
        const daysAgo = dateRange === "7d" ? 7 : dateRange === "30d" ? 30 : 90;
        const cutoffDate = new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1e3);
        if (txDate < cutoffDate) return false;
      }
    }
    return true;
  });
  const sortedTransactions = [...filteredTransactions].sort((a, b) => {
    let comparison = 0;
    switch (sortBy) {
      case "date":
        comparison = new Date(a.block_time).getTime() - new Date(b.block_time).getTime();
        break;
      case "amount": {
        const aAmount = parseFloat(a.price?.replace(" WAX", "") || "0");
        const bAmount = parseFloat(b.price?.replace(" WAX", "") || "0");
        comparison = aAmount - bAmount;
        break;
      }
      case "type":
        comparison = a.type.localeCompare(b.type);
        break;
    }
    return sortOrder === "desc" ? -comparison : comparison;
  });
  const totalPages = Math.ceil(sortedTransactions.length / transactionsPerPage);
  const startIndex = (currentPage - 1) * transactionsPerPage;
  const paginatedTransactions = sortedTransactions.slice(startIndex, startIndex + transactionsPerPage);
  const exportTransactions = (format) => {
    setIsExporting(true);
    setExportError(null);
    try {
      let content;
      let filename;
      let mimeType;
      if (format === "csv") {
        const headers = ["Transaction ID", "Date", "Type", "Asset Name", "Collection", "Price", "From", "To", "Status"];
        const csvRows = [headers.join(",")];
        filteredTransactions.forEach((tx) => {
          const row = [
            tx.transaction_id,
            tx.block_time,
            tx.type,
            tx.asset_name || "",
            tx.collection_name || "",
            tx.price || "",
            tx.from || "",
            tx.to || "",
            tx.status
          ].map((field) => `"${field}"`);
          csvRows.push(row.join(","));
        });
        content = csvRows.join("\n");
        filename = `transactions_${account}_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`;
        mimeType = "text/csv";
      } else {
        content = JSON.stringify(filteredTransactions, null, 2);
        filename = `transactions_${account}_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
        mimeType = "application/json";
      }
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    } catch (error2) {
      log.error("Export failed", "UserProfile", error2);
      const errorMessage = error2 instanceof Error ? error2.message : "Failed to export transactions. Please try again.";
      setExportError(errorMessage);
      showError("Export Error", errorMessage);
    } finally {
      setIsExporting(false);
    }
  };
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };
  const formatWAX = (amount) => {
    return formatWAXPrice(parseFloat(amount.replace(" WAX", "")));
  };
  if (!isConnected) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "user-profile", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "profile-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "not-connected", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "not-connected-icon", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Connect Your Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Please connect your wallet to view your profile and transaction history." })
    ] }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-profile", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "profile-avatar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "avatar-placeholder", children: account?.charAt(0).toUpperCase() }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: account }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-badges", children: [
            userBadges.map((badge) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `badge ${badge.id}`, title: badge.description, children: [
              badge.icon,
              " ",
              badge.name
            ] }, badge.id)),
            userBadges.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge no-badges", children: "No badges earned yet" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "profile-stats-quick", children: userStats && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: userStats.nftsOwned }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "NFTs Owned" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: userStats.totalPurchases }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Purchases" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: userStats.totalSales }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Sales" })
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-tabs", role: "tablist", "aria-label": "Profile sections", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `tab-button ${activeTab === "overview" ? "active" : ""}`,
              onClick: () => setActiveTab("overview"),
              role: "tab",
              "aria-selected": activeTab === "overview",
              "aria-controls": "overview-panel",
              id: "overview-tab",
              children: "Overview"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `tab-button ${activeTab === "transactions" ? "active" : ""}`,
              onClick: () => setActiveTab("transactions"),
              role: "tab",
              "aria-selected": activeTab === "transactions",
              "aria-controls": "transactions-panel",
              id: "transactions-tab",
              children: "Transactions"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `tab-button ${activeTab === "portfolio" ? "active" : ""}`,
              onClick: () => setActiveTab("portfolio"),
              role: "tab",
              "aria-selected": activeTab === "portfolio",
              "aria-controls": "portfolio-panel",
              id: "portfolio-tab",
              children: "Portfolio Analytics"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `tab-button ${activeTab === "pxbadges" ? "active" : ""}`,
              onClick: () => setActiveTab("pxbadges"),
              role: "tab",
              "aria-selected": activeTab === "pxbadges",
              "aria-controls": "pxbadges-panel",
              id: "pxbadges-tab",
              children: "PxBadges"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `tab-button ${activeTab === "network-resources" ? "active" : ""}`,
              onClick: () => setActiveTab("network-resources"),
              role: "tab",
              "aria-selected": activeTab === "network-resources",
              "aria-controls": "network-resources-panel",
              id: "network-resources-tab",
              children: "Network Resources"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `tab-button ${activeTab === "powerup" ? "active" : ""}`,
              onClick: () => setActiveTab("powerup"),
              role: "tab",
              "aria-selected": activeTab === "powerup",
              "aria-controls": "powerup-panel",
              id: "powerup-tab",
              children: "Powerup"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `tab-button ${activeTab === "token-balances" ? "active" : ""}`,
              onClick: () => setActiveTab("token-balances"),
              role: "tab",
              "aria-selected": activeTab === "token-balances",
              "aria-controls": "token-balances-panel",
              id: "token-balances-tab",
              children: "Token Balances"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `tab-button ${activeTab === "swap" ? "active" : ""}`,
              onClick: () => setActiveTab("swap"),
              role: "tab",
              "aria-selected": activeTab === "swap",
              "aria-controls": "swap-panel",
              id: "swap-tab",
              children: "Swap"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-content", children: [
        loading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading profile data..." })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-state", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: loadUserData, className: "retry-button", children: "Retry" })
        ] }),
        !loading && !error && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          activeTab === "overview" && userStats && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overview-tab", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-label", children: "WAX Balance:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-value", children: waxBalance })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-label", children: "USD Value:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-value", children: "$0.00" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "account-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-label", children: "Account Name:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-value", children: account })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-label", children: "Created:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-value", children: accountData?.created ? new Date(accountData.created).toLocaleDateString() : "Loading..." })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-label", children: "Last Active:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-value", children: lastTransactionDate ? new Date(lastTransactionDate).toLocaleDateString() : accountData?.last_code_update ? new Date(accountData.last_code_update).toLocaleDateString() : "Loading..." })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-label", children: "Reputation:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-value", children: userStats?.reputation || " (4.8/5)" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-grid", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: userStats?.nftsOwned || 0 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "NFTs Owned" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: userStats?.totalTransactions || 0 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Transactions" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: userStats?.totalEarned || "0" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "WAX Earned" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: userStats?.tierStatus || "Bronze" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Tier Status" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "favorite-collections", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Favorite Collections" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collections-list", children: userStats.favoriteCollections.map((collection, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-collection-avatar", children: [
                  collectionAvatars[collection] ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: collectionAvatars[collection],
                      alt: `${collection} avatar`,
                      onError: (e) => {
                        e.currentTarget.style.display = "none";
                        e.currentTarget.nextElementSibling.style.display = "flex";
                      }
                    }
                  ) : null,
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fallback-avatar", style: { display: collectionAvatars[collection] ? "none" : "flex" }, children: collection.charAt(0).toUpperCase() })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "collection-name", children: collection })
              ] }, index)) })
            ] })
          ] }),
          activeTab === "transactions" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transactions-tab", children: [
            !isConnected && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-connection-prompt", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "prompt-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Connect Your Wallet" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your WAX wallet to view your personal transaction history and account details." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "connect-wallet-btn", onClick: login, children: "Connect Wallet" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "demo-notice", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                " Currently showing demo data from account: ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "pixeljourney" })
              ] }) })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quick-filters", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `filter-btn ${transactionFilter === "all" ? "active" : ""}`,
                  onClick: () => setTransactionFilter("all"),
                  children: " All Activity"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `filter-btn ${transactionFilter === "purchase" ? "active" : ""}`,
                  onClick: () => setTransactionFilter("purchase"),
                  children: " Purchases"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `filter-btn ${transactionFilter === "sale" ? "active" : ""}`,
                  onClick: () => setTransactionFilter("sale"),
                  children: " Sales"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `filter-btn ${transactionFilter === "transfer" ? "active" : ""}`,
                  onClick: () => setTransactionFilter("transfer"),
                  children: " Transfers"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `filter-btn ${transactionFilter === "tokens" ? "active" : ""}`,
                  onClick: () => setTransactionFilter("tokens"),
                  children: " Tokens"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transactions-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transactions-stats", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: sortedTransactions.length }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Total Found" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: transactions.length }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "All Transactions" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transactions-actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    className: "export-btn",
                    onClick: () => exportTransactions("csv"),
                    disabled: isExporting || filteredTransactions.length === 0,
                    children: [
                      isExporting ? "" : "",
                      " Export CSV"
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    className: "export-btn",
                    onClick: () => exportTransactions("json"),
                    disabled: isExporting || filteredTransactions.length === 0,
                    children: [
                      isExporting ? "" : "",
                      " Export JSON"
                    ]
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transactions-controls", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-input-wrapper", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    placeholder: "Search by asset name, collection, transaction ID, or address...",
                    value: searchQuery,
                    onChange: (e) => {
                      setSearchQuery(e.target.value);
                      setCurrentPage(1);
                    },
                    className: "search-input"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "search-icon", children: "" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filters-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Type:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: transactionFilter,
                      onChange: (e) => {
                        setTransactionFilter(e.target.value);
                        setCurrentPage(1);
                      },
                      className: "filter-select",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All Types" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "purchase", children: " Purchases" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "sale", children: " Sales" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "transfer", children: " Transfers" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "tokens", children: " Token Transactions" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Date:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: dateRange,
                      onChange: (e) => {
                        setDateRange(e.target.value);
                        setCurrentPage(1);
                      },
                      className: "filter-select",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "7d", children: "Last 7 days" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "30d", children: "Last 30 days" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "90d", children: "Last 90 days" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All time" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "custom", children: " Custom Range" })
                      ]
                    }
                  ),
                  dateRange === "custom" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-date-range", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "date-input-group", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "From:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "date",
                          className: "date-input",
                          value: customDateRange.start,
                          onChange: (e) => {
                            setCustomDateRange((prev) => ({
                              ...prev,
                              start: e.target.value
                            }));
                            setCurrentPage(1);
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "date-input-group", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "To:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "date",
                          className: "date-input",
                          value: customDateRange.end,
                          onChange: (e) => {
                            setCustomDateRange((prev) => ({
                              ...prev,
                              end: e.target.value
                            }));
                            setCurrentPage(1);
                          }
                        }
                      )
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Sort:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: `${sortBy}-${sortOrder}`,
                      onChange: (e) => {
                        const [newSortBy, newSortOrder] = e.target.value.split("-");
                        setSortBy(newSortBy);
                        setSortOrder(newSortOrder);
                      },
                      className: "filter-select",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "date-desc", children: " Newest First" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "date-asc", children: " Oldest First" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "amount-desc", children: " Highest Amount" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "amount-asc", children: " Lowest Amount" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "type-asc", children: " Type A-Z" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "type-desc", children: " Type Z-A" })
                      ]
                    }
                  )
                ] })
              ] })
            ] }),
            isLoadingTransactions && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Loading Transactions..." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Fetching your transaction history from the blockchain." })
            ] }),
            transactionError && !isLoadingTransactions && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-state", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Failed to Load Transactions" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionError }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "retry-btn",
                  onClick: () => loadTransactions(),
                  children: " Retry"
                }
              )
            ] }),
            exportError && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "export-error", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "error-text", children: [
                "Export failed: ",
                exportError
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "dismiss-error-btn",
                  onClick: () => setExportError(null),
                  children: ""
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transactions-list", children: !isLoadingTransactions && !transactionError && paginatedTransactions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "no-transactions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-transactions-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No transactions found" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: searchQuery ? `No transactions match your search "${searchQuery}"` : "No transactions found for the selected filters." }),
              (searchQuery || transactionFilter !== "all" || dateRange !== "all") && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "clear-filters-btn",
                  onClick: () => {
                    setSearchQuery("");
                    setTransactionFilter("all");
                    setDateRange("all");
                    setCustomDateRange({ start: "", end: "" });
                    setCurrentPage(1);
                  },
                  children: "Clear All Filters"
                }
              )
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transactions-grid", children: paginatedTransactions.map((tx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-card", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-header", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-icon", children: [
                    tx.type === "purchase" && "",
                    tx.type === "sale" && "",
                    tx.type === "transfer" && "",
                    tx.type === "token_send" && "",
                    tx.type === "token_receive" && "",
                    tx.type === "mint" && ""
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transaction-type-badge", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `type-badge ${tx.type}`, children: tx.type.charAt(0).toUpperCase() + tx.type.slice(1).replace("_", " ") }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transaction-status", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `status-badge ${tx.status}`, children: [
                    tx.status === "completed" && "",
                    tx.status === "pending" && "",
                    tx.status === "failed" && ""
                  ] }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-content", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-info", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "asset-name", children: tx.asset_name || "Unknown Asset" }),
                    tx.collection_name && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "collection-name", children: tx.collection_name })
                  ] }),
                  tx.price && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transaction-amount", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `amount ${tx.type === "sale" || tx.type === "token_receive" ? "positive" : "negative"}`, children: [
                    tx.type === "sale" || tx.type === "token_receive" ? "+" : "-",
                    formatWAX(tx.price)
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-meta", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "meta-row", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-label", children: "Date:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-value", children: formatDate(tx.block_time) })
                    ] }),
                    tx.from && tx.from !== account && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "meta-row", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-label", children: "From:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-value address", children: tx.from })
                    ] }),
                    tx.to && tx.to !== account && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "meta-row", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-label", children: "To:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-value address", children: tx.to })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "meta-row", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-label", children: "TX ID:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "span",
                        {
                          className: "meta-value transaction-id-link",
                          onClick: () => navigate(`/transactions/${tx.transaction_id}`),
                          title: "View transaction details",
                          children: [
                            tx.transaction_id.slice(0, 12),
                            "..."
                          ]
                        }
                      )
                    ] }),
                    tx.memo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "meta-row", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-label", children: "Memo:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-value memo", children: tx.memo })
                    ] })
                  ] })
                ] })
              ] }, tx.transaction_id)) }),
              totalPages > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pagination-info", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  "Showing ",
                  startIndex + 1,
                  "-",
                  Math.min(startIndex + transactionsPerPage, sortedTransactions.length),
                  " of ",
                  sortedTransactions.length,
                  " transactions"
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-controls", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "pagination-btn",
                      onClick: () => setCurrentPage(1),
                      disabled: currentPage === 1,
                      title: "First page",
                      children: ""
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "pagination-btn",
                      onClick: () => setCurrentPage(currentPage - 1),
                      disabled: currentPage === 1,
                      title: "Previous page",
                      children: ""
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-numbers", children: Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                    let pageNum;
                    if (totalPages <= 5) {
                      pageNum = i + 1;
                    } else if (currentPage <= 3) {
                      pageNum = i + 1;
                    } else if (currentPage >= totalPages - 2) {
                      pageNum = totalPages - 4 + i;
                    } else {
                      pageNum = currentPage - 2 + i;
                    }
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        className: `page-number ${currentPage === pageNum ? "active" : ""}`,
                        onClick: () => setCurrentPage(pageNum),
                        children: pageNum
                      },
                      pageNum
                    );
                  }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "pagination-btn",
                      onClick: () => setCurrentPage(currentPage + 1),
                      disabled: currentPage === totalPages,
                      title: "Next page",
                      children: ""
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "pagination-btn",
                      onClick: () => setCurrentPage(totalPages),
                      disabled: currentPage === totalPages,
                      title: "Last page",
                      children: ""
                    }
                  )
                ] })
              ] })
            ] }) })
          ] }),
          activeTab === "portfolio" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portfolio-tab", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PortfolioAnalytics, {}) }),
          activeTab === "pxbadges" && /* @__PURE__ */ jsxRuntimeExports.jsx(PxBadges, {}),
          activeTab === "network-resources" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "network-resources-tab", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resources-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Network Resources" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Manage your WAX account resources (CPU, NET, RAM)" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resources-grid", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-card cpu", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-header", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-icon", children: "" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-info", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "CPU" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Processing power for transactions" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-stats", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-fill cpu", style: { width: resourceData ? `${resourceData.cpu.used / resourceData.cpu.max * 100}%` : "45%" } }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-text", children: resourceData ? `${(resourceData.cpu.used / resourceData.cpu.max * 100).toFixed(1)}% used (${(resourceData.cpu.used / 1e3).toFixed(1)}ms / ${(resourceData.cpu.max / 1e3).toFixed(1)}ms)` : "45% used (4.5ms / 10ms)" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-actions", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "stake-btn", onClick: () => openStakingModal("cpu", "stake"), children: "Stake CPU" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "unstake-btn", onClick: () => openStakingModal("cpu", "unstake"), children: "Unstake CPU" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-card net", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-header", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-icon", children: "" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-info", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "NET" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Network bandwidth for transactions" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-stats", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-fill net", style: { width: resourceData ? `${resourceData.net.used / resourceData.net.max * 100}%` : "30%" } }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-text", children: resourceData ? `${(resourceData.net.used / resourceData.net.max * 100).toFixed(1)}% used (${(resourceData.net.used / 1024).toFixed(1)}KB / ${(resourceData.net.max / 1024).toFixed(1)}KB)` : "30% used (3KB / 10KB)" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-actions", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "stake-btn", onClick: () => openStakingModal("net", "stake"), children: "Stake NET" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "unstake-btn", onClick: () => openStakingModal("net", "unstake"), children: "Unstake NET" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-card ram", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-header", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-icon", children: "" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-info", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "RAM" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Storage space for account data" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-stats", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-fill ram", style: { width: resourceData ? `${resourceData.ram.used / resourceData.ram.max * 100}%` : "65%" } }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-text", children: resourceData ? `${(resourceData.ram.used / resourceData.ram.max * 100).toFixed(1)}% used (${(resourceData.ram.used / 1024).toFixed(1)}KB / ${(resourceData.ram.max / 1024).toFixed(1)}KB)` : "65% used (6.5KB / 10KB)" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-actions", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "buy-ram-btn", onClick: () => openRAMModal("buy"), children: "Buy RAM" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "sell-ram-btn", onClick: () => openRAMModal("sell"), children: "Sell RAM" })
                ] })
              ] })
            ] })
          ] }),
          activeTab === "powerup" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "powerup-tab", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "powerup-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Powerup Resources" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Boost your account resources for 24 hours" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "powerup-stats", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-usage", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Current Resource Usage" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "usage-grid", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "usage-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "usage-label", children: "CPU:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-fill", style: { width: resourceData ? `${calculateResourceUsage(resourceData.cpu.used, resourceData.cpu.max)}%` : "0%" } }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "usage-percent", children: resourceData ? `${calculateResourceUsage(resourceData.cpu.used, resourceData.cpu.max).toFixed(1)}%` : "0%" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "usage-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "usage-label", children: "NET:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "usage-fill", style: { width: resourceData ? `${calculateResourceUsage(resourceData.net.used, resourceData.net.max)}%` : "0%" } }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "usage-percent", children: resourceData ? `${calculateResourceUsage(resourceData.net.used, resourceData.net.max).toFixed(1)}%` : "0%" })
                ] })
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "powerup-form", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Account to Boost:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    placeholder: "Enter account name",
                    value: accountToBoost,
                    onChange: (e) => setAccountToBoost(e.target.value)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "WAX Amount to Spend:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "amount-input-container", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "0.0000",
                      value: powerupAmount || "",
                      onChange: handleInputChange,
                      step: "0.0001",
                      min: "0",
                      max: parseFloat(waxBalance.split(" ")[0])
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wax-label", children: "WAX" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slider-container", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "range",
                      min: "0",
                      max: "100",
                      value: parseFloat(waxBalance.split(" ")[0]) > 0 ? powerupAmount / parseFloat(waxBalance.split(" ")[0]) * 100 : 0,
                      onChange: handleSliderChange,
                      className: "slider"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slider-value", children: [
                    formatWAXPrice(powerupAmount),
                    " (Max: ",
                    waxBalance,
                    ")"
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
                  "CPU/NET Ratio: ",
                  cpuAllocation,
                  "% CPU / ",
                  100 - cpuAllocation,
                  "% NET"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "progress-container", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "progress-bar-container", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar cpu", style: { width: `${cpuAllocation}%` } }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar net", style: { width: `${100 - cpuAllocation}%` } })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "progress-text", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "cpu-text", children: [
                      cpuAllocation,
                      "% CPU"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "separator", children: " / " }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "net-text", children: [
                      100 - cpuAllocation,
                      "% NET"
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slider-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "range",
                    min: "0",
                    max: "100",
                    value: cpuAllocation,
                    onChange: handleCpuSliderChange,
                    className: "slider"
                  }
                ) })
              ] }),
              powerupAmount > 0 && powerupState && chainInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "powerup-estimation", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Estimated Boost (24 hours):" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "boost-details", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "boost-item", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "CPU:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: estimateCpuWithElasticLimit(
                      waxToCpuFrac(powerupAmount, cpuAllocation),
                      waxToNetFrac(powerupAmount, cpuAllocation),
                      powerupState?.cpu,
                      powerupState?.net,
                      chainInfo
                    ) })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "boost-item", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "NET:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: netCalc(
                      predictResourceAmounts(
                        waxToCpuFrac(powerupAmount, cpuAllocation),
                        waxToNetFrac(powerupAmount, cpuAllocation),
                        powerupState?.cpu,
                        powerupState?.net
                      ).netAmount
                    ) })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cost-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cost-item", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "CPU Cost:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      predictResourceAmounts(
                        waxToCpuFrac(powerupAmount, cpuAllocation),
                        waxToNetFrac(powerupAmount, cpuAllocation),
                        powerupState?.cpu,
                        powerupState?.net
                      ).cpuFee.toFixed(8),
                      " WAX"
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "cost-item", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "NET Cost:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      predictResourceAmounts(
                        waxToCpuFrac(powerupAmount, cpuAllocation),
                        waxToNetFrac(powerupAmount, cpuAllocation),
                        powerupState?.cpu,
                        powerupState?.net
                      ).netFee.toFixed(8),
                      " WAX"
                    ] })
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "powerup-btn",
                  disabled: !powerupAmount || powerupAmount <= 0 || !accountToBoost || txIsLoading,
                  onClick: () => {
                    if (powerupAmount > 0 && accountToBoost && session) {
                      const cpuFrac = waxToCpuFrac(powerupAmount, cpuAllocation);
                      const netFrac = waxToNetFrac(powerupAmount, cpuAllocation);
                      submitPowerupTx(
                        accountToBoost,
                        powerupAmount,
                        cpuFrac,
                        netFrac,
                        setTxIsLoading,
                        session
                      );
                    }
                  },
                  children: txIsLoading ? "Processing..." : "Boost Resources"
                }
              )
            ] })
          ] }),
          activeTab === "token-balances" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balances-tab", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balances-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Token Balances" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "View your token balances with USD values" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-summary", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-summary-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-summary-label", children: "Total Tokens:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-summary-value", children: tokenBalances.length })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-summary-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-summary-label", children: "With USD Values:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-summary-value", children: tokenBalances.filter((t) => t.value !== "N/A" && t.value !== "0.00").length })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balances-controls", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-sort", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    placeholder: "Search tokens...",
                    className: "search-input"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("select", { className: "sort-select", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "balance", children: "Sort by Balance" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "value", children: "Sort by Value" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "name", children: "Sort by Name" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bulk-actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "select-all-btn", onClick: handleSelectAll, children: selectedTokens.size === tokenBalances.length ? "Deselect All" : "Select All" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "selected-info", children: [
                  selectedTokens.size,
                  " selected"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "bulk-sell-btn",
                    onClick: handleBulkSell,
                    disabled: selectedTokens.size === 0 || bulkSellLoading,
                    children: bulkSellLoading ? "Processing..." : `Bulk Sell into PXJ ${selectedTokens.size > 0 ? `(${selectedTokens.size})` : "(Coming Soon)"}`
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-balances-grid", children: tokenBalances.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "no-tokens-message", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-tokens-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No Token Balances Found" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Your account doesn't have any token balances or they're still loading." })
            ] }) : tokenBalances.map((token, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balance-card", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-header", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-icon", children: "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-details", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: token.symbol }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "token-contract", children: token.contract })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-amounts", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balance", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-label", children: "Balance:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "balance-value", children: token.balance })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-usd-value", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "usd-label", children: "USD Value:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `usd-value ${token.value === "N/A" ? "unavailable" : token.value === "0.00" ? "zero" : "available"}`, children: token.value === "N/A" ? "N/A" : `$${token.value}` })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "token-action-btn transfer",
                    onClick: () => openTokenTransferModal(token),
                    children: "Transfer"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "token-action-btn trade", disabled: true, children: "Trade" })
              ] })
            ] }, `${token.contract}-${token.symbol}-${index}`)) })
          ] }),
          activeTab === "swap" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-tab", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-tab-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Token Swap" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Swap tokens directly using Alcor DEX integration" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SwapInterface, {})
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StakingModal,
      {
        isOpen: stakingModal.isOpen,
        onClose: closeStakingModal,
        resourceType: stakingModal.resourceType,
        action: stakingModal.action,
        onSuccess: handleResourceSuccess
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RAMModal,
      {
        isOpen: ramModal.isOpen,
        onClose: closeRAMModal,
        action: ramModal.action,
        onSuccess: handleResourceSuccess
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TokenTransferModal,
      {
        isOpen: tokenTransferModal.isOpen,
        onClose: closeTokenTransferModal,
        token: tokenTransferModal.token,
        onSuccess: handleTokenTransferSuccess
      }
    )
  ] });
};
const getAccountCreationDate = async (account) => {
  try {
    const accountInfo = await apiService.getWaxAccountInfo(account);
    if (accountInfo && accountInfo.created) {
      return new Date(accountInfo.created).toISOString().split("T")[0];
    }
  } catch (error) {
    log.warn("Could not fetch account creation date:", "UserProfileLookup.getAccountCreationDate", error);
  }
  try {
    const transactions = await apiService.getUserTransactions(account, 1);
    if (transactions && transactions.length > 0) {
      const firstTx = transactions[transactions.length - 1];
      if (firstTx.block_time) {
        return new Date(firstTx.block_time).toISOString().split("T")[0];
      }
    }
  } catch (error) {
    log.warn("Could not fetch first transaction date:", "UserProfileLookup.getAccountCreationDate", error);
  }
  return "2023-01-01";
};
const UserProfileLookup = () => {
  const { account: paramAccount } = useParams();
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const account = paramAccount || searchParams.get("user");
  const [profileData, setProfileData] = reactExports.useState(null);
  const [userStats, setUserStats] = reactExports.useState(null);
  const [accountInfo, setAccountInfo] = reactExports.useState(null);
  const [waxBalance, setWaxBalance] = reactExports.useState("0.0000");
  const [tokenBalances, setTokenBalances] = reactExports.useState([]);
  const [resourceData, setResourceData] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [selectedNFT, setSelectedNFT] = reactExports.useState(null);
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [collectionAvatars, setCollectionAvatars] = reactExports.useState({});
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [filter, setFilter] = reactExports.useState("all");
  const [userBadges, setUserBadges] = reactExports.useState([]);
  const itemsPerPage = 20;
  const [pixalFilters, setPixalFilters] = reactExports.useState({
    Body: "",
    Eyes: "",
    Head: "",
    Mouth: "",
    WaxRock: "",
    PixelPet: "",
    Background: "",
    "Hats and Hair": "",
    "Glasses and Masks": "",
    "Special Accessories": ""
  });
  const [availableTraits, setAvailableTraits] = reactExports.useState({});
  const fetchTokenBalances = reactExports.useCallback(async (userAccount) => {
    try {
      const tokenContracts = ["token.pxj", "eosio.token"];
      const balances = [];
      for (const contract of tokenContracts) {
        try {
          const contractBalances = await apiService.getWaxCurrencyBalance(userAccount, contract);
          const balancesWithValue = await Promise.all(contractBalances.map(async (balance) => ({
            ...balance,
            contract,
            value: await calculateTokenValue(balance.balance, balance.symbol)
          })));
          balances.push(...balancesWithValue);
        } catch (error2) {
          log.error(`Failed to fetch balance for ${contract}:`, "UserProfileLookup.fetchTokenBalances", error2);
        }
      }
      setTokenBalances(balances);
    } catch (error2) {
      log.error("Error fetching token balances:", "UserProfileLookup.fetchTokenBalances", error2);
    }
  }, []);
  const loadUserProfile = reactExports.useCallback(async () => {
    if (!account) return;
    setLoading(true);
    setError(null);
    try {
      const inventory = await apiService.getUserInventory(account);
      const collections = [...new Set(inventory.map((nft) => nft.collection))];
      const badgeResult = await badgeService.checkUserBadges(account);
      setUserBadges(badgeResult.badges);
      const pixalNFTs = inventory.filter((nft) => nft.collection === "pixeljourney" && nft.schema === "pixals");
      const traits = {
        Body: /* @__PURE__ */ new Set(),
        Eyes: /* @__PURE__ */ new Set(),
        Head: /* @__PURE__ */ new Set(),
        Mouth: /* @__PURE__ */ new Set(),
        WaxRock: /* @__PURE__ */ new Set(),
        PixelPet: /* @__PURE__ */ new Set(),
        Background: /* @__PURE__ */ new Set(),
        "Hats and Hair": /* @__PURE__ */ new Set(),
        "Glasses and Masks": /* @__PURE__ */ new Set(),
        "Special Accessories": /* @__PURE__ */ new Set()
      };
      pixalNFTs.forEach((nft) => {
        Object.keys(traits).forEach((trait) => {
          const value = nft.data?.[trait];
          if (value && value !== "none" && value !== "") {
            traits[trait].add(value);
          }
        });
      });
      const availableTraitsObj = {};
      Object.entries(traits).forEach(([trait, values]) => {
        availableTraitsObj[trait] = Array.from(values).sort();
      });
      setAvailableTraits(availableTraitsObj);
      await Promise.all([
        fetchWaxAccountInfo(account),
        fetchWaxBalance(account),
        fetchTokenBalances(account)
      ]);
      const joinDate = await getAccountCreationDate(account);
      const profileData2 = {
        account,
        nftsOwned: inventory,
        totalNFTs: inventory.length,
        collections,
        joinDate,
        isVerified: badgeResult.badges.some((badge) => badge.id === "pixal-pfp"),
        badges: badgeResult.badges.map((badge) => badge.name)
      };
      const totalValue = await calculateTotalValue(inventory);
      const stats = {
        totalAssets: inventory.length,
        uniqueCollections: collections.length,
        totalValue,
        rareAssets: inventory.filter((nft) => nft.template_mint && nft.template_mint <= 100).length
      };
      setProfileData(profileData2);
      setUserStats(stats);
      if (collections.length > 0) {
        fetchCollectionAvatars(collections);
      }
    } catch (err) {
      log.error("Error loading user profile:", "UserProfileLookup.loadUserProfile", err);
      setError("Failed to load user profile. Please check the account name and try again.");
    } finally {
      setLoading(false);
    }
  }, [account, fetchTokenBalances]);
  reactExports.useEffect(() => {
    if (account) {
      loadUserProfile();
    }
  }, [account, loadUserProfile]);
  const fetchWaxAccountInfo = async (userAccount) => {
    try {
      const accountInfo2 = await apiService.getWaxAccountInfo(userAccount);
      setAccountInfo(accountInfo2);
      if (accountInfo2) {
        const resources = {
          cpu: {
            used: accountInfo2.cpu_limit.used,
            available: accountInfo2.cpu_limit.available,
            max: accountInfo2.cpu_limit.max
          },
          net: {
            used: accountInfo2.net_limit.used,
            available: accountInfo2.net_limit.available,
            max: accountInfo2.net_limit.max
          },
          ram: {
            used: accountInfo2.ram_usage,
            available: accountInfo2.ram_quota - accountInfo2.ram_usage,
            max: accountInfo2.ram_quota
          }
        };
        setResourceData(resources);
      }
    } catch (error2) {
      log.error("Failed to fetch WAX account info:", "UserProfileLookup.fetchWaxAccountInfo", error2);
    }
  };
  const fetchWaxBalance = async (userAccount) => {
    try {
      const balance = await balanceService.getWaxBalance(userAccount);
      setWaxBalance(balance);
    } catch (error2) {
      log.error("Failed to fetch WAX balance:", "UserProfileLookup.fetchWaxBalance", error2);
    }
  };
  const calculateTokenValue = async (balance, symbol) => {
    const amount = parseFloat(balance.split(" ")[0]);
    try {
      const tokenContracts = {
        "TLM": "alien.worlds",
        "NEFTY": "neftyblocksp",
        "SEST": "sest.token"
      };
      const contract = tokenContracts[symbol];
      if (contract) {
        const priceData = await apiService.getAlcorTokenPrice(symbol, contract);
        if (priceData && priceData.usd_price) {
          return `$${(amount * priceData.usd_price).toFixed(4)}`;
        }
      }
      const fallbackPrices = {
        "TLM": 0.02,
        "NEFTY": 1e-3,
        "SEST": 1e-4
      };
      const price = fallbackPrices[symbol] || 1e-3;
      return `$${(amount * price).toFixed(4)}`;
    } catch (error2) {
      log.error(`Error fetching price for ${symbol}:`, "UserProfileLookup.fetchWaxAccountInfo", error2);
      const fallbackPrices = {
        "TLM": 0.02,
        "NEFTY": 1e-3,
        "SEST": 1e-4
      };
      const price = fallbackPrices[symbol] || 1e-3;
      return `$${(amount * price).toFixed(4)}`;
    }
  };
  const calculateTotalValue = async (inventory) => {
    if (inventory.length === 0) return "0.00 WAX";
    try {
      const collectionGroups = inventory.reduce((groups, nft) => {
        const collection = nft.collection;
        if (!groups[collection]) groups[collection] = [];
        groups[collection].push(nft);
        return groups;
      }, {});
      let totalValue = 0;
      for (const [collection, nfts] of Object.entries(collectionGroups)) {
        try {
          const stats = await apiService.getCollectionStats(collection);
          let collectionFloorPrice = 0;
          if (stats && stats.floor_price) {
            collectionFloorPrice = parseFloat(stats.floor_price);
          } else {
            const salesResponse = await fetch(
              `${apiService.atomicMarketAPI}/atomicmarket/v1/sales?state=3&collection_name=${collection}&limit=50&order=desc&sort=updated`
            );
            const salesData = await salesResponse.json();
            if (salesData.success && salesData.data?.length > 0) {
              const prices = salesData.data.filter((sale) => sale.price?.amount).map((sale) => parseFloat(sale.price.amount) / Math.pow(10, sale.price.token_precision || 8));
              if (prices.length > 0) {
                collectionFloorPrice = Math.min(...prices);
              }
            }
          }
          if (collectionFloorPrice === 0) {
            collectionFloorPrice = 1;
          }
          nfts.forEach((nft) => {
            let nftValue = collectionFloorPrice;
            if (nft.template_mint) {
              if (nft.template_mint <= 10) {
                nftValue *= 3;
              } else if (nft.template_mint <= 50) {
                nftValue *= 2;
              } else if (nft.template_mint <= 100) {
                nftValue *= 1.5;
              }
            }
            totalValue += nftValue;
          });
        } catch (error2) {
          log.warn(`Failed to get market data for collection ${collection}, using fallback pricing:`, "UserProfileLookup.calculateTotalValue", error2);
          totalValue += nfts.length * 1.5;
        }
      }
      return `${totalValue.toFixed(2)} WAX`;
    } catch (error2) {
      log.error("Error calculating total portfolio value:", "UserProfileLookup.calculateTotalValue", error2);
      const fallbackValue = inventory.length * 2;
      return `${fallbackValue.toFixed(2)} WAX`;
    }
  };
  const getFilteredNFTs = () => {
    if (!profileData) return [];
    let filtered = profileData.nftsOwned;
    switch (filter) {
      case "pixals":
        filtered = filtered.filter((nft) => nft.collection === "pixeljourney" && nft.schema === "pixals");
        Object.entries(pixalFilters).forEach(([trait, value]) => {
          if (value && value !== "") {
            filtered = filtered.filter((nft) => {
              const traitValue = nft.data?.[trait];
              return traitValue && traitValue.toLowerCase().includes(value.toLowerCase());
            });
          }
        });
        break;
      case "waxrock": {
        filtered = filtered.filter((nft) => {
          const waxRock = nft.data?.WaxRock;
          return nft.collection === "pixeljourney" && nft.schema === "pixals" && waxRock && waxRock !== "none";
        });
        break;
      }
      case "ingredients":
        filtered = filtered.filter((nft) => nft.collection === "pixeljourney" && nft.schema === "ingredients");
        break;
    }
    return filtered;
  };
  const getPaginatedNFTs = () => {
    const filtered = getFilteredNFTs();
    const startIndex = (currentPage - 1) * itemsPerPage;
    return filtered.slice(startIndex, startIndex + itemsPerPage);
  };
  const getTotalPages = () => {
    const filtered = getFilteredNFTs();
    return Math.ceil(filtered.length / itemsPerPage);
  };
  const handleNFTClick = (nft) => {
    setSelectedNFT(nft);
    setIsModalOpen(true);
  };
  const fetchCollectionAvatars = async (collections) => {
    const avatars = {};
    for (const collection of collections) {
      try {
        const response = await fetch(`https://aa.dapplica.io/atomicassets/v1/collections/${collection}`);
        const data = await response.json();
        if (data.success && data.data?.img) {
          const img = data.data.img;
          avatars[collection] = img.startsWith("http") ? img : `https://ipfs.io/ipfs/${img}`;
        }
      } catch (error2) {
        log.error(`Error fetching avatar for collection ${collection}:`, "UserProfileLookup.fetchCollectionAvatars", error2);
      }
    }
    setCollectionAvatars(avatars);
  };
  const handleCloseModal = () => {
    setIsModalOpen(false);
    setSelectedNFT(null);
  };
  const handlePageChange = (page) => {
    setCurrentPage(page);
    window.scrollTo({ top: 0, behavior: "smooth" });
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "user-profile-lookup", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "profile-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading user profile..." })
    ] }) }) });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "user-profile-lookup", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "profile-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-icon", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Profile Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => navigate(-1), className: "btn-secondary", children: "Go Back" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: loadUserProfile, className: "btn-primary", children: "Try Again" })
      ] })
    ] }) }) });
  }
  if (!profileData || !userStats) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "user-profile-lookup", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "profile-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-data", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No profile data available" }) }) }) });
  }
  const filteredNFTs = getFilteredNFTs();
  const paginatedNFTs = getPaginatedNFTs();
  const totalPages = getTotalPages();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-profile-lookup", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "profile-avatar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "avatar-placeholder", children: account?.charAt(0).toUpperCase() }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: account }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-badges", children: [
            profileData.isVerified && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge verified", children: " Verified" }),
            userBadges.map((badge) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `badge ${badge.id}`, title: badge.description, children: [
              badge.icon,
              " ",
              badge.name
            ] }, badge.id))
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "profile-stats-quick", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: userStats.totalAssets }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "NFTs Owned" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: userStats.uniqueCollections }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Collections" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: userStats.rareAssets }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Rare Assets" })
          ] })
        ] })
      ] }),
      accountInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "account-info-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Account Information" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "account-info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "info-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-details", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Account Name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: accountInfo.account_name })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "info-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-details", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Created" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: new Date(accountInfo.created).toLocaleDateString() })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "info-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-details", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Permissions" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                accountInfo.permissions?.length || 0,
                " keys"
              ] })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Balances" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-card primary", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "balance-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-details", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "WAX Balance" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "balance-value", children: waxBalance })
            ] })
          ] }),
          tokenBalances.map((token, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "balance-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-details", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: token.symbol }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "balance-value", children: token.balance }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "balance-usd", children: token.value })
            ] })
          ] }, index))
        ] })
      ] }),
      resourceData && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resources-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Resources" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resources-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "resource-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "CPU" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "resource-fill",
                style: { width: `${resourceData.cpu.used / resourceData.cpu.max * 100}%` }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-stats", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                resourceData.cpu.used.toLocaleString(),
                " / ",
                resourceData.cpu.max.toLocaleString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                (resourceData.cpu.used / resourceData.cpu.max * 100).toFixed(1),
                "%"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "resource-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "NET" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "resource-fill",
                style: { width: `${resourceData.net.used / resourceData.net.max * 100}%` }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-stats", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                resourceData.net.used.toLocaleString(),
                " / ",
                resourceData.net.max.toLocaleString()
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                (resourceData.net.used / resourceData.net.max * 100).toFixed(1),
                "%"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "resource-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "RAM" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "resource-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "resource-fill",
                style: { width: `${resourceData.ram.used / resourceData.ram.max * 100}%` }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "resource-stats", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                (resourceData.ram.used / 1024).toFixed(2),
                " KB / ",
                (resourceData.ram.max / 1024).toFixed(2),
                " KB"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                (resourceData.ram.used / resourceData.ram.max * 100).toFixed(1),
                "%"
              ] })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-grid", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Total Assets" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "stat-value", children: userStats.totalAssets })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Collections" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "stat-value", children: userStats.uniqueCollections })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Estimated Value" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "stat-value", children: userStats.totalValue })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Rare Assets" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "stat-value", children: userStats.rareAssets })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collections-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
          "Collections (",
          profileData.collections.length,
          ")"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collections-list", children: profileData.collections.map((collection, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-item", onClick: () => navigate(`/collections/${collection}`), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-collection-avatar", children: [
            collectionAvatars[collection] ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: collectionAvatars[collection],
                alt: `${collection} avatar`,
                onError: (e) => {
                  e.currentTarget.style.display = "none";
                  e.currentTarget.nextElementSibling.style.display = "flex";
                }
              }
            ) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fallback-avatar", style: { display: collectionAvatars[collection] ? "none" : "flex" }, children: collection.charAt(0).toUpperCase() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "collection-name", children: collection }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "collection-count", children: profileData.nftsOwned.filter((nft) => nft.collection === collection).length })
        ] }, index)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
            "NFT Inventory (",
            filteredNFTs.length,
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-tabs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: `filter-tab ${filter === "all" ? "active" : ""}`,
                onClick: () => {
                  setFilter("all");
                  setCurrentPage(1);
                },
                children: [
                  "All (",
                  profileData.nftsOwned.length,
                  ")"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: `filter-tab ${filter === "pixals" ? "active" : ""}`,
                onClick: () => {
                  setFilter("pixals");
                  setCurrentPage(1);
                },
                children: [
                  "Pixals (",
                  profileData.nftsOwned.filter((nft) => nft.collection === "pixeljourney" && nft.schema === "pixals").length,
                  ")"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: `filter-tab ${filter === "waxrock" ? "active" : ""}`,
                onClick: () => {
                  setFilter("waxrock");
                  setCurrentPage(1);
                },
                children: [
                  "WaxRock (",
                  profileData.nftsOwned.filter((nft) => {
                    const waxRock = nft.data?.WaxRock;
                    return nft.collection === "pixeljourney" && nft.schema === "pixals" && waxRock && waxRock !== "none";
                  }).length,
                  ")"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: `filter-tab ${filter === "ingredients" ? "active" : ""}`,
                onClick: () => {
                  setFilter("ingredients");
                  setCurrentPage(1);
                },
                children: [
                  "Ingredients (",
                  profileData.nftsOwned.filter((nft) => nft.collection === "pixeljourney" && nft.schema === "ingredients").length,
                  ")"
                ]
              }
            )
          ] }),
          filter === "pixals" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pixal-filters", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Filter by Traits" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "filters-grid", children: Object.entries(pixalFilters).map(([trait, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: trait }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  value,
                  onChange: (e) => {
                    setPixalFilters((prev) => ({
                      ...prev,
                      [trait]: e.target.value
                    }));
                    setCurrentPage(1);
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("option", { value: "", children: [
                      "All ",
                      trait
                    ] }),
                    availableTraits[trait]?.map((traitValue) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: traitValue, children: traitValue }, traitValue))
                  ]
                }
              )
            ] }, trait)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "clear-filters-btn",
                onClick: () => {
                  setPixalFilters({
                    Body: "",
                    Eyes: "",
                    Head: "",
                    Mouth: "",
                    WaxRock: "",
                    PixelPet: "",
                    Background: "",
                    "Hats and Hair": "",
                    "Glasses and Masks": "",
                    "Special Accessories": ""
                  });
                  setCurrentPage(1);
                },
                children: "Clear All Filters"
              }
            )
          ] })
        ] }),
        paginatedNFTs.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-inventory", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No NFTs Found" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "This user doesn't have any NFTs in the selected category." })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-grid", children: paginatedNFTs.map((nft) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-card", onClick: () => handleNFTClick(nft), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-image", children: nft.video ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "video",
              {
                src: nft.video,
                className: "nft-media",
                muted: true,
                loop: true,
                onMouseEnter: (e) => e.currentTarget.play(),
                onMouseLeave: (e) => e.currentTarget.pause(),
                onError: (e) => {
                  const img = document.createElement("img");
                  img.src = nft.image;
                  img.className = "nft-media";
                  img.alt = nft.name;
                  img.loading = "lazy";
                  e.currentTarget.parentNode?.replaceChild(img, e.currentTarget);
                }
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: nft.image, alt: nft.name, className: "nft-media", loading: "lazy" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "nft-name", children: nft.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-collection", children: nft.collection }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-schema-template", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-schema", children: nft.schema }),
                nft.template_id && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-template", children: [
                  "T#",
                  nft.template_id
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-details", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-mint", children: [
                  "#",
                  nft.template_mint
                ] }),
                nft.max_supply && parseInt(nft.max_supply) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-supply", children: [
                  "/",
                  nft.max_supply
                ] })
              ] })
            ] })
          ] }, nft.asset_id)) }),
          totalPages > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "pagination-btn",
                onClick: () => handlePageChange(currentPage - 1),
                disabled: currentPage === 1,
                children: "Previous"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pagination-numbers", children: Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
              let pageNum;
              if (totalPages <= 5) {
                pageNum = i + 1;
              } else if (currentPage <= 3) {
                pageNum = i + 1;
              } else if (currentPage >= totalPages - 2) {
                pageNum = totalPages - 4 + i;
              } else {
                pageNum = currentPage - 2 + i;
              }
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `pagination-number ${currentPage === pageNum ? "active" : ""}`,
                  onClick: () => handlePageChange(pageNum),
                  children: pageNum
                },
                pageNum
              );
            }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "pagination-btn",
                onClick: () => handlePageChange(currentPage + 1),
                disabled: currentPage === totalPages,
                children: "Next"
              }
            )
          ] })
        ] })
      ] })
    ] }),
    selectedNFT && /* @__PURE__ */ jsxRuntimeExports.jsx(
      NFTDetailsModal,
      {
        nft: selectedNFT,
        isOpen: isModalOpen,
        onClose: handleCloseModal
      }
    )
  ] });
};
const Packs = () => {
  const { settings } = useDisplaySettings();
  const { showSuccess, showError } = useNotifications();
  const [packs, setPacks] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [selectedNft, setSelectedNft] = reactExports.useState(null);
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [selectedItems, setSelectedItems] = reactExports.useState(/* @__PURE__ */ new Set());
  const [isMultiSelectMode, setIsMultiSelectMode] = reactExports.useState(false);
  const [showUnpackModal, setShowUnpackModal] = reactExports.useState(false);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [debouncedSearchTerm, setDebouncedSearchTerm] = reactExports.useState("");
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [hasMoreNFTs, setHasMoreNFTs] = reactExports.useState(false);
  const [apiPage, setApiPage] = reactExports.useState(1);
  const { isConnected, account, login, session } = useWallet$1();
  const itemsPerPage = 20;
  reactExports.useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
    }, 300);
    return () => clearTimeout(timer);
  }, [searchTerm]);
  const loadPacks = reactExports.useCallback(async (page = 1, append = false) => {
    if (!account) return;
    if (page === 1) {
      setLoading(true);
    }
    try {
      const response = await apiService.getUserInventoryPaginated(account, page, 100);
      const allNFTs = response.assets.map((nft) => ({
        asset_id: nft.asset_id,
        name: nft.name,
        img: nft.image,
        video: nft.video || nft.traits?.video || void 0,
        collection: {
          name: nft.collection,
          collection_name: nft.collection
        },
        schema: {
          schema_name: nft.schema
        },
        template: {
          template_id: nft.template_id?.toString() || "0",
          max_supply: (nft.max_supply || 0).toString()
        },
        data: nft.traits || {},
        mint_number: nft.template_mint
      }));
      const packNFTs = allNFTs.filter((nft) => NeftyBlendService.isPackNFT(nft));
      if (append) {
        setPacks((prev) => [...prev, ...packNFTs]);
      } else {
        setPacks(packNFTs);
        setCurrentPage(1);
      }
      setHasMoreNFTs(response.assets.length === 100);
      setApiPage(page);
    } catch (error) {
      console.error("Error loading packs:", error);
      showError("Failed to load pack inventory");
    } finally {
      setLoading(false);
    }
  }, [account, showError]);
  reactExports.useEffect(() => {
    if (isConnected && account) {
      loadPacks(1, false);
    } else {
      setPacks([]);
    }
  }, [isConnected, account, loadPacks]);
  const filteredPacks = reactExports.useMemo(() => {
    if (!debouncedSearchTerm) return packs;
    const searchLower = debouncedSearchTerm.toLowerCase();
    return packs.filter(
      (pack) => pack.name.toLowerCase().includes(searchLower) || pack.collection.collection_name.toLowerCase().includes(searchLower) || pack.schema.schema_name.toLowerCase().includes(searchLower)
    );
  }, [packs, debouncedSearchTerm]);
  const paginatedPacks = reactExports.useMemo(() => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    return filteredPacks.slice(startIndex, endIndex);
  }, [filteredPacks, currentPage, itemsPerPage]);
  const totalPages = Math.ceil(filteredPacks.length / itemsPerPage);
  const filteredCount = filteredPacks.length;
  const handleNFTClick = (pack) => {
    if (isMultiSelectMode) {
      const newSelected = new Set(selectedItems);
      if (newSelected.has(pack.asset_id)) {
        newSelected.delete(pack.asset_id);
      } else {
        newSelected.add(pack.asset_id);
      }
      setSelectedItems(newSelected);
    } else {
      setSelectedNft(pack);
      setIsModalOpen(true);
    }
  };
  const handleBulkUnpack = () => {
    if (selectedItems.size === 0) return;
    setShowUnpackModal(true);
  };
  const handleLoadMore = () => {
    if (hasMoreNFTs) {
      loadPacks(apiPage + 1, true);
    }
  };
  const handlePageChange = (page) => {
    setCurrentPage(page);
    window.scrollTo({ top: 0, behavior: "smooth" });
  };
  const toggleMultiSelect = () => {
    setIsMultiSelectMode(!isMultiSelectMode);
    setSelectedItems(/* @__PURE__ */ new Set());
  };
  if (!isConnected) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Pack Inventory" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Manage and unpack your NFT packs" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "connect-wallet-prompt", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connect-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Connect Your Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your WAX wallet to view your pack inventory" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "connect-btn", onClick: login, children: "Connect Wallet" })
      ] }) })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-content packs-page", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Pack Inventory" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Manage and unpack your NFT packs, chests, boxes, and containers" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inventory-controls", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search packs...",
          value: searchTerm,
          onChange: (e) => setSearchTerm(e.target.value),
          className: "search-input"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "control-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `multi-select-btn ${isMultiSelectMode ? "active" : ""}`,
            onClick: toggleMultiSelect,
            children: isMultiSelectMode ? " Multi-Select" : "Multi-Select"
          }
        ),
        isMultiSelectMode && selectedItems.size > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "bulk-btn unpack-btn", onClick: handleBulkUnpack, children: [
          " Unpack (",
          selectedItems.size,
          ")"
        ] })
      ] })
    ] }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading your packs..." })
    ] }),
    !loading && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inventory-page-stats", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        filteredCount,
        " packs found"
      ] }) }),
      packs.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inventory-page-grid", children: paginatedPacks.map((pack) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `nft-card ${isMultiSelectMode && selectedItems.has(pack.asset_id) ? "selected" : ""}`,
            onClick: () => handleNFTClick(pack),
            children: [
              isMultiSelectMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selection-checkbox", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  checked: selectedItems.has(pack.asset_id),
                  onChange: () => {
                  }
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-image-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MediaRenderer,
                  {
                    imageUrl: getAssetImageUrl({ img: pack.img }),
                    videoUrl: pack.video ? getAssetVideoUrl({ video: pack.video }) : void 0,
                    alt: pack.name,
                    className: "w-full h-full object-cover",
                    controls: settings.showVideoControls,
                    autoPlay: settings.autoPlayVideos,
                    muted: settings.muteVideos
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pack-indicator", children: " Pack" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "nft-name", children: pack.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-collection", children: typeof pack.collection === "string" ? pack.collection : pack.collection?.collection_name || pack.collection?.name || "Unknown" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-schema", children: pack.schema.schema_name }),
                pack.mint_number && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "nft-mint", children: [
                  "Mint #",
                  pack.mint_number
                ] })
              ] })
            ]
          },
          pack.asset_id
        )) }),
        hasMoreNFTs && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "load-more-btn", onClick: handleLoadMore, children: "Load More Packs" }) }),
        totalPages > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "pagination-btn",
                onClick: () => handlePageChange(currentPage - 1),
                disabled: currentPage === 1,
                children: "Previous"
              }
            ),
            Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
              const page = i + 1;
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `pagination-btn ${currentPage === page ? "active" : ""}`,
                  onClick: () => handlePageChange(page),
                  children: page
                },
                page
              );
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "pagination-btn",
                onClick: () => handlePageChange(currentPage + 1),
                disabled: currentPage === totalPages,
                children: "Next"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-info", children: [
            "Page ",
            currentPage,
            " of ",
            totalPages
          ] })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No Packs Found" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "You don't have any pack NFTs in your inventory yet." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Packs, chests, boxes, and containers will appear here when you acquire them." })
      ] })
    ] }),
    selectedNft && /* @__PURE__ */ jsxRuntimeExports.jsx(
      NFTDetailsModal,
      {
        nft: {
          asset_id: selectedNft.asset_id,
          name: selectedNft.name,
          image: selectedNft.img,
          collection: selectedNft.collection.collection_name,
          schema: selectedNft.schema.schema_name,
          template_mint: selectedNft.mint_number,
          traits: selectedNft.data,
          price: null,
          sale_id: null,
          seller: null
        },
        isOpen: isModalOpen,
        onClose: () => {
          setIsModalOpen(false);
          setSelectedNft(null);
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      UnpackModal,
      {
        selectedNFTs: packs.filter((pack) => selectedItems.has(pack.asset_id)),
        isOpen: showUnpackModal,
        onClose: () => {
          setShowUnpackModal(false);
        },
        userAccount: account || "",
        walletSession: session,
        onUnpackComplete: () => {
          setSelectedItems(/* @__PURE__ */ new Set());
          setIsMultiSelectMode(false);
          loadPacks(1, false);
          showSuccess("Packs unpacked successfully!");
        }
      }
    )
  ] });
};
const Watchlist = () => {
  const [watchlistItems, setWatchlistItems] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [usdPrices, setUsdPrices] = reactExports.useState({});
  const [showAddAlert, setShowAddAlert] = reactExports.useState(null);
  const [alertPrice, setAlertPrice] = reactExports.useState("");
  const [alertType, setAlertType] = reactExports.useState("below");
  reactExports.useEffect(() => {
    loadWatchlist();
  }, []);
  reactExports.useEffect(() => {
    const loadUsdPrices = async () => {
      const prices = {};
      for (const item of watchlistItems) {
        if (item.nft.price) {
          prices[item.nft.asset_id] = await priceService.convertWaxToUSDAsync(item.nft.price);
        }
      }
      setUsdPrices(prices);
    };
    if (watchlistItems.length > 0) {
      loadUsdPrices();
    }
  }, [watchlistItems]);
  const loadWatchlist = async () => {
    try {
      setLoading(true);
      const items = await watchlistService.getWatchlist();
      setWatchlistItems(items);
    } catch (error) {
      log.error("Error loading watchlist", "Watchlist", error);
    } finally {
      setLoading(false);
    }
  };
  const removeFromWatchlist = async (assetId) => {
    try {
      await watchlistService.removeFromWatchlist(assetId);
      setWatchlistItems((prev) => prev.filter((item) => item.nft.asset_id !== assetId));
    } catch (error) {
      log.error("Error removing from watchlist", "Watchlist", error);
    }
  };
  const addPriceAlert = async (assetId) => {
    if (!alertPrice) return;
    try {
      await watchlistService.setPriceAlert(assetId, {
        targetPrice: parseFloat(alertPrice),
        alertType,
        enabled: true
      });
      setWatchlistItems((prev) => prev.map(
        (item) => item.nft.asset_id === assetId ? { ...item, targetPrice: parseFloat(alertPrice), alertType } : item
      ));
      setShowAddAlert(null);
      setAlertPrice("");
    } catch (error) {
      log.error("Error adding price alert", "Watchlist", error);
    }
  };
  const removePriceAlert = async (assetId) => {
    try {
      await watchlistService.removePriceAlert(assetId);
      setWatchlistItems((prev) => prev.map(
        (item) => item.nft.asset_id === assetId ? { ...item, targetPrice: void 0, alertType: "any" } : item
      ));
    } catch (error) {
      log.error("Error removing price alert", "Watchlist", error);
    }
  };
  const getPriceChangeColor = (change) => {
    if (!change) return "var(--text-secondary)";
    return change > 0 ? "var(--success-color)" : "var(--error-color)";
  };
  const getPriceChangeIcon = (change) => {
    if (!change) return "";
    return change > 0 ? "" : "";
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "watchlist-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "watchlist-loading", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading your watchlist..." })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "watchlist-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "watchlist-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "My Watchlist" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "watchlist-subtitle", children: "Track your favorite NFTs and get notified when prices change" })
    ] }),
    watchlistItems.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "watchlist-empty", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-icon", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Your watchlist is empty" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Add NFTs to your watchlist from the marketplace to track their prices" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/marketplace", className: "btn-primary", children: "Browse Marketplace" })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "watchlist-grid", children: watchlistItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "watchlist-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "watchlist-card-image", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: item.nft.image,
            alt: item.nft.name,
            onError: (e) => {
              const target = e.target;
              target.src = "https://pixeljourney.xyz/img/toppixals/10.webp";
            }
          }
        ),
        item.targetPrice && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "alert-badge", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "alert-icon", children: "" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "watchlist-card-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "nft-name", children: item.nft.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "nft-collection", children: item.nft.collection }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-price", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-label", children: "Current Price:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-values", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "wax-price", children: [
                item.nft.price,
                " WAX"
              ] }),
              usdPrices[item.nft.asset_id] && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "usd-price", children: [
                "$",
                usdPrices[item.nft.asset_id]
              ] })
            ] })
          ] }),
          item.priceChange !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-change", style: { color: getPriceChangeColor(item.priceChange) }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-icon", children: getPriceChangeIcon(item.priceChange) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              Math.abs(item.priceChange).toFixed(2),
              "%"
            ] })
          ] })
        ] }),
        item.targetPrice && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-alert-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "alert-label", children: [
            "Alert when price is ",
            item.alertType,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "alert-price", children: [
            item.targetPrice,
            " WAX"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "watchlist-actions", children: [
          item.targetPrice ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-secondary btn-sm",
              onClick: () => removePriceAlert(item.nft.asset_id),
              children: "Remove Alert"
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary btn-sm",
              onClick: () => setShowAddAlert(item.nft.asset_id),
              children: "Add Price Alert"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-danger btn-sm",
              onClick: () => removeFromWatchlist(item.nft.asset_id),
              children: "Remove"
            }
          )
        ] })
      ] }),
      showAddAlert === item.nft.asset_id && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-alert-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Set Price Alert" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Alert Type:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: alertType,
              onChange: (e) => setAlertType(e.target.value),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "below", children: "Price drops below" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "above", children: "Price rises above" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "any", children: "Any price change" })
              ]
            }
          )
        ] }),
        alertType !== "any" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Target Price (WAX):" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              step: "0.01",
              value: alertPrice,
              onChange: (e) => setAlertPrice(e.target.value),
              placeholder: "Enter price in WAX"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary btn-sm",
              onClick: () => addPriceAlert(item.nft.asset_id),
              disabled: alertType !== "any" && !alertPrice,
              children: "Set Alert"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-secondary btn-sm",
              onClick: () => setShowAddAlert(null),
              children: "Cancel"
            }
          )
        ] })
      ] })
    ] }, item.nft.asset_id)) })
  ] });
};
const Footer = () => {
  const links = [
    {
      title: "Pixel Journey",
      url: "https://pixeljourney.xyz",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 14s1.5 2 4 2 4-2 4-2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "9", x2: "9.01", y2: "9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "9", x2: "15.01", y2: "9" })
      ] })
    },
    {
      title: "Documentation",
      url: "https://docs.pixeljourney.xyz",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "14,2 14,8 20,8" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "16", y1: "13", x2: "8", y2: "13" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "16", y1: "17", x2: "8", y2: "17" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "10,9 9,9 8,9" })
      ] })
    },
    {
      title: "Discord",
      url: "http://discord.gg/pixel-journey-1130670500776005734",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028c.462-.63.874-1.295 1.226-1.994a.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z" }) })
    },
    {
      title: "Twitter/X",
      url: "https://x.com/PXJourney",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" }) })
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("footer", { className: "footer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-brand", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://pixeljourney.xyz", className: "footer-logo", target: "_blank", rel: "noopener noreferrer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: "https://pixeljourney.xyz/img/logo.png",
              alt: "Pixel Journey",
              className: "footer-logo-image"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "footer-logo-text", children: "Pixel Journey" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "footer-description", children: "Explore the Pixel Journey ecosystem - a comprehensive NFT marketplace and gaming platform across multiple blockchains." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-section footer-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "footer-section-title", children: "PXJourney across Web3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "blockchain-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://opensea.io/collection/pixeljourney-eth", target: "_blank", rel: "noopener noreferrer", className: "blockchain-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "https://pixeljourney.xyz/img/blockchain-icons/ethereum.svg", alt: "Ethereum", className: "blockchain-logo" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "blockchain-name", children: "Ethereum" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://opensea.io/collection/pixeljourney-polygon", target: "_blank", rel: "noopener noreferrer", className: "blockchain-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "https://pixeljourney.xyz/img/blockchain-icons/polygon.jpeg", alt: "Polygon", className: "blockchain-logo" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "blockchain-name", children: "Polygon" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://opensea.io/collection/pixeljourney-base", target: "_blank", rel: "noopener noreferrer", className: "blockchain-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "https://pixeljourney.xyz/img/blockchain-icons/base.jpg", alt: "Base", className: "blockchain-logo" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "blockchain-name", children: "Base" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://nft.monbase.com/collections/66c4eb2ca339b05c5a660e44/detail", target: "_blank", rel: "noopener noreferrer", className: "blockchain-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "https://pixeljourney.xyz/img/blockchain-icons/BSC.png", alt: "BNB Chain", className: "blockchain-logo" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "blockchain-name", children: "BNB Chain" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bridge-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://bridge.mycloudwallet.com/", target: "_blank", rel: "noopener noreferrer", className: "bridge-link", children: "Bridge Now" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-section footer-wax", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "footer-section-title", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://wax.io/", target: "_blank", rel: "noopener noreferrer", className: "wax-title-link", children: "PXJourney across WAX" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-dapps-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://market.pixeljourney.xyz", target: "_blank", rel: "noopener noreferrer", className: "wax-dapp-item purple-glow", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-name", children: "PxMarket" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://stake.pixeljourney.xyz", target: "_blank", rel: "noopener noreferrer", className: "wax-dapp-item green-glow", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-name", children: "PxStaking" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://lb.pixeljourney.xyz", target: "_blank", rel: "noopener noreferrer", className: "wax-dapp-item golden-glow", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-name", children: "PxLeaderboards" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/pxcrafting", className: "wax-dapp-item craft-glow", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-name", children: "PxCraft" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "journey-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/journeymap", className: "journey-link", children: "Journey Map" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-section footer-right", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "footer-title", children: "Quick Links" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "footer-links", children: links.map((link, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "a",
          {
            href: link.url,
            target: "_blank",
            rel: "noopener noreferrer",
            className: "footer-link",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "footer-link-icon", children: link.icon }),
              link.title
            ]
          },
          index
        )) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "footer-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-bottom-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "footer-copyright", children: " 2025 Pixel Journey. All rights reserved." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "footer-bottom-links", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "footer-note", children: "Requires a Pixal PFP to unlock full market access" }) })
    ] }) })
  ] }) });
};
const ActivityStats = React.memo(() => {
  const navigate = useNavigate();
  const { settings } = useDisplaySettings();
  const [activeTab, setActiveTab] = reactExports.useState("activity");
  const [recentSales, setRecentSales] = reactExports.useState([]);
  const [collectionStats, setCollectionStats] = reactExports.useState([]);
  const [marketStats, setMarketStats] = reactExports.useState(null);
  const [nftTradingStats, setNftTradingStats] = reactExports.useState(null);
  const [recentTrades, setRecentTrades] = reactExports.useState([]);
  const [topCollections, setTopCollections] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [refreshing, setRefreshing] = reactExports.useState(false);
  const loadActivityData = async () => {
    try {
      setLoading(true);
      setError(null);
      const salesData = await apiService.getRecentSales(50);
      setRecentSales(salesData.map((sale) => {
        const asset = sale.assets[0];
        return {
          sale_id: sale.sale_id,
          asset_id: asset?.asset_id || "",
          collection_name: asset?.collection?.collection_name || "",
          schema_name: asset?.schema?.schema_name || "",
          template_id: asset?.template?.template_id || "",
          asset_name: asset?.name || "",
          seller: sale.seller || "",
          buyer: sale.buyer || "",
          price: sale.listing_price || "0",
          updated_at_time: sale.updated_at_time || "",
          state: sale.state || 0,
          image: asset?.data?.img || void 0,
          video: asset?.data?.video || void 0
        };
      }));
    } catch (err) {
      console.error("Error loading activity data:", err);
      setError("Failed to load activity data");
    } finally {
      setLoading(false);
    }
  };
  const loadStatsData = async () => {
    try {
      setLoading(true);
      setError(null);
      const collectionsData = await apiService.getCollections({ limit: 20, whitelistOnly: true });
      if (collectionsData.length > 0) {
        const statsPromises = collectionsData.slice(0, 10).map(async (collection) => {
          try {
            const marketData = await apiService.getCollectionStats(collection.collection_name);
            return {
              collection_name: collection.collection_name,
              assets: "0",
              // CollectionData doesn't have assets count, would need separate API call
              burned: "0",
              // CollectionData doesn't have burned count, would need separate API call
              templates: "0",
              // CollectionData doesn't have templates count, would need separate API call
              schemas: "0",
              // CollectionData doesn't have schemas count, would need separate API call
              volume: marketData?.volume || "0",
              sales: marketData?.sales || "0",
              floor_price: marketData?.floor || "0"
            };
          } catch {
            return {
              collection_name: collection.collection_name,
              assets: "0",
              burned: "0",
              templates: "0",
              schemas: "0",
              volume: "0",
              sales: "0",
              floor_price: "0"
            };
          }
        });
        const stats = await Promise.all(statsPromises);
        setCollectionStats(stats);
      }
      const latestData = await apiService.getMarketStats();
      if (latestData && latestData.results && latestData.results.length > 0) {
        const latestResult = latestData.results[latestData.results.length - 1];
        setMarketStats({
          total_sales: latestResult.sales || "0",
          total_volume: latestResult.volume || "0",
          total_assets: "0",
          // This would need a separate API call
          active_listings: "0"
          // This would need a separate API call
        });
      }
      const [nftStats, topCollectionsData, recentTrades2] = await Promise.all([
        apiService.getNFTTradingStats(),
        apiService.getTopCollectionsByVolume(10),
        apiService.getRecentNFTTrades(20)
      ]);
      if (nftStats) {
        setNftTradingStats({
          dailyVolume: nftStats.dailyVolume || "0",
          dailySales: nftStats.dailySales || 0,
          totalTransactions: nftStats.totalTransactions || 0,
          activeListings: nftStats.activeListings || 0,
          averagePrice: nftStats.averagePrice || "0",
          topCollectionsByVolume: topCollectionsData.map((col) => ({
            collection_name: col.collection_name,
            volume_24h: "0",
            sales_24h: 0,
            floor_price: "0",
            assets_count: "0"
          }))
        });
      }
      setTopCollections(topCollectionsData.map((col) => ({
        collection_name: col.collection_name,
        volume_24h: "0",
        sales_24h: 0,
        floor_price: "0",
        assets_count: "0"
      })) || []);
      setRecentTrades((recentTrades2 || []).map((trade) => ({
        sale_id: trade.sale_id,
        collection_name: trade.collection_name || "",
        asset_name: String(trade.assets?.[0]?.data?.name || trade.assets?.[0]?.template?.immutable_data?.name || "Unknown Asset"),
        price: String(trade.listing_price || trade.price?.amount || "0"),
        buyer: trade.buyer || "",
        seller: trade.seller || "",
        timestamp: trade.updated_at_time || ""
      })));
    } catch (err) {
      console.error("Error loading stats data:", err);
      setError("Failed to load statistics data");
    } finally {
      setLoading(false);
    }
  };
  const handleRefresh = reactExports.useCallback(async () => {
    setRefreshing(true);
    if (activeTab === "activity") {
      await loadActivityData();
    } else {
      await loadStatsData();
    }
    setRefreshing(false);
  }, [activeTab]);
  const handleUserClick = reactExports.useCallback((user) => {
    navigate(`/user-profile-lookup?user=${encodeURIComponent(user)}`);
  }, [navigate]);
  const handleAssetClick = reactExports.useCallback((assetId) => {
    navigate(`/assets/${assetId}`);
  }, [navigate]);
  const handleCollectionClick = reactExports.useCallback((collectionName) => {
    navigate(`/collections/${encodeURIComponent(collectionName)}`);
  }, [navigate]);
  const handleSaleClick = reactExports.useCallback((saleId) => {
    navigate(`/listings/${saleId}`);
  }, [navigate]);
  const handleTradeClick = reactExports.useCallback((saleId) => {
    navigate(`/listings/${saleId}`);
  }, [navigate]);
  reactExports.useEffect(() => {
    if (activeTab === "activity") {
      loadActivityData();
    } else {
      loadStatsData();
    }
  }, [activeTab]);
  const formatPrice = (price) => {
    if (typeof price === "string" && price.includes("WAX")) {
      return price;
    }
    const numPrice = parseFloat(price) / 1e8;
    return formatWAXPrice(numPrice);
  };
  const formatNumber2 = (num) => {
    const number = parseInt(num);
    if (number >= 1e6) {
      return `${(number / 1e6).toFixed(1)}M`;
    } else if (number >= 1e3) {
      return `${(number / 1e3).toFixed(1)}K`;
    }
    return number.toString();
  };
  const formatDate = (timestamp) => {
    const date = new Date(parseInt(timestamp) * 1e3);
    return date.toLocaleString();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-stats-page", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-stats-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "activity-stats-title", children: "Market Activity & Statistics" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "activity-stats-subtitle", children: "Real-time marketplace data and analytics" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-stats-tabs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `tab-btn ${activeTab === "activity" ? "active" : ""}`,
          onClick: () => setActiveTab("activity"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 3v18h18" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 12l4-4 4 4 6-6" })
            ] }),
            "Activity Feed"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `tab-btn ${activeTab === "stats" ? "active" : ""}`,
          onClick: () => setActiveTab("stats"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2", ry: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "9", x2: "9", y2: "15" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "11", x2: "15", y2: "15" })
            ] }),
            "Statistics"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `refresh-btn ${refreshing ? "refreshing" : ""}`,
          onClick: handleRefresh,
          disabled: refreshing,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "23 4 23 10 17 10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "1 20 1 14 7 14" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15" })
            ] }),
            refreshing ? "Refreshing..." : "Refresh"
          ]
        }
      )
    ] }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-message", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "9", x2: "9", y2: "15" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "9", x2: "15", y2: "15" })
      ] }),
      error
    ] }),
    activeTab === "activity" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Recent Sales" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Latest NFT sales across all collections" })
      ] }),
      loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading recent sales..." })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sales-feed", children: [
        recentSales.map((sale) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-item clickable-sale", onClick: () => handleSaleClick(sale.sale_id), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sale-media", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: sale.image,
              videoUrl: sale.video,
              alt: sale.asset_name || `Asset #${sale.asset_id}`,
              className: "sale-image",
              enableAnimations: settings.enableAnimatedNFTs
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-asset", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h4",
                {
                  className: "clickable-asset-name",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleAssetClick(sale.asset_id);
                  },
                  children: sale.asset_name || `Asset #${sale.asset_id}`
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  className: "sale-collection clickable-collection",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleCollectionClick(sale.collection_name);
                  },
                  children: sale.collection_name
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-details", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sale-price", children: formatPrice(sale.price) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sale-time", children: formatDate(sale.updated_at_time) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sale-status", children: sale.state === 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-sold", children: " Sold" }) : sale.state === 2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-canceled", children: " Canceled" }) : sale.state === 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-active", children: " Active" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-active", children: " Active" }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-parties", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-party", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "party-label", children: "Seller:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "party-name clickable",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleUserClick(sale.seller);
                  },
                  children: sale.seller
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-party", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "party-label", children: "Buyer:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "party-name clickable",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleUserClick(sale.buyer);
                  },
                  children: sale.buyer
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sale-party", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "party-label", children: "Sale ID:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "span",
                {
                  className: "sale-id-link clickable",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleSaleClick(sale.sale_id);
                  },
                  title: "View sale details",
                  children: [
                    sale.sale_id.slice(0, 8),
                    "..."
                  ]
                }
              )
            ] })
          ] })
        ] }, sale.sale_id)),
        recentSales.length === 0 && !loading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 6v6l4 2" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No recent sales" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No sales data available at the moment" })
        ] })
      ] })
    ] }),
    activeTab === "stats" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-content", children: [
      marketStats && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "market-overview", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Market Overview" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: formatNumber2(marketStats.total_sales) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Total Sales" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: formatPrice(marketStats.total_volume) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Total Volume" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: formatNumber2(marketStats.total_assets) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Total Assets" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: formatNumber2(marketStats.active_listings) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Active Listings" })
          ] })
        ] })
      ] }),
      nftTradingStats && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-trading-stats-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "WAX NFT Trading Data" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-stats-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card nft-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-value", children: [
              nftTradingStats.dailyVolume,
              " WAX"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "24h Trading Volume" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card nft-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: formatNumber2(nftTradingStats.dailySales.toString()) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "24h Sales" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card nft-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: formatNumber2(nftTradingStats.activeListings.toString()) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Active Listings" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card nft-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-value", children: [
              nftTradingStats.averagePrice,
              " WAX"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Average Sale Price" })
          ] })
        ] }),
        topCollections.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "top-collections-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Top Collections by Volume" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "top-collections-grid", children: topCollections.slice(0, 6).map((collection) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "collection-name", children: collection.collection_name }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-volume", children: [
              collection.volume_24h,
              " WAX"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-sales", children: [
              collection.sales_24h,
              " sales"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-floor", children: [
              "Floor: ",
              collection.floor_price,
              " WAX"
            ] })
          ] }, collection.collection_name)) })
        ] }),
        recentTrades.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recent-trades-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Recent NFT Trades" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "recent-trades-list", children: recentTrades.slice(0, 8).map((trade) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "trade-item clickable-trade", onClick: () => handleTradeClick(trade.sale_id), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "trade-asset", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "asset-name clickable-asset-name",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleTradeClick(trade.sale_id);
                  },
                  children: trade.asset_name
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "collection-name clickable-collection",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleCollectionClick(trade.collection_name);
                  },
                  children: trade.collection_name
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "trade-price", children: [
              trade.price,
              " WAX"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "trade-time", children: formatDate(trade.timestamp) })
          ] }, trade.sale_id)) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Collection Statistics" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Performance metrics for top collections" })
      ] }),
      loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading collection statistics..." })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collections-table", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "table-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: "Collection" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: "Assets" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: "Volume" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: "Sales" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: "Floor Price" })
        ] }),
        collectionStats.map((collection) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "table-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell collection-name", children: collection.collection_name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: formatNumber2(collection.assets) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: formatPrice(collection.volume) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: formatNumber2(collection.sales) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: formatPrice(collection.floor_price) })
        ] }, collection.collection_name)),
        collectionStats.length === 0 && !loading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "9", x2: "9", y2: "15" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "11", x2: "15", y2: "15" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No statistics available" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Statistics data is currently unavailable" })
        ] })
      ] })
    ] })
  ] });
});
ActivityStats.displayName = "ActivityStats";
class AuctionService {
  constructor() {
    __publicField(this, "subscriptions", /* @__PURE__ */ new Map());
    __publicField(this, "pollInterval", null);
    __publicField(this, "isPolling", false);
    __publicField(this, "POLL_INTERVAL", 3e4);
    // 30 seconds - reduced frequency
    __publicField(this, "MAX_REQUESTS_PER_MINUTE", 30);
    __publicField(this, "REQUEST_DELAY", 2e3);
    // 2 seconds between requests
    __publicField(this, "lastRequestTime", 0);
    __publicField(this, "requestCount", 0);
    __publicField(this, "requestResetTime", Date.now() + 6e4);
    __publicField(this, "auctionCache", /* @__PURE__ */ new Map());
    __publicField(this, "CACHE_DURATION", 15e3);
  }
  // 15 seconds cache
  // Subscribe to auction updates
  subscribe(auctionId, callback) {
    if (!this.subscriptions.has(auctionId)) {
      this.subscriptions.set(auctionId, []);
    }
    const subscription = { auction_id: auctionId, callback };
    this.subscriptions.get(auctionId).push(subscription);
    this.startPolling();
    return () => {
      const subs = this.subscriptions.get(auctionId);
      if (subs) {
        const index = subs.indexOf(subscription);
        if (index > -1) {
          subs.splice(index, 1);
        }
        if (subs.length === 0) {
          this.subscriptions.delete(auctionId);
        }
      }
      if (this.subscriptions.size === 0) {
        this.stopPolling();
      }
    };
  }
  // Start polling for auction updates
  startPolling() {
    if (this.isPolling) return;
    this.isPolling = true;
    this.pollInterval = setInterval(() => {
      this.pollAuctionUpdates();
    }, this.POLL_INTERVAL);
  }
  // Stop polling
  stopPolling() {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }
    this.isPolling = false;
  }
  // Poll for auction updates
  async pollAuctionUpdates() {
    const auctionIds = Array.from(this.subscriptions.keys());
    if (auctionIds.length === 0) {
      this.stopPolling();
      return;
    }
    try {
      this.clearExpiredCache();
      const updates = await this.fetchAuctionUpdates(auctionIds);
      updates.forEach((update) => {
        const subscribers = this.subscriptions.get(update.auction_id);
        if (subscribers) {
          subscribers.forEach((sub) => {
            try {
              sub.callback(update);
            } catch (error) {
              ErrorMessageService.logError("AuctionService.pollAuctionUpdates.callback", error, {
                auctionId: update.auction_id
              });
            }
          });
        }
      });
    } catch (error) {
      ErrorMessageService.logError("AuctionService.pollAuctionUpdates", error, {
        auctionIds
      });
    }
  }
  // Fetch auction updates from API with rate limiting and caching
  async fetchAuctionUpdates(auctionIds) {
    const updates = [];
    const now = Date.now();
    if (now > this.requestResetTime) {
      this.requestCount = 0;
      this.requestResetTime = now + 6e4;
    }
    for (const auctionId of auctionIds) {
      const cached = this.auctionCache.get(auctionId);
      if (cached && now - cached.timestamp < this.CACHE_DURATION) {
        updates.push(cached.data);
        continue;
      }
      if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
        logger.warn("Rate limit reached, skipping auction", "AUCTION", { auctionId });
        if (cached) {
          updates.push(cached.data);
        }
        continue;
      }
      const timeSinceLastRequest = now - this.lastRequestTime;
      if (timeSinceLastRequest < this.REQUEST_DELAY) {
        await new Promise((resolve) => setTimeout(resolve, this.REQUEST_DELAY - timeSinceLastRequest));
      }
      try {
        const url = `${apiService.getCurrentAtomicEndpoint()}/atomicmarket/v1/auctions/${auctionId}`;
        const response = await apiService.fetchWithRetry(url);
        const data = await response.json();
        this.requestCount++;
        this.lastRequestTime = Date.now();
        if (data.success && data.data) {
          const auction = data.data;
          const update = {
            auction_id: auctionId,
            current_bid: auction.current_bid,
            bidder: auction.current_bidder,
            end_time: auction.end_time,
            status: this.getAuctionStatus(auction),
            bid_count: auction.bid_count || 0,
            last_bid_time: auction.updated_at_time
          };
          this.auctionCache.set(auctionId, {
            data: update,
            timestamp: Date.now()
          });
          updates.push(update);
        }
      } catch (error) {
        ErrorMessageService.logError("AuctionService.fetchAuctionUpdates.single", error, {
          auctionId
        });
        if (cached) {
          updates.push(cached.data);
        }
      }
    }
    return updates;
  }
  // Determine auction status
  getAuctionStatus(auction) {
    const now = Date.now();
    const endTime = (/* @__PURE__ */ new Date(auction.end_time + "Z")).getTime();
    if (auction.state === 3) return "cancelled";
    if (now > endTime) return "ended";
    return "active";
  }
  // Get auction bid history
  async getAuctionBids(auctionId) {
    try {
      const auctionResponse = await apiService.getAuctions({
        limit: 1
      });
      if (!auctionResponse.success || !auctionResponse.data.length) {
        return [];
      }
      const auction = auctionResponse.data[0];
      const assetIds = auction.assets.map((asset) => asset.asset_id);
      const bidHistory = await this.fetchAuctionBidHistory(auctionId, assetIds);
      return bidHistory.sort(
        (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
      );
    } catch (error) {
      ErrorMessageService.logError("AuctionService.getAuctionBids", error, { auctionId });
      return [];
    }
  }
  // Fetch real auction bid history from blockchain
  async fetchAuctionBidHistory(auctionId, assetIds) {
    try {
      const hyperionEndpoints = [
        API_ENDPOINTS.WAX_CHAIN.EOSRIO,
        API_ENDPOINTS.WAX_CHAIN.WAXSWEDEN,
        API_ENDPOINTS.HYPERION[2]
        // eosdetroit hyperion endpoint
      ];
      for (const endpoint of hyperionEndpoints) {
        try {
          const response = await fetch(`${endpoint}/v2/history/get_actions?account=atomicmarket&filter=atomicmarket:auctionbid&limit=100&sort=desc&after=${new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3).toISOString()}`, {
            method: "GET",
            headers: {
              "Accept": "application/json"
            }
          });
          if (!response.ok) continue;
          const data = await response.json();
          const bids = [];
          if (data.actions) {
            for (const action of data.actions) {
              if (action.act?.data?.auction_id === auctionId) {
                bids.push({
                  bidder: action.act.data.bidder || action.act.authorization?.[0]?.actor || "unknown",
                  bid_amount: action.act.data.bid || "0.0000 WAX",
                  timestamp: action.timestamp,
                  transaction_id: action.trx_id
                });
              }
            }
          }
          return bids;
        } catch (endpointError) {
          logger.warn("Failed to fetch from endpoint", "AUCTION", { endpoint, error: endpointError });
          continue;
        }
      }
      return [];
    } catch (error) {
      ErrorMessageService.logError("AuctionService.fetchAuctionBidHistory", error, { auctionId, assetIds });
      return [];
    }
  }
  // Calculate time remaining for auction
  getTimeRemaining(endTime) {
    const now = Date.now();
    let end;
    if (!endTime) {
      return {
        total: 0,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        isExpired: true
      };
    }
    if (endTime.includes("T") && !endTime.endsWith("Z")) {
      end = (/* @__PURE__ */ new Date(endTime + "Z")).getTime();
    } else if (endTime.includes("T") && endTime.endsWith("Z")) {
      end = new Date(endTime).getTime();
    } else {
      const timestamp = parseInt(endTime);
      if (!isNaN(timestamp)) {
        end = timestamp > 1e12 ? timestamp : timestamp * 1e3;
      } else {
        end = new Date(endTime).getTime();
      }
    }
    if (isNaN(end)) {
      logger.warn("Invalid endTime format", "AUCTION", { endTime });
      return {
        total: 0,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        isExpired: true
      };
    }
    const total = end - now;
    if (total <= 0) {
      return {
        total: 0,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        isExpired: true
      };
    }
    const days = Math.floor(total / (1e3 * 60 * 60 * 24));
    const hours = Math.floor(total % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60));
    const minutes = Math.floor(total % (1e3 * 60 * 60) / (1e3 * 60));
    const seconds = Math.floor(total % (1e3 * 60) / 1e3);
    return {
      total,
      days,
      hours,
      minutes,
      seconds,
      isExpired: false
    };
  }
  // Format time remaining as string
  formatTimeRemaining(endTime) {
    const time = this.getTimeRemaining(endTime);
    if (time.isExpired) {
      return "Auction ended";
    }
    if (time.days > 0) {
      return `${time.days}d ${time.hours}h ${time.minutes}m`;
    } else if (time.hours > 0) {
      return `${time.hours}h ${time.minutes}m ${time.seconds}s`;
    } else if (time.minutes > 0) {
      return `${time.minutes}m ${time.seconds}s`;
    } else {
      return `${time.seconds}s`;
    }
  }
  // Check if auction is ending soon (less than 5 minutes)
  isEndingSoon(endTime) {
    const time = this.getTimeRemaining(endTime);
    return !time.isExpired && time.total < 5 * 60 * 1e3;
  }
  // Clear expired cache entries
  clearExpiredCache() {
    const now = Date.now();
    for (const [auctionId, cached] of this.auctionCache.entries()) {
      if (now - cached.timestamp > this.CACHE_DURATION * 2) {
        this.auctionCache.delete(auctionId);
      }
    }
  }
  // Cleanup all subscriptions
  cleanup() {
    this.subscriptions.clear();
    this.stopPolling();
    this.auctionCache.clear();
  }
}
const auctionService = new AuctionService();
const Auctions = React.memo(() => {
  const navigate = useNavigate();
  const { isConnected, account, session } = useWallet();
  const { showSuccess, showError } = useNotifications();
  const [auctions, setAuctions] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [loadingMore, setLoadingMore] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [hasMore, setHasMore] = reactExports.useState(true);
  const [totalPages, setTotalPages] = reactExports.useState(1);
  const [filter, setFilter] = reactExports.useState("all");
  const [sortBy, setSortBy] = reactExports.useState("created_desc");
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [selectedCollection, setSelectedCollection] = reactExports.useState("");
  const [hideEmptyAuctions, setHideEmptyAuctions] = reactExports.useState(false);
  const [showCreateModal, setShowCreateModal] = reactExports.useState(false);
  const [showBidModal, setShowBidModal] = reactExports.useState(false);
  const [selectedAuction, setSelectedAuction] = reactExports.useState(null);
  const [bidAmount, setBidAmount] = reactExports.useState("");
  const [isPlacingBid, setIsPlacingBid] = reactExports.useState(false);
  const [isCreatingAuction, setIsCreatingAuction] = reactExports.useState(false);
  const [selectedAssets, setSelectedAssets] = reactExports.useState(/* @__PURE__ */ new Set());
  const [userAssets, setUserAssets] = reactExports.useState([]);
  const [isLoadingAssets, setIsLoadingAssets] = reactExports.useState(false);
  const [startingPrice, setStartingPrice] = reactExports.useState("");
  const [durationWeeks, setDurationWeeks] = reactExports.useState(0);
  const [durationDays, setDurationDays] = reactExports.useState(1);
  const [durationHours, setDurationHours] = reactExports.useState(0);
  const [durationMinutes, setDurationMinutes] = reactExports.useState(0);
  const [auctionMemo, setAuctionMemo] = reactExports.useState("");
  const [collections, setCollections] = reactExports.useState([]);
  const getSortField = reactExports.useCallback(() => {
    switch (sortBy) {
      case "price_asc":
      case "price_desc":
        return "price";
      case "created_desc":
      case "created_asc":
      default:
        return "created";
    }
  }, [sortBy]);
  const getSortOrder = reactExports.useCallback(() => {
    switch (sortBy) {
      case "price_asc":
      case "created_asc":
        return "asc";
      case "price_desc":
      case "created_desc":
      default:
        return "desc";
    }
  }, [sortBy]);
  const loadAuctions = reactExports.useCallback(async (page = 1, append = false) => {
    try {
      if (page === 1) {
        setLoading(true);
        setCurrentPage(1);
        setHasMore(true);
      } else {
        setLoadingMore(true);
      }
      setError(null);
      const response = await apiService.getAuctions({
        state: 1,
        // Active auctions
        limit: 36,
        offset: (page - 1) * 36,
        sort: getSortField(),
        order: getSortOrder(),
        hide_empty_auctions: hideEmptyAuctions,
        search: searchTerm || void 0,
        collection_name: selectedCollection || void 0,
        collection_blacklist: "flinttffunko,onlyfanzgaly,farmerpetsco,fantaspeop",
        seller_blacklist: "dximg.wam,xpvrs.wam,5rrrc.wam,nnmnmnmnn.gm",
        symbol: "WAX"
      });
      if (!response.success || !response.data) {
        throw new Error("Failed to fetch auctions data");
      }
      const formattedAuctions = response.data.map((auction) => ({
        auction_id: auction.auction_id,
        asset_id: auction.asset_id,
        seller: auction.seller,
        price: auction.price,
        end_time: auction.end_time,
        collection_name: auction.collection_name,
        template_id: auction.template_id,
        asset_name: auction.asset_name,
        image: auction.image,
        current_bid: auction.current_bid || null,
        bidder: auction.bidder || null,
        collection_info: void 0
        // Remove individual collection fetching to prevent API spam
      }));
      if (append && page > 1) {
        setAuctions((prev) => [...prev, ...formattedAuctions]);
      } else {
        setAuctions(formattedAuctions);
      }
      const itemsPerPage = 36;
      const hasMoreData = formattedAuctions.length === itemsPerPage;
      setHasMore(hasMoreData);
      setCurrentPage(page);
      if (hasMoreData) {
        setTotalPages(page + 1);
      } else {
        setTotalPages(page);
      }
    } catch (err) {
      log.error("Error loading auctions", "Auctions", err);
      setError("Failed to load auctions. Please try again later.");
    } finally {
      setLoading(false);
      setLoadingMore(false);
    }
  }, [getSortField, getSortOrder, hideEmptyAuctions, searchTerm, selectedCollection]);
  const loadMoreAuctions = reactExports.useCallback(() => {
    if (!loadingMore && hasMore) {
      loadAuctions(currentPage + 1, true);
    }
  }, [loadAuctions, currentPage, hasMore, loadingMore]);
  const resetAndLoadAuctions = reactExports.useCallback(() => {
    setCurrentPage(1);
    setHasMore(true);
    loadAuctions(1, false);
  }, [loadAuctions]);
  reactExports.useEffect(() => {
    resetAndLoadAuctions();
  }, [resetAndLoadAuctions, filter, searchTerm, selectedCollection, hideEmptyAuctions, sortBy]);
  reactExports.useEffect(() => {
    const loadCollections = async () => {
      try {
        const collectionsData = await apiService.getCollections({ limit: 50, whitelistOnly: true });
        if (collectionsData && collectionsData.length > 0) {
          const mappedCollections = collectionsData.map((col) => ({
            collection_name: col.collection_name,
            name: col.name || col.collection_name
          }));
          setCollections(mappedCollections);
        }
      } catch (error2) {
        log.error("Failed to load collections", "Auctions", error2);
        setCollections([
          { collection_name: "pixeljourney", name: "Pixel Journey" },
          { collection_name: "friedfactory", name: "Fried Factory" }
        ]);
      }
    };
    loadCollections();
  }, []);
  const loadUserAssets = async () => {
    if (!account) return;
    setIsLoadingAssets(true);
    try {
      const url = `${apiService.atomicAssetsAPI}/atomicassets/v1/assets?owner=${account}&limit=100`;
      const response = await apiService.fetchWithRetry(url);
      const data = await response.json();
      if (data.success && data.data) {
        const assets = data.data.map((asset) => ({
          asset_id: asset.asset_id,
          name: asset.name || `${asset.collection.collection_name} #${asset.template_mint || asset.asset_id}`,
          collection_name: asset.collection.collection_name,
          image: asset.data?.img ? `https://ipfs.io/ipfs/${asset.data.img}` : void 0,
          template_mint: asset.template_mint,
          isSelected: false
        }));
        setUserAssets(assets);
      }
    } catch (error2) {
      log.error("Error loading user assets", "Auctions", error2);
      setUserAssets([]);
    } finally {
      setIsLoadingAssets(false);
    }
  };
  const formatPrice = (price) => {
    const waxPrice = parseFloat(price) / 1e8;
    return formatWAXPrice(waxPrice);
  };
  const filteredAuctions = reactExports.useMemo(() => {
    return auctions.filter((auction) => {
      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        const matchesSearch = auction.asset_name?.toLowerCase().includes(searchLower) || auction.asset_id?.toString().includes(searchLower) || auction.collection_name?.toLowerCase().includes(searchLower);
        if (!matchesSearch) return false;
      }
      if (selectedCollection && auction.collection_name !== selectedCollection) {
        return false;
      }
      if (hideEmptyAuctions && (!auction.bidder || !auction.current_bid || auction.current_bid === "0")) {
        return false;
      }
      return true;
    });
  }, [auctions, searchTerm, selectedCollection, hideEmptyAuctions]);
  reactExports.useEffect(() => {
    const unsubscribeFunctions = [];
    filteredAuctions.forEach((auction) => {
      const unsubscribe = auctionService.subscribe(auction.auction_id, (update) => {
        setAuctions(
          (prevAuctions) => prevAuctions.map(
            (prevAuction) => prevAuction.auction_id === update.auction_id ? {
              ...prevAuction,
              current_bid: update.current_bid || prevAuction.current_bid,
              bidder: update.bidder || prevAuction.bidder,
              end_time: update.end_time
            } : prevAuction
          )
        );
      });
      unsubscribeFunctions.push(unsubscribe);
    });
    return () => {
      unsubscribeFunctions.forEach((unsubscribe) => unsubscribe());
    };
  }, [filteredAuctions]);
  const handlePlaceBid = (auction) => {
    if (!isConnected || !account) {
      showError("Wallet Required", "Please connect your wallet to place bids");
      return;
    }
    if (auction.seller === account) {
      showError("Invalid Action", "You cannot bid on your own auction");
      return;
    }
    setSelectedAuction(auction);
    setBidAmount("");
    setShowBidModal(true);
  };
  const submitBid = async () => {
    if (!selectedAuction || !session || !account) {
      showError("Error", "Please connect your wallet first");
      return;
    }
    const bidFloat = parseFloat(bidAmount);
    if (isNaN(bidFloat) || bidFloat <= 0) {
      showError("Invalid Bid", "Please enter a valid bid amount");
      return;
    }
    const currentBidAmount = parseFloat(selectedAuction.current_bid || selectedAuction.price) / 1e8;
    const hasExistingBids = selectedAuction.current_bid && selectedAuction.bidder;
    if (hasExistingBids && bidFloat <= currentBidAmount) {
      showError("Invalid Bid", `Bid must be higher than current bid of ${formatWAXPrice(currentBidAmount)}`);
      return;
    } else if (!hasExistingBids && bidFloat < currentBidAmount) {
      showError("Invalid Bid", `Bid must be at least the starting price of ${formatWAXPrice(currentBidAmount)}`);
      return;
    }
    setIsPlacingBid(true);
    try {
      const formattedBid = bidFloat.toFixed(8);
      const bidString = `${formattedBid} WAX`;
      const action = {
        account: "atomicmarket",
        name: "auctionbid",
        authorization: [{
          actor: account,
          permission: WharfKitService.safeGetPermission(session)
        }],
        data: {
          bidder: account,
          auction_id: selectedAuction.auction_id,
          bid: bidString,
          taker_marketplace: "market.pxj"
        }
      };
      const result = await session.transact({ actions: [action] });
      if (result) {
        showSuccess("Bid Placed", `Successfully placed bid of ${formatWAXPrice(bidFloat)}`);
        setShowBidModal(false);
        setBidAmount("");
        setSelectedAuction(null);
        loadAuctions();
      }
    } catch (error2) {
      log.error("Error placing bid", "Auctions", error2);
      const errorMessage = error2 instanceof Error ? error2.message : "Failed to place bid. Please try again.";
      showError("Bid Failed", errorMessage);
    } finally {
      setIsPlacingBid(false);
    }
  };
  const handleViewDetails = (auction) => {
    navigate(`/assets/${auction.asset_id}`);
  };
  const handleCreateAuction = () => {
    setShowCreateModal(true);
    if (account) {
      loadUserAssets();
    }
  };
  const toggleAssetSelection = (assetId) => {
    const newSelected = new Set(selectedAssets);
    if (newSelected.has(assetId)) {
      newSelected.delete(assetId);
    } else {
      newSelected.add(assetId);
    }
    setSelectedAssets(newSelected);
  };
  const calculateTotalDuration = () => {
    return durationWeeks * 7 * 24 * 60 * 60 + durationDays * 24 * 60 * 60 + durationHours * 60 * 60 + durationMinutes * 60;
  };
  const updateDurationComponent = (component, value) => {
    const clampedValue = Math.max(0, Math.min(value, getMaxValue(component)));
    switch (component) {
      case "weeks":
        setDurationWeeks(clampedValue);
        break;
      case "days":
        setDurationDays(clampedValue);
        break;
      case "hours":
        setDurationHours(clampedValue);
        break;
      case "minutes":
        setDurationMinutes(clampedValue);
        break;
    }
  };
  const getMaxValue = (component) => {
    switch (component) {
      case "weeks":
        return 4;
      // Max 4 weeks
      case "days":
        return 30;
      // Max 30 days
      case "hours":
        return 23;
      // Max 23 hours
      case "minutes":
        return 59;
      // Max 59 minutes
      default:
        return 0;
    }
  };
  const formatDurationDisplay = () => {
    const parts = [];
    if (durationWeeks > 0) parts.push(`${durationWeeks} week${durationWeeks > 1 ? "s" : ""}`);
    if (durationDays > 0) parts.push(`${durationDays} day${durationDays > 1 ? "s" : ""}`);
    if (durationHours > 0) parts.push(`${durationHours} hour${durationHours > 1 ? "s" : ""}`);
    if (durationMinutes > 0) parts.push(`${durationMinutes} minute${durationMinutes > 1 ? "s" : ""}`);
    if (parts.length === 0) return "No duration set";
    return parts.join(", ");
  };
  const handleCreateAuctionSubmit = async () => {
    if (selectedAssets.size === 0) {
      showError("No Assets Selected", "Please select at least one asset to auction");
      return;
    }
    if (!startingPrice || parseFloat(startingPrice) <= 0) {
      showError("Invalid Price", "Please enter a valid starting price");
      return;
    }
    const totalDurationSeconds = calculateTotalDuration();
    if (totalDurationSeconds < 3600) {
      showError("Invalid Duration", "Auction duration must be at least 1 hour");
      return;
    }
    if (totalDurationSeconds > 2592e3) {
      showError("Invalid Duration", "Auction duration cannot exceed 30 days");
      return;
    }
    try {
      setIsCreatingAuction(true);
      const assetIds = Array.from(selectedAssets).map((id) => parseInt(id));
      const startingBidAmount = `${parseFloat(startingPrice).toFixed(8)} WAX`;
      const actions = [{
        account: "atomicmarket",
        name: "announceauct",
        authorization: [{
          actor: account || "",
          permission: session?.permission || "active"
        }],
        data: {
          seller: account || "",
          asset_ids: assetIds,
          starting_bid: startingBidAmount,
          duration: totalDurationSeconds,
          maker_marketplace: "market.pxj"
        }
      }];
      if (session) {
        await session.transact({ actions });
      }
      showSuccess("Auction Created", `Successfully created auction for ${selectedAssets.size} asset(s). Remember to transfer your assets to the atomicmarket contract to activate the auction.`);
      setShowCreateModal(false);
      setSelectedAssets(/* @__PURE__ */ new Set());
      setStartingPrice("");
      setDurationWeeks(0);
      setDurationDays(1);
      setDurationHours(0);
      setDurationMinutes(0);
      setAuctionMemo("");
      loadAuctions();
    } catch (error2) {
      log.error("Failed to create auction", "Auctions", error2);
      showError("Auction Creation Failed", error2 instanceof Error ? error2.message : "Failed to create auction");
    } finally {
      setIsCreatingAuction(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auctions-page", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-text", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Auctions" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Discover and bid on unique NFTs from the WAX ecosystem" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "create-auction-btn", onClick: handleCreateAuction, children: "Create Auction" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auctions-controls", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-input-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "search-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder: "Search auctions by name or asset ID...",
            value: searchTerm,
            onChange: (e) => setSearchTerm(e.target.value),
            className: "search-input"
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filters-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Collection:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: selectedCollection,
              onChange: (e) => setSelectedCollection(e.target.value),
              className: "collection-filter",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "All Collections" }),
                collections.map((collection) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: collection.collection_name, children: collection.name }, collection.collection_name))
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Sort by:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: sortBy,
              onChange: (e) => setSortBy(e.target.value),
              className: "sort-filter",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_asc", children: "Price: Low to High" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_desc", children: "Price: High to Low" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "created_desc", children: "Newest First" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "created_asc", children: "Oldest First" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "filter-group", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "checkbox-label", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: hideEmptyAuctions,
              onChange: (e) => setHideEmptyAuctions(e.target.checked)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "checkmark" }),
          "Hide auctions without bids"
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auctions-filters", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `filter-btn ${filter === "all" ? "active" : ""}`,
            onClick: () => setFilter("all"),
            children: "All Auctions"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `filter-btn ${filter === "ending-soon" ? "active" : ""}`,
            onClick: () => setFilter("ending-soon"),
            children: "Ending Soon"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `filter-btn ${filter === "new" ? "active" : ""}`,
            onClick: () => setFilter("new"),
            children: "New Auctions"
          }
        )
      ] })
    ] }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading auctions..." })
    ] }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => loadAuctions(), className: "retry-btn", children: "Try Again" })
    ] }),
    !loading && !error && filteredAuctions.length === 0 && auctions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No Matching Auctions" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No auctions match your current filters. Try adjusting your search criteria." })
    ] }),
    !loading && !error && auctions.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No Active Auctions" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "There are currently no active auctions. Check back later!" })
    ] }),
    !loading && !error && filteredAuctions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auctions-grid", children: filteredAuctions.map((auction) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "auction-card clickable-card",
        onClick: () => navigate(`/auctions/${auction.auction_id}`),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-image", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MediaRenderer,
              {
                imageUrl: auction.image,
                videoUrl: auction.video,
                alt: auction.asset_name,
                className: "auction-media",
                enableAnimations: true
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auction-timer", children: auctionService.formatTimeRemaining(auction.end_time) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "auction-title", children: auction.asset_name }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-collection-info", children: [
              auction.collection_info?.img && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: auction.collection_info.img,
                  alt: auction.collection_info.name,
                  className: "collection-avatar"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collection-details", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "collection-name", children: auction.collection_info?.name || auction.collection_name }),
                auction.collection_info?.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "collection-description", children: auction.collection_info.description.length > 60 ? `${auction.collection_info.description.substring(0, 60)}...` : auction.collection_info.description })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seller-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Seller: " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: (e) => {
                    e.stopPropagation();
                    navigate(`/user-profile-lookup?user=${encodeURIComponent(auction.seller)}`);
                  },
                  className: "seller-account",
                  children: auction.seller
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-pricing", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-bid", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: auction.current_bid ? "Current Bid:" : "Starting Price:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price", children: auction.current_bid ? formatPrice(auction.current_bid) : formatPrice(auction.price) })
              ] }),
              auction.bidder && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bidder", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Top Bidder:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: (e) => {
                      e.stopPropagation();
                      navigate(`/user-profile-lookup?user=${encodeURIComponent(auction.bidder || "")}`);
                    },
                    className: "account",
                    children: auction.bidder
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "bid-btn",
                  onClick: (e) => {
                    e.stopPropagation();
                    handlePlaceBid(auction);
                  },
                  disabled: !isConnected || auction.seller === account,
                  children: !isConnected ? "Connect Wallet" : auction.seller === account ? "Your Auction" : "Place Bid"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "view-btn",
                  onClick: (e) => {
                    e.stopPropagation();
                    handleViewDetails(auction);
                  },
                  children: "View Details"
                }
              )
            ] })
          ] })
        ]
      },
      auction.auction_id
    )) }),
    !loading && !error && filteredAuctions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-container", children: [
      hasMore && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "load-more-btn",
          onClick: loadMoreAuctions,
          disabled: loadingMore,
          children: loadingMore ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner small" }),
            "Loading more..."
          ] }) : "Load More Auctions"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Page ",
          currentPage,
          " of ",
          totalPages
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          filteredAuctions.length,
          " auctions loaded"
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "coming-soon-notice", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Integration in Progress" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Full AtomicMarket auction integration is currently being implemented. This page will soon display live auction data and allow bidding functionality." })
    ] }),
    showBidModal && selectedAuction && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: () => setShowBidModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Place Your Bid" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "close-btn",
            onClick: () => setShowBidModal(false),
            children: ""
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-auction-summary", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-asset-image", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MediaRenderer,
              {
                imageUrl: selectedAuction.image,
                videoUrl: selectedAuction.video,
                alt: selectedAuction.asset_name,
                className: "bid-modal-media",
                enableAnimations: true
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auction-timer-small", children: auctionService.formatTimeRemaining(selectedAuction.end_time) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-asset-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: selectedAuction.asset_name }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-collection-info", children: [
              selectedAuction.collection_info?.img && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: selectedAuction.collection_info.img,
                  alt: selectedAuction.collection_info.name,
                  className: "collection-avatar-small"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "collection-name", children: selectedAuction.collection_info?.name || selectedAuction.collection_name })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-current-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-bid-display", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: selectedAuction.current_bid ? "Current Bid" : "Starting Price" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "amount", children: formatPrice(selectedAuction.current_bid || selectedAuction.price) })
              ] }),
              selectedAuction.bidder && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-bidder", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Leading Bidder" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: (e) => {
                      e.stopPropagation();
                      navigate(`/user-profile-lookup?user=${encodeURIComponent(selectedAuction.bidder || "")}`);
                    },
                    className: "bidder-account",
                    children: selectedAuction.bidder
                  }
                )
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bid-input-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Your Bid Amount" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-input-wrapper", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                value: bidAmount,
                onChange: (e) => setBidAmount(e.target.value),
                placeholder: "0.0000",
                step: "0.0001",
                min: selectedAuction.current_bid && selectedAuction.bidder ? parseFloat(selectedAuction.current_bid) / 1e8 + 1e-4 : parseFloat(selectedAuction.price) / 1e8,
                className: "bid-amount-input",
                disabled: isPlacingBid
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "currency-label", children: "WAX" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-requirements", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "minimum-bid", children: selectedAuction.current_bid && selectedAuction.bidder ? `Minimum: ${formatWAXPrice(parseFloat(selectedAuction.current_bid) / 1e8 + 1e-4)}` : `Starting Price: ${formatWAXPrice(parseFloat(selectedAuction.price) / 1e8)}` }),
            bidAmount && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "bid-total", children: [
              "Total: ",
              formatWAXPrice(parseFloat(bidAmount))
            ] })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "previous-bids-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Bid History" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bids-list", children: selectedAuction.bidder ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bidder-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: (e) => {
                    e.stopPropagation();
                    navigate(`/user-profile-lookup?user=${encodeURIComponent(selectedAuction.bidder || "")}`);
                  },
                  className: "bidder",
                  children: selectedAuction.bidder
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bid-time", children: "Current leading bid" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bid-amount", children: formatPrice(selectedAuction.current_bid || selectedAuction.price) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-bids", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No bids yet - be the first to bid!" }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-notice", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notice-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notice-text", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Important:" }),
            " Ensure you have sufficient WAX balance for your bid. Bids are binding and cannot be cancelled."
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-modal-footer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "cancel-bid-btn",
            onClick: () => setShowBidModal(false),
            disabled: isPlacingBid,
            children: "Cancel"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "submit-bid-btn",
            onClick: submitBid,
            disabled: isPlacingBid || !bidAmount || (selectedAuction.current_bid && selectedAuction.bidder ? parseFloat(bidAmount) <= parseFloat(selectedAuction.current_bid) / 1e8 : parseFloat(bidAmount) < parseFloat(selectedAuction.price) / 1e8),
            children: isPlacingBid ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "loading-spinner-small" }),
              "Placing Bid..."
            ] }) : `Place Bid  ${bidAmount || "0.0000"} WAX`
          }
        )
      ] })
    ] }) }),
    showCreateModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay auction-modal", onClick: () => setShowCreateModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Create Auction" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "close-btn",
            onClick: () => setShowCreateModal(false),
            children: ""
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-selection-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Select Assets to Auction" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-selection-container", children: isLoadingAssets ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-assets", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading your assets..." })
          ] }) : userAssets.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "assets-grid", children: userAssets.map((asset) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `asset-item ${selectedAssets.has(asset.asset_id) ? "selected" : ""}`,
              onClick: () => toggleAssetSelection(asset.asset_id),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-image", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    MediaRenderer,
                    {
                      imageUrl: getAssetImageUrl(asset),
                      videoUrl: getAssetVideoUrl(asset),
                      alt: asset.name || `Asset #${asset.asset_id}`,
                      className: "asset-media",
                      enableAnimations: true,
                      loading: "lazy"
                    }
                  ),
                  selectedAssets.has(asset.asset_id) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selection-indicator", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9,20.42l-6.21,-6.21l2.83,-2.83L9,14.77l9.88,-9.89l2.83,2.83L9,20.42z" }) }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-name", children: asset.name || `Asset #${asset.asset_id}` }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-collection", children: asset.collection_name }),
                  asset.template_mint && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-mint-info", children: [
                    "Mint #",
                    asset.template_mint
                  ] })
                ] })
              ]
            },
            asset.asset_id
          )) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "no-assets", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "no-assets-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20,7l-8,-4l-8,4m16,0l-8,4m8,-4v10l-8,4m0,-10L4,7m8,4v10M4,7v10l8,4" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "No Assets Found" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "You don't have any assets to auction. Visit the marketplace to acquire some NFTs first." })
          ] }) }),
          selectedAssets.size > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selection-summary", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            selectedAssets.size,
            " asset",
            selectedAssets.size > 1 ? "s" : "",
            " selected"
          ] }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-form-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Starting Price (WAX)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "0.0000",
                step: "0.0001",
                min: "0",
                value: startingPrice,
                onChange: (e) => setStartingPrice(e.target.value),
                className: "form-input"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Auction Duration" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-inputs", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-field", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "duration-label", children: "Weeks" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "number",
                    min: "0",
                    max: "4",
                    value: durationWeeks,
                    onChange: (e) => updateDurationComponent("weeks", parseInt(e.target.value) || 0),
                    className: "duration-input"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-field", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "duration-label", children: "Days" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "number",
                    min: "0",
                    max: "30",
                    value: durationDays,
                    onChange: (e) => updateDurationComponent("days", parseInt(e.target.value) || 0),
                    className: "duration-input"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-field", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "duration-label", children: "Hours" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "number",
                    min: "0",
                    max: "23",
                    value: durationHours,
                    onChange: (e) => updateDurationComponent("hours", parseInt(e.target.value) || 0),
                    className: "duration-input"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-field", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "duration-label", children: "Minutes" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "number",
                    min: "0",
                    max: "59",
                    value: durationMinutes,
                    onChange: (e) => updateDurationComponent("minutes", parseInt(e.target.value) || 0),
                    className: "duration-input"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "duration-summary", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "duration-display", children: formatDurationDisplay() }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "duration-total", children: [
                "Total: ",
                Math.floor(calculateTotalDuration() / 3600),
                "h ",
                Math.floor(calculateTotalDuration() % 3600 / 60),
                "m"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Memo (Optional)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                placeholder: "Add a description for your auction",
                className: "form-textarea",
                rows: 3,
                value: auctionMemo,
                onChange: (e) => setAuctionMemo(e.target.value)
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "cancel-btn",
            onClick: () => setShowCreateModal(false),
            children: "Cancel"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "create-btn",
            onClick: handleCreateAuctionSubmit,
            disabled: selectedAssets.size === 0 || !startingPrice || parseFloat(startingPrice) <= 0 || isCreatingAuction,
            children: isCreatingAuction ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "loading-spinner-small" }),
              "Creating Auction..."
            ] }) : `Create Auction${selectedAssets.size > 0 ? ` (${selectedAssets.size} asset${selectedAssets.size > 1 ? "s" : ""})` : ""}`
          }
        )
      ] })
    ] }) })
  ] });
});
const AuctionDetail = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const { isConnected, account, session } = useWallet();
  const { showSuccess, showError } = useNotifications();
  const [auction, setAuction] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const [showBidModal, setShowBidModal] = reactExports.useState(false);
  const [bidAmount, setBidAmount] = reactExports.useState("");
  const [isPlacingBid, setIsPlacingBid] = reactExports.useState(false);
  const loadAuction = reactExports.useCallback(async () => {
    if (!id) return;
    setLoading(true);
    setError(null);
    try {
      const response = await apiService.getAuction(id);
      if (!response.success || !response.data) {
        setError("Auction not found");
        return;
      }
      setAuction(response.data);
    } catch (err) {
      console.error("Error loading auction:", err);
      setError("Failed to load auction details");
    } finally {
      setLoading(false);
    }
  }, [id]);
  reactExports.useEffect(() => {
    if (id) {
      loadAuction();
    }
  }, [id, loadAuction]);
  reactExports.useEffect(() => {
    if (!auction) return;
    const unsubscribe = auctionService.subscribe(auction.auction_id, (update) => {
      setAuction((prevAuction) => {
        if (!prevAuction) return null;
        return {
          ...prevAuction,
          current_bid: update.current_bid || prevAuction.current_bid,
          bidder: update.bidder || prevAuction.bidder,
          end_time: update.end_time
        };
      });
    });
    return () => unsubscribe();
  }, [auction]);
  const handlePlaceBid = () => {
    if (!isConnected || !account) {
      showError("Wallet Required", "Please connect your wallet to place bids");
      return;
    }
    if (auction?.seller === account) {
      showError("Invalid Action", "You cannot bid on your own auction");
      return;
    }
    setBidAmount("");
    setShowBidModal(true);
  };
  const submitBid = async () => {
    if (!auction || !session || !account) {
      showError("Error", "Please connect your wallet first");
      return;
    }
    const bidFloat = parseFloat(bidAmount);
    if (isNaN(bidFloat) || bidFloat <= 0) {
      showError("Invalid Bid", "Please enter a valid bid amount");
      return;
    }
    const currentBidAmount = parseFloat(auction.current_bid || auction.price) / 1e8;
    const hasExistingBids = auction.current_bid && auction.bidder;
    if (hasExistingBids && bidFloat <= currentBidAmount) {
      showError("Invalid Bid", `Bid must be higher than current bid of ${currentBidAmount.toFixed(4)} WAX`);
      return;
    }
    if (!hasExistingBids && bidFloat < parseFloat(auction.price) / 1e8) {
      showError("Invalid Bid", `Bid must be at least ${(parseFloat(auction.price) / 1e8).toFixed(4)} WAX`);
      return;
    }
    setIsPlacingBid(true);
    try {
      const bidAmountInt = Math.floor(bidFloat * 1e8);
      const result = await session.transact({
        actions: [{
          account: "atomicmarket",
          name: "auctionbid",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            bidder: account,
            auction_id: auction.auction_id,
            bid: `${bidAmountInt} WAX`,
            taker_marketplace: "market.pxj"
          }
        }]
      });
      if (result) {
        showSuccess("Bid Placed", `Successfully placed bid of ${bidFloat.toFixed(4)} WAX`);
        setShowBidModal(false);
        setBidAmount("");
        setAuction((prev) => prev ? {
          ...prev,
          current_bid: bidAmountInt.toString(),
          bidder: account
        } : null);
      }
    } catch (error2) {
      console.error("Error placing bid:", error2);
      showError("Bid Failed", error2 instanceof Error ? error2.message : "Failed to place bid");
    } finally {
      setIsPlacingBid(false);
    }
  };
  const formatPrice = (price) => {
    const waxPrice = parseFloat(price) / 1e8;
    return `${waxPrice.toFixed(4)} WAX`;
  };
  const formatTimeRemaining = (endTime) => {
    return auctionService.formatTimeRemaining(endTime);
  };
  const handleUserClick = (userAccount) => {
    navigate(`/user-profile-lookup?user=${encodeURIComponent(userAccount)}`);
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auction-detail-page", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading auction details..." })
    ] }) });
  }
  if (error || !auction) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auction-detail-page", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Auction Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error || "The requested auction could not be found." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: () => navigate("/auctions"),
          children: "Back to Auctions"
        }
      )
    ] }) });
  }
  const timeRemaining = formatTimeRemaining(auction.end_time);
  const isEnded = timeRemaining === "Auction ended";
  const currentPrice = auction.current_bid ? formatPrice(auction.current_bid) : formatPrice(auction.price);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-detail-page", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-detail-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "back-button",
          onClick: () => navigate("/auctions"),
          children: " Back to Auctions"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-detail-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-image-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auction-image-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: auction.image ? `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${auction.image}` : void 0,
              videoUrl: auction.video ? `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${auction.video}` : void 0,
              alt: auction.asset_name || "NFT",
              className: "auction-image",
              enableAnimations: true
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-basic-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "auction-title", children: auction.asset_name || `Asset #${auction.asset_id || "Unknown"}` }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-collection", children: [
              "Collection: ",
              auction.collection_name || "Unknown"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-id", children: [
              "Auction ID: ",
              auction.auction_id
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-status", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `status-badge ${isEnded ? "ended" : "active"}`, children: isEnded ? "Ended" : "Active" }),
            !isEnded && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "time-remaining", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-label", children: "Time Remaining:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-value", children: timeRemaining })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-price", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-label", children: auction.current_bid ? "Current Bid:" : "Starting Price:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price-value", children: currentPrice })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "participants-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seller-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "participant-label", children: "Seller:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "participant-link",
                  onClick: () => handleUserClick(auction.seller),
                  children: auction.seller
                }
              )
            ] }),
            auction.bidder && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bidder-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "participant-label", children: "Top Bidder:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "participant-link",
                  onClick: () => handleUserClick(auction.bidder || ""),
                  children: auction.bidder
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "auction-actions", children: !isEnded && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary bid-button",
              onClick: handlePlaceBid,
              disabled: !isConnected || auction.seller === account,
              children: !isConnected ? "Connect Wallet" : auction.seller === account ? "Your Auction" : "Place Bid"
            }
          ) })
        ] })
      ] })
    ] }),
    showBidModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: () => setShowBidModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Place Bid" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "modal-close",
            onClick: () => setShowBidModal(false),
            children: ""
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "auction-summary", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: auction.image ? `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${auction.image}` : void 0,
              videoUrl: auction.video ? `${API_ENDPOINTS.IPFS.GATEWAYS[0]}${auction.video}` : void 0,
              alt: auction.asset_name || "NFT",
              className: "modal-nft-image",
              enableAnimations: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-nft-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: auction.asset_name || `Asset #${auction.asset_id || "Unknown"}` }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              "Current: ",
              currentPrice
            ] })
          ] })
        ] }),
        auction.bidder && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-bidder", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Leading Bidder" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "bidder-account",
              onClick: () => handleUserClick(auction.bidder),
              children: auction.bidder
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-input-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "bidAmount", children: "Your Bid (WAX)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              id: "bidAmount",
              type: "number",
              step: "0.0001",
              placeholder: "Enter bid amount",
              value: bidAmount,
              onChange: (e) => setBidAmount(e.target.value),
              min: auction.current_bid && auction.bidder ? parseFloat(auction.current_bid) / 1e8 + 1e-4 : parseFloat(auction.price) / 1e8
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bid-requirement", children: [
            "Minimum: ",
            auction.current_bid && auction.bidder ? `${(parseFloat(auction.current_bid) / 1e8 + 1e-4).toFixed(4)} WAX` : `${(parseFloat(auction.price) / 1e8).toFixed(4)} WAX`
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-secondary",
            onClick: () => setShowBidModal(false),
            disabled: isPlacingBid,
            children: "Cancel"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary",
            onClick: submitBid,
            disabled: isPlacingBid || !bidAmount,
            children: isPlacingBid ? "Placing Bid..." : "Place Bid"
          }
        )
      ] })
    ] }) })
  ] });
};
const Learn = () => {
  const [activeSection, setActiveSection] = reactExports.useState("getting-started");
  const guides = [
    {
      id: "getting-started",
      title: "Getting Started on WAX",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "guide-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Welcome to the WAX Blockchain!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "WAX (Worldwide Asset eXchange) is a purpose-built blockchain for NFTs and gaming. Here's how to get started:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step-list", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "step-number", children: "1" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Create a WAX Wallet" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                "Visit ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://wallet.wax.io", target: "_blank", rel: "noopener noreferrer", children: "wallet.wax.io" }),
                " to create your free WAX account. No gas fees required!"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "step-number", children: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Get Some WAX Tokens" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Purchase WAX tokens from exchanges like Binance, KuCoin, or use the built-in WAX wallet exchange." })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "step-number", children: "3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Connect Your Wallet" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: 'Use the "Connect Wallet" button in the top right to connect your WAX wallet to PxMarket.' })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "step-number", children: "4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Start Trading!" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Browse collections, buy NFTs, and start building your digital asset portfolio." })
            ] })
          ] })
        ] })
      ] })
    },
    {
      id: "pixel-journey",
      title: "About Pixel Journey",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "guide-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Welcome to Pixel Journey!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Pixel Journey is a comprehensive NFT ecosystem on the WAX blockchain, featuring unique pixel art collections and gaming utilities." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Pixel Art NFTs" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Collect unique pixel art characters, items, and accessories with various rarity levels." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Gaming Integration" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Use your NFTs in games and earn rewards through various gameplay mechanics." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Staking Rewards" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Stake your Pixel Journey NFTs to earn PXJ tokens and other rewards." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Marketplace" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Trade your NFTs on our integrated marketplace with zero fees for holders." })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collections-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Main Collections:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Pixals:" }),
              " The main character collection with various traits and rarities"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Pixel Ingredients:" }),
              " Crafting materials and consumables"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Pixel Tools:" }),
              " Equipment and utility items"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Pixel Lands:" }),
              " Virtual land parcels for building and development"
            ] })
          ] })
        ] })
      ] })
    },
    {
      id: "trading-tips",
      title: "Trading Tips & Strategies",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "guide-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Smart Trading on WAX" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tip-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Research Before Buying" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Check the collection's total supply and rarity distribution" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Look at recent sales history and price trends" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Verify the authenticity of the collection" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Join the project's Discord or Telegram for community insights" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tip-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Pricing Strategies" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Use floor price as a baseline for common items" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Factor in rarity and trait combinations for pricing" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Consider market timing and overall WAX ecosystem trends" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Set competitive prices for quick sales or premium prices for rare items" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tip-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Risk Management" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Never invest more than you can afford to lose" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Diversify across different collections and projects" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Be aware of market volatility and seasonal trends" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Keep some WAX liquid for opportunities" })
          ] })
        ] })
      ] })
    },
    {
      id: "faq",
      title: "Frequently Asked Questions",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "guide-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Common Questions" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faq-list", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faq-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Q: Are there any fees for trading on PxMarket?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "A: PxMarket charges a small marketplace fee on sales. However, Pixel Journey NFT holders may receive fee discounts or exemptions." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faq-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Q: How do I know if an NFT is authentic?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "A: Always verify the collection name and creator account. Authentic Pixel Journey NFTs are minted by verified accounts and will show the official collection badge." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faq-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Q: Can I cancel a listing after it's posted?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "A: Yes, you can cancel your listings at any time from your inventory or profile page. There's no fee for canceling listings." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faq-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Q: What happens if I lose access to my WAX wallet?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "A: Always keep your private keys and recovery phrases secure. If you lose access, you may lose your NFTs permanently. Consider using hardware wallets for valuable collections." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faq-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Q: How do I participate in NFT drops and launches?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "A: Follow Pixel Journey on social media and join our Discord for announcements. Most drops happen directly through our platform or partner sites." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faq-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Q: Can I use my NFTs in games?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "A: Many Pixel Journey NFTs have gaming utility. Check the NFT details page for specific game integrations and benefits." })
          ] })
        ] })
      ] })
    },
    {
      id: "advanced",
      title: "Advanced Features",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "guide-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Power User Features" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "advanced-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Bulk Operations" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Use our bulk tools to:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "List multiple NFTs at once with smart pricing" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Transfer multiple items to different recipients" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Burn unwanted NFTs in batches" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Stake multiple NFTs for rewards" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "advanced-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Analytics & Tracking" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Monitor your portfolio with:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Real-time portfolio value tracking" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Transaction history and profit/loss analysis" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Collection performance metrics" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Market trend indicators" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "advanced-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Watchlists & Alerts" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Stay informed with:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Custom watchlists for tracking specific NFTs" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Price alerts for collections you're interested in" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "New listing notifications" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Auction ending reminders" })
          ] })
        ] })
      ] })
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "learn-page", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Learn Hub" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Everything you need to know about WAX, NFTs, and Pixel Journey" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "learn-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "learn-sidebar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "learn-nav", children: guides.map((guide) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `nav-item ${activeSection === guide.id ? "active" : ""}`,
          onClick: () => setActiveSection(guide.id),
          children: guide.title
        },
        guide.id
      )) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "learn-content", children: guides.find((guide) => guide.id === activeSection)?.content })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "help-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Need More Help?" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Access our documentation and join our community for support:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "community-links", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://docs.pixeljourney.xyz", target: "_blank", rel: "noopener noreferrer", className: "community-link docs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "icon", children: "" }),
          "Documentation"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", className: "community-link discord", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "icon", children: "" }),
          "Discord Community"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", className: "community-link telegram", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "icon", children: "" }),
          "Telegram Group"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", className: "community-link twitter", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "icon", children: "" }),
          "Twitter Updates"
        ] })
      ] })
    ] })
  ] });
};
const JourneyMap = () => {
  const [activeSection, setActiveSection] = reactExports.useState("overview");
  const sections = [
    {
      id: "overview",
      title: "Overview",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "PxMarket Journey Map" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Welcome to the comprehensive roadmap of the Pixel Journey ecosystem. This page serves as both a sitemap for current features and a development roadmap for future enhancements." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ecosystem-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ecosystem-card current", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Current Platform" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "PxMarket - Your gateway to the Pixel Journey NFT ecosystem" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ecosystem-card future", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Future dApps" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Expanding ecosystem of interconnected applications" })
          ] })
        ] })
      ] })
    },
    {
      id: "pxmarket-features",
      title: "PxMarket Features",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "PxMarket Feature Map" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Explore all the features available in the current PxMarket platform:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Marketplace Core" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "NFT Marketplace" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Collection Browser" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Asset Details" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Advanced Filtering" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " User Features" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "User Profiles" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Inventory Management" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Watchlist" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Activity Tracking" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Trading & Economy" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Buy/Sell NFTs" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Bulk Operations" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Price Analytics" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Auctions" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Offers System" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Shopping Cart" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " WAX Integration" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "RWAX Tokenization" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "WAX Balance Management" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Resource Management (CPU/NET/RAM)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Multi-Wallet Support" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Staking & Rewards" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "NFT Staking" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Token Staking" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Reward Distribution" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "PXJ Badge System" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Rewards & Gamification" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Pack Opening" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Chat System" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Live Transactions Feed" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Social Sharing" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item planned", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Achievement System" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge planned", children: "Planned" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Advanced Features" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "NFT Comparison Tool" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Portfolio Analytics" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Price Alerts" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Collection Analytics" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Accessibility Features" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item live", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "PWA Support" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Crafting & Creation" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item beta", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "NFT Crafting System" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge beta", children: "Beta" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item planned", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Custom Templates" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge planned", children: "Planned" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item planned", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-name", children: "Community Creations" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge planned", children: "Planned" })
            ] })
          ] })
        ] })
      ] })
    },
    {
      id: "wax-ecosystem",
      title: "WAX Ecosystem",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "PXJourney across WAX" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Explore the expanding Pixel Journey ecosystem on the WAX blockchain:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card live purple-glow", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PxMarket" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "NFT marketplace and trading platform" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://market.pixeljourney.xyz", target: "_blank", rel: "noopener noreferrer", className: "dapp-link", children: "Visit PxMarket " })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card live green-glow", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PxStaking" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Stake your Pixel Journey NFTs for rewards" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://stake.pixeljourney.xyz", target: "_blank", rel: "noopener noreferrer", className: "dapp-link", children: "Visit PxStaking " })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card live golden-glow", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PxLeaderboards" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge live", children: "Live" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Track rankings and compete with other players" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://lb.pixeljourney.xyz", target: "_blank", rel: "noopener noreferrer", className: "dapp-link", children: "Visit PxLeaderboards " })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card planned", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PxDeFi" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge planned", children: "ETA TBD" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Decentralized finance features for the ecosystem" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-link disabled", children: "Coming via PxMilestones" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card coming-soon", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PxCraft" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge coming-soon", children: "Coming Soon" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Craft and create new NFTs from existing assets" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-link disabled", children: "In Development" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card coming-soon", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PxMilestones" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge coming-soon", children: "Coming Soon" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Achievement and milestone tracking system" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-link disabled", children: "In Development" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card planned", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PxQuest" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge planned", children: "ETA TBD" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Quest and mission system for earning rewards" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-link disabled", children: "Coming via PxMilestones" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card planned", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PxDAO" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge planned", children: "ETA TBD" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Decentralized governance for the ecosystem" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-link disabled", children: "Coming via PxMilestones" })
          ] })
        ] })
      ] })
    },
    {
      id: "external-links",
      title: "External Platforms",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Pixel Journey Across Platforms" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Find Pixel Journey on various platforms and marketplaces:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "platform-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Official Websites" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "link-grid", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://pixeljourney.xyz/", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "Main Website" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Official Pixel Journey homepage" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://docs.pixeljourney.xyz", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "Documentation" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Complete project documentation" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "platform-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " NFT Marketplaces (WAX)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "link-grid", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://atomichub.io/explorer/collection/wax-mainnet/pixeljourney", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "AtomicHub" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Primary WAX marketplace" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://neftyblocks.com/collection/pixeljourney/", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "NeftyBlocks" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "WAX NFT marketplace" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://nfthive.io/collection/pixeljourney", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "NFTHive" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "WAX marketplace and drops" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://www.pfpwizard.xyz/pfp/pixals/ranking/", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "PFP Wizard" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Pixal PFP marketplace" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "platform-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Cross-Chain Marketplaces" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "link-grid", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://opensea.io/collection/pixeljourney-polygon", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "OpenSea (Polygon)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Polygon bridged collection" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://opensea.io/collection/pixeljourney-base", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "OpenSea (Base)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Base bridged collection" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://opensea.io/collection/pixeljourney-eth", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "OpenSea (Ethereum)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Ethereum bridged collection" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://nft.monbase.com/collections/66c4eb2ca339b05c5a660e44/detail", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "MonBase" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Base chain marketplace" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "platform-category", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " DeFi & Staking" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "link-grid", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://waxdao.io/v2/farm/pixeljourney", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "WaxDAO Farm" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "NFT staking rewards" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://www.pfpwizard.xyz/pfp/pixals/buy/", target: "_blank", rel: "noopener noreferrer", className: "platform-link", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-name", children: "PFP Wizard Buy" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "platform-desc", children: "Get your Pixal PFP" })
            ] })
          ] })
        ] })
      ] })
    },
    {
      id: "social-community",
      title: "Social & Community",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Join the Community" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect with the Pixel Journey community across various platforms:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://twitter.com/PxJourney", target: "_blank", rel: "noopener noreferrer", className: "social-link twitter", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-name", children: "Twitter/X" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-desc", children: "Latest updates and announcements" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://t.me/pixel_journey", target: "_blank", rel: "noopener noreferrer", className: "social-link telegram", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-name", children: "Telegram" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-desc", children: "Community chat and discussions" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://discord.gg/waxblockchain", target: "_blank", rel: "noopener noreferrer", className: "social-link discord", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-name", children: "WAX Discord" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-desc", children: "Join the broader WAX community" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://instagram.com/pixeljourney_xyz", target: "_blank", rel: "noopener noreferrer", className: "social-link instagram", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-name", children: "Instagram" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-desc", children: "Visual updates and behind-the-scenes" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://coinmarketcap.com/community/profile/pixeljourney/", target: "_blank", rel: "noopener noreferrer", className: "social-link cmc", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-name", children: "CoinMarketCap" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-desc", children: "Project profile and metrics" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://dappradar.com/nft-collection/pixel-journey", target: "_blank", rel: "noopener noreferrer", className: "social-link dappradar", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-name", children: "DappRadar" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-desc", children: "NFT collection analytics" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "https://pixel-journey.uncut.network/", target: "_blank", rel: "noopener noreferrer", className: "social-link uncut", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "social-icon", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "social-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-name", children: "Uncut Network" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "social-desc", children: "Gaming community presence" })
            ] })
          ] })
        ] })
      ] })
    },
    {
      id: "roadmap",
      title: "Development Roadmap",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "section-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Future Development Roadmap" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Planned features and enhancements for the Pixel Journey ecosystem:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "roadmap-timeline", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "roadmap-phase completed", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "phase-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Phase 1: Foundation" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "phase-status completed", children: "Completed" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " PxMarket NFT marketplace launch" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Basic trading functionality" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " User profiles and inventory" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " PXJ token integration" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "roadmap-phase current", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "phase-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Phase 2: Enhancement" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "phase-status current", children: "Current" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Advanced filtering and search" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Bulk operations" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Auction system (Beta)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Enhanced analytics" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "roadmap-phase planned", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "phase-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Phase 3: Ecosystem Expansion" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "phase-status planned", children: "Q2 2025" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " PxCraft crafting system" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " PxMilestones achievement system" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Enhanced gamification" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Cross-platform integration" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "roadmap-phase future", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "phase-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Phase 4: Advanced Features" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "phase-status future", children: "Q3-Q4 2025" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " PxQuest mission system" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " PxDeFi financial features" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " PxDAO governance" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Mobile applications" })
            ] })
          ] })
        ] })
      ] })
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "journeymap-page", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Journey Map" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Your comprehensive guide to the Pixel Journey ecosystem - current features, future roadmap, and community links" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "journeymap-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "journeymap-sidebar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "journeymap-nav", children: sections.map((section) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `nav-item ${activeSection === section.id ? "active" : ""}`,
          onClick: () => setActiveSection(section.id),
          children: section.title
        },
        section.id
      )) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "journeymap-content", children: sections.find((section) => section.id === activeSection)?.content })
    ] })
  ] });
};
const NFTStakingModal = ({
  isOpen,
  onClose,
  templateId,
  templateName,
  action,
  onSuccess
}) => {
  const [assets, setAssets] = reactExports.useState([]);
  const [selectedAssets, setSelectedAssets] = reactExports.useState([]);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [isProcessing, setIsProcessing] = reactExports.useState(false);
  const [batchProgress, setBatchProgress] = reactExports.useState(null);
  const [transactionResults, setTransactionResults] = reactExports.useState(null);
  const { session, account } = useWallet$1();
  const { addNotification, showSuccess, showError } = useNotifications();
  reactExports.useEffect(() => {
    if (isOpen && account) {
      fetchAssets();
    }
  }, [isOpen, account, templateId]);
  const fetchAssets = async () => {
    if (!account) return;
    setIsLoading(true);
    try {
      if (action === "stake") {
        const { apiService: apiService2 } = await __vitePreload(async () => {
          const { apiService: apiService3 } = await Promise.resolve().then(() => api);
          return { apiService: apiService3 };
        }, true ? void 0 : void 0);
        const endpoint = `${apiService2.atomicAssetsAPI}/atomicassets/v1/assets?owner=${account}&template_id=${templateId}&page=1&limit=100&order=desc&sort=asset_id`;
        const response = await apiService2.fetchWithRetry(endpoint);
        const data = await response.json();
        setAssets(data.data || []);
      } else {
        const { apiService: apiService2 } = await __vitePreload(async () => {
          const { apiService: apiService3 } = await Promise.resolve().then(() => api);
          return { apiService: apiService3 };
        }, true ? void 0 : void 0);
        const contractResponse = await apiService2.waxRpcCall("/v1/chain/get_table_rows", {
          json: true,
          code: "farms.waxdao",
          scope: "farms.waxdao",
          table: "stakers",
          lower_bound: account,
          upper_bound: account,
          limit: 1
        });
        const contractData = contractResponse;
        const userStakeData = contractData.rows.find((row) => row.user === account);
        const stakedAssetIds = userStakeData?.staked_assets || [];
        if (stakedAssetIds.length === 0) {
          setAssets([]);
        } else {
          const assetsResponse = await apiService2.fetchWithRetry(`${apiService2.atomicAssetsAPI}/atomicassets/v1/assets?ids=${stakedAssetIds.join(",")}&page=1&limit=1000`);
          if (!assetsResponse.ok) {
            throw new Error("Failed to fetch asset details");
          }
          const assetsData = await assetsResponse.json();
          setAssets(assetsData.data || []);
        }
      }
    } catch (error) {
      log.error("Failed to fetch staking assets", "NFTStakingModal.fetchAssets", error, { account });
      addNotification({ type: "error", message: "Failed to load assets" });
    } finally {
      setIsLoading(false);
    }
  };
  const handleAssetToggle = (assetId) => {
    setSelectedAssets(
      (prev) => prev.includes(assetId) ? prev.filter((id) => id !== assetId) : [...prev, assetId]
    );
  };
  const handleSelectAll = () => {
    if (selectedAssets.length === assets.length) {
      setSelectedAssets([]);
    } else {
      setSelectedAssets(assets.map((asset) => asset.asset_id));
    }
  };
  const handleSubmit = async () => {
    if (!session || selectedAssets.length === 0) return;
    setIsProcessing(true);
    setBatchProgress({ current: 0, total: selectedAssets.length });
    setTransactionResults(null);
    try {
      let result;
      if (action === "stake") {
        result = await stakingService.stakeNFTsBatch(
          session,
          selectedAssets,
          "pixeljourney"
        );
      } else {
        result = await stakingService.unstakeNFTsBatch(
          session,
          selectedAssets
        );
      }
      setTransactionResults(result);
      if (result.success) {
        showSuccess(
          "Transaction Successful",
          `Successfully ${action}d ${result.successful_transactions.length} ${templateName} NFT${result.successful_transactions.length > 1 ? "s" : ""}`
        );
        setTimeout(() => {
          onSuccess?.();
          onClose();
        }, 2e3);
      } else {
        const successCount = result.successful_transactions.length;
        const failCount = result.failed_transactions.length;
        if (successCount > 0) {
          showSuccess(
            "Partial Success",
            `${successCount} NFTs ${action}d successfully, ${failCount} failed`
          );
        } else {
          showError(
            "Transaction Failed",
            `Failed to ${action} NFTs. Please try again.`
          );
        }
      }
    } catch (error) {
      log.error(`NFT ${action} operation failed`, `NFTStakingModal.handleBatchAction`, error, { action, selectedAssetsCount: selectedAssets.length });
      const errorMessage = error instanceof Error ? error.message : `Failed to ${action} NFTs`;
      showError(
        "Transaction Error",
        errorMessage
      );
    } finally {
      setIsProcessing(false);
      setBatchProgress(null);
    }
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content nft-staking-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
        action === "stake" ? "Stake" : "Unstake",
        " ",
        templateName,
        " NFTs"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "Loading your ",
        templateName,
        " NFTs..."
      ] })
    ] }) : isProcessing ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "processing-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        action === "stake" ? "Staking" : "Unstaking",
        " your NFTs..."
      ] }),
      batchProgress && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "batch-progress", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "progress-fill",
            style: { width: `${batchProgress.current / batchProgress.total * 100}%` }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "Processing ",
          batchProgress.current,
          " of ",
          batchProgress.total,
          " NFTs"
        ] })
      ] }),
      transactionResults && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-results", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "results-summary", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "success-count", children: [
            " ",
            transactionResults.successful_transactions.length,
            " successful"
          ] }),
          transactionResults.failed_transactions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-count", children: [
            " ",
            transactionResults.failed_transactions.length,
            " failed"
          ] })
        ] }),
        transactionResults.failed_transactions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "failed-transactions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Failed Transactions:" }),
          transactionResults.failed_transactions.slice(0, 5).map((failure) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "failure-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "#",
              failure.asset_id
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "error-message", children: failure.error })
          ] }, failure.asset_id)),
          transactionResults.failed_transactions.length > 5 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "... and ",
            transactionResults.failed_transactions.length - 5,
            " more"
          ] })
        ] })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selection-controls", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn btn-secondary",
            onClick: handleSelectAll,
            children: selectedAssets.length === assets.length ? "Deselect All" : "Select All"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "selection-count", children: [
          selectedAssets.length,
          " of ",
          assets.length,
          " selected"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-grid", children: assets.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-assets", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "No ",
        templateName,
        " NFTs available to ",
        action
      ] }) }) : assets.map((asset) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `asset-item ${selectedAssets.includes(asset.asset_id) ? "selected" : ""}`,
          onClick: () => handleAssetToggle(asset.asset_id),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              NFTImage,
              {
                src: asset.image || `https://ipfs.io/ipfs/${asset.data?.img || "placeholder"}`,
                alt: asset.name
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-id", children: [
              "#",
              asset.asset_id
            ] }),
            selectedAssets.includes(asset.asset_id) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selection-indicator", children: "" })
          ]
        },
        asset.asset_id
      )) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-secondary", onClick: onClose, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn btn-primary",
          onClick: handleSubmit,
          disabled: selectedAssets.length === 0 || isProcessing,
          children: isProcessing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
            action === "stake" ? "Staking..." : "Unstaking..."
          ] }) : `${action === "stake" ? "Stake" : "Unstake"} ${selectedAssets.length} NFT${selectedAssets.length !== 1 ? "s" : ""}`
        }
      )
    ] })
  ] }) });
};
const getTokenIcon = (tokenSymbol) => {
  const tokenIcons = {
    "PXJ": "/img/tokens/pxj.png",
    "WUF": "/img/tokens/wuf.png",
    "WAX": "/img/tokens/wax.png",
    "PIXAL": "/img/tokens/pixal.png"
  };
  return tokenIcons[tokenSymbol.toUpperCase()] || "/img/tokens/default.png";
};
const TokenStakingModal = ({
  isOpen,
  onClose,
  action,
  farmName = "pxjfarm1",
  onSuccess
}) => {
  const { session } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  const [amount, setAmount] = reactExports.useState("");
  const [isProcessing, setIsProcessing] = reactExports.useState(false);
  const [farmInfo, setFarmInfo] = reactExports.useState(null);
  const [userStakeInfo, setUserStakeInfo] = reactExports.useState(null);
  const [userBalance, setUserBalance] = reactExports.useState(0);
  const [loading, setLoading] = reactExports.useState(false);
  const fetchData = reactExports.useCallback(async () => {
    if (!session) return;
    setLoading(true);
    try {
      const farm = await stakingService.getTokenFarmInfo(farmName);
      setFarmInfo(farm);
      const userStake = await stakingService.getTokenStakingInfo(session.actor.toString(), farmName);
      setUserStakeInfo(userStake);
      const balanceResponse = await fetch("https://wax.greymass.com/v1/chain/get_currency_balance", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          code: "pixeljourney",
          account: session.actor.toString(),
          symbol: "PXJ"
        })
      });
      if (balanceResponse.ok) {
        const balanceData = await balanceResponse.json();
        const balance = balanceData.length > 0 ? parseFloat(balanceData[0].split(" ")[0]) : 0;
        setUserBalance(balance);
      }
    } catch (error) {
      console.error("Error fetching data:", error);
      showError("Failed to load staking data");
    } finally {
      setLoading(false);
    }
  }, [session, setLoading, farmName, setFarmInfo, setUserStakeInfo, setUserBalance, showError]);
  reactExports.useEffect(() => {
    if (isOpen && session) {
      fetchData();
    }
  }, [isOpen, session, farmName, fetchData]);
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!session || isProcessing) return;
    if (action !== "claim" && (!amount || parseFloat(amount) <= 0)) {
      showError("Please enter a valid amount");
      return;
    }
    if (action === "stake" && parseFloat(amount) > userBalance) {
      showError("Insufficient PXJ balance");
      return;
    }
    if (action === "unstake" && userStakeInfo && parseFloat(amount) > userStakeInfo.staked_amount) {
      showError("Amount exceeds staked balance");
      return;
    }
    setIsProcessing(true);
    try {
      let result;
      const formattedAmount = `${parseFloat(amount).toFixed(4)} PXJ`;
      switch (action) {
        case "stake":
          result = await stakingService.stakeTokens(session, formattedAmount, farmName);
          break;
        case "unstake":
          result = await stakingService.unstakeTokens(session, formattedAmount, farmName);
          break;
        case "claim":
          result = await stakingService.claimTokenFarmRewards(session, farmName);
          break;
        default:
          throw new Error("Invalid action");
      }
      if (result.success) {
        showSuccess(`Successfully ${action === "stake" ? "staked" : action === "unstake" ? "unstaked" : "claimed"} tokens!`);
        onSuccess?.();
        onClose();
      } else {
        showError(result.error || `Failed to ${action} tokens`);
      }
    } catch (error) {
      console.error(`Error ${action}ing tokens:`, error);
      showError(error instanceof Error ? error.message : `Failed to ${action} tokens`);
    } finally {
      setIsProcessing(false);
    }
  };
  const formatTokenAmount = (amount2) => {
    return amount2.toLocaleString(void 0, { minimumFractionDigits: 4, maximumFractionDigits: 4 });
  };
  const formatTimeRemaining = (timestamp) => {
    const now = Date.now() / 1e3;
    const remaining = timestamp - now;
    if (remaining <= 0) return "Available now";
    const days = Math.floor(remaining / 86400);
    const hours = Math.floor(remaining % 86400 / 3600);
    const minutes = Math.floor(remaining % 3600 / 60);
    if (days > 0) return `${days}d ${hours}h remaining`;
    if (hours > 0) return `${hours}h ${minutes}m remaining`;
    return `${minutes}m remaining`;
  };
  if (!isOpen) return null;
  const getModalTitle = () => {
    switch (action) {
      case "stake":
        return "Stake PXJ Tokens";
      case "unstake":
        return "Unstake PXJ Tokens";
      case "claim":
        return "Claim Rewards";
      default:
        return "Token Staking";
    }
  };
  const getActionButtonText = () => {
    if (isProcessing) return "Processing...";
    switch (action) {
      case "stake":
        return "Stake Tokens";
      case "unstake":
        return "Unstake Tokens";
      case "claim":
        return "Claim Rewards";
      default:
        return "Submit";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content token-staking-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: getModalTitle() }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading staking data..." })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      farmInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "farm-info-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Farm Information" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Farm:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: farmInfo.farm_name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Total Staked:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "value", children: [
              formatTokenAmount(farmInfo.total_staked),
              " PXJ"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Vesting Period:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "value", children: [
              Math.floor(farmInfo.vesting_time / 86400),
              " days"
            ] })
          ] })
        ] })
      ] }),
      userStakeInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-stake-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Your Staking Position" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Staked Amount:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "value", children: [
              formatTokenAmount(userStakeInfo.staked_amount),
              " PXJ"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Pending Rewards:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: userStakeInfo.pending_rewards.map(
              (reward) => `${formatTokenAmount(reward.amount)} ${reward.token}`
            ).join(", ") || "None" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Unlock Time:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: formatTimeRemaining(userStakeInfo.vesting_time) })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "balance-info", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TokenImage, { src: getTokenIcon("PXJ"), alt: "PXJ" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Available: ",
          formatTokenAmount(userBalance),
          " PXJ"
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "staking-form", children: [
        action !== "claim" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "amount", children: "Amount (PXJ)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                id: "amount",
                value: amount,
                onChange: (e) => setAmount(e.target.value),
                placeholder: "0.0000",
                step: "0.0001",
                min: "0",
                max: action === "stake" ? userBalance : userStakeInfo?.staked_amount || 0,
                required: true,
                disabled: isProcessing
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "max-btn",
                onClick: () => {
                  const maxAmount = action === "stake" ? userBalance : userStakeInfo?.staked_amount || 0;
                  setAmount(maxAmount.toFixed(4));
                },
                disabled: isProcessing,
                children: "MAX"
              }
            )
          ] })
        ] }),
        action === "claim" && userStakeInfo && userStakeInfo.pending_rewards.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rewards-preview", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Rewards to Claim:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rewards-list", children: userStakeInfo.pending_rewards.map((reward, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reward-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TokenImage, { src: getTokenIcon(reward.token), alt: reward.token }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              formatTokenAmount(reward.amount),
              " ",
              reward.token
            ] })
          ] }, index)) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn btn-secondary",
              onClick: onClose,
              disabled: isProcessing,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn btn-primary",
              disabled: isProcessing || action !== "claim" && !amount,
              children: getActionButtonText()
            }
          )
        ] })
      ] })
    ] }) })
  ] }) });
};
const getTemplateEstimatedValue = async (templateId, rarity) => {
  try {
    const sales = await apiService.getSales({ template: templateId, limit: 10 });
    if (sales && sales.data.length > 0) {
      const avgPrice = sales.data.reduce((sum, sale) => {
        const price = parseFloat(sale.price?.amount || "0");
        return sum + price;
      }, 0) / sales.data.length;
      return Math.floor(avgPrice * 100);
    }
  } catch (error) {
    log.warn("Could not fetch template sales data", "Staking", error);
  }
  const rarityMultipliers = {
    "Common": 1e3,
    "Uncommon": 2500,
    "Rare": 5e3,
    "Epic": 15e3,
    "Legendary": 5e4
  };
  return rarityMultipliers[rarity] || 1e3;
};
const getTemplateMarketPrice = async (templateId) => {
  try {
    const listings = await apiService.getSales({ template: templateId, limit: 5 });
    if (listings && listings.data.length > 0) {
      const prices = listings.data.map((listing) => parseFloat(listing.price?.amount || "0"));
      const minPrice = Math.min(...prices.filter((p) => p > 0));
      return Math.floor(minPrice);
    }
  } catch (error) {
    log.warn("Could not fetch template listings", "Staking", error);
  }
  return 50;
};
const QuickBuyModal = ({ template, isOpen, onClose }) => {
  if (!isOpen || !template) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content quick-buy-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
        "Quick Buy - ",
        template.name
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buy-item-preview", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(NFTImage, { src: template.image, alt: template.name }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "item-details", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: template.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "rarity", children: template.rarity }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "price", children: [
          template.market_price || "N/A",
          " WAX"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "available", children: [
          template.available_for_sale || 0,
          " available"
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-secondary", onClick: onClose, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-primary", children: "Buy Now" })
    ] })
  ] }) });
};
const Staking = () => {
  const { session, isConnected, login } = useWallet$1();
  const { showSuccess, showError } = useNotifications();
  const [loading, setLoading] = reactExports.useState(false);
  const [nftTemplates, setNftTemplates] = reactExports.useState([]);
  const [rewards, setRewards] = reactExports.useState({ pxj: 0, wuf: 0 });
  const [nftLoading, setNftLoading] = reactExports.useState(false);
  const [totalStakingPower, setTotalStakingPower] = reactExports.useState(0);
  const [selectedTemplate, setSelectedTemplate] = reactExports.useState(null);
  const [stakingModalOpen, setStakingModalOpen] = reactExports.useState(false);
  const [craftingModalOpen, setCraftingModalOpen] = reactExports.useState(false);
  const [quickBuyModalOpen, setQuickBuyModalOpen] = reactExports.useState(false);
  const [selectedBuyTemplate, setSelectedBuyTemplate] = reactExports.useState(null);
  const [simulationMode, setSimulationMode] = reactExports.useState(false);
  const [tokenStakeInfo, setTokenStakeInfo] = reactExports.useState(null);
  const [tokenFarmInfo, setTokenFarmInfo] = reactExports.useState(null);
  const [tokenStakingModalOpen, setTokenStakingModalOpen] = reactExports.useState(false);
  const [tokenStakingAction, setTokenStakingAction] = reactExports.useState("stake");
  const [tokenLoading, setTokenLoading] = reactExports.useState(false);
  const [userPxjBalance, setUserPxjBalance] = reactExports.useState(0);
  const defaultTemplates = reactExports.useMemo(() => [
    {
      template_id: "1001",
      name: "Black Ingredient",
      type: "Legendary",
      rarity: "Legendary",
      image: "",
      // Will be handled by NFTImage component fallback
      owned_count: 0,
      staked_count: 0,
      rewards_per_hour: { pxj: 50, wuf: 25 },
      estimated_value: 1e5,
      apr: 120,
      market_price: 2500,
      available_for_sale: 3
    },
    {
      template_id: "1002",
      name: "Tertiary Ingredient",
      type: "Epic",
      rarity: "Epic",
      image: "",
      // Will be handled by NFTImage component fallback
      owned_count: 0,
      staked_count: 0,
      rewards_per_hour: { pxj: 10, wuf: 5 },
      estimated_value: 25e3,
      apr: 80,
      market_price: 500,
      available_for_sale: 12
    },
    {
      template_id: "1003",
      name: "Secondary Ingredient",
      type: "Rare",
      rarity: "Rare",
      image: "",
      // Will be handled by NFTImage component fallback
      owned_count: 0,
      staked_count: 0,
      rewards_per_hour: { pxj: 2, wuf: 1 },
      estimated_value: 5e3,
      apr: 40,
      market_price: 100,
      available_for_sale: 25
    },
    {
      template_id: "1004",
      name: "Primary Ingredient",
      type: "Common",
      rarity: "Common",
      image: "",
      // Will be handled by NFTImage component fallback
      owned_count: 0,
      staked_count: 0,
      rewards_per_hour: { pxj: 0.1, wuf: 0.05 },
      estimated_value: 1e3,
      apr: 10,
      market_price: 25,
      available_for_sale: 50
    }
  ], []);
  const fetchNFTTemplates = reactExports.useCallback(async () => {
    setNftLoading(true);
    try {
      if (!session) {
        setNftTemplates(defaultTemplates);
        setNftLoading(false);
        return;
      }
      try {
        const { apiService: apiService2 } = await __vitePreload(async () => {
          const { apiService: apiService22 } = await Promise.resolve().then(() => api);
          return { apiService: apiService22 };
        }, true ? void 0 : void 0);
        const templatesResponse = await apiService2.fetchWithRetry(
          `${apiService2.atomicAssetsAPI}/atomicassets/v1/templates?collection_name=pixeljourney&schema_name=ingredients&page=1&limit=100&order=desc&sort=created`
        );
        if (!templatesResponse.ok) {
          throw new Error("AtomicAssets API failed");
        }
        const templatesData = await templatesResponse.json();
        const templateIds = templatesData.data.slice(0, 10).map((t) => t.template_id);
        const countsResult = await apiService2.getAssetCountsBatch(templateIds, session.actor.toString());
        const templates2 = await Promise.all(
          templatesData.data.slice(0, 10).map(async (template) => {
            try {
              const owned_count = countsResult.data[template.template_id] || 0;
              let staked_count = 0;
              try {
                const stakedResponse = await fetch("https://wax.greymass.com/v1/chain/get_table_rows", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify({
                    json: true,
                    code: "farms.waxdao",
                    scope: "farms.waxdao",
                    table: "stakers",
                    lower_bound: WharfKitService.safeGetActor(session),
                    upper_bound: WharfKitService.safeGetActor(session),
                    limit: 1
                  })
                });
                if (stakedResponse.ok) {
                  const stakedData = await stakedResponse.json();
                  const userStakeData = stakedData.rows.find((row) => row.user === session.actor.toString());
                  const stakedAssets = userStakeData?.staked_assets || [];
                  staked_count = stakedAssets.length;
                }
              } catch (error) {
                log.warn("Failed to fetch staked count for template", "Staking", { templateId: template.template_id, error });
              }
              const rarity = String(template.immutable_data?.rarity || "Common");
              let baseReward = 0.1;
              let apr = 5;
              switch (rarity.toLowerCase()) {
                case "legendary":
                  baseReward = 50;
                  apr = 120;
                  break;
                case "epic":
                  baseReward = 10;
                  apr = 80;
                  break;
                case "rare":
                  baseReward = 2;
                  apr = 40;
                  break;
                case "uncommon":
                  baseReward = 0.5;
                  apr = 20;
                  break;
                default:
                  baseReward = 0.1;
                  apr = 10;
              }
              return {
                template_id: template.template_id,
                name: template.immutable_data?.name || `Template ${template.template_id}`,
                type: template.immutable_data?.type || rarity,
                rarity,
                image: template.immutable_data?.img ? `https://ipfs.io/ipfs/${template.immutable_data.img}` : "",
                // Will be handled by NFTImage component fallback
                owned_count,
                staked_count,
                rewards_per_hour: {
                  pxj: baseReward,
                  wuf: baseReward * 0.5
                },
                estimated_value: await getTemplateEstimatedValue(template.template_id, rarity),
                apr,
                market_price: await getTemplateMarketPrice(template.template_id),
                available_for_sale: Math.floor(Math.random() * 20) + 1
              };
            } catch (error) {
              log.error("Error processing template", "Staking", error);
              return null;
            }
          })
        );
        const validTemplates = templates2.filter((t) => t !== null);
        setNftTemplates(validTemplates.length > 0 ? validTemplates : defaultTemplates);
        if (countsResult.errors.length > 0) {
          log.warn("Some template counts could not be fetched", "Staking", { errors: countsResult.errors });
        }
      } catch (apiError) {
        log.warn("API fetch failed, using default templates", "Staking", apiError);
        setNftTemplates(defaultTemplates);
      }
    } catch (error) {
      log.error("Failed to fetch NFT templates", "Staking", error);
      setNftTemplates(defaultTemplates);
    } finally {
      setNftLoading(false);
    }
  }, [session, setNftLoading, setNftTemplates, defaultTemplates]);
  const fetchRewards = reactExports.useCallback(async () => {
    if (!session) return;
    try {
      const stakingInfo = await stakingService.getStakingInfo(session.actor.toString());
      const rewardsData = stakingInfo.pending_rewards.reduce((acc, reward) => {
        if (reward.token === "PXJ") {
          acc.pxj = reward.amount;
        } else if (reward.token === "WUF") {
          acc.wuf = reward.amount;
        }
        return acc;
      }, { pxj: 0, wuf: 0 });
      setRewards(rewardsData);
      setTotalStakingPower(stakingInfo.total_staking_power);
      const updatedTemplates = nftTemplates.map((template) => {
        const stakedNfts = stakingInfo.staked_nfts.filter(
          (nft) => nft.template_id === template.template_id
        );
        return {
          ...template,
          staked_count: stakedNfts.length,
          rewards_per_hour: stakedNfts.length > 0 ? stakedNfts[0].rewards_per_hour : template.rewards_per_hour
        };
      });
      setNftTemplates(updatedTemplates);
    } catch (error) {
      log.error("Failed to fetch rewards", "Staking", error);
      const now = Date.now();
      const lastClaimTime = localStorage.getItem(`lastClaimTime_${WharfKitService.safeGetActor(session)}`) || now.toString();
      const elapsedSeconds = (now - parseInt(lastClaimTime)) / 1e3;
      const elapsedHours = elapsedSeconds / 3600;
      const calculatedRewards = nftTemplates.reduce((acc, template) => {
        const stakedPxjRewards = template.staked_count * template.rewards_per_hour.pxj * Math.floor(elapsedHours);
        const stakedWufRewards = template.staked_count * template.rewards_per_hour.wuf * Math.floor(elapsedHours);
        return {
          pxj: acc.pxj + stakedPxjRewards,
          wuf: acc.wuf + stakedWufRewards
        };
      }, { pxj: 0, wuf: 0 });
      setRewards(calculatedRewards);
    }
  }, [session, nftTemplates, setRewards, setTotalStakingPower, setNftTemplates]);
  const fetchTokenStakingData = reactExports.useCallback(async () => {
    if (!session) return;
    setTokenLoading(true);
    try {
      const farmInfo = await stakingService.getTokenFarmInfo("pxjfarm1");
      setTokenFarmInfo(farmInfo);
      const userStakeInfo = await stakingService.getTokenStakingInfo(session.actor.toString(), "pxjfarm1");
      setTokenStakeInfo(userStakeInfo);
      const balanceResponse = await fetch("https://wax.greymass.com/v1/chain/get_currency_balance", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          code: "pixeljourney",
          account: session.actor.toString(),
          symbol: "PXJ"
        })
      });
      if (balanceResponse.ok) {
        const balanceData = await balanceResponse.json();
        const balance = balanceData.length > 0 ? parseFloat(balanceData[0].split(" ")[0]) : 0;
        setUserPxjBalance(balance);
      }
    } catch (error) {
      log.error("Failed to fetch token staking data", "Staking", error);
    } finally {
      setTokenLoading(false);
    }
  }, [session, setTokenLoading, setTokenFarmInfo, setTokenStakeInfo, setUserPxjBalance]);
  const openTokenStakingModal = (action) => {
    setTokenStakingAction(action);
    setTokenStakingModalOpen(true);
  };
  const closeTokenStakingModal = () => {
    setTokenStakingModalOpen(false);
  };
  const claimRewards = async () => {
    if (!session) {
      showError("Error", "Please connect your wallet first");
      return;
    }
    if (rewards.pxj === 0 && rewards.wuf === 0) {
      showError("Error", "No rewards available to claim");
      return;
    }
    setLoading(true);
    try {
      const result = await stakingService.claimAllRewards(session, "pixeljourney");
      if (result.success) {
        const claimedAmount = `PXJ: ${rewards.pxj.toFixed(1)} | WUF: ${rewards.wuf.toFixed(1)}`;
        showSuccess("Success", `Rewards claimed successfully! ${claimedAmount}`);
        setRewards({ pxj: 0, wuf: 0 });
        await fetchRewards();
        const now = Date.now();
        localStorage.setItem(`lastClaimTime_${WharfKitService.safeGetActor(session)}`, now.toString());
      } else {
        showError("Error", result.error || "Failed to claim rewards");
      }
    } catch (error) {
      log.error("Failed to claim rewards", "Staking", error);
      showError("Error", "Failed to claim rewards. Please try again.");
    } finally {
      setLoading(false);
    }
  };
  const openNFTStakingModal = (template) => {
    setSelectedTemplate(template);
    setStakingModalOpen(true);
  };
  const closeNFTStakingModal = () => {
    setStakingModalOpen(false);
    setSelectedTemplate(null);
  };
  const openQuickBuyModal = (template) => {
    setSelectedBuyTemplate(template);
    setQuickBuyModalOpen(true);
  };
  const closeQuickBuyModal = () => {
    setQuickBuyModalOpen(false);
    setSelectedBuyTemplate(null);
  };
  const refreshAllData = async () => {
    setLoading(true);
    await Promise.all([
      fetchNFTTemplates(),
      fetchRewards(),
      fetchTokenStakingData()
    ]);
    setLoading(false);
  };
  const getRarityColor = (rarity) => {
    switch (rarity.toLowerCase()) {
      case "legendary":
        return "#f59e0b";
      case "epic":
        return "#8b5cf6";
      case "rare":
        return "#3b82f6";
      case "uncommon":
        return "#10b981";
      default:
        return "#6b7280";
    }
  };
  reactExports.useEffect(() => {
    fetchNFTTemplates();
    if (session) {
      fetchRewards();
      fetchTokenStakingData();
    }
  }, [session, fetchNFTTemplates, fetchRewards, fetchTokenStakingData]);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if (session) {
        fetchRewards();
        fetchTokenStakingData();
      }
    }, 3e4);
    return () => clearInterval(interval);
  }, [session, nftTemplates, fetchRewards, fetchTokenStakingData]);
  reactExports.useEffect(() => {
    const totalPower = nftTemplates.reduce(
      (sum, template) => sum + template.staked_count * (template.rewards_per_hour.pxj + template.rewards_per_hour.wuf),
      0
    );
    setTotalStakingPower(totalPower);
  }, [nftTemplates]);
  if (!isConnected) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "staking-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connect-wallet-prompt", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Connect Your Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your WAX wallet to access NFT staking features" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-primary", onClick: login, children: "Connect Wallet" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-staking-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Pixel Journey NFT Staking" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "section-description", children: "Stake your Pixel Journey ingredients to earn PXJ and WUF rewards" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-grid", children: defaultTemplates.map((template) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-image", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              NFTImage,
              {
                src: template.image,
                alt: template.name,
                width: 160,
                height: 160,
                fallbackText: template.name
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "rarity-badge",
                style: { backgroundColor: getRarityColor(template.rarity) },
                children: template.rarity
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-name", children: template.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-apr", children: [
                template.apr,
                "% APR"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-stats", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: template.rewards_per_hour.pxj }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "PXJ/hr" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: template.rewards_per_hour.wuf }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "WUF/hr" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "staking-status", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Connect wallet to view your assets" }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn btn-secondary",
                onClick: () => openQuickBuyModal(template),
                children: "Quick Buy"
              }
            ) })
          ] })
        ] }, template.template_id)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        QuickBuyModal,
        {
          template: selectedBuyTemplate,
          isOpen: quickBuyModalOpen,
          onClose: closeQuickBuyModal
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "staking-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "staking-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "NFT Staking Dashboard" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "refresh-btn",
          onClick: refreshAllData,
          disabled: loading,
          children: [
            loading ? "" : "",
            " Refresh"
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "staking-portal-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Advanced Staking Portal" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Access our comprehensive staking platform with advanced features, analytics, and enhanced rewards management." })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-features", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Advanced Analytics" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Enhanced Rewards" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "feature-icon", children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Advanced Tools" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "a",
        {
          href: "https://stake.pixeljourney.xyz",
          target: "_blank",
          rel: "noopener noreferrer",
          className: "btn btn-primary portal-btn",
          children: [
            "Launch Staking Portal",
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "external-icon", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" }) })
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-bar", style: { display: "none" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TokenImage, { src: "/img/tokens/pxj.png", alt: "PXJ" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "PXJ Balance: 0" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TokenImage, { src: "/img/tokens/wuf.png", alt: "WUF" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "WUF Balance: 0" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dashboard-row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rewards-section", id: "rewardsSection", style: { display: rewards.pxj > 0 || rewards.wuf > 0 ? "block" : "none" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rewards-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Claimable Rewards" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "simulation-toggle", onClick: () => setSimulationMode(!simulationMode), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `toggle ${simulationMode ? "active" : ""}` }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "claimableRewards", children: [
          rewards.pxj.toFixed(2),
          " PXJ + ",
          rewards.wuf.toFixed(2),
          " WUF"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "claim-btn",
            onClick: claimRewards,
            disabled: loading,
            children: loading ? "Claiming..." : "Claim All Rewards"
          }
        ),
        simulationMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "simulation-status", children: " SIMULATION MODE ACTIVE" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "quick-claim-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Quick Actions" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "quick-claim-btn",
            onClick: () => setCraftingModalOpen(true),
            children: "Open Crafting"
          }
        )
      ] })
    ] }),
    totalStakingPower > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "total-power", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Total Staking Power" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "power-value-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "power-value", children: totalStakingPower.toFixed(1) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "power-rate", children: "/hr" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Combined rewards per hour from all staked NFTs" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-staking-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-staking-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "PXJ Token Staking" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "section-description", children: "Stake your PXJ tokens in the pxjfarm1 to earn additional rewards" })
      ] }),
      tokenLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading token staking data..." })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-staking-content", children: [
        tokenFarmInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-farm-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "farm-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "farm-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TokenImage, { src: "/img/tokens/pxj.png", alt: "PXJ" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "farm-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: tokenFarmInfo.farm_name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "farm-description", children: "PXJ Token Farm" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "farm-stats", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Total Staked" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-value", children: [
                tokenFarmInfo.total_staked.toLocaleString(),
                " PXJ"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Vesting Period" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-value", children: [
                Math.floor(tokenFarmInfo.vesting_time / 86400),
                " days"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "Your Balance" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-value", children: [
                userPxjBalance.toLocaleString(),
                " PXJ"
              ] })
            ] })
          ] }),
          tokenStakeInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-position", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Your Staking Position" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "position-stats", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "position-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Staked:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "value", children: [
                  tokenStakeInfo.staked_amount.toLocaleString(),
                  " PXJ"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "position-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Pending Rewards:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: tokenStakeInfo.pending_rewards.length > 0 ? tokenStakeInfo.pending_rewards.map((r) => `${r.amount.toFixed(4)} ${r.token}`).join(", ") : "None" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "position-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Unlock Time:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: tokenStakeInfo.vesting_time > Date.now() / 1e3 ? `${Math.ceil((tokenStakeInfo.vesting_time - Date.now() / 1e3) / 86400)} days remaining` : "Available now" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn btn-primary",
                onClick: () => openTokenStakingModal("stake"),
                disabled: !isConnected || userPxjBalance <= 0,
                children: "Stake PXJ"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn btn-secondary",
                onClick: () => openTokenStakingModal("unstake"),
                disabled: !isConnected || !tokenStakeInfo || tokenStakeInfo.staked_amount <= 0,
                children: "Unstake PXJ"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn btn-accent",
                onClick: () => openTokenStakingModal("claim"),
                disabled: !isConnected || !tokenStakeInfo || tokenStakeInfo.pending_rewards.length === 0,
                children: "Claim Rewards"
              }
            )
          ] })
        ] }),
        !isConnected && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "connect-prompt", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Connect Your Wallet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your WAX wallet to view and manage your PXJ token staking" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-primary", onClick: login, children: "Connect Wallet" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-staking-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-staking-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Pixel Journey NFT Staking" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "section-description", children: "Stake your ingredients to earn PXJ and WUF rewards" })
      ] }),
      nftLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-state", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading NFT staking data..." })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-grid", children: nftTemplates.map((template) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "template-image",
            style: { backgroundImage: `url(${template.image})` },
            children: [
              template.owned_count > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-count", children: template.owned_count }),
              template.staked_count > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "staked-count", children: [
                "",
                template.staked_count
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "rarity-badge",
                  style: { backgroundColor: getRarityColor(template.rarity) },
                  children: template.rarity
                }
              ),
              !template.image.includes("placeholder") ? null : template.name
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-name", children: template.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-apr", children: [
              template.apr,
              "% APR"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "template-stats", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: template.rewards_per_hour.pxj }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "PXJ/hr" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: template.rewards_per_hour.wuf }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: "WUF/hr" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "staking-status", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Staked: ",
              template.staked_count,
              "/",
              template.owned_count
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "template-actions", children: template.owned_count > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn btn-primary",
              onClick: () => openNFTStakingModal(template),
              children: "Manage Staking"
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn btn-secondary",
              onClick: () => openQuickBuyModal(template),
              children: "Quick Buy"
            }
          ) })
        ] })
      ] }, template.template_id)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crafting-mechanics", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "PXJ Lockup & Crafting Mechanics" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mechanics-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mechanics-overview", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " PXJ Lockup System" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Lock your PXJ tokens to participate in advanced crafting and upgrade systems. Each month, we distribute additional NFT rewards to collectors based on their PXJ lockup value." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "leaderboard-info", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "leaderboard-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "leaderboard-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "leaderboard-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Monthly Leaderboard Rewards" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "leaderboard-details", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Entry Requirement:" }),
                " 25,000 PXJ locked per entry"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Rewards distributed based on upgraded ingredient lockup value" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: "https://lb.pixeljourney.xyz/",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: "btn btn-primary",
                  children: "View Leaderboard"
                }
              )
            ] })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crafting-process", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Ingredient Combination System" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "process-flow", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "process-step", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "step-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Primary Ingredients" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Common base materials that form the foundation of all crafting recipes" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "process-arrow", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "process-step", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "step-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Secondary Ingredients" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Rare catalysts that enhance and modify the properties of primary ingredients" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "process-arrow", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "process-step", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "step-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Tertiary Ingredients" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Epic components that unlock powerful abilities and unique traits" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "process-arrow", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "process-step", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "step-icon", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Black Ingredients" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Legendary materials that create the most powerful and sought-after items" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "learn-more-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "learn-more-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Want to Learn More?" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Dive deeper into the Pixel Journey ecosystem with our comprehensive documentation covering all aspects of crafting, staking, and gameplay mechanics." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "learn-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/learn", className: "btn-primary", children: "Visit Learn Page" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://docs.pixeljourney.xyz/season-1/recycling-and-crafting",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "btn-secondary",
                children: "Journey Docs"
              }
            )
          ] })
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NFTStakingModal,
      {
        isOpen: stakingModalOpen,
        onClose: closeNFTStakingModal,
        templateId: selectedTemplate?.template_id || "",
        templateName: selectedTemplate?.name || "",
        action: "stake",
        onSuccess: () => {
          fetchNFTTemplates();
          fetchRewards();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TokenStakingModal,
      {
        isOpen: tokenStakingModalOpen,
        onClose: closeTokenStakingModal,
        action: tokenStakingAction,
        farmName: "pxjfarm1",
        onSuccess: () => {
          fetchTokenStakingData();
          fetchRewards();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CraftingModal,
      {
        isOpen: craftingModalOpen,
        onClose: () => setCraftingModalOpen(false),
        ingredient: null
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      QuickBuyModal,
      {
        template: selectedBuyTemplate,
        isOpen: quickBuyModalOpen,
        onClose: closeQuickBuyModal
      }
    )
  ] });
};
class AttributeService {
  constructor() {
    __publicField(this, "baseUrl", "https://wax-api.hivebp.io/api");
  }
  /**
   * Fetch available attribute filters for a collection
   */
  async getAttributeFilters(contract, schema) {
    try {
      const url = new URL(`${this.baseUrl}/filter-attributes/${contract}`);
      if (schema) {
        url.searchParams.append("schema", schema);
      }
      const response = await fetch(url.toString());
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data;
    } catch (error) {
      log.error("Error fetching attribute filters from API, will use fallback", "AttributeService", error);
      return {};
    }
  }
  /**
   * Extract attribute filters from NFT data as fallback when API is unavailable
   */
  extractAttributesFromNFTs(nfts, schema) {
    const attributeMap = /* @__PURE__ */ new Map();
    const filteredNFTs = schema ? nfts.filter((nft) => nft.schema === schema) : nfts;
    filteredNFTs.forEach((nft) => {
      if (nft.traits) {
        Object.entries(nft.traits).forEach(([key, value]) => {
          if (value !== null && value !== void 0) {
            if (!attributeMap.has(key)) {
              attributeMap.set(key, /* @__PURE__ */ new Map());
            }
            const valueMap = attributeMap.get(key);
            const stringValue = String(value);
            const currentCount = valueMap.get(stringValue) || 0;
            valueMap.set(stringValue, currentCount + 1);
          }
        });
      }
    });
    const result = {};
    attributeMap.forEach((valueMap, attributeName) => {
      const values = [];
      valueMap.forEach((count, value) => {
        values.push({
          value,
          numMinted: count,
          maxSupply: count
          // Use count as approximation since we don't have max supply data
        });
      });
      values.sort((a, b) => b.numMinted - a.numMinted);
      result[attributeName] = { values };
    });
    return result;
  }
  /**
   * Format attributes for API query string
   * @param filters Object with attribute name as key and selected values as array
   * @returns Formatted attribute string for API
   */
  formatAttributesForQuery(filters) {
    const attributePairs = [];
    Object.entries(filters).forEach(([attributeName, values]) => {
      values.forEach((value) => {
        attributePairs.push(`${attributeName}:${encodeURIComponent(value)}`);
      });
    });
    return attributePairs.join("&");
  }
  /**
   * Parse attribute query string back to object
   * @param attributeString Formatted attribute string from API
   * @returns Object with attribute filters
   */
  parseAttributeQuery(attributeString) {
    const filters = {};
    if (!attributeString) return filters;
    const pairs = attributeString.split("&");
    pairs.forEach((pair) => {
      const [attributeName, value] = pair.split(":");
      if (attributeName && value) {
        const decodedValue = decodeURIComponent(value);
        if (!filters[attributeName]) {
          filters[attributeName] = [];
        }
        filters[attributeName].push(decodedValue);
      }
    });
    return filters;
  }
}
const attributeService = new AttributeService();
const TokenizeFromInventoryModal = ({
  isOpen,
  onClose,
  onSuccess
}) => {
  const { account } = useWallet();
  const { showSuccess, showError } = useNotifications();
  const [userAssets, setUserAssets] = reactExports.useState([]);
  const [feeTokens, setFeeTokens] = reactExports.useState([]);
  const [selectedAssets, setSelectedAssets] = reactExports.useState(/* @__PURE__ */ new Set());
  const [selectedFeeToken, setSelectedFeeToken] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [totalAssets, setTotalAssets] = reactExports.useState(0);
  const assetsPerPage = 12;
  const loadUserAssets = reactExports.useCallback(async (page = 1) => {
    if (!account) return;
    setLoading(true);
    setError("");
    try {
      const offset = (page - 1) * assetsPerPage;
      const assets = await rwaxService.getUserPixalAssets(account, assetsPerPage, offset);
      setUserAssets(assets);
      setTotalAssets(assets.length);
    } catch (error2) {
      log.error("Failed to load user Pixal assets", "TokenizeFromInventoryModal.loadUserAssets", error2, { account, page });
      setError("Failed to load your Pixal assets. Please try again.");
      showError("Failed to load assets");
    } finally {
      setLoading(false);
    }
  }, [account, assetsPerPage, showError]);
  const loadFeeTokens = reactExports.useCallback(async () => {
    try {
      const tokens = await rwaxService.getFeeTokens();
      setFeeTokens(tokens);
    } catch (error2) {
      log.error("Failed to load fee tokens", "TokenizeFromInventoryModal.loadFeeTokens", error2);
      showError("Failed to load fee tokens");
    }
  }, [showError]);
  reactExports.useEffect(() => {
    if (isOpen && account) {
      loadUserAssets(currentPage);
      loadFeeTokens();
    }
  }, [isOpen, account, currentPage, loadUserAssets, loadFeeTokens]);
  const toggleAssetSelection = (assetId) => {
    const newSelection = new Set(selectedAssets);
    if (newSelection.has(assetId)) {
      newSelection.delete(assetId);
    } else {
      newSelection.add(assetId);
    }
    setSelectedAssets(newSelection);
  };
  const selectAllAssets = () => {
    const allAssetIds = new Set(userAssets.map((asset) => asset.assetId.toString()));
    setSelectedAssets(allAssetIds);
  };
  const clearAllSelections = () => {
    setSelectedAssets(/* @__PURE__ */ new Set());
  };
  const executeTokenization = async () => {
    if (!account || selectedAssets.size === 0 || !selectedFeeToken) {
      showError("Please select assets and a fee token");
      return;
    }
    setLoading(true);
    try {
      const assetIds = Array.from(selectedAssets);
      const transaction = await rwaxService.executeTokenization(assetIds, selectedFeeToken);
      showSuccess(`Tokenization transaction prepared for ${assetIds.length} asset(s)`);
      log.info("Tokenization transaction prepared", "TokenizeFromInventoryModal.executeTokenization", { assetIds, feeToken: selectedFeeToken.symbol, transaction });
      setSelectedAssets(/* @__PURE__ */ new Set());
      setSelectedFeeToken(null);
      onClose();
      if (onSuccess) {
        onSuccess();
      }
    } catch (error2) {
      log.error("Tokenization execution failed", "TokenizeFromInventoryModal.executeTokenization", error2, { assetIds: Array.from(selectedAssets), feeToken: selectedFeeToken?.symbol });
      showError("Tokenization failed. Please try again.");
    } finally {
      setLoading(false);
    }
  };
  const handlePageChange = (page) => {
    setCurrentPage(page);
    setSelectedAssets(/* @__PURE__ */ new Set());
  };
  if (!isOpen) return null;
  const totalPages = Math.ceil(totalAssets / assetsPerPage);
  const selectedCount = selectedAssets.size;
  return reactDomExports.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tokenize-inventory-modal", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Tokenize from Inventory" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-button", onClick: onClose, children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selection-controls", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selection-info", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            selectedCount,
            " asset",
            selectedCount !== 1 ? "s" : "",
            " selected"
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selection-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "select-all-btn",
                onClick: selectAllAssets,
                disabled: loading,
                children: "Select All on Page"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "clear-all-btn",
                onClick: clearAllSelections,
                disabled: loading || selectedCount === 0,
                children: "Clear All"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "assets-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Your Pixal Assets" }),
          loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-spinner", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading your assets..." })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "assets-grid", children: userAssets.map((asset) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `asset-card ${selectedAssets.has(asset.assetId.toString()) ? "selected" : ""}`,
              onClick: () => toggleAssetSelection(asset.assetId.toString()),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-image-container", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    MediaRenderer,
                    {
                      imageUrl: asset.image,
                      alt: asset.name,
                      className: "asset-image"
                    }
                  ),
                  selectedAssets.has(asset.assetId.toString()) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selection-indicator", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" }) }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "asset-name", children: asset.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-id", children: [
                    "#",
                    asset.assetId.toString()
                  ] })
                ] })
              ]
            },
            asset.assetId
          )) }),
          totalPages > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pagination", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "pagination-btn",
                onClick: () => handlePageChange(currentPage - 1),
                disabled: currentPage === 1 || loading,
                children: "Previous"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "pagination-info", children: [
              "Page ",
              currentPage,
              " of ",
              totalPages
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "pagination-btn",
                onClick: () => handlePageChange(currentPage + 1),
                disabled: currentPage === totalPages || loading,
                children: "Next"
              }
            )
          ] })
        ] }),
        selectedCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fee-selection", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Select Fee Token" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fee-tokens-grid", children: feeTokens.map((token, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `fee-option ${selectedFeeToken === token ? "selected" : ""}`,
              onClick: () => setSelectedFeeToken(token),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fee-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fee-amount", children: token.fee }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "fee-contract", children: [
                    "(",
                    token.contract,
                    ")"
                  ] })
                ] }),
                token.wax_value && token.symbol !== "WAX" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-equivalent", children: [
                  " ",
                  parseFloat(token.wax_value).toFixed(4),
                  " WAX"
                ] })
              ]
            },
            index
          )) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "cancel-button", onClick: onClose, disabled: loading, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "tokenize-button",
            onClick: executeTokenization,
            disabled: loading || selectedCount === 0 || !selectedFeeToken,
            children: loading ? "Processing..." : `Tokenize ${selectedCount} Asset${selectedCount !== 1 ? "s" : ""}`
          }
        )
      ] })
    ] }) }),
    document.body
  );
};
const AssetDetailModal = ({
  asset,
  isOpen,
  onClose,
  onRedeem
}) => {
  const { account } = useWallet();
  const { showError } = useNotifications();
  const [feeTokens, setFeeTokens] = reactExports.useState([]);
  const [selectedFeeToken, setSelectedFeeToken] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(false);
  const [showRedeemSection, setShowRedeemSection] = reactExports.useState(false);
  const loadFeeTokens = async () => {
    try {
      const tokens = await rwaxService.getFeeTokens();
      setFeeTokens(tokens);
    } catch (error) {
      log.error("Failed to load fee tokens", "AssetDetailModal.loadFeeTokens", error);
      showError("Failed to load fee tokens");
    }
  };
  reactExports.useEffect(() => {
    if (isOpen && asset) {
      loadFeeTokens();
    }
  }, [isOpen, asset, loadFeeTokens]);
  const handleRedeem = async () => {
    if (!asset || !selectedFeeToken || !account) {
      showError("Please select a fee token");
      return;
    }
    setLoading(true);
    try {
      if (onRedeem) {
        await onRedeem(asset, selectedFeeToken);
      }
      onClose();
    } catch (error) {
      log.error("Asset redemption failed", "AssetDetailModal.handleRedeem", error, { assetId: asset?.assetId, feeToken: selectedFeeToken?.symbol });
      showError("Redemption failed. Please try again.");
    } finally {
      setLoading(false);
    }
  };
  if (!isOpen || !asset) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-detail-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Asset Details" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-button", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-main-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "asset-image-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          MediaRenderer,
          {
            imageUrl: asset.image,
            alt: asset.name,
            className: "asset-image"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-info-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "asset-name", children: asset.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-metadata", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Asset ID:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: asset.assetId })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Collection:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: asset.collection?.displayName || asset.collection?.collectionName })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Schema:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: asset.schema })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Mint #:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: asset.mint })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Template ID:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: asset.template?.templateId })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "WPIXAL Amount:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "value highlight", children: [
                asset.rwax.redeemAmount.toFixed(8),
                " WPIXAL"
              ] })
            ] }),
            asset.rarityScore && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Rarity Score:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value highlight", children: asset.rarityScore.toFixed(2) })
            ] }),
            asset.attributesFloor && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Attributes Floor:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "value highlight", children: [
                asset.attributesFloor.toFixed(8),
                " WPIXAL"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Contract:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: asset.contract })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "metadata-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Owner:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: asset.owner })
            ] })
          ] }),
          asset.immutableData && asset.immutableData.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-attributes", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "NFT Traits" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attributes-grid", children: asset.immutableData.filter(({ key, value }) => {
              const excludeKeys = ["image", "img", "video", "audio", "model", "description", "name"];
              return !excludeKeys.includes(key.toLowerCase()) && value && value[1] !== null && value[1] !== void 0 && value[1] !== "";
            }).map(({ key, value }) => {
              const formattedKey = key.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
              const displayValue = Array.isArray(value) ? value[1] : value;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "trait-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "trait-label", children: formattedKey }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "trait-value", children: String(displayValue) })
              ] }, key);
            }) }),
            (() => {
              const descriptionItem = asset.immutableData.find((item) => item.key.toLowerCase() === "description");
              const description = descriptionItem ? Array.isArray(descriptionItem.value) ? descriptionItem.value[1] : descriptionItem.value : null;
              return description && String(description).trim() ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-description", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Description" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: String(description) })
              ] }) : null;
            })()
          ] })
        ] })
      ] }),
      account && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "redemption-section", children: !showRedeemSection ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "show-redeem-button",
          onClick: () => setShowRedeemSection(true),
          children: "Redeem this Asset"
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "redeem-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Redeem Asset" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "redeem-description", children: [
          "Redeem this tokenized asset by paying ",
          asset.rwax.redeemAmount.toFixed(8),
          " WPIXAL plus a fee."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fee-selection", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Select Fee Token:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fee-options", children: feeTokens.map((token, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `fee-option ${selectedFeeToken === token ? "selected" : ""}`,
              onClick: () => setSelectedFeeToken(token),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fee-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fee-amount", children: token.fee }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "fee-contract", children: [
                    "(",
                    token.contract,
                    ")"
                  ] })
                ] }),
                token.wax_value && token.symbol !== "WAX" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-equivalent", children: [
                  " ",
                  parseFloat(token.wax_value).toFixed(4),
                  " WAX"
                ] })
              ]
            },
            index
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "redeem-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "cancel-redeem-button",
              onClick: () => setShowRedeemSection(false),
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "confirm-redeem-button",
              onClick: handleRedeem,
              disabled: !selectedFeeToken || loading,
              children: loading ? "Processing..." : "Confirm Redemption"
            }
          )
        ] })
      ] }) }),
      !account && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-connect-message", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Connect your wallet to redeem this asset" }) })
    ] })
  ] }) });
};
const RWAXLiveTransactions = ({
  limit = 12,
  refreshInterval = 3e4
}) => {
  const [transactions, setTransactions] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const [lastUpdate, setLastUpdate] = reactExports.useState(null);
  const [page, setPage] = reactExports.useState(1);
  const [hasMore, setHasMore] = reactExports.useState(true);
  const [loadingMore, setLoadingMore] = reactExports.useState(false);
  const fetchTransactions = reactExports.useCallback(async (pageNum = 1, append = false) => {
    try {
      if (!append) {
        setError(null);
        setLoading(true);
      } else {
        setLoadingMore(true);
      }
      const response = await apiService.getRWAXTransfers({
        limit,
        page: pageNum,
        order: "desc"
      });
      if (response.success) {
        const newTransactions = response.data;
        if (append) {
          setTransactions((prev) => [...prev, ...newTransactions]);
        } else {
          setTransactions(newTransactions);
        }
        setHasMore(newTransactions.length === limit);
        setLastUpdate(/* @__PURE__ */ new Date());
      } else {
        throw new Error("Failed to fetch RWAX transactions");
      }
    } catch (err) {
      log.error("Error fetching RWAX transactions", "RWAXLiveTransactions", err);
      if (!append) {
        setError("Failed to load RWAX transactions");
      }
    } finally {
      setLoading(false);
      setLoadingMore(false);
    }
  }, [limit]);
  const loadMore = async () => {
    if (!loadingMore && hasMore) {
      const nextPage = page + 1;
      setPage(nextPage);
      await fetchTransactions(nextPage, true);
    }
  };
  reactExports.useEffect(() => {
    fetchTransactions();
    const interval = setInterval(() => {
      fetchTransactions(1, false);
      setPage(1);
    }, refreshInterval);
    return () => clearInterval(interval);
  }, [limit, refreshInterval, fetchTransactions]);
  const formatTime = (timestamp) => {
    try {
      const date = new Date(timestamp);
      if (isNaN(date.getTime())) {
        return "Unknown";
      }
      const now = /* @__PURE__ */ new Date();
      const diffMs = now.getTime() - date.getTime();
      const diffMins = Math.floor(diffMs / 6e4);
      if (diffMins < 0) return "Just now";
      if (diffMins < 1) return "Just now";
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
      return `${Math.floor(diffMins / 1440)}d ago`;
    } catch (error2) {
      return "Unknown";
    }
  };
  const getTransactionIcon = (type) => {
    return type === "tokenization" ? "" : "";
  };
  const getTransactionLabel = (type) => {
    return type === "tokenization" ? "Tokenized" : "Redeemed";
  };
  const processImageUrl = (imageUrl) => {
    if (!imageUrl) return "/placeholder-nft.png";
    if (imageUrl.startsWith("Qm") || imageUrl.startsWith("baf")) {
      return `https://ipfs.io/ipfs/${imageUrl}`;
    }
    if (imageUrl.startsWith("/")) {
      return `https://ipfs.io/ipfs${imageUrl}`;
    }
    return imageUrl;
  };
  if (loading && transactions.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-live-transactions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-live-transactions-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Live RWAX Transactions" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transactions-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading RWAX transactions..." }) })
    ] });
  }
  if (error && transactions.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-live-transactions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-live-transactions-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Live RWAX Transactions" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => fetchTransactions(), className: "refresh-button", children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transactions-error", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => fetchTransactions(), className: "retry-button", children: "Try Again" })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-live-transactions", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-live-transactions-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Live RWAX Transactions" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-actions", children: [
        lastUpdate && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "last-update", children: [
          "Updated ",
          formatTime(lastUpdate.toISOString())
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => {
              fetchTransactions(1, false);
              setPage(1);
            },
            className: "refresh-button",
            disabled: loading,
            children: loading ? "" : ""
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rwax-transactions-grid", children: transactions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-transactions", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No recent RWAX transactions found" }) }) : transactions.map((tx, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-transaction-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-type", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "transaction-icon", children: getTransactionIcon(tx.type) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `transaction-label ${tx.type}`, children: getTransactionLabel(tx.type) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "transaction-time", children: formatTime(tx.created_at_time) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-assets", children: [
        tx.assets.slice(0, 1).map((asset) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-preview", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: processImageUrl(asset.data?.img),
              alt: asset.name || "Unknown Asset",
              className: "asset-image"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "asset-name", children: asset.name || "Unknown Asset" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "asset-mint", children: [
              "#",
              asset.template_mint || asset.asset_id || "N/A"
            ] })
          ] })
        ] }, asset.asset_id)),
        tx.assets.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "additional-assets", children: [
          "+",
          tx.assets.length - 1,
          " more"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-details", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-accounts", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "account from", children: [
            "From: ",
            tx.sender_name.length > 8 ? `${tx.sender_name.slice(0, 6)}...` : tx.sender_name
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "account to", children: [
            "To: ",
            tx.recipient_name.length > 8 ? `${tx.recipient_name.slice(0, 6)}...` : tx.recipient_name
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transaction-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "view-tx-button",
            onClick: () => window.open(`https://waxblock.io/transaction/${tx.txid}`, "_blank"),
            title: "View on WAX Block Explorer",
            children: ""
          }
        ) })
      ] })
    ] }, `${tx.txid}-${tx.transfer_id}-${index}`)) }),
    hasMore && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: loadMore,
        className: "load-more-button",
        disabled: loadingMore,
        children: loadingMore ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner small" }),
          "Loading more..."
        ] }) : "Load More Transactions"
      }
    ) })
  ] });
};
const PIXAL_ATTRIBUTES = {
  "Background": [
    "Nefty Spot",
    "Blue Sky",
    "Forest",
    "Desert",
    "Ocean",
    "Mountain",
    "City",
    "Space",
    "Sunset",
    "Rainbow"
  ],
  "Body": [
    "Pink-Blue Overalls",
    "Red Shirt",
    "Blue Hoodie",
    "Green Jacket",
    "Yellow Dress",
    "Purple Suit",
    "Orange Tank",
    "Black Tee",
    "White Polo",
    "Gray Sweater"
  ],
  "Eyes": [
    "Kawaii Green",
    "Brown",
    "Blue",
    "Hazel",
    "Gray",
    "Amber",
    "Violet",
    "Red",
    "Black",
    "Gold"
  ],
  "Head": [
    "Grey",
    "Black Hair",
    "Brown Hair",
    "Blonde Hair",
    "Red Hair",
    "Blue Hair",
    "Green Hair",
    "Purple Hair",
    "Bald",
    "Hat"
  ]
};
const PixalAttributeFilter = ({
  onFiltersChange,
  initialFilters = {}
}) => {
  const [filterState, setFilterState] = reactExports.useState({});
  reactExports.useEffect(() => {
    const newFilterState = {};
    Object.keys(PIXAL_ATTRIBUTES).forEach((attributeName) => {
      newFilterState[attributeName] = {
        isExpanded: false,
        selectedValues: new Set(initialFilters[attributeName] || []),
        searchTerm: ""
      };
    });
    setFilterState(newFilterState);
  }, []);
  const handleValueToggle = reactExports.useCallback((attributeName, value) => {
    setFilterState((prev) => {
      const newState = { ...prev };
      if (!newState[attributeName]) {
        newState[attributeName] = {
          isExpanded: false,
          selectedValues: /* @__PURE__ */ new Set(),
          searchTerm: ""
        };
      }
      const selectedValues = new Set(newState[attributeName].selectedValues);
      if (selectedValues.has(value)) {
        selectedValues.delete(value);
      } else {
        selectedValues.add(value);
      }
      newState[attributeName] = {
        ...newState[attributeName],
        selectedValues
      };
      return newState;
    });
  }, []);
  const handleAttributeToggle = reactExports.useCallback((attributeName) => {
    setFilterState((prev) => ({
      ...prev,
      [attributeName]: {
        ...prev[attributeName],
        isExpanded: !prev[attributeName]?.isExpanded
      }
    }));
  }, []);
  const handleSearchChange = reactExports.useCallback((attributeName, searchTerm) => {
    setFilterState((prev) => ({
      ...prev,
      [attributeName]: {
        ...prev[attributeName],
        searchTerm
      }
    }));
  }, []);
  const clearAllFilters = reactExports.useCallback(() => {
    const clearedState = {};
    Object.keys(PIXAL_ATTRIBUTES).forEach((attributeName) => {
      clearedState[attributeName] = {
        isExpanded: false,
        selectedValues: /* @__PURE__ */ new Set(),
        searchTerm: ""
      };
    });
    setFilterState(clearedState);
  }, []);
  reactExports.useEffect(() => {
    const filters = {};
    Object.entries(filterState).forEach(([attributeName, state]) => {
      if (state.selectedValues.size > 0) {
        filters[attributeName] = Array.from(state.selectedValues);
      }
    });
    onFiltersChange(filters);
  }, [filterState, onFiltersChange]);
  const getFilteredValues = (attributeName) => {
    const searchTerm = filterState[attributeName]?.searchTerm?.toLowerCase() || "";
    const values = PIXAL_ATTRIBUTES[attributeName] || [];
    if (!searchTerm) return values;
    return values.filter(
      (value) => value.toLowerCase().includes(searchTerm)
    );
  };
  const totalSelected = Object.values(filterState).reduce(
    (total, state) => total + state.selectedValues.size,
    0
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute-filter-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Pixal Traits" }),
      totalSelected > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "clear-all-button", onClick: clearAllFilters, children: [
        "Clear All (",
        totalSelected,
        ")"
      ] })
    ] }),
    Object.entries(PIXAL_ATTRIBUTES).map(([attributeName]) => {
      const state = filterState[attributeName];
      const filteredValues = getFilteredValues(attributeName);
      const selectedCount = state?.selectedValues.size || 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "filter-group-header",
            onClick: () => handleAttributeToggle(attributeName),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attribute-name", children: [
                attributeName,
                selectedCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "selected-count", children: selectedCount })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `expand-icon ${state?.isExpanded ? "expanded" : ""}`, children: "" })
            ]
          }
        ),
        state?.isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-group-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: `Search ${attributeName.toLowerCase()}...`,
              value: state.searchTerm,
              onChange: (e) => handleSearchChange(attributeName, e.target.value),
              className: "attribute-search"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attribute-values", children: filteredValues.length > 0 ? filteredValues.map((value) => {
            const isSelected = state.selectedValues.has(value);
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `attribute-value-item ${isSelected ? "selected" : ""}`,
                onClick: () => handleValueToggle(attributeName, value),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "attribute-value-text", children: value })
              },
              value
            );
          }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "no-results", children: [
            "No ",
            attributeName.toLowerCase(),
            ' found matching "',
            state.searchTerm,
            '"'
          ] }) })
        ] })
      ] }, attributeName);
    })
  ] });
};
const RWax = () => {
  const navigate = useNavigate();
  const { account, session } = useWallet();
  const { showSuccess, showError } = useNotifications();
  const [activeTab, setActiveTab] = reactExports.useState("redeem");
  const [tokenizedAssets, setTokenizedAssets] = reactExports.useState([]);
  const [feeTokens, setFeeTokens] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [showTokenizeModal, setShowTokenizeModal] = reactExports.useState(false);
  const [showRedeemModal, setShowRedeemModal] = reactExports.useState(false);
  const [showInventoryModal, setShowInventoryModal] = reactExports.useState(false);
  const [showAssetDetailModal, setShowAssetDetailModal] = reactExports.useState(false);
  const [showWaxRedeemModal, setShowWaxRedeemModal] = reactExports.useState(false);
  const [selectedAsset, setSelectedAsset] = reactExports.useState(null);
  const [selectedDetailAsset, setSelectedDetailAsset] = reactExports.useState(null);
  const [selectedFeeToken, setSelectedFeeToken] = reactExports.useState(null);
  const [waxRedeemStep, setWaxRedeemStep] = reactExports.useState("confirm");
  const [waxAmount, setWaxAmount] = reactExports.useState("");
  const [selectedAssets, setSelectedAssets] = reactExports.useState(/* @__PURE__ */ new Set());
  const [showImageZoom, setShowImageZoom] = reactExports.useState(false);
  const [zoomedImage, setZoomedImage] = reactExports.useState(null);
  const [showWpixalPurchaseModal, setShowWpixalPurchaseModal] = reactExports.useState(false);
  const [wpixalToPurchase, setWpixalToPurchase] = reactExports.useState(0);
  const [wpixalPriceWAX, setWpixalPriceWAX] = reactExports.useState(0);
  const [wpixalPriceUSD, setWpixalPriceUSD] = reactExports.useState(0);
  const [isFilterSidebarOpen, setIsFilterSidebarOpen] = reactExports.useState(false);
  const [priceRange, setPriceRange] = reactExports.useState({ min: "", max: "" });
  const [waxPriceUSD, setWaxPriceUSD] = reactExports.useState(0);
  const [showPriceAlertModal, setShowPriceAlertModal] = reactExports.useState(false);
  const [alertAsset] = reactExports.useState(null);
  const [alertPercentage, setAlertPercentage] = reactExports.useState(10);
  const [showShareModal, setShowShareModal] = reactExports.useState(false);
  const [shareAsset, setShareAsset] = reactExports.useState(null);
  const [showWpixalAlertModal, setShowWpixalAlertModal] = reactExports.useState(false);
  const [wpixalAlertPrice, setWpixalAlertPrice] = reactExports.useState("");
  const [waxBalance, setWaxBalance] = reactExports.useState("0.0000 WAX");
  const [assetsPage, setAssetsPage] = reactExports.useState(1);
  const [hasMoreAssets, setHasMoreAssets] = reactExports.useState(true);
  const [loadingMoreAssets, setLoadingMoreAssets] = reactExports.useState(false);
  const [sortBy, setSortBy] = reactExports.useState("rarity_score_desc");
  const [attributeFilters, setAttributeFilters] = reactExports.useState("");
  const [selectedAttributeFilters, setSelectedAttributeFilters] = reactExports.useState({});
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [watchlist, setWatchlist] = reactExports.useState(/* @__PURE__ */ new Set());
  const [priceAlerts, setPriceAlerts] = reactExports.useState(/* @__PURE__ */ new Map());
  const filteredAssets = reactExports.useMemo(() => {
    if (!searchTerm.trim()) {
      return tokenizedAssets;
    }
    const searchLower = searchTerm.toLowerCase();
    return tokenizedAssets.filter((asset) => {
      if (asset.name?.toLowerCase().includes(searchLower)) {
        return true;
      }
      if (asset.collection?.collectionName?.toLowerCase().includes(searchLower) || asset.collection?.displayName?.toLowerCase().includes(searchLower)) {
        return true;
      }
      if (asset.template?.templateId?.toString().includes(searchLower)) {
        return true;
      }
      if (asset.immutableData) {
        for (const attr of asset.immutableData) {
          if (attr.key?.toLowerCase().includes(searchLower) || attr.value?.[1]?.toString().toLowerCase().includes(searchLower)) {
            return true;
          }
        }
      }
      if (asset.mutableData) {
        for (const attr of asset.mutableData) {
          if (attr.key?.toLowerCase().includes(searchLower) || attr.value?.[1]?.toString().toLowerCase().includes(searchLower)) {
            return true;
          }
        }
      }
      return false;
    });
  }, [tokenizedAssets, searchTerm]);
  const loadTokenizedAssets = reactExports.useCallback(async (page = 1, append = false) => {
    log.debug("Loading tokenized assets", "RWax.loadTokenizedAssets", { page, append, sortBy, attributeFilters });
    try {
      if (!append) {
        setLoading(true);
        setError(null);
      } else {
        setLoadingMoreAssets(true);
      }
      const limit = 36;
      const offset = (page - 1) * limit;
      log.debug("Calling rwaxService.getTokenizedAssets", "RWax.loadTokenizedAssets", { limit, offset, sortBy, attributeFilters });
      const assets = await rwaxService.getTokenizedAssets(limit, offset, sortBy, attributeFilters);
      log.info("Received tokenized assets", "RWax.loadTokenizedAssets", { count: assets.length });
      if (append) {
        setTokenizedAssets((prev) => [...prev, ...assets]);
      } else {
        setTokenizedAssets(assets);
      }
      setHasMoreAssets(assets.length === limit);
    } catch (err) {
      log.error("Error loading tokenized assets", "RWax", err);
      if (!append) {
        setError("Failed to load tokenized assets. Please try again later.");
      }
    } finally {
      setLoading(false);
      setLoadingMoreAssets(false);
    }
  }, [sortBy, attributeFilters]);
  const loadMoreAssets = reactExports.useCallback(async () => {
    const nextPage = assetsPage + 1;
    await loadTokenizedAssets(nextPage, true);
    setAssetsPage(nextPage);
  }, [assetsPage, loadTokenizedAssets]);
  const handleSortChange = reactExports.useCallback((newSortBy) => {
    setSortBy(newSortBy);
    setAssetsPage(1);
  }, []);
  const handleAttributeFiltersChange = reactExports.useCallback((filters) => {
    setSelectedAttributeFilters(filters);
    const formattedFilters = attributeService.formatAttributesForQuery(filters);
    setAttributeFilters(formattedFilters);
    setAssetsPage(1);
  }, []);
  reactExports.useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (activeTab === "redeem") {
        loadTokenizedAssets(1, false);
      }
    }, 300);
    return () => clearTimeout(timeoutId);
  }, [sortBy, attributeFilters, activeTab]);
  const loadFeeTokens = reactExports.useCallback(async () => {
    try {
      const tokens = await rwaxService.getFeeTokens();
      setFeeTokens(tokens);
    } catch (err) {
      log.error("Error loading fee tokens", "RWax", err);
    }
  }, []);
  const loadPriceData = reactExports.useCallback(async () => {
    try {
      const [wpixalWAX, wpixalUSD, waxUSD] = await Promise.all([
        priceService.getWpixalPriceWAX(),
        priceService.getWpixalPriceUSD(),
        priceService.getWaxPriceUSD()
      ]);
      setWpixalPriceWAX(wpixalWAX);
      setWpixalPriceUSD(wpixalUSD);
      setWaxPriceUSD(waxUSD);
    } catch (err) {
      log.error("Error loading price data", "RWax", err);
      setWpixalPriceWAX(0.0177);
      setWpixalPriceUSD(9e-4);
      setWaxPriceUSD(0.051);
      showError("Price Loading Error", "Unable to fetch current prices. Using fallback values.");
    }
  }, [showError]);
  const loadWaxBalance = reactExports.useCallback(async () => {
    if (!account) {
      setWaxBalance("0.0000 WAX");
      return;
    }
    try {
      const balance = await balanceService.getWaxBalance(account);
      setWaxBalance(balance);
    } catch (err) {
      log.error("Error loading WAX balance", "RWax", err);
      setWaxBalance("0.0000 WAX");
    }
  }, [account]);
  reactExports.useEffect(() => {
    loadFeeTokens();
    loadPriceData();
    loadWaxBalance();
    if (activeTab === "redeem") {
      loadTokenizedAssets(1, false);
    }
  }, [activeTab, loadTokenizedAssets, loadFeeTokens, loadPriceData, loadWaxBalance]);
  reactExports.useEffect(() => {
    const priceInterval = setInterval(loadPriceData, 5 * 60 * 1e3);
    return () => clearInterval(priceInterval);
  }, [loadPriceData]);
  const handleRedeem = (asset) => {
    setSelectedAsset(asset);
    setShowRedeemModal(true);
  };
  const handleWaxRedeem = (asset) => {
    setSelectedAsset(asset);
    setShowWaxRedeemModal(true);
    setWaxRedeemStep("confirm");
    setWaxAmount("");
  };
  const handleImageZoom = (imageUrl, name) => {
    let processedUrl = imageUrl;
    if (imageUrl && !imageUrl.startsWith("http")) {
      if (imageUrl.startsWith("Qm") || imageUrl.startsWith("baf")) {
        processedUrl = `https://ipfs.io/ipfs/${imageUrl}`;
      } else if (imageUrl.startsWith("/ipfs/")) {
        processedUrl = `https://ipfs.io/ipfs/${imageUrl.replace("/ipfs/", "")}`;
      } else if (imageUrl.startsWith("ipfs://")) {
        processedUrl = imageUrl.replace("ipfs://", "https://ipfs.io/ipfs/");
      }
    }
    setZoomedImage({ url: processedUrl, name });
    setShowImageZoom(true);
  };
  const handleAssetSelection = (assetId) => {
    const newSelected = new Set(selectedAssets);
    if (newSelected.has(assetId)) {
      newSelected.delete(assetId);
    } else {
      newSelected.add(assetId);
    }
    setSelectedAssets(newSelected);
  };
  const handleSelectAll = () => {
    if (selectedAssets.size === tokenizedAssets.length) {
      setSelectedAssets(/* @__PURE__ */ new Set());
    } else {
      setSelectedAssets(new Set(tokenizedAssets.map((asset) => asset.assetId.toString())));
    }
  };
  const handleBatchRedeem = async () => {
    if (selectedAssets.size === 0) return;
    try {
      setLoading(true);
      const selectedAssetsList = tokenizedAssets.filter((asset) => selectedAssets.has(asset.assetId.toString()));
      const defaultFeeToken = feeTokens.length > 0 ? feeTokens[0] : null;
      if (!defaultFeeToken) {
        showError("No fee tokens available for batch redemption");
        return;
      }
      for (const asset of selectedAssetsList) {
        if (!account) {
          showError("Please connect your wallet");
          return;
        }
        try {
          const actions = [
            {
              account: "nft.hive",
              name: "boost",
              authorization: [{
                actor: account,
                permission: "active"
              }],
              data: {
                booster: account
              }
            },
            {
              account: defaultFeeToken.contract,
              name: "transfer",
              authorization: [{
                actor: account,
                permission: "active"
              }],
              data: {
                from: account,
                to: "rwax",
                quantity: defaultFeeToken.fee,
                memo: "payfee"
              }
            },
            {
              account: "pixeljourney",
              name: "transfer",
              authorization: [{
                actor: account,
                permission: "active"
              }],
              data: {
                from: account,
                to: "rwax",
                quantity: `${asset.rwax.redeemAmount.toFixed(8)} WPIXAL`,
                memo: "redeem"
              }
            },
            {
              account: "rwax",
              name: "redeem",
              authorization: [{
                actor: account,
                permission: "active"
              }],
              data: {
                redeemer: account,
                contract: "pixeljourney",
                quantity: `${asset.rwax.redeemAmount.toFixed(8)} WPIXAL`,
                asset_id: asset.assetId.toString(),
                fee_currency: `8,${defaultFeeToken.symbol}`
              }
            }
          ];
          const result = await wharfKitService.transact(actions);
          log.info(`Redemption transaction completed for ${asset.name}`, "RWax.handleBatchRedemption", { assetId: asset.assetId, result });
        } catch (err) {
          log.error(`Error redeeming asset ${asset.assetId}`, "RWax", err);
        }
      }
      showSuccess(`Successfully processed redemption for ${selectedAssets.size} assets!`);
      setSelectedAssets(/* @__PURE__ */ new Set());
      loadTokenizedAssets();
    } catch (error2) {
      log.error("Batch redemption failed", "RWax", error2);
      showError("Batch redemption failed. Please try again.");
    } finally {
      setLoading(false);
    }
  };
  const handleWpixalPurchase = (amount) => {
    setWpixalToPurchase(amount);
    setShowWpixalPurchaseModal(true);
  };
  const closeWaxRedeemModal = () => {
    setShowWaxRedeemModal(false);
    setWaxRedeemStep("confirm");
    setWaxAmount("");
    setLoading(false);
    setSelectedAsset(null);
  };
  const handleViewAssetDetail = (asset) => {
    setSelectedDetailAsset(asset);
    setShowAssetDetailModal(true);
  };
  const toggleFilterSidebar = reactExports.useCallback(() => {
    setIsFilterSidebarOpen((prev) => !prev);
  }, []);
  const closeFilterSidebar = reactExports.useCallback(() => {
    setIsFilterSidebarOpen(false);
  }, []);
  const handleRedeemFromDetail = async (asset, feeToken) => {
    if (!account) {
      showError("Please connect your wallet");
      return;
    }
    try {
      setLoading(true);
      const actions = [
        {
          account: "nft.hive",
          name: "boost",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            booster: account
          }
        },
        {
          account: feeToken.contract,
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "rwax",
            quantity: feeToken.fee,
            memo: "payfee"
          }
        },
        {
          account: "pixeljourney",
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "rwax",
            quantity: `${asset.rwax.redeemAmount.toFixed(8)} WPIXAL`,
            memo: "redeem"
          }
        },
        {
          account: "rwax",
          name: "redeem",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            redeemer: account,
            contract: "pixeljourney",
            quantity: `${asset.rwax.redeemAmount.toFixed(8)} WPIXAL`,
            asset_id: asset.assetId.toString(),
            fee_currency: `8,${feeToken.symbol}`
          }
        }
      ];
      const result = await wharfKitService.transact(actions);
      showSuccess("Redemption transaction completed successfully!");
      log.info("Redemption transaction completed", "RWax.handleRedemption", { result });
      setShowAssetDetailModal(false);
      setSelectedDetailAsset(null);
      loadTokenizedAssets();
    } catch (err) {
      log.error("Error during redemption", "RWax", err);
      showError("Redemption failed. Please try again.");
    } finally {
      setLoading(false);
    }
  };
  const executeWaxRedeem = async () => {
    if (!selectedAsset || !account || !session || !isTokenizedAsset(selectedAsset)) {
      showError("Missing required data for WAX redemption");
      return;
    }
    const userWaxAmount = parseFloat(waxBalance.split(" ")[0]);
    const requiredWaxAmount = parseFloat(waxAmount);
    if (userWaxAmount < requiredWaxAmount) {
      showError(`Insufficient WAX balance. You have ${waxBalance} but need ${requiredWaxAmount.toFixed(4)} WAX`);
      return;
    }
    try {
      setLoading(true);
      setWaxRedeemStep("swap");
      const swapTransaction = await alcorService.executeSwap(waxAmount, account);
      showSuccess("Swap transaction prepared");
      log.info("Swap transaction prepared", "RWax.handleWaxRedemption", { swapTransaction });
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      setWaxRedeemStep("redeem");
      const feeToken = {
        fee: "0.00000000",
        contract: "eosio.token",
        exchange_rate: "1",
        symbol: "WAX",
        amount: "0.00000000"
      };
      if (!isTokenizedAsset(selectedAsset)) {
        showError("Selected asset is not a tokenized asset");
        return;
      }
      const redeemTransaction = await rwaxService.executeRedemption(
        selectedAsset.assetId.toString(),
        selectedAsset.rwax.redeemAmount.toFixed(8) + " WPIXAL",
        feeToken
      );
      showSuccess("Redemption transaction prepared");
      log.info("Redemption transaction prepared", "RWax.handleWaxRedemption", { redeemTransaction });
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      setWaxRedeemStep("complete");
      showSuccess("WAX redemption completed successfully!");
    } catch (err) {
      log.error("Error during WAX redemption", "RWax", err);
      showError("WAX redemption failed. Please try again.");
      setWaxRedeemStep("confirm");
    } finally {
      setLoading(false);
    }
  };
  const executeTokenization = async () => {
    if (!selectedAsset || !selectedFeeToken || !session || !account) {
      showError("Please select an asset and fee token");
      return;
    }
    try {
      const transaction = await rwaxService.executeTokenization([selectedAsset.assetId.toString()], selectedFeeToken);
      showSuccess("Tokenization transaction prepared");
      log.info("Tokenization transaction prepared", "RWax.handleTokenization", { transaction });
      setShowTokenizeModal(false);
      setTimeout(() => {
        loadTokenizedAssets();
      }, 2e3);
    } catch (err) {
      log.error("Error during tokenization", "RWax", err);
      showError("Tokenization failed. Please try again.");
    }
  };
  const isTokenizedAsset = (asset) => {
    return "rwax" in asset && asset.rwax && "redeemAmount" in asset.rwax;
  };
  const executeRedemption = async () => {
    if (!selectedAsset || !selectedFeeToken || !session || !account || !isTokenizedAsset(selectedAsset)) {
      showError("Please select an asset and fee token");
      return;
    }
    try {
      setLoading(true);
      const actions = [
        {
          account: "nft.hive",
          name: "boost",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            booster: account
          }
        },
        {
          account: selectedFeeToken.contract,
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "rwax",
            quantity: selectedFeeToken.fee,
            memo: "payfee"
          }
        },
        {
          account: "pixeljourney",
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "rwax",
            quantity: `${selectedAsset.rwax.redeemAmount.toFixed(8)} WPIXAL`,
            memo: "redeem"
          }
        },
        {
          account: "rwax",
          name: "redeem",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            redeemer: account,
            contract: "pixeljourney",
            quantity: `${selectedAsset.rwax.redeemAmount.toFixed(8)} WPIXAL`,
            asset_id: selectedAsset.assetId.toString(),
            fee_currency: `8,${selectedFeeToken.symbol}`
          }
        }
      ];
      const result = await wharfKitService.transact(actions);
      showSuccess("Redemption transaction completed successfully!");
      log.info("Redemption transaction completed", "RWax.handleRedeemFromModal", { result });
      setShowRedeemModal(false);
      setTimeout(() => {
        loadTokenizedAssets();
      }, 2e3);
    } catch (err) {
      log.error("Error during redemption", "RWax", err);
      showError("Redemption failed. Please try again.");
    } finally {
      setLoading(false);
    }
  };
  const handleToggleWatchlist = (assetId) => {
    const newWatchlist = new Set(watchlist);
    if (newWatchlist.has(assetId)) {
      newWatchlist.delete(assetId);
      showSuccess("Removed from watchlist");
    } else {
      newWatchlist.add(assetId);
      showSuccess("Added to watchlist");
    }
    setWatchlist(newWatchlist);
    localStorage.setItem("rwax-watchlist", JSON.stringify(Array.from(newWatchlist)));
  };
  reactExports.useEffect(() => {
    const savedWatchlist = localStorage.getItem("rwax-watchlist");
    if (savedWatchlist) {
      try {
        const watchlistArray = JSON.parse(savedWatchlist);
        setWatchlist(new Set(watchlistArray));
      } catch (err) {
        log.error("Error loading watchlist", "RWax", err);
      }
    }
  }, []);
  const handleShareAsset = (asset) => {
    setShareAsset(asset);
    setShowShareModal(true);
  };
  const handleSetPriceAlert = reactExports.useCallback((asset, alertPercentage2) => {
    const currentPrice = parseFloat(asset.rwax.redeemAmount.toString());
    const alertData = {
      assetId: asset.assetId.toString(),
      assetName: asset.name,
      originalPrice: currentPrice,
      alertPercentage: alertPercentage2,
      createdAt: Date.now()
    };
    const newPriceAlerts = new Map(priceAlerts);
    newPriceAlerts.set(asset.assetId.toString(), alertData);
    setPriceAlerts(newPriceAlerts);
    const alertsArray = Array.from(newPriceAlerts.entries());
    localStorage.setItem("rwax-price-alerts", JSON.stringify(alertsArray));
    showSuccess(`Price alert set for ${asset.name} at ${alertPercentage2}% change`);
  }, [priceAlerts, showSuccess]);
  const removePriceAlert = reactExports.useCallback((assetId) => {
    const newPriceAlerts = new Map(priceAlerts);
    newPriceAlerts.delete(assetId);
    setPriceAlerts(newPriceAlerts);
    const alertsArray = Array.from(newPriceAlerts.entries());
    localStorage.setItem("rwax-price-alerts", JSON.stringify(alertsArray));
    showSuccess("Price alert removed");
  }, [priceAlerts, showSuccess]);
  const checkPriceAlerts = reactExports.useCallback(() => {
    if (priceAlerts.size === 0 || tokenizedAssets.length === 0) return;
    priceAlerts.forEach((alertData, assetId) => {
      const currentAsset = tokenizedAssets.find((asset) => asset.assetId.toString() === assetId);
      if (!currentAsset) {
        showError(`Alert: ${alertData.assetName} is no longer available on RWAX!`);
        removePriceAlert(assetId);
        return;
      }
      const currentPrice = parseFloat(currentAsset.rwax.redeemAmount.toString());
      const priceChange = (currentPrice - alertData.originalPrice) / alertData.originalPrice * 100;
      if (Math.abs(priceChange) >= alertData.alertPercentage) {
        const direction = priceChange > 0 ? "increased" : "decreased";
        showSuccess(`Price Alert: ${alertData.assetName} has ${direction} by ${Math.abs(priceChange).toFixed(2)}%!`);
        handleSetPriceAlert(currentAsset, alertData.alertPercentage);
      }
    });
  }, [priceAlerts, tokenizedAssets, showError, showSuccess, removePriceAlert, handleSetPriceAlert]);
  reactExports.useEffect(() => {
    const savedAlerts = localStorage.getItem("rwax-price-alerts");
    if (savedAlerts) {
      try {
        const alertsArray = JSON.parse(savedAlerts);
        setPriceAlerts(new Map(alertsArray));
      } catch (err) {
        log.error("Error loading price alerts", "RWax", err);
      }
    }
  }, []);
  reactExports.useEffect(() => {
    checkPriceAlerts();
  }, [checkPriceAlerts]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-header-top", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "rwax-back-button", onClick: () => navigate("/marketplace"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }),
          "Back to Marketplace"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-actions" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "R-WAX Tokenization" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Tokenize your Pixals to WPIXAL or redeem WPIXAL back to Pixals" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { marginTop: "16px", fontSize: "0.9rem", color: "var(--text-secondary)" }, children: [
        "Visit the ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: "https://r-wax.io/token/pixeljourney/WPIXAL",
            target: "_blank",
            rel: "noopener noreferrer",
            style: { color: "var(--primary-purple)", textDecoration: "none", fontWeight: "500" },
            onMouseEnter: (e) => e.target.style.textDecoration = "underline",
            onMouseLeave: (e) => e.target.style.textDecoration = "none",
            children: "official RWAX website"
          }
        ),
        " for full WPIXAL markets and trading features."
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-tabs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab-button ${activeTab === "redeem" ? "active" : ""}`,
          onClick: () => setActiveTab("redeem"),
          children: "WPIXAL to Pixal PFP"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab-button ${activeTab === "other-collections" ? "active" : ""}`,
          onClick: () => setActiveTab("other-collections"),
          children: "Other RWAX Collections"
        }
      )
    ] }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rwax-content", children: activeTab === "redeem" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "redeem-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "actions-and-controls-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "left-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "action-group", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "inventory-tokenize-button",
              onClick: () => setShowInventoryModal(true),
              children: "Tokenize from Inventory"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "action-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: `wpixal-alert-button ${localStorage.getItem("wpixalPriceAlert") ? "has-alert" : ""}`,
                onClick: () => setShowWpixalAlertModal(true),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.73 21a2 2 0 0 1-3.46 0" })
                  ] }),
                  "WPIXAL Price Alert"
                ]
              }
            ),
            localStorage.getItem("wpixalPriceAlert") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-alert-display", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "Current Alert: ",
                localStorage.getItem("wpixalPriceAlert"),
                " WAX"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "remove-alert",
                  onClick: (e) => {
                    e.stopPropagation();
                    localStorage.removeItem("wpixalPriceAlert");
                    setWpixalAlertPrice("");
                  },
                  title: "Remove Alert",
                  children: ""
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sorting-and-filter-controls", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-bar-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-input-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "search-icon", viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Search R-WAX assets...",
                value: searchTerm,
                onChange: (e) => setSearchTerm(e.target.value),
                className: "search-input"
              }
            ),
            searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setSearchTerm(""),
                className: "clear-search",
                "aria-label": "Clear search",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }) })
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sorting-controls", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "sort-select", children: "Sort by:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                id: "sort-select",
                value: sortBy,
                onChange: (e) => handleSortChange(e.target.value),
                className: "sort-dropdown",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "date_desc", children: "Date (Newest First)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "date_asc", children: "Date (Oldest First)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_desc", children: "Price (High to Low)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "price_asc", children: "Price (Low to High)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "floor_desc", children: "Floor Price (High to Low)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "floor_asc", children: "Floor Price (Low to High)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_desc", children: "Mint Number (High to Low)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "mint_asc", children: "Mint Number (Low to High)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "rarity_score_desc", children: "Rarity Score (High to Low)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "rarity_score_asc", children: "Rarity Score (Low to High)" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "filter-toggle-btn",
                onClick: toggleFilterSidebar,
                title: "Open Filters",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "40", height: "40", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" }) })
              }
            )
          ] })
        ] })
      ] }),
      loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner", children: "Loading tokenized assets..." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        filteredAssets.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "multi-select-controls", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "select-all-button",
              onClick: handleSelectAll,
              children: selectedAssets.size === filteredAssets.length ? "Deselect All" : "Select All"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-count-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-count", children: [
              selectedAssets.size,
              " of ",
              filteredAssets.length,
              " selected"
            ] }),
            hasMoreAssets && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "load-more-small-button",
                onClick: loadMoreAssets,
                disabled: loadingMoreAssets,
                title: "Load More Assets",
                children: loadingMoreAssets ? "Loading..." : "Load More"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "batch-redeem-button",
              onClick: handleBatchRedeem,
              disabled: selectedAssets.size === 0 || !account,
              children: [
                "Batch Redeem (",
                selectedAssets.size,
                ")"
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rwax-assets-grid", children: filteredAssets.map((asset, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `asset-card ${selectedAssets.has(asset.assetId.toString()) ? "selected" : ""}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: `selection-checkbox ${selectedAssets.has(asset.assetId.toString()) ? "checked" : ""}`,
                  onClick: (e) => {
                    e.stopPropagation();
                    handleAssetSelection(asset.assetId.toString());
                  },
                  children: selectedAssets.has(asset.assetId.toString()) && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" }) })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "asset-card-content",
                  onClick: () => handleViewAssetDetail(asset),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-image", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        MediaRenderer,
                        {
                          imageUrl: asset.image,
                          alt: asset.name,
                          className: "nft-image"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: "zoom-overlay",
                          onClick: (e) => {
                            e.stopPropagation();
                            handleImageZoom(asset.image, asset.name);
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "currentColor", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" })
                          ] })
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: asset.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pricing-info", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            className: "wpixal-amount",
                            onClick: (e) => {
                              e.stopPropagation();
                              handleWpixalPurchase(parseFloat(asset.rwax.redeemAmount.toString()));
                            },
                            title: `Exact amount: ${asset.rwax.redeemAmount} WPIXAL`,
                            children: [
                              parseFloat(asset.rwax.redeemAmount.toString()).toFixed(1),
                              " WPIXAL"
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-price-convert", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-price", children: [
                            " ",
                            (parseFloat(asset.rwax.redeemAmount.toString()) * wpixalPriceWAX).toFixed(4),
                            " WAX"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "usd-price", children: [
                            " $",
                            (parseFloat(asset.rwax.redeemAmount.toString()) * wpixalPriceUSD).toFixed(4),
                            " USD"
                          ] })
                        ] })
                      ] })
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "asset-actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "redeem-button primary",
                    onClick: (e) => {
                      e.stopPropagation();
                      handleRedeem(asset);
                    },
                    disabled: !account,
                    children: "Redeem (WPIXAL)"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "secondary-actions", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "wax-redeem-button secondary",
                      onClick: (e) => {
                        e.stopPropagation();
                        handleWaxRedeem(asset);
                      },
                      disabled: !account,
                      children: "Redeem (WAX)"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "info-button secondary",
                      onClick: (e) => {
                        e.stopPropagation();
                        handleViewAssetDetail(asset);
                      },
                      children: "Info"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "icon-actions", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: `btn-watchlist icon-only ${watchlist.has(asset.assetId.toString()) ? "active" : ""}`,
                      onClick: (e) => {
                        e.stopPropagation();
                        handleToggleWatchlist(asset.assetId.toString());
                      },
                      title: watchlist.has(asset.assetId.toString()) ? "Remove from Watchlist" : "Add to Watchlist",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: watchlist.has(asset.assetId.toString()) ? "currentColor" : "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" }) })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "btn-copy-link icon-only",
                      onClick: (e) => {
                        e.stopPropagation();
                        const assetUrl = `${window.location.origin}/asset/${asset.assetId}`;
                        navigator.clipboard.writeText(assetUrl).then(() => {
                          showSuccess("Asset link copied to clipboard!");
                        }).catch(() => {
                          showError("Failed to copy link");
                        });
                      },
                      title: "Copy Link",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "btn-share icon-only",
                      onClick: (e) => {
                        e.stopPropagation();
                        handleShareAsset(asset);
                      },
                      title: "Share Asset",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "16,6 12,2 8,6" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "2", x2: "12", y2: "15" })
                      ] })
                    }
                  )
                ] })
              ] })
            ]
          },
          `${asset.assetId}-${index}`
        )) }),
        hasMoreAssets && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load-more-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "load-more-button",
            onClick: loadMoreAssets,
            disabled: loadingMoreAssets,
            children: loadingMoreAssets ? "Loading..." : "Load More Assets"
          }
        ) })
      ] })
    ] }) : activeTab === "other-collections" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "other-collections-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "construction-message", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "construction-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Other RWAX Collections" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Support for additional RWAX collections is coming soon!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "construction-details", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "We're working on expanding RWAX tokenization to support more NFT collections beyond Pixals. Stay tuned for updates!" }) })
    ] }) }) : null }),
    showTokenizeModal && selectedAsset && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rwax-modal-overlay", onClick: () => setShowTokenizeModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Tokenize Pixal" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rwax-close-button", onClick: () => setShowTokenizeModal(false), children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-asset", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: selectedAsset.image,
              alt: selectedAsset.name,
              className: "modal-asset-image"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: selectedAsset.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fee-selection", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Select Fee Token:" }),
          feeTokens.map((token, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `fee-option ${selectedFeeToken === token ? "selected" : ""}`,
              onClick: () => setSelectedFeeToken(token),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fee-amount", children: token.fee }),
                token.wax_value && token.symbol !== "WAX" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "wax-equivalent", children: [
                  " ",
                  parseFloat(token.wax_value).toFixed(4),
                  " WAX"
                ] })
              ]
            },
            index
          ))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "cancel-button", onClick: () => setShowTokenizeModal(false), children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "confirm-button",
              onClick: executeTokenization,
              disabled: !selectedFeeToken,
              children: "Tokenize"
            }
          )
        ] })
      ] })
    ] }) }),
    showRedeemModal && selectedAsset && isTokenizedAsset(selectedAsset) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rwax-modal-overlay", onClick: () => setShowRedeemModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Redeem WPIXAL" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rwax-close-button", onClick: () => setShowRedeemModal(false), children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-asset", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: selectedAsset.image,
              alt: selectedAsset.name,
              className: "modal-asset-image"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: selectedAsset.name }),
          isTokenizedAsset(selectedAsset) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "wpixal-required", children: [
            "Required: ",
            selectedAsset.rwax.redeemAmount.toFixed(8),
            " WPIXAL"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fee-selection", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Select Fee Token:" }),
          feeTokens.map((token, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `fee-option ${selectedFeeToken === token ? "selected" : ""}`,
              onClick: () => setSelectedFeeToken(token),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fee-amount", children: token.fee }),
                token.wax_value && token.symbol !== "WAX" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "wax-equivalent", children: [
                  " ",
                  parseFloat(token.wax_value).toFixed(4),
                  " WAX"
                ] })
              ]
            },
            index
          ))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "cancel-button", onClick: () => setShowRedeemModal(false), children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "confirm-button",
              onClick: executeRedemption,
              disabled: !selectedFeeToken,
              children: "Redeem"
            }
          )
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TokenizeFromInventoryModal,
      {
        isOpen: showInventoryModal,
        onClose: () => setShowInventoryModal(false),
        onSuccess: () => {
          if (activeTab === "redeem") {
            loadTokenizedAssets();
          }
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AssetDetailModal,
      {
        asset: selectedDetailAsset,
        isOpen: showAssetDetailModal,
        onClose: () => {
          setShowAssetDetailModal(false);
          setSelectedDetailAsset(null);
        },
        onRedeem: handleRedeemFromDetail
      }
    ),
    showWaxRedeemModal && selectedAsset && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rwax-modal-overlay", onClick: closeWaxRedeemModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-content rwax-wax-redeem-modal", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Pay with WAX" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rwax-close-button", onClick: closeWaxRedeemModal, children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "selected-asset", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: selectedAsset.image,
              alt: selectedAsset.name,
              className: "modal-asset-image"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: selectedAsset.name }),
          isTokenizedAsset(selectedAsset) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "wpixal-required", children: [
              "Required: ",
              selectedAsset.rwax.redeemAmount.toFixed(8),
              " WPIXAL"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "wax-cost", children: [
              "Cost: ",
              (selectedAsset.rwax.redeemAmount * wpixalPriceWAX).toFixed(4),
              " WAX"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "usd-cost", children: [
              "USD: $",
              (selectedAsset.rwax.redeemAmount * wpixalPriceUSD).toFixed(4)
            ] })
          ] })
        ] }),
        waxRedeemStep === "confirm" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-redeem-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Step 1: Confirm WAX Payment" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "step-description", children: "This process will swap your WAX for WPIXAL via Alcor, then use that WPIXAL to redeem your NFT." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-calculator-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "available-wax", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Your Available WAX" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-balance", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nav-balance-amount", children: waxBalance }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "balance-usd", children: [
                  "($",
                  (parseFloat(waxBalance.split(" ")[0]) * waxPriceUSD).toFixed(2),
                  " USD)"
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wpixal-calculator", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "WPIXAL Calculator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "calculator-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "With your available WAX, you can buy:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-wpixal", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                  wpixalPriceWAX > 0 ? (100 / wpixalPriceWAX).toFixed(4) : "0.0000",
                  " WPIXAL"
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rate-info", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                  "Rate: 1 WPIXAL = ",
                  wpixalPriceWAX.toFixed(6),
                  " WAX"
                ] }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "purchase-slider", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Amount to purchase:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "range",
                    min: "0",
                    max: Math.min(100, wpixalPriceWAX > 0 && isTokenizedAsset(selectedAsset) ? selectedAsset.rwax.redeemAmount * wpixalPriceWAX : 0),
                    step: "0.0001",
                    value: waxAmount ? parseFloat(waxAmount) : 0,
                    onChange: (e) => setWaxAmount(parseFloat(e.target.value).toFixed(4)),
                    className: "wpixal-slider"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slider-labels", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "0 WAX" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    Math.min(100, wpixalPriceWAX > 0 && isTokenizedAsset(selectedAsset) ? selectedAsset.rwax.redeemAmount * wpixalPriceWAX : 0).toFixed(4),
                    " WAX"
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "purchase-summary", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-row", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "WPIXAL to buy:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    waxAmount ? (parseFloat(waxAmount) / wpixalPriceWAX).toFixed(4) : "0.0000",
                    " WPIXAL"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-row", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "WAX cost:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    waxAmount || "0.0000",
                    " WAX"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-row", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "USD cost:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    "$",
                    waxAmount ? (parseFloat(waxAmount) * waxPriceUSD).toFixed(4) : "0.0000"
                  ] })
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "process-steps", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "step-number", children: "1" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "step-text", children: "Swap WAX  WPIXAL via Alcor" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "step-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "step-number", children: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "step-text", children: "Redeem NFT with WPIXAL" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "cancel-button", onClick: closeWaxRedeemModal, children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "confirm-button",
                onClick: executeWaxRedeem,
                disabled: !waxAmount || parseFloat(waxAmount) <= 0 || wpixalPriceWAX <= 0 || !isTokenizedAsset(selectedAsset) || parseFloat(waxAmount) / wpixalPriceWAX > selectedAsset.rwax.redeemAmount,
                children: "Buy WPIXAL & Redeem"
              }
            )
          ] })
        ] }),
        waxRedeemStep === "swap" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-redeem-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Step 2: Swapping WAX to WPIXAL" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "step-description", children: [
            "Connecting to Alcor to swap ",
            waxAmount,
            " WAX for WPIXAL..."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-progress", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-spinner" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Processing swap transaction..." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "cancel-button", onClick: closeWaxRedeemModal, children: "Cancel" }) })
        ] }),
        waxRedeemStep === "redeem" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-redeem-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Step 3: Redeeming NFT" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "step-description", children: "Using WPIXAL to redeem your NFT..." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "redeem-progress", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-spinner" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Processing redemption transaction..." })
          ] })
        ] }),
        waxRedeemStep === "complete" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wax-redeem-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Redemption Complete!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "step-description success", children: "Your NFT has been successfully redeemed using WAX payment." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "confirm-button",
              onClick: () => {
                closeWaxRedeemModal();
                loadTokenizedAssets();
              },
              children: "Done"
            }
          ) })
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "live-transactions-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RWAXLiveTransactions, { limit: 12, refreshInterval: 3e4 }) }),
    showImageZoom && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "image-zoom-modal", onClick: () => setShowImageZoom(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "zoom-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "zoom-modal-close",
          onClick: () => setShowImageZoom(false),
          children: ""
        }
      ),
      zoomedImage && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: zoomedImage.url,
            alt: zoomedImage.name,
            className: "zoom-modal-image"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "zoom-modal-info", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: zoomedImage.name }) })
      ] })
    ] }) }),
    showWpixalPurchaseModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwapInterface,
      {
        isModal: true,
        onClose: () => setShowWpixalPurchaseModal(false),
        initialBuyAmount: wpixalToPurchase
      }
    ),
    showPriceAlertModal && alertAsset && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rwax-modal-overlay", onClick: () => setShowPriceAlertModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Set Price Alert" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "rwax-close-button",
            onClick: () => setShowPriceAlertModal(false),
            children: ""
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-body", children: [
        alertAsset && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert-asset-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MediaRenderer,
            {
              imageUrl: alertAsset.image,
              alt: alertAsset.name,
              className: "modal-asset-image"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: alertAsset.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Current Price: ",
            alertAsset.rwax.redeemAmount.toFixed(8),
            " WPIXAL"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert-settings", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Alert when price changes by:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "percentage-options", children: [5, 10, 15, 20, 25].map((percentage) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `percentage-option ${alertPercentage === percentage ? "selected" : ""}`,
              onClick: () => setAlertPercentage(percentage),
              children: [
                percentage,
                "%"
              ]
            },
            percentage
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-percentage", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Custom percentage:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                min: "1",
                max: "100",
                value: alertPercentage,
                onChange: (e) => setAlertPercentage(parseInt(e.target.value) || 10),
                className: "percentage-input"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "%" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert-preview", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              "You will be notified when the price moves ",
              alertPercentage,
              "% from the current value."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-thresholds", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "threshold-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "threshold-label", children: "Alert above:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "threshold-value", children: [
                  (alertAsset.rwax.redeemAmount * (1 + alertPercentage / 100)).toFixed(4),
                  " WPIXAL"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "threshold-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "threshold-label", children: "Alert below:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "threshold-value", children: [
                  (alertAsset.rwax.redeemAmount * (1 - alertPercentage / 100)).toFixed(4),
                  " WPIXAL"
                ] })
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "cancel-button",
              onClick: () => setShowPriceAlertModal(false),
              children: "Cancel"
            }
          ),
          alertAsset && priceAlerts.has(alertAsset.assetId.toString()) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "remove-alert-button",
              onClick: () => {
                if (alertAsset) {
                  removePriceAlert(alertAsset.assetId.toString());
                  setShowPriceAlertModal(false);
                }
              },
              children: "Remove Alert"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "confirm-button",
              onClick: () => {
                if (alertAsset) {
                  handleSetPriceAlert(alertAsset, alertPercentage);
                  setShowPriceAlertModal(false);
                }
              },
              children: alertAsset && priceAlerts.has(alertAsset.assetId.toString()) ? "Update Alert" : "Set Alert"
            }
          )
        ] })
      ] })
    ] }) }),
    showWpixalAlertModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rwax-modal-overlay", onClick: () => setShowWpixalAlertModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "WPIXAL Price Alert" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "rwax-close-button",
            onClick: () => setShowWpixalAlertModal(false),
            children: ""
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rwax-modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wpixal-alert-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Set WPIXAL Price Alert" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "current-wpixal-prices", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Current WPIXAL Price:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-display", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wax-price", children: wpixalPriceWAX > 0 ? `${wpixalPriceWAX.toFixed(8)} WAX` : "Loading..." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "usd-price", children: wpixalPriceUSD > 0 ? `($${wpixalPriceUSD.toFixed(6)} USD)` : "" })
            ] })
          ] }),
          localStorage.getItem("wpixalPriceAlert") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "existing-alert-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              "Your Current Alert: ",
              localStorage.getItem("wpixalPriceAlert"),
              " WAX"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "price-comparison", children: wpixalPriceWAX > 0 && localStorage.getItem("wpixalPriceAlert") ? `Current price is ${((wpixalPriceWAX - parseFloat(localStorage.getItem("wpixalPriceAlert"))) / parseFloat(localStorage.getItem("wpixalPriceAlert")) * 100).toFixed(2)}% ${wpixalPriceWAX > parseFloat(localStorage.getItem("wpixalPriceAlert")) ? "above" : "below"} your alert` : "" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Get notified when WPIXAL price drops below your target value" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert-settings", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Alert when WPIXAL price (in WAX) drops below:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-input-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                step: "0.00000001",
                min: "0",
                value: wpixalAlertPrice,
                onChange: (e) => setWpixalAlertPrice(e.target.value),
                placeholder: "Enter WAX amount",
                className: "price-alert-input"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "currency-label", children: "WAX" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "cancel-button",
              onClick: () => setShowWpixalAlertModal(false),
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "confirm-button",
              onClick: () => {
                if (wpixalAlertPrice && parseFloat(wpixalAlertPrice) > 0) {
                  localStorage.setItem("wpixalPriceAlert", wpixalAlertPrice);
                  setShowWpixalAlertModal(false);
                  setWpixalAlertPrice("");
                  showSuccess("Price Alert Set", `WPIXAL price alert set for ${wpixalAlertPrice} WAX`);
                }
              },
              disabled: !wpixalAlertPrice || parseFloat(wpixalAlertPrice) <= 0,
              children: "Set Alert"
            }
          )
        ] })
      ] })
    ] }) }),
    isFilterSidebarOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "filter-sidebar-overlay", onClick: closeFilterSidebar }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-sidebar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-sidebar-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Advanced Filters" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-sidebar-btn", onClick: closeFilterSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filter-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Price Range (WPIXAL)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-range-inputs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Min",
                value: priceRange.min,
                onChange: (e) => setPriceRange((prev) => ({ ...prev, min: e.target.value })),
                className: "price-input"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "to" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Max",
                value: priceRange.max,
                onChange: (e) => setPriceRange((prev) => ({ ...prev, max: e.target.value })),
                className: "price-input"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "filter-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PixalAttributeFilter,
          {
            onFiltersChange: handleAttributeFiltersChange,
            initialFilters: selectedAttributeFilters
          }
        ) })
      ] })
    ] }),
    showShareModal && shareAsset && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ShareModal,
      {
        isOpen: showShareModal,
        onClose: () => {
          setShowShareModal(false);
          setShareAsset(null);
        },
        type: "nft",
        title: "",
        shareUrl: `${window.location.origin}/rwax/asset/${shareAsset.assetId}`,
        defaultShareText: `Check out this tokenized Pixal: ${shareAsset.name} - ${shareAsset.rwax.redeemAmount.toFixed(8)} WPIXAL on PxMarket! `
      }
    )
  ] });
};
const templates = [
  { id: 781515, pxj: 1, wuf: 22, pxjUpgrade: 0, name: "Pixal PFP", type: "pixals" },
  { id: 820134, pxj: 2.22, wuf: 5, pxjUpgrade: 0, name: "Pixel Ingredient Pack", type: "pixelpack" },
  { id: 858568, pxj: 142, wuf: 142, pxjUpgrade: 0, name: "Black", type: "special" },
  { id: 858569, pxj: 0.42, wuf: 1, pxjUpgrade: 0, name: "Blue", type: "primary ingredient" },
  { id: 858570, pxj: 0.42, wuf: 1, pxjUpgrade: 0, name: "Red", type: "primary ingredient" },
  { id: 858571, pxj: 0.42, wuf: 1, pxjUpgrade: 0, name: "Yellow", type: "primary ingredient" },
  { id: 858572, pxj: 2.22, wuf: 1, pxjUpgrade: 25e3, name: "Green", type: "secondary ingredient" },
  { id: 858573, pxj: 2.22, wuf: 1, pxjUpgrade: 25e3, name: "Orange", type: "secondary ingredient" },
  { id: 858574, pxj: 2.22, wuf: 1, pxjUpgrade: 25e3, name: "Purple", type: "secondary ingredient" },
  { id: 858575, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Amber", type: "tertiary ingredient" },
  { id: 858576, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Chartreuse", type: "tertiary ingredient" },
  { id: 858577, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Violet", type: "tertiary ingredient" },
  { id: 858578, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Teal", type: "tertiary ingredient" },
  { id: 858580, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Vermillion", type: "tertiary ingredient" },
  { id: 859273, pxj: 14.2, wuf: 14.2, pxjUpgrade: 15e4, name: "Magenta", type: "tertiary ingredient" }
];
const PxCrafting = () => {
  const [activeTab, setActiveTab] = reactExports.useState("overview");
  const [craftingModalOpen, setCraftingModalOpen] = reactExports.useState(false);
  const [pxjPrice, setPxjPrice] = reactExports.useState(1e-3);
  const [wufPrice, setWufPrice] = reactExports.useState(5e-4);
  const [collapsedSections, setCollapsedSections] = reactExports.useState({
    ingredients: true,
    governance: true,
    collectibles: true,
    overviewIngredients: true
  });
  const calculateROI = (recipe) => {
    const template = templates.find((t) => t.id === recipe.resultTemplateId);
    if (!template) {
      return { craftingCost: 0, dailyEarnings: 0, roiDays: 0, profitMargin: 0 };
    }
    const ingredientCosts = recipe.ingredients.reduce((total, ing) => {
      const ingTemplate = templates.find((t) => t.id === ing.templateId);
      return total + (ingTemplate ? ingTemplate.pxj * ing.quantity : 0);
    }, 0);
    const craftingCost = (ingredientCosts + template.pxjUpgrade) * pxjPrice;
    const dailyEarnings = template.pxj * 24 * pxjPrice;
    const roiDays = craftingCost > 0 ? craftingCost / dailyEarnings : 0;
    const profitMargin = dailyEarnings > 0 ? (dailyEarnings - craftingCost / 365) / dailyEarnings * 100 + 100 : 100;
    return { craftingCost, dailyEarnings, roiDays, profitMargin };
  };
  const templatesByType = reactExports.useMemo(() => {
    const groups = {
      "special": [],
      "primary ingredient": [],
      "secondary ingredient": [],
      "tertiary ingredient": [],
      "pixals": [],
      "pixelpack": []
    };
    templates.forEach((template) => {
      if (groups[template.type]) {
        groups[template.type].push(template);
      }
    });
    return groups;
  }, []);
  const openCraftingModal = () => {
    setCraftingModalOpen(true);
  };
  const getIngredientImage = (templateId) => {
    const templateVideos = {
      "858575": "http://pixeljourney.xyz/ingredients/Pixel_Amber_vid_25fps_300px.mp4",
      // amber
      "858576": "http://pixeljourney.xyz/ingredients/Pixel_Chartreuse_vid_25fps_300px.mp4",
      // chartreuse
      "858577": "http://pixeljourney.xyz/ingredients/Pixel_Violet_vid_25fps_300px.mp4",
      // violet
      "858578": "http://pixeljourney.xyz/ingredients/Pixel_Teal_vid_25fps_300px.mp4",
      // teal
      "858580": "http://pixeljourney.xyz/ingredients/Pixel_Vermillion_vid_25fps_300px.mp4",
      // vermillion
      "859273": "http://pixeljourney.xyz/ingredients/Pixel_Magenta_vid_25fps_300px.mp4",
      // magenta
      "858574": "http://pixeljourney.xyz/ingredients/Pixel_Purple_vid_25fps_300px.mp4",
      // purple
      "858573": "http://pixeljourney.xyz/ingredients/Pixel_Orange_vid_25fps_300px.mp4",
      // orange
      "858572": "http://pixeljourney.xyz/ingredients/Pixel_Green_vid_25fps_300px.mp4",
      // green
      "858570": "http://pixeljourney.xyz/ingredients/Pixel_Red_vid_25fps_300px.mp4",
      // red
      "858569": "http://pixeljourney.xyz/ingredients/Pixel_Blue_vid_25fps_300px.mp4",
      // blue
      "858571": "http://pixeljourney.xyz/ingredients/Pixel_Yellow_vid_25fps_300px.mp4",
      // yellow
      "858568": "http://pixeljourney.xyz/ingredients/Pixel_Black_White_vid_25fps_300px.mp4"
      // black
    };
    return templateVideos[templateId.toString()] || `/img/ingredients/${templateId}.png`;
  };
  const isVideoFormat = (src) => {
    return src.includes(".mp4") || src.includes(".webm");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxcrafting-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxcrafting-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Pixel Ingredient Crafting" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pxcrafting-subtitle", children: "Master the art of pixel ingredient crafting with comprehensive guides, ROI calculations, and staking insights." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxcrafting-tabs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab-btn ${activeTab === "overview" ? "active" : ""}`,
          onClick: () => setActiveTab("overview"),
          children: "Overview"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab-btn ${activeTab === "recipes" ? "active" : ""}`,
          onClick: () => setActiveTab("recipes"),
          children: "Recipes"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab-btn ${activeTab === "calculator" ? "active" : ""}`,
          onClick: () => setActiveTab("calculator"),
          children: "ROI Calculator"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab-btn ${activeTab === "staking" ? "active" : ""}`,
          onClick: () => setActiveTab("staking"),
          children: "Staking Info"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxcrafting-content", children: [
      activeTab === "overview" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overview-tab", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overview-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overview-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Crafting System" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Create powerful pixel ingredients by combining primary colors into secondary and tertiary ingredients. Each tier offers increased staking rewards and unique properties." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "cta-button",
                onClick: () => openCraftingModal(),
                children: "Start Crafting"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overview-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Staking Rewards" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Stake your crafted ingredients to earn PXJ and WUF tokens. Higher tier ingredients provide significantly better returns on your investment." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "cta-button secondary",
                onClick: () => setActiveTab("staking"),
                children: "View Staking Info"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overview-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " ROI Analysis" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Calculate the return on investment for different crafting strategies. Optimize your crafting decisions with real-time profitability analysis." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "cta-button secondary",
                onClick: () => setActiveTab("calculator"),
                children: "Calculate ROI"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "main-staking-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "main-staking-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Main Staking Platform" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Visit the official Pixel Journey staking platform to stake all your NFT collectibles and earn rewards across the entire ecosystem." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "https://stake.pixeljourney.xyz",
              target: "_blank",
              rel: "noopener noreferrer",
              className: "main-staking-button",
              children: "Visit Staking Platform"
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ingredient-tiers", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collapsible-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "section-header", onClick: () => setCollapsedSections((prev) => ({ ...prev, overviewIngredients: !prev.overviewIngredients })), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Staking Values" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `collapse-icon ${collapsedSections.overviewIngredients ? "collapsed" : ""}`, children: "" })
          ] }),
          !collapsedSections.overviewIngredients && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "smart-tier-layout", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-row tier-row-premium", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card pixelpack", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Pixel Ingredient Pack" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-ingredients", children: templates.filter((t) => t.type === "pixelpack").map((template) => {
                  const imageSrc = getIngredientImage(template.id) || "https://pixeljourney.xyz/img/pixel_journey_pack_002_500x500.gif";
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-preview", children: [
                    isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "video",
                      {
                        src: imageSrc,
                        autoPlay: true,
                        loop: true,
                        muted: true,
                        onError: (e) => {
                          e.currentTarget.style.display = "none";
                          const img = document.createElement("img");
                          img.src = "https://pixeljourney.xyz/img/pixel_journey_pack_002_500x500.gif";
                          img.alt = template.name;
                          e.currentTarget.parentNode?.appendChild(img);
                        }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: imageSrc,
                        alt: template.name,
                        onError: (e) => {
                          e.currentTarget.src = "https://pixeljourney.xyz/img/pixel_journey_pack_002_500x500.gif";
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      template.name,
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "season-tag", children: "Season 1" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                      template.pxj,
                      " PXJ/hr"
                    ] })
                  ] }, template.id);
                }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card special", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Special Ingredients" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-ingredients", children: templates.filter((t) => t.type === "special").map((template) => {
                  const imageSrc = getIngredientImage(template.id);
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-preview", children: [
                    isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "video",
                      {
                        src: imageSrc,
                        autoPlay: true,
                        loop: true,
                        muted: true,
                        onError: (e) => {
                          e.currentTarget.style.display = "none";
                          const img = document.createElement("img");
                          img.src = "/img/placeholder-ingredient.png";
                          img.alt = template.name;
                          e.currentTarget.parentNode?.appendChild(img);
                        }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: imageSrc,
                        alt: template.name,
                        onError: (e) => {
                          e.currentTarget.src = "/img/placeholder-ingredient.png";
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      template.name,
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "season-tag", children: "Season 1" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                      template.pxj,
                      " PXJ/hr"
                    ] })
                  ] }, template.id);
                }) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-row tier-row-standard", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card primary", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Primary Ingredients" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-ingredients", children: templates.filter((t) => t.type === "primary ingredient").map((template) => {
                  const imageSrc = getIngredientImage(template.id);
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-preview", children: [
                    isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "video",
                      {
                        src: imageSrc,
                        autoPlay: true,
                        loop: true,
                        muted: true,
                        onError: (e) => {
                          e.currentTarget.style.display = "none";
                          const img = document.createElement("img");
                          img.src = "/img/placeholder-ingredient.png";
                          img.alt = template.name;
                          e.currentTarget.parentNode?.appendChild(img);
                        }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: imageSrc,
                        alt: template.name,
                        onError: (e) => {
                          e.currentTarget.src = "/img/placeholder-ingredient.png";
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      template.name,
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "season-tag", children: "Season 1" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                      template.pxj,
                      " PXJ/hr"
                    ] })
                  ] }, template.id);
                }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card secondary", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Secondary Ingredients" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-ingredients", children: templates.filter((t) => t.type === "secondary ingredient").map((template) => {
                  const imageSrc = getIngredientImage(template.id);
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-preview", children: [
                    isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "video",
                      {
                        src: imageSrc,
                        autoPlay: true,
                        loop: true,
                        muted: true,
                        onError: (e) => {
                          e.currentTarget.style.display = "none";
                          const img = document.createElement("img");
                          img.src = "/img/placeholder-ingredient.png";
                          img.alt = template.name;
                          e.currentTarget.parentNode?.appendChild(img);
                        }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: imageSrc,
                        alt: template.name,
                        onError: (e) => {
                          e.currentTarget.src = "/img/placeholder-ingredient.png";
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      template.name,
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "season-tag", children: "Season 1" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                      template.pxj,
                      " PXJ/hr"
                    ] })
                  ] }, template.id);
                }) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-row tier-row-tertiary", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card tertiary", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Tertiary Ingredients" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-ingredients", children: templates.filter((t) => t.type === "tertiary ingredient").map((template) => {
                  const imageSrc = getIngredientImage(template.id);
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-preview", children: [
                    isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "video",
                      {
                        src: imageSrc,
                        autoPlay: true,
                        loop: true,
                        muted: true,
                        onError: (e) => {
                          e.currentTarget.style.display = "none";
                          const img = document.createElement("img");
                          img.src = "/img/placeholder-ingredient.png";
                          img.alt = template.name;
                          e.currentTarget.parentNode?.appendChild(img);
                        }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: imageSrc,
                        alt: template.name,
                        onError: (e) => {
                          e.currentTarget.src = "/img/placeholder-ingredient.png";
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      template.name,
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "season-tag", children: "Season 1" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                      template.pxj,
                      " PXJ/hr"
                    ] })
                  ] }, template.id);
                }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-card collectibles", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Collectibles" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-ingredients", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-tier", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "PFPs" }),
                  templates.filter((t) => t.type === "pixals").map((template) => {
                    const imageSrc = getIngredientImage(template.id) || "https://ipfs.io/ipfs/QmQKA9fxWBAsoDnMRZj1v1vsjwZeWZpHmnoEyujmeMi2rp";
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-preview", children: [
                      isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "video",
                        {
                          src: imageSrc,
                          autoPlay: true,
                          loop: true,
                          muted: true,
                          onError: (e) => {
                            e.currentTarget.style.display = "none";
                            const img = document.createElement("img");
                            img.src = "https://ipfs.io/ipfs/QmQKA9fxWBAsoDnMRZj1v1vsjwZeWZpHmnoEyujmeMi2rp";
                            img.alt = template.name;
                            e.currentTarget.parentNode?.appendChild(img);
                          }
                        }
                      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "img",
                        {
                          src: imageSrc,
                          alt: template.name,
                          onError: (e) => {
                            e.currentTarget.src = "https://ipfs.io/ipfs/QmQKA9fxWBAsoDnMRZj1v1vsjwZeWZpHmnoEyujmeMi2rp";
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        template.name,
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "season-tag", children: "Season 1" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                        template.pxj,
                        " PXJ/hr"
                      ] })
                    ] }, template.id);
                  })
                ] }) })
              ] })
            ] })
          ] })
        ] }) })
      ] }),
      activeTab === "recipes" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipes-tab", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipes-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Crafting Recipes" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-category-tabs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "recipe-tab active", children: "Ingredient" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "recipe-tab disabled", title: "Coming Soon", children: "Collectibles" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "recipe-tab disabled", title: "Coming Soon", children: "Event" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "recipe-tab disabled", title: "Coming Soon", children: "Governance" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "recipes-grid", children: CRAFTING_RECIPES.map((recipe, index) => {
          const roi = calculateROI(recipe);
          const resultTemplate = templates.find((t) => t.id === recipe.resultTemplateId);
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-header", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: recipe.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `tier-badge ${recipe.tier}`, children: recipe.tier })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-ingredients", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Ingredients Required:" }),
              recipe.ingredients.map((ing, ingIndex) => {
                const ingTemplate = templates.find((t) => t.id === ing.templateId);
                const imageSrc = getIngredientImage(ing.templateId);
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-requirement", children: [
                  isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "video",
                    {
                      src: imageSrc,
                      autoPlay: true,
                      loop: true,
                      muted: true,
                      onError: (e) => {
                        e.currentTarget.style.display = "none";
                        const img = document.createElement("img");
                        img.src = "/img/placeholder-ingredient.png";
                        img.alt = ingTemplate?.name || "Unknown";
                        e.currentTarget.parentNode?.appendChild(img);
                      }
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: imageSrc,
                      alt: ingTemplate?.name || "Unknown",
                      onError: (e) => {
                        e.currentTarget.src = "/img/placeholder-ingredient.png";
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    ing.quantity,
                    "x ",
                    ingTemplate?.name || "Unknown"
                  ] })
                ] }, ingIndex);
              })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-result", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Creates:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "result-item", children: [
                (() => {
                  const imageSrc = getIngredientImage(recipe.resultTemplateId);
                  return isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "video",
                    {
                      src: imageSrc,
                      autoPlay: true,
                      loop: true,
                      muted: true,
                      onError: (e) => {
                        e.currentTarget.style.display = "none";
                        const img = document.createElement("img");
                        img.src = "/img/placeholder-ingredient.png";
                        img.alt = resultTemplate?.name || "Unknown";
                        e.currentTarget.parentNode?.appendChild(img);
                      }
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: imageSrc,
                      alt: resultTemplate?.name || "Unknown",
                      onError: (e) => {
                        e.currentTarget.src = "/img/placeholder-ingredient.png";
                      }
                    }
                  );
                })(),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  "1x ",
                  resultTemplate?.name || "Unknown"
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "recipe-stats", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Cost:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  roi.craftingCost.toFixed(4),
                  " WAX"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Daily Earnings:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  roi.dailyEarnings.toFixed(4),
                  " WAX"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "ROI Period:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  roi.roiDays.toFixed(1),
                  " days"
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "craft-button",
                onClick: () => {
                  openCraftingModal();
                },
                children: "Craft This Recipe"
              }
            )
          ] }, index);
        }) })
      ] }),
      activeTab === "calculator" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "calculator-tab", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "ROI Calculator" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "price-inputs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "PXJ Price (WAX):" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                step: "0.0001",
                value: pxjPrice,
                onChange: (e) => setPxjPrice(parseFloat(e.target.value) || 0)
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "WUF Price (WAX):" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                step: "0.0001",
                value: wufPrice,
                onChange: (e) => setWufPrice(parseFloat(e.target.value) || 0)
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "roi-table", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Recipe" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Tier" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Crafting Cost" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Daily Earnings" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "ROI Period" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Profit Margin" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: CRAFTING_RECIPES.map((recipe, index) => {
            const roi = calculateROI(recipe);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: recipe.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `tier-badge ${recipe.tier}`, children: recipe.tier }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                roi.craftingCost.toFixed(4),
                " WAX"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                roi.dailyEarnings.toFixed(4),
                " WAX"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                roi.roiDays.toFixed(1),
                " days"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: roi.profitMargin > 0 ? "positive" : "negative", children: [
                roi.profitMargin.toFixed(1),
                "%"
              ] })
            ] }, index);
          }) })
        ] }) })
      ] }),
      activeTab === "staking" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "staking-tab", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Staking Information" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "staking-description", children: "Stake your Pixel Journey NFTs to earn PXJ and WUF rewards. Use PXJ to infuse, upgrade, and unlock new journeys while earning returns over a 2-3 year period. Benefit from our yearly PXJ allocations (~25% of yearly inflation) that boost crafting incentives and reward active participants in the ecosystem." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "staking-tiers", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collapsible-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "section-header", onClick: () => setCollapsedSections((prev) => ({ ...prev, collectibles: !prev.collectibles })), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Collectibles" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `collapse-icon ${collapsedSections.collectibles ? "collapsed" : ""}`, children: "" })
            ] }),
            !collapsedSections.collectibles && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tiers-grid", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-section", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "tier-title", children: "PFPs" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-items", children: templates.filter((t) => t.type === "pixals").map((template) => {
                const imageSrc = getIngredientImage(template.id);
                const fallbackUrl = "https://ipfs.io/ipfs/QmQKA9fxWBAsoDnMRZj1v1vsjwZeWZpHmnoEyujmeMi2rp";
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-item", children: [
                  isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "video",
                    {
                      src: imageSrc,
                      autoPlay: true,
                      loop: true,
                      muted: true,
                      onError: (e) => {
                        e.currentTarget.style.display = "none";
                        const img = document.createElement("img");
                        img.src = fallbackUrl;
                        img.alt = template.name;
                        e.currentTarget.parentNode?.appendChild(img);
                      }
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: imageSrc,
                      alt: template.name,
                      onError: (e) => {
                        e.currentTarget.src = fallbackUrl;
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-info", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: template.name }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-stats", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        "PXJ: ",
                        template.pxj
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        "WUF: ",
                        template.wuf
                      ] }),
                      template.pxjUpgrade > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        "Upgrade: ",
                        template.pxjUpgrade.toLocaleString(),
                        " PXJ"
                      ] })
                    ] })
                  ] })
                ] }, template.id);
              }) })
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collapsible-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "section-header", onClick: () => setCollapsedSections((prev) => ({ ...prev, ingredients: !prev.ingredients })), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Ingredients" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `collapse-icon ${collapsedSections.ingredients ? "collapsed" : ""}`, children: "" })
            ] }),
            !collapsedSections.ingredients && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tiers-grid", children: [
              templatesByType.pixelpack.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "tier-title", children: "Pixel Ingredient Pack" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-items", children: templatesByType.pixelpack.map((template) => {
                  const imageSrc = getIngredientImage(template.id);
                  const fallbackUrl = "https://pixeljourney.xyz/img/pixel_journey_pack_002_500x500.gif";
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-item", children: [
                    isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "video",
                      {
                        src: imageSrc,
                        autoPlay: true,
                        loop: true,
                        muted: true,
                        onError: (e) => {
                          e.currentTarget.style.display = "none";
                          const img = document.createElement("img");
                          img.src = fallbackUrl;
                          img.alt = template.name;
                          e.currentTarget.parentNode?.appendChild(img);
                        }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: imageSrc,
                        alt: template.name,
                        onError: (e) => {
                          e.currentTarget.src = fallbackUrl;
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: template.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-stats", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                          "PXJ: ",
                          template.pxj
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                          "WUF: ",
                          template.wuf
                        ] }),
                        template.pxjUpgrade > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                          "Cost: ",
                          template.pxjUpgrade.toLocaleString(),
                          " PXJ"
                        ] })
                      ] })
                    ] })
                  ] }, template.id);
                }) })
              ] }),
              Object.entries(templatesByType).filter(([type]) => type !== "pixals" && type !== "pixelpack").map(([type, typeTemplates]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "tier-title", children: [
                  type.charAt(0).toUpperCase() + type.slice(1),
                  " Ingredients"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tier-items", children: typeTemplates.map((template) => {
                  const imageSrc = getIngredientImage(template.id);
                  const fallbackUrl = template.type === "pixelpack" ? "https://pixeljourney.xyz/img/pixel_journey_pack_002_500x500.gif" : template.type === "pixals" ? "https://ipfs.io/ipfs/QmQKA9fxWBAsoDnMRZj1v1vsjwZeWZpHmnoEyujmeMi2rp" : "/img/placeholder-ingredient.png";
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tier-item", children: [
                    isVideoFormat(imageSrc) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "video",
                      {
                        src: imageSrc,
                        autoPlay: true,
                        loop: true,
                        muted: true,
                        onError: (e) => {
                          e.currentTarget.style.display = "none";
                          const img = document.createElement("img");
                          img.src = fallbackUrl;
                          img.alt = template.name;
                          e.currentTarget.parentNode?.appendChild(img);
                        }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: imageSrc,
                        alt: template.name,
                        onError: (e) => {
                          e.currentTarget.src = fallbackUrl;
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: template.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ingredient-stats", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                          "PXJ: ",
                          template.pxj
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                          "WUF: ",
                          template.wuf
                        ] }),
                        template.pxjUpgrade > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                          "Cost: ",
                          template.pxjUpgrade.toLocaleString(),
                          " PXJ"
                        ] })
                      ] })
                    ] })
                  ] }, template.id);
                }) })
              ] }, type))
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "collapsible-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "section-header", onClick: () => setCollapsedSections((prev) => ({ ...prev, governance: !prev.governance })), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Governance NFTs" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `collapse-icon ${collapsedSections.governance ? "collapsed" : ""}`, children: "" })
            ] }),
            !collapsedSections.governance && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "coming-soon-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Coming soon at next PixelDAO expansions" }) })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CraftingModal,
      {
        isOpen: craftingModalOpen,
        onClose: () => setCraftingModalOpen(false),
        ingredient: null
      }
    )
  ] });
};
class FeaturedTokensService {
  constructor() {
    __publicField(this, "FEATURE_ACCOUNT", "feature.pxj");
    __publicField(this, "MIN_AMOUNT", 5e5);
    // 500K PXJ
    __publicField(this, "MAX_AMOUNT", 5e6);
    // 5M PXJ
    __publicField(this, "MIN_DAYS", 30);
    __publicField(this, "MAX_DAYS", 365);
  }
  /**
   * Calculate promotion duration based on PXJ amount
   */
  calculateDuration(pxjAmount) {
    const ratio = (pxjAmount - this.MIN_AMOUNT) / (this.MAX_AMOUNT - this.MIN_AMOUNT);
    return Math.floor(this.MIN_DAYS + ratio * (this.MAX_DAYS - this.MIN_DAYS));
  }
  /**
   * Calculate required PXJ amount for desired duration
   */
  calculateRequiredAmount(days) {
    const ratio = (days - this.MIN_DAYS) / (this.MAX_DAYS - this.MIN_DAYS);
    return Math.floor(this.MIN_AMOUNT + ratio * (this.MAX_AMOUNT - this.MIN_AMOUNT));
  }
  /**
   * Generate compact memo for promotion payment
   * Format: TOKEN@CONTRACT|DESCRIPTION|IMAGE|WEBSITE
   */
  generatePromoMemo(payment) {
    const token = `${payment.tokenSymbol}@${payment.tokenContract}`;
    const baseLength = token.length + 1;
    const imageLength = payment.imageUrl ? payment.imageUrl.length + 1 : 0;
    const websiteLength = payment.websiteUrl ? payment.websiteUrl.length + 1 : 0;
    const usedLength = baseLength + imageLength + websiteLength;
    const maxDescLength = Math.min(100, 235 - usedLength);
    let description = payment.description;
    if (description.length > maxDescLength) {
      description = description.substring(0, maxDescLength - 3) + "...";
    }
    let memo = `${token}|${description}`;
    if (payment.imageUrl) {
      memo += `|${payment.imageUrl}`;
    }
    if (payment.websiteUrl) {
      memo += `|${payment.websiteUrl}`;
    }
    return memo;
  }
  /**
   * Parse memo from blockchain transaction
   * Supports both new compact format and old JSON format for backward compatibility
   */
  parseMemo(memo) {
    if (!memo) return null;
    try {
      if (memo.includes("|") && memo.includes("@") && !memo.startsWith("{")) {
        const parts = memo.split("|");
        if (parts.length >= 2) {
          const [token, description, image = "", website = ""] = parts;
          const [tokenSymbol, tokenContract] = token.split("@");
          return {
            type: "feature_token",
            token,
            tokenSymbol,
            tokenContract,
            description,
            image,
            website
          };
        }
      }
      const parsed = JSON.parse(memo);
      if (parsed.type === "feature_token") {
        return parsed;
      }
      return null;
    } catch (error) {
      log.error("Failed to parse memo:", "FeaturedTokensService.parseMemo", error);
      return null;
    }
  }
  /**
   * Fetch featured token promotions from blockchain
   */
  async getFeaturedTokens() {
    try {
      const response = await fetch(`https://wax.eosrio.io/v2/history/get_actions?account=${this.FEATURE_ACCOUNT}&filter=eosio.token:transfer&limit=100&sort=desc`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      const promos = [];
      for (const action of data.actions || []) {
        try {
          const transfer = action.act.data;
          const memo = this.parseMemo(transfer.memo);
          if (!memo || memo.type !== "feature_token") continue;
          const pxjAmount = parseFloat(transfer.quantity.split(" ")[0]);
          const startDate = new Date(action.timestamp);
          const endDate = new Date(startDate.getTime() + memo.duration * 24 * 60 * 60 * 1e3);
          const isActive = /* @__PURE__ */ new Date() <= endDate;
          if (pxjAmount >= this.MIN_AMOUNT && isActive) {
            const [tokenSymbol, tokenContract] = memo.token.split("@");
            promos.push({
              id: action.trx_id,
              tokenSymbol,
              tokenContract,
              description: memo.description,
              imageUrl: memo.image,
              websiteUrl: memo.website,
              paidAmount: pxjAmount,
              startDate,
              endDate,
              transactionId: action.trx_id,
              isActive
            });
          }
        } catch (error) {
          log.error("Error processing featured token action:", "FeaturedTokensService.getFeaturedTokens", error);
        }
      }
      return promos.sort((a, b) => {
        if (a.paidAmount !== b.paidAmount) {
          return b.paidAmount - a.paidAmount;
        }
        return b.startDate.getTime() - a.startDate.getTime();
      });
    } catch (error) {
      log.error("Failed to fetch featured tokens:", "FeaturedTokensService.getFeaturedTokens", error);
      return [];
    }
  }
  /**
   * Validate promotion payment parameters
   */
  validatePayment(payment) {
    if (payment.amount < this.MIN_AMOUNT || payment.amount > this.MAX_AMOUNT) {
      return {
        valid: false,
        error: `Amount must be between ${this.MIN_AMOUNT.toLocaleString()} and ${this.MAX_AMOUNT.toLocaleString()} PXJ`
      };
    }
    if (payment.duration < this.MIN_DAYS || payment.duration > this.MAX_DAYS) {
      return {
        valid: false,
        error: `Duration must be between ${this.MIN_DAYS} and ${this.MAX_DAYS} days`
      };
    }
    if (!payment.tokenSymbol || !payment.tokenContract) {
      return {
        valid: false,
        error: "Token symbol and contract are required"
      };
    }
    if (!payment.description || payment.description.length < 10) {
      return {
        valid: false,
        error: "Description must be at least 10 characters"
      };
    }
    const token = `${payment.tokenSymbol}@${payment.tokenContract}`;
    const baseLength = token.length + 1;
    const imageLength = payment.imageUrl ? payment.imageUrl.length + 1 : 0;
    const websiteLength = payment.websiteUrl ? payment.websiteUrl.length + 1 : 0;
    const usedLength = baseLength + imageLength + websiteLength;
    const maxDescLength = Math.min(100, 235 - usedLength);
    if (payment.description.length > maxDescLength) {
      return {
        valid: false,
        error: `Description too long. Maximum ${maxDescLength} characters allowed with current image/website URLs.`
      };
    }
    return { valid: true };
  }
}
const featuredTokensService = new FeaturedTokensService();
const FeaturedTokens = ({ className = "" }) => {
  const { account, session } = useWallet();
  const { showSuccess, showError } = useNotifications();
  const [featuredTokens, setFeaturedTokens] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [showPromoModal, setShowPromoModal] = reactExports.useState(false);
  const [promoForm, setPromoForm] = reactExports.useState({
    amount: 5e5,
    duration: 30,
    tokenSymbol: "",
    tokenContract: "",
    description: "",
    imageUrl: "",
    websiteUrl: ""
  });
  reactExports.useEffect(() => {
    loadFeaturedTokens();
  }, []);
  const loadFeaturedTokens = async () => {
    try {
      setLoading(true);
      const tokens = await featuredTokensService.getFeaturedTokens();
      setFeaturedTokens(tokens);
    } catch (error) {
      log.error("Failed to load featured tokens:", "FeaturedTokens.loadFeaturedTokens", error);
    } finally {
      setLoading(false);
    }
  };
  const handleAmountChange = (amount) => {
    const duration = featuredTokensService.calculateDuration(amount);
    setPromoForm((prev) => ({ ...prev, amount, duration }));
  };
  const submitPromotion = async () => {
    if (!account || !session) {
      showError("Please connect your wallet first");
      return;
    }
    const validation = featuredTokensService.validatePayment(promoForm);
    if (!validation.valid) {
      showError(validation.error || "Invalid promotion parameters");
      return;
    }
    try {
      const memo = featuredTokensService.generatePromoMemo(promoForm);
      const transaction = {
        actions: [{
          account: "pixeljourney",
          name: "transfer",
          authorization: [{
            actor: account,
            permission: "active"
          }],
          data: {
            from: account,
            to: "feature.pxj",
            quantity: `${promoForm.amount.toFixed(4)} PXJ`,
            memo
          }
        }]
      };
      const result = await session.transact(transaction);
      let transactionId = null;
      if (result) {
        transactionId = result.transaction_id || result.id || result.processed?.id || result.processed?.transaction_id || result.response && result.response.transaction_id || result.transaction && result.transaction.id;
      }
      if (transactionId) {
        showSuccess(`Promotion submitted successfully! Transaction: ${transactionId}`);
      } else {
        showSuccess("Promotion submitted successfully!");
      }
      setShowPromoModal(false);
      setTimeout(() => {
        loadFeaturedTokens();
      }, 3e3);
    } catch (error) {
      log.error("Failed to submit promotion:", "FeaturedTokens.submitPromotion", error);
      showError(`Failed to submit promotion: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  };
  const formatTimeRemaining = (endDate) => {
    const now = /* @__PURE__ */ new Date();
    const diff = endDate.getTime() - now.getTime();
    const days = Math.floor(diff / (1e3 * 60 * 60 * 24));
    const hours = Math.floor(diff % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60));
    if (days > 0) {
      return `${days}d ${hours}h remaining`;
    } else if (hours > 0) {
      return `${hours}h remaining`;
    } else {
      return "Expires soon";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `featured-tokens ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "featured-tokens-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " Featured Tokens" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "promote-button",
          onClick: () => setShowPromoModal(true),
          disabled: !account,
          children: "Promote Your Token"
        }
      )
    ] }),
    loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "featured-tokens-loading", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading featured tokens..." })
    ] }) : featuredTokens.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "featured-tokens-grid", children: featuredTokens.slice(0, 6).map((token) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "featured-token-card", children: [
      token.imageUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-image", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: token.imageUrl, alt: token.tokenSymbol }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-symbol", children: token.tokenSymbol }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "token-contract", children: [
            "@",
            token.tokenContract
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "token-description", children: token.description }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-meta", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "promo-amount", children: [
            token.paidAmount.toLocaleString(),
            " PXJ"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-remaining", children: formatTimeRemaining(token.endDate) })
        ] }),
        token.websiteUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: token.websiteUrl,
            target: "_blank",
            rel: "noopener noreferrer",
            className: "token-website",
            children: "Visit Website "
          }
        )
      ] })
    ] }, token.id)) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "no-featured-tokens", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No featured tokens at the moment." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Be the first to promote your token!" })
    ] }),
    showPromoModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "promo-modal-overlay", onClick: () => setShowPromoModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "promo-modal", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "promo-modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Promote Your Token" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "close-button",
            onClick: () => setShowPromoModal(false),
            children: ""
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "promo-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Token Symbol" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: promoForm.tokenSymbol,
              onChange: (e) => setPromoForm((prev) => ({ ...prev, tokenSymbol: e.target.value.toUpperCase() })),
              placeholder: "e.g., MYTOKEN"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Token Contract" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: promoForm.tokenContract,
              onChange: (e) => setPromoForm((prev) => ({ ...prev, tokenContract: e.target.value })),
              placeholder: "e.g., mycontract12"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Description" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: promoForm.description,
              onChange: (e) => setPromoForm((prev) => ({ ...prev, description: e.target.value })),
              placeholder: "Describe your token and why users should trade it...",
              rows: 3
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Image URL (optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "url",
              value: promoForm.imageUrl,
              onChange: (e) => setPromoForm((prev) => ({ ...prev, imageUrl: e.target.value })),
              placeholder: "https://example.com/token-logo.png"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Website URL (optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "url",
              value: promoForm.websiteUrl,
              onChange: (e) => setPromoForm((prev) => ({ ...prev, websiteUrl: e.target.value })),
              placeholder: "https://yourtoken.com"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
            "Promotion Amount: ",
            promoForm.amount.toLocaleString(),
            " PXJ"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "range",
              min: 5e5,
              max: 5e6,
              step: 5e4,
              value: promoForm.amount,
              onChange: (e) => handleAmountChange(parseInt(e.target.value)),
              className: "amount-slider"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slider-labels", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "500K PXJ (30 days)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "5M PXJ (365 days)" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "promotion-summary", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Duration:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              promoForm.duration,
              " days"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "summary-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Cost:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              promoForm.amount.toLocaleString(),
              " PXJ"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "cancel-button",
              onClick: () => setShowPromoModal(false),
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "submit-button",
              onClick: submitPromotion,
              disabled: !promoForm.tokenSymbol || !promoForm.tokenContract || !promoForm.description,
              children: "Submit Promotion"
            }
          )
        ] })
      ] })
    ] }) })
  ] });
};
const PxSwap = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pxswap-page", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxswap-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxswap-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "PxSwap" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Swap between WAX and WPIXAL tokens with live market rates" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pxswap-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwapInterface, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pxswap-info", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-info-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " PxSwap Platform Overview" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Universal Token Swapping" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "PxSwap enables seamless trading of any tokens held directly on our platform. Trade between WAX ecosystem tokens, community tokens, and project-specific assets with ease using our integrated Alcor Exchange routing." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card routing-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Multi-DEX Routing" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              "PxSwap currently uses ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Alcor Exchange" }),
              " for all swaps, providing reliable liquidity and competitive rates. We're expanding to include multi-DEX routing in the future for even better prices and deeper liquidity."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Want advanced routing now?" }),
              " Visit",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: "https://waxonedge.app/swap/WAX_eosio.token/PXJ_pixeljourney",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: "external-link",
                  children: "WaxOnEdge"
                }
              ),
              " ",
              "for their ecosystem-MVP swap routing platform."
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FeaturedTokens, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-info-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " DeFi & LP Farming on WAX" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Alcor Exchange" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "The premier DEX on WAX with deep liquidity pools and farming opportunities." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://alcor.exchange/farm",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "info-link",
                children: "Farm on Alcor "
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " TacoCrypto" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Innovative DeFi platform offering unique yield farming and staking mechanisms." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://swap.tacocrypto.io/meal",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "info-link",
                children: "Explore TacoCrypto "
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-info-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " PXJ Spot Markets" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PXJ/WAX" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Primary trading pair with highest liquidity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://alcor.exchange/trade/pxj-pixeljourney_wax-eosio.token",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "info-link",
                children: "Trade PXJ/WAX "
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "PXJ/WUF" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Community favorite pairing" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://alcor.exchange/trade/pxj-pixeljourney_wuf-wuffi",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "info-link",
                children: "Trade PXJ/WUF "
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card community-request", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " What's Next?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "What market should we open next? WPIXAL/PXJ? WPIXAL/USDC? Let us and the WaxRock Council know on our Discord!" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "#",
                className: "info-link discord-link",
                children: "Join Discord "
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-info-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: " WAX DeFi Analytics" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " Alcor Analytics" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Detailed trading data and market insights for Alcor Exchange" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://alcor.exchange/analytics/",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "info-link",
                children: "View Alcor Data "
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " WaxOnEdge Analytics" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Comprehensive ecosystem analytics and cross-DEX insights" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://waxonedge.app/analytics",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "info-link",
                children: "Explore WaxOnEdge "
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: " WAX Network Overview" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Complete WAX blockchain DeFi metrics and network statistics" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://grafana.waxtools.net/",
                target: "_blank",
                rel: "noopener noreferrer",
                className: "info-link",
                children: "View Network Stats "
              }
            )
          ] })
        ] })
      ] })
    ] })
  ] }) });
};
const PriceAlertNotification = ({ alert, onClose }) => {
  const [isVisible, setIsVisible] = reactExports.useState(false);
  const [isClosing, setIsClosing] = reactExports.useState(false);
  const handleClose = reactExports.useCallback(() => {
    setIsClosing(true);
    setTimeout(() => {
      onClose();
    }, 300);
  }, [onClose]);
  reactExports.useEffect(() => {
    const showTimer = setTimeout(() => setIsVisible(true), 100);
    const autoCloseTimer = setTimeout(() => {
      handleClose();
    }, 8e3);
    return () => {
      clearTimeout(showTimer);
      clearTimeout(autoCloseTimer);
    };
  }, [handleClose]);
  const handleViewWatchlist = () => {
    window.location.href = "/watchlist";
    handleClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `price-alert-notification ${isVisible && !isClosing ? "visible" : ""} ${isClosing ? "closing" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-content", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notification-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 17h5l-5 5-5-5h5v-5a7.5 7.5 0 1 0-15 0v5h5l-5 5-5-5h5v-5a12.5 12.5 0 1 1 25 0v5z" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-title", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Price Alert" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "notification-time", children: (/* @__PURE__ */ new Date()).toLocaleTimeString() })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "notification-close", onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-preview", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: alert.item.nft.image,
          alt: alert.item.nft.name,
          onError: (e) => {
            const target = e.target;
            target.src = "https://pixeljourney.xyz/img/toppixals/10.webp";
          }
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert-details", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "nft-name", children: alert.item.nft.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "alert-message", children: alert.message })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: handleClose, children: "Dismiss" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleViewWatchlist, children: "View Watchlist" })
    ] })
  ] }) });
};
const PriceAlertManager = () => {
  const [alerts, setAlerts] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const handlePriceAlert = (event) => {
      setAlerts((prev) => [...prev, event.detail]);
    };
    window.addEventListener("priceAlert", handlePriceAlert);
    return () => {
      window.removeEventListener("priceAlert", handlePriceAlert);
    };
  }, []);
  const removeAlert = (index) => {
    setAlerts((prev) => prev.filter((_, i) => i !== index));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "price-alert-manager", children: alerts.map((alert, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    PriceAlertNotification,
    {
      alert,
      onClose: () => removeAlert(index)
    },
    `${alert.item.nft.asset_id}-${Date.now()}-${index}`
  )) });
};
const NotificationContainer = () => {
  const { notifications, removeNotification, soundEnabled } = useNotifications();
  const audioContextRef = reactExports.useRef(null);
  const soundsRef = reactExports.useRef({});
  const createTone = (audioContext, frequency, duration, type) => {
    const sampleRate = audioContext.sampleRate;
    const frameCount = sampleRate * duration;
    const buffer = audioContext.createBuffer(1, frameCount, sampleRate);
    const channelData = buffer.getChannelData(0);
    for (let i = 0; i < frameCount; i++) {
      const t = i / sampleRate;
      let sample = 0;
      switch (type) {
        case "sine":
          sample = Math.sin(2 * Math.PI * frequency * t);
          break;
        case "square":
          sample = Math.sign(Math.sin(2 * Math.PI * frequency * t));
          break;
        case "triangle":
          sample = 2 / Math.PI * Math.asin(Math.sin(2 * Math.PI * frequency * t));
          break;
      }
      const envelope = Math.exp(-t * 5);
      channelData[i] = sample * envelope * 0.1;
    }
    return buffer;
  };
  const playNotificationSound = reactExports.useCallback((type) => {
    if (!soundEnabled || !audioContextRef.current || !soundsRef.current[type]) return;
    try {
      const source = audioContextRef.current.createBufferSource();
      source.buffer = soundsRef.current[type];
      source.connect(audioContextRef.current.destination);
      source.start();
    } catch (error) {
      console.warn("Failed to play notification sound:", error);
    }
  }, [soundEnabled]);
  reactExports.useEffect(() => {
    const initAudio = async () => {
      try {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        const sounds = {
          success: createTone(audioContextRef.current, 800, 0.1, "sine"),
          error: createTone(audioContextRef.current, 400, 0.2, "square"),
          warning: createTone(audioContextRef.current, 600, 0.15, "triangle"),
          info: createTone(audioContextRef.current, 500, 0.1, "sine")
        };
        soundsRef.current = sounds;
      } catch (error) {
        console.warn("Audio context initialization failed:", error);
      }
    };
    initAudio();
    return () => {
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
  }, []);
  reactExports.useEffect(() => {
    if (notifications.length > 0) {
      const latestNotification = notifications[notifications.length - 1];
      playNotificationSound(latestNotification.type);
    }
  }, [notifications.length, notifications, playNotificationSound]);
  if (notifications.length === 0) {
    return null;
  }
  const handleRemoveNotification = (id) => {
    const notificationElement = document.querySelector(`[data-notification-id="${id}"]`);
    if (notificationElement) {
      notificationElement.classList.add("removing");
      setTimeout(() => {
        removeNotification(id);
      }, 300);
    } else {
      removeNotification(id);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notification-container", children: notifications.map((notification) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `notification notification-${notification.type}`,
      "data-notification-id": notification.id,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-header", children: [
          notification.title && /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "notification-title", children: notification.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "notification-close",
              onClick: () => handleRemoveNotification(notification.id),
              "aria-label": "Close notification",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
              ] })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-body", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-icon", children: [
            notification.type === "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "22,4 12,14.01 9,11.01" })
            ] }),
            notification.type === "error" && /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "9", x2: "9", y2: "15" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "9", x2: "15", y2: "15" })
            ] }),
            notification.type === "warning" && /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "9", x2: "12", y2: "13" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" })
            ] }),
            notification.type === "info" && /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 16v-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8h.01" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-message", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: notification.message }),
            notification.action && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "notification-action",
                onClick: notification.action.onClick,
                children: notification.action.label
              }
            )
          ] })
        ] })
      ] })
    },
    notification.id
  )) });
};
const ConfirmDialog = () => {
  const { confirmDialog, resolveConfirm } = useNotifications();
  if (!confirmDialog) {
    return null;
  }
  const handleConfirm = () => {
    resolveConfirm(true);
  };
  const handleCancel = () => {
    resolveConfirm(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: handleCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal confirm-dialog", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: confirmDialog.title || "Confirm Action" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: handleCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: confirmDialog.message }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: handleCancel, children: confirmDialog.cancelText || "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleConfirm, children: confirmDialog.confirmText || "Confirm" })
    ] })
  ] }) });
};
class ErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    __publicField(this, "reportError", async (error, errorInfo) => {
      try {
        const errorReport = {
          message: error.message,
          stack: error.stack,
          componentStack: errorInfo.componentStack,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          userAgent: navigator.userAgent,
          url: window.location.href
        };
        logger.warn("Error Report generated", "ErrorBoundary", errorReport);
      } catch (reportingError) {
        logger.error("Failed to report error", "ErrorBoundary", reportingError);
      }
    });
    __publicField(this, "handleRetry", () => {
      const newRetryCount = this.state.retryCount + 1;
      if (newRetryCount > 3) {
        logger.warn("Maximum retry attempts reached", "ErrorBoundary");
        return;
      }
      this.setState({
        hasError: false,
        error: void 0,
        errorInfo: void 0,
        retryCount: newRetryCount
      });
    });
    this.state = { hasError: false, retryCount: 0 };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    logger.error("ErrorBoundary caught an error", "ErrorBoundary", error, {
      componentStack: errorInfo.componentStack,
      errorBoundary: this.constructor.name
    });
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
    this.setState({
      error,
      errorInfo
    });
    this.reportError(error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      const isMaxRetries = this.state.retryCount >= 3;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ErrorMessage,
        {
          title: "Something went wrong",
          message: isMaxRetries ? "Multiple errors occurred. Please refresh the page or contact support if the problem persists." : "An unexpected error occurred. Please try again or refresh the page.",
          onRetry: isMaxRetries ? void 0 : this.handleRetry,
          showRetry: !isMaxRetries
        }
      );
    }
    return this.props.children;
  }
}
class APIErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    __publicField(this, "maxRetries", 3);
    __publicField(this, "retryTimeouts", []);
    __publicField(this, "handleRetry", () => {
      if (this.state.retryCount >= this.maxRetries) {
        log.warn("Max retries reached for API error boundary");
        return;
      }
      const baseDelay = 1e3;
      const delay = baseDelay * Math.pow(2, this.state.retryCount);
      const jitter = Math.random() * 0.1 * delay;
      const finalDelay = Math.min(delay + jitter, 3e4);
      this.setState({ isRetrying: true, lastRetryTime: Date.now() });
      const timeout = setTimeout(() => {
        this.setState((prevState) => ({
          hasError: false,
          error: void 0,
          errorInfo: void 0,
          retryCount: prevState.retryCount + 1,
          isRetrying: false
        }));
      }, finalDelay);
      this.retryTimeouts.push(timeout);
    });
    __publicField(this, "handleReset", () => {
      this.setState({
        hasError: false,
        error: void 0,
        errorInfo: void 0,
        retryCount: 0
      });
    });
    this.state = {
      hasError: false,
      retryCount: 0,
      isRetrying: false,
      errorCategory: "unknown"
    };
  }
  componentWillUnmount() {
    this.retryTimeouts.forEach((timeout) => clearTimeout(timeout));
  }
  static getDerivedStateFromError(error) {
    const errorMessage = error.message.toLowerCase();
    let errorCategory = "unknown";
    if (errorMessage.includes("fetch") || errorMessage.includes("network") || errorMessage.includes("connection")) {
      errorCategory = "network";
    } else if (errorMessage.includes("timeout") || errorMessage.includes("aborted")) {
      errorCategory = "timeout";
    } else if (errorMessage.includes("http") || errorMessage.includes("api") || errorMessage.includes("failed to load")) {
      errorCategory = "api";
    }
    const shouldHandle = ["network", "api", "timeout"].includes(errorCategory) || error.name === "ChunkLoadError" || error.name === "TypeError" && errorMessage.includes("fetch");
    if (shouldHandle) {
      return { hasError: true, error, errorCategory };
    }
    throw error;
  }
  componentDidCatch(error, errorInfo) {
    ErrorMessageService.logError("APIErrorBoundary", error, {
      errorInfo,
      retryCount: this.state.retryCount,
      componentStack: errorInfo.componentStack
    });
    this.setState({
      error,
      errorInfo
    });
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }
  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      const canRetry = this.state.retryCount < this.maxRetries;
      let errorType;
      switch (this.state.errorCategory) {
        case "network":
          errorType = "NETWORK_ERROR";
          break;
        case "timeout":
          errorType = "TIMEOUT_ERROR";
          break;
        case "api":
          errorType = "API_ERROR";
          break;
        default:
          errorType = "LOAD_FAILED";
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-boundary-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ErrorMessage,
          {
            errorType,
            onRetry: canRetry ? this.handleRetry : this.handleReset,
            showRetry: true,
            isRetrying: this.state.isRetrying,
            retryCount: this.state.retryCount,
            maxRetries: this.maxRetries
          }
        ),
        this.state.retryCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-retry-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Retry attempt ",
            this.state.retryCount,
            " of ",
            this.maxRetries
          ] }),
          this.state.isRetrying && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "retry-progress", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "retry-spinner" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Retrying..." })
          ] })
        ] }),
        false
      ] });
    }
    return this.props.children;
  }
}
const WatchlistAlertChecker = () => {
  const { isConnected, account } = useWallet$1();
  reactExports.useEffect(() => {
    if (!isConnected || !account) return;
    const checkTriggeredAlerts = async () => {
      try {
        const lastCheckKey = `watchlist_last_check_${account}`;
        const lastCheck = localStorage.getItem(lastCheckKey);
        const lastCheckTime = lastCheck ? parseInt(lastCheck) : 0;
        const now = Date.now();
        if (now - lastCheckTime < 5 * 60 * 1e3) {
          return;
        }
        const watchlistItems = await watchlistService.getWatchlist();
        if (watchlistItems.length === 0) {
          localStorage.setItem(lastCheckKey, now.toString());
          return;
        }
        const recentAlerts = [];
        for (const item of watchlistItems) {
          const alert = watchlistService.getPriceAlert(item.nft.asset_id);
          if (alert && alert.enabled && alert.lastTriggered) {
            if (alert.lastTriggered > lastCheckTime) {
              let message = "";
              const currentPrice = item.lastPrice || parseFloat(item.nft.price || "0");
              switch (alert.alertType) {
                case "below":
                  message = `${item.nft.name} price dropped to ${currentPrice.toFixed(2)} WAX (target: ${alert.targetPrice} WAX)`;
                  break;
                case "above":
                  message = `${item.nft.name} price rose to ${currentPrice.toFixed(2)} WAX (target: ${alert.targetPrice} WAX)`;
                  break;
                case "any": {
                  const changePercent = Math.abs(item.priceChange || 0);
                  const direction = (item.priceChange || 0) > 0 ? "increased" : "decreased";
                  message = `${item.nft.name} price ${direction} by ${changePercent.toFixed(1)}% to ${currentPrice.toFixed(2)} WAX`;
                  break;
                }
              }
              recentAlerts.push({
                alert,
                item,
                message,
                triggeredAt: alert.lastTriggered
              });
            }
          }
        }
        recentAlerts.sort((a, b) => b.triggeredAt - a.triggeredAt);
        recentAlerts.forEach((alertData, index) => {
          setTimeout(() => {
            window.dispatchEvent(new CustomEvent("priceAlert", {
              detail: {
                item: alertData.item,
                message: alertData.message
              }
            }));
          }, index * 1e3);
        });
        localStorage.setItem(lastCheckKey, now.toString());
        if (recentAlerts.length > 0) {
          log.info(`Found ${recentAlerts.length} triggered watchlist alerts since last visit`);
        }
      } catch (error) {
        log.error("Error checking watchlist alerts:", "WatchlistAlertChecker.checkTriggeredAlerts", error);
      }
    };
    const timeoutId = setTimeout(checkTriggeredAlerts, 2e3);
    return () => clearTimeout(timeoutId);
  }, [isConnected, account]);
  return null;
};
const usePWA = () => {
  const [installPrompt, setInstallPrompt] = reactExports.useState(null);
  const [isInstallable, setIsInstallable] = reactExports.useState(false);
  const [isInstalled, setIsInstalled] = reactExports.useState(false);
  const [isOnline, setIsOnline] = reactExports.useState(navigator.onLine);
  const [isStandalone, setIsStandalone] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const checkStandalone = () => {
      const isStandaloneMode = window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone || document.referrer.includes("android-app://");
      setIsStandalone(isStandaloneMode);
      setIsInstalled(isStandaloneMode);
    };
    checkStandalone();
    const handleBeforeInstallPrompt = (e) => {
      e.preventDefault();
      const promptEvent = e;
      setInstallPrompt(promptEvent);
      setIsInstallable(true);
    };
    const handleAppInstalled = () => {
      setIsInstalled(true);
      setIsInstallable(false);
      setInstallPrompt(null);
    };
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
    window.addEventListener("appinstalled", handleAppInstalled);
    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);
    const mediaQuery = window.matchMedia("(display-mode: standalone)");
    const handleDisplayModeChange = (e) => {
      setIsStandalone(e.matches);
      setIsInstalled(e.matches);
    };
    if (mediaQuery.addEventListener) {
      mediaQuery.addEventListener("change", handleDisplayModeChange);
    } else {
      mediaQuery.addListener(handleDisplayModeChange);
    }
    return () => {
      window.removeEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
      window.removeEventListener("appinstalled", handleAppInstalled);
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
      if (mediaQuery.removeEventListener) {
        mediaQuery.removeEventListener("change", handleDisplayModeChange);
      } else {
        mediaQuery.removeListener(handleDisplayModeChange);
      }
    };
  }, []);
  const showInstallPrompt = async () => {
    if (!installPrompt) return;
    try {
      await installPrompt.prompt();
      const { outcome } = await installPrompt.userChoice;
      if (outcome === "accepted") {
        log.info("User accepted the install prompt");
      } else {
        log.info("User dismissed the install prompt");
      }
      setInstallPrompt(null);
      setIsInstallable(false);
    } catch (error) {
      log.error("Error showing install prompt:", "usePWA.showInstallPrompt", error);
    }
  };
  const dismissInstallPrompt = () => {
    setInstallPrompt(null);
    setIsInstallable(false);
  };
  return {
    isInstallable,
    isInstalled,
    isOnline,
    isStandalone,
    installPrompt,
    showInstallPrompt,
    dismissInstallPrompt
  };
};
const PWAInstallBanner = ({ className = "" }) => {
  const { isInstallable, isInstalled, isStandalone, showInstallPrompt, dismissInstallPrompt } = usePWA();
  if (!isInstallable || isInstalled || isStandalone) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `pwa-install-banner ${className}`, role: "banner", "aria-label": "Install app banner", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pwa-banner-content", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pwa-banner-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2", fill: "currentColor", fillOpacity: "0.1", stroke: "currentColor", strokeWidth: "1.5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 12l2 2 4-4", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pwa-banner-text", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "pwa-banner-title", children: "Install PxMarket" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pwa-banner-description", children: "Get the full app experience with offline access and faster loading." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pwa-banner-actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          className: "pwa-install-button",
          onClick: showInstallPrompt,
          "aria-label": "Install PxMarket app",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 1v10M4 7l4 4 4-4", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) }),
            "Install"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          className: "pwa-dismiss-button",
          onClick: dismissInstallPrompt,
          "aria-label": "Dismiss install banner",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 4L4 12M4 4l8 8", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) })
        }
      )
    ] })
  ] }) });
};
const OfflineIndicator = ({ className = "" }) => {
  const { isOnline } = usePWA();
  if (isOnline) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `offline-indicator ${className}`,
      role: "status",
      "aria-live": "polite",
      "aria-label": "You are currently offline",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offline-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "offline-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M3 7c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2v6c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V7z",
              stroke: "currentColor",
              strokeWidth: "1.5",
              fill: "none"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7 9l6 4M13 9l-6 4",
              stroke: "currentColor",
              strokeWidth: "1.5",
              strokeLinecap: "round"
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offline-text", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "offline-title", children: "You're offline" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "offline-description", children: "Some features may be limited" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "offline-pulse", "aria-hidden": "true" })
      ] })
    }
  );
};
const useTransactionManager = () => {
  const [state, setState] = reactExports.useState({
    activeTransactions: /* @__PURE__ */ new Map(),
    completedTransactions: [],
    isProcessing: false
  });
  const {
    executeTransaction,
    getTransaction: getWalletTransaction,
    cancelTransaction: cancelWalletTransaction
  } = useWallet$1();
  const pollIntervals = reactExports.useRef(/* @__PURE__ */ new Map());
  const updateTransaction = reactExports.useCallback((id, updates) => {
    setState((prev) => {
      const newActiveTransactions = new Map(prev.activeTransactions);
      const existing = newActiveTransactions.get(id);
      if (existing) {
        const updated = { ...existing, ...updates };
        if (updated.status === "success" || updated.status === "failed" || updated.status === "cancelled") {
          newActiveTransactions.delete(id);
          const interval = pollIntervals.current.get(id);
          if (interval) {
            clearInterval(interval);
            pollIntervals.current.delete(id);
          }
          return {
            ...prev,
            activeTransactions: newActiveTransactions,
            completedTransactions: [updated, ...prev.completedTransactions.slice(0, 49)],
            // Keep last 50
            isProcessing: newActiveTransactions.size > 0
          };
        } else {
          newActiveTransactions.set(id, updated);
          return {
            ...prev,
            activeTransactions: newActiveTransactions
          };
        }
      }
      return prev;
    });
  }, []);
  const pollTransactionStatus = reactExports.useCallback(async (id) => {
    try {
      if (!getWalletTransaction) {
        log.warn("getWalletTransaction not available");
        return;
      }
      const txData = await getWalletTransaction(id);
      if (txData) {
        updateTransaction(id, txData);
      }
    } catch (error) {
      log.error(`Error polling transaction ${id}:`, "useTransactionManager.pollTransactionStatus", error);
      updateTransaction(id, {
        status: "failed",
        error: "Failed to check transaction status"
      });
    }
  }, [getWalletTransaction, updateTransaction]);
  const startPolling = reactExports.useCallback((id) => {
    const existingInterval = pollIntervals.current.get(id);
    if (existingInterval) {
      clearInterval(existingInterval);
    }
    const interval = setInterval(() => {
      pollTransactionStatus(id);
    }, 2e3);
    pollIntervals.current.set(id, interval);
    setTimeout(() => {
      const currentInterval = pollIntervals.current.get(id);
      if (currentInterval === interval) {
        clearInterval(interval);
        pollIntervals.current.delete(id);
        updateTransaction(id, {
          status: "failed",
          error: "Transaction timeout - please check manually"
        });
      }
    }, 5 * 60 * 1e3);
  }, [pollTransactionStatus, updateTransaction]);
  const startTransaction = reactExports.useCallback(async (type, data) => {
    try {
      setState((prev) => ({ ...prev, isProcessing: true }));
      if (!executeTransaction) {
        throw new Error("executeTransaction not available - wallet not connected");
      }
      const transactionId = await executeTransaction(type, data);
      if (transactionId) {
        const newTransaction = {
          id: transactionId,
          type,
          status: "pending",
          timestamp: Date.now(),
          account: "",
          // Will be set by the transaction service
          actions: [],
          // Will be populated by the transaction service
          metadata: data
          // Store the data as metadata
        };
        setState((prev) => {
          const newActiveTransactions = new Map(prev.activeTransactions);
          newActiveTransactions.set(transactionId, newTransaction);
          return {
            ...prev,
            activeTransactions: newActiveTransactions
          };
        });
        startPolling(transactionId);
        return transactionId;
      }
      return null;
    } catch (error) {
      log.error("Error starting transaction:", "useTransactionManager.startTransaction", error);
      setState((prev) => ({ ...prev, isProcessing: false }));
      throw error;
    }
  }, [executeTransaction, startPolling]);
  const getTransaction = reactExports.useCallback((id) => {
    const active = state.activeTransactions.get(id);
    if (active) return active;
    const completed = state.completedTransactions.find((tx) => tx.id === id);
    return completed || null;
  }, [state.activeTransactions, state.completedTransactions]);
  const cancelTransaction = reactExports.useCallback(async (id) => {
    try {
      if (!cancelWalletTransaction) {
        log.warn("cancelWalletTransaction not available");
        return false;
      }
      const success = await cancelWalletTransaction(id);
      if (success) {
        updateTransaction(id, {
          status: "cancelled",
          error: "Transaction cancelled by user"
        });
      }
      return success;
    } catch (error) {
      log.error("Error cancelling transaction:", "useTransactionManager.cancelTransaction", error);
      return false;
    }
  }, [cancelWalletTransaction, updateTransaction]);
  const clearCompleted = reactExports.useCallback(() => {
    setState((prev) => ({
      ...prev,
      completedTransactions: []
    }));
  }, []);
  const getActiveCount = reactExports.useCallback(() => {
    return state.activeTransactions.size;
  }, [state.activeTransactions.size]);
  const getCompletedCount = reactExports.useCallback(() => {
    return state.completedTransactions.length;
  }, [state.completedTransactions.length]);
  const hasFailedTransactions = reactExports.useCallback(() => {
    return state.completedTransactions.some((tx) => tx.status === "failed");
  }, [state.completedTransactions]);
  return {
    // State
    activeTransactions: Array.from(state.activeTransactions.values()),
    completedTransactions: state.completedTransactions,
    isProcessing: state.isProcessing,
    // Actions
    startTransaction,
    getTransaction,
    cancelTransaction,
    clearCompleted,
    // Status tracking
    getActiveCount,
    getCompletedCount,
    hasFailedTransactions
  };
};
const TransactionNotifications = () => {
  const [notifications, setNotifications] = reactExports.useState([]);
  const [processedTransactions, setProcessedTransactions] = reactExports.useState(/* @__PURE__ */ new Set());
  const { activeTransactions, completedTransactions } = useTransactionManager();
  const { showSuccess, showError } = useNotifications();
  const addNotification = reactExports.useCallback((notification) => {
    const newNotification = {
      ...notification,
      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      timestamp: Date.now(),
      autoHide: notification.autoHide ?? true,
      duration: notification.duration ?? 5e3
    };
    setNotifications((prev) => [newNotification, ...prev.slice(0, 4)]);
    if (newNotification.autoHide) {
      setTimeout(() => {
        removeNotification(newNotification.id);
      }, newNotification.duration);
    }
  }, []);
  const removeNotification = reactExports.useCallback((id) => {
    setNotifications((prev) => prev.filter((n) => n.id !== id));
  }, []);
  reactExports.useEffect(() => {
    const allTransactions = [...activeTransactions, ...completedTransactions];
    allTransactions.forEach((tx) => {
      if (processedTransactions.has(tx.id)) return;
      setProcessedTransactions((prev) => /* @__PURE__ */ new Set([...prev, tx.id]));
      switch (tx.status) {
        case "pending":
          addNotification({
            type: "info",
            title: "Transaction Started",
            message: `${getTransactionTypeLabel(tx.type)} transaction is being prepared...`,
            transactionId: tx.id,
            duration: 3e3
          });
          break;
        case "processing":
          addNotification({
            type: "info",
            title: "Processing Transaction",
            message: `${getTransactionTypeLabel(tx.type)} is being processed on the blockchain...`,
            transactionId: tx.id,
            duration: 4e3
          });
          break;
        case "success":
          addNotification({
            type: "success",
            title: "Transaction Successful!",
            message: `${getTransactionTypeLabel(tx.type)} completed successfully`,
            transactionId: tx.id,
            duration: 6e3
          });
          showSuccess(
            "Transaction Complete",
            `Your ${getTransactionTypeLabel(tx.type).toLowerCase()} has been processed successfully!`
          );
          break;
        case "failed":
          addNotification({
            type: "error",
            title: "Transaction Failed",
            message: tx.error || `${getTransactionTypeLabel(tx.type)} failed to process`,
            transactionId: tx.id,
            autoHide: false
            // Keep error notifications visible
          });
          showError(
            "Transaction Failed",
            tx.error || "Your transaction failed to process. Please try again."
          );
          break;
        case "cancelled":
          addNotification({
            type: "warning",
            title: "Transaction Cancelled",
            message: `${getTransactionTypeLabel(tx.type)} was cancelled`,
            transactionId: tx.id,
            duration: 4e3
          });
          break;
      }
    });
  }, [activeTransactions, completedTransactions, processedTransactions, addNotification, showSuccess, showError]);
  const getTransactionTypeLabel = (type) => {
    switch (type) {
      case "nft_purchase":
        return "NFT Purchase";
      case "nft_transfer":
        return "NFT Transfer";
      case "token_transfer":
        return "Token Transfer";
      case "nft_listing":
        return "NFT Listing";
      case "listing_cancel":
        return "Cancel Listing";
      case "crafting":
        return "Crafting";
      case "blend":
        return "Blend";
      case "burn":
        return "Burn Assets";
      case "unpack":
        return "Unpack Asset";
      case "auction_bid":
        return "Auction Bid";
      case "tokenize_wax":
        return "Tokenize WAX";
      default:
        return type.replace("_", " ").replace(/\b\w/g, (l) => l.toUpperCase());
    }
  };
  const getNotificationIcon = (type) => {
    switch (type) {
      case "success":
        return "";
      case "error":
        return "";
      case "warning":
        return "";
      case "info":
      default:
        return "";
    }
  };
  const formatTimeAgo = (timestamp) => {
    const now = Date.now();
    const diffMs = now - timestamp;
    const diffSecs = Math.floor(diffMs / 1e3);
    const diffMins = Math.floor(diffSecs / 60);
    if (diffSecs < 60) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    const diffHours = Math.floor(diffMins / 60);
    if (diffHours < 24) return `${diffHours}h ago`;
    return new Date(timestamp).toLocaleDateString();
  };
  if (notifications.length === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transaction-notifications", children: notifications.map((notification) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `notification notification-${notification.type}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "notification-icon", children: getNotificationIcon(notification.type) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "notification-title", children: notification.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "notification-time", children: formatTimeAgo(notification.timestamp) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "notification-close",
                onClick: () => removeNotification(notification.id),
                children: ""
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notification-message", children: notification.message }),
          notification.transactionId && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-transaction-id", children: [
            "ID: ",
            notification.transactionId.slice(0, 8),
            "...",
            notification.transactionId.slice(-8)
          ] })
        ] }),
        notification.autoHide && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "notification-progress",
            style: {
              animationDuration: `${notification.duration}ms`
            }
          }
        )
      ]
    },
    notification.id
  )) });
};
const AppContent = () => {
  const location2 = useLocation();
  const [currentPage, setCurrentPage] = reactExports.useState("landing");
  React.useEffect(() => {
    const path = location2.pathname;
    if (path === "" || path === "/" || path === "/market-alphatest/" || path === "/market-alphatest") {
      setCurrentPage("/landing");
    } else if (path === "/marketplace" || path === "/market-alphatest/marketplace") {
      setCurrentPage("marketplace");
    } else if (path === "/rewards") {
      setCurrentPage("rewards");
    } else if (path === "/inventory") {
      setCurrentPage("inventory");
    } else if (path === "/packs") {
      setCurrentPage("packs");
    } else if (path.startsWith("/collections")) {
      setCurrentPage("collections");
    } else if (path === "/activity" || path === "/stats") {
      setCurrentPage("activity");
    } else if (path === "/staking") {
      setCurrentPage("staking");
    } else if (path === "/profile") {
      setCurrentPage("profile");
    } else if (path === "/watchlist") {
      setCurrentPage("watchlist");
    } else if (path === "/auctions") {
      setCurrentPage("auctions");
    } else if (path === "/learn") {
      setCurrentPage("learn");
    } else if (path === "/journeymap") {
      setCurrentPage("journeymap");
    } else if (path === "/pxcrafting") {
      setCurrentPage("pxcrafting");
    }
  }, [location2.pathname]);
  React.useEffect(() => {
    window.scrollTo(0, 0);
  }, [location2.pathname]);
  const handlePageChange = (page) => {
    setCurrentPage(page);
    if (page === "landing") {
      window.history.pushState(null, "", "/");
    } else if (page === "marketplace") {
      window.history.pushState(null, "", "/marketplace");
    } else {
      window.history.pushState(null, "", `/${page}`);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "App", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Navigation, { currentPage, onPageChange: handlePageChange }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { id: "main-content", role: "main", "aria-label": "Main content", className: "main-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LandingPage, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/marketplace", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Marketplace, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/rewards", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Rewards, { onPageChange: handlePageChange }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/inventory", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Inventory, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/packs", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Packs, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/collections", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collections, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/collections/:collectionName", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionDetail, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/collections/:collectionName/templates/:templateId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TemplateDetail, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/assets/:assetId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AssetDetail, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/listings/:saleId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListingDetail, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/transactions/:transactionId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransactionDetails, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/activity", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ActivityStats, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/stats", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ActivityStats, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/profile", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserProfile, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/profile/:account", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserProfileLookup, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/user-profile-lookup", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserProfileLookup, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/watchlist", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Watchlist, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/auctions", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Auctions, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/auctions/:id", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuctionDetail, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/learn", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Learn, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/journeymap", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(JourneyMap, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/staking", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Staking, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/rwax", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RWax, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/pxcrafting", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PxCrafting, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/pxswap", element: /* @__PURE__ */ jsxRuntimeExports.jsx(APIErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PxSwap, {}) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {})
  ] });
};
function App() {
  React.useEffect(() => {
    monitoringService.trackEvent("app_initialized", {
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      }
    });
    accessibilityService.initialize().then(() => {
      log.info("Accessibility service ready", "App");
      monitoringService.trackEvent("accessibility_service_ready", {
        preferences: accessibilityService.getPreferences()
      });
    }).catch((error) => {
      log.error("Failed to initialize accessibility service", "App", error);
      monitoringService.reportError(error, "accessibility_init_error");
    });
    pushNotificationService.initialize().then((success) => {
      if (success) {
        log.info("Push notification service initialized successfully", "App");
        monitoringService.trackEvent("push_service_ready", {
          supported: pushNotificationService.getPermissionState().supported
        });
      } else {
        log.warn("Push notification service initialization failed", "App");
      }
    }).catch((error) => {
      log.error("Push notification service initialization error", "App", error);
      monitoringService.reportError(error, "push_service_init_error");
    });
    MarketplaceConfigService.preloadConfiguration().then(() => {
      log.info("Marketplace configuration preloaded successfully", "App");
      monitoringService.trackEvent("marketplace_config_preloaded", {
        timestamp: Date.now()
      });
    }).catch((error) => {
      log.warn("Failed to preload marketplace configuration", "App", { error });
      monitoringService.reportError(error, "marketplace_config_preload_error");
    });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WalletProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DisplaySettingsProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(NotificationProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { basename: "/market-alphatest", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppContent, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WatchlistAlertChecker, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PriceAlertManager, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationContainer, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmDialog, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ChatWidget, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PWAInstallBanner, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OfflineIndicator, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TransactionNotifications, {})
  ] }) }) }) });
}
clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
//# sourceMappingURL=index-BpcCTPXh.js.map
